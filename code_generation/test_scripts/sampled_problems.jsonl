{"problem": "Write\n```python\nsmaller(arr)\n```\nthat given an array ```arr```, you have to return the amount of numbers that are smaller than ```arr[i]``` to the right.\n\nFor example:\n```python\nsmaller([5, 4, 3, 2, 1]) == [4, 3, 2, 1, 0]\nsmaller([1, 2, 0]) == [1, 1, 0]\n```\n``` haskell\nsmaller [5,4,3,2,1]  `shouldBe` [4,3,2,1,0]\nsmaller [1,2,3]      `shouldBe` [0,0,0]\nsmaller [1, 2, 0]    `shouldBe` [1, 1, 0]\n```\nIf you've completed this one and you feel like testing your performance tuning of this same kata, head over to the much tougher version How many are smaller than me II?", "solutions": ["def smaller(arr):\n\treturn [len([a for a in arr[i:] if a < arr[i]]) for i in range(0, len(arr))]\n", "def smaller(arr):\n\treturn [sum((b < a for b in arr[i + 1:])) for (i, a) in enumerate(arr)]\n", "def smaller(arr):\n\treturn [sum((x > y for y in arr[i + 1:])) for (i, x) in enumerate(arr)]\n", "def smaller(arr):\n\treturn [sum((j < v for j in arr[i:])) for (i, v) in enumerate(arr)]\n", "def smaller(arr):\n\ta = []\n\tcounter = 0\n\tfor j in range(len(arr)):\n\t\tj = arr[0]\n\t\tfor k in arr:\n\t\t\tif j > k:\n\t\t\t\tcounter += 1\n\t\ta.append(counter)\n\t\tcounter = 0\n\t\tarr.remove(arr[0])\n\treturn a\n", "def smaller(arr):\n\treturn [sum((1 for right in arr[i + 1:] if right < item)) for (i, item) in enumerate(arr)]\n", "def smaller(nums):\n\ti = 0\n\tres = []\n\twhile i < len(nums):\n\t\tj = i + 1\n\t\tnb = 0\n\t\twhile j < len(nums):\n\t\t\tif nums[i] > nums[j]:\n\t\t\t\tnb += 1\n\t\t\tj += 1\n\t\tres.append(nb)\n\t\ti += 1\n\treturn res\n", "def countsort(arr, cntarr, cntdict):\n\tif len(arr) > 1:\n\t\tmid = len(arr) // 2\n\t\tleft = arr[:mid]\n\t\tleftcount = cntarr[:mid]\n\t\tright = arr[mid:]\n\t\trightcount = cntarr[mid:]\n\t\tcountsort(left, leftcount, cntdict)\n\t\tcountsort(right, rightcount, cntdict)\n\t\ti = 0\n\t\tj = 0\n\t\tk = 0\n\t\twhile i < len(left) and j < len(right):\n\t\t\tif left[i] > right[j]:\n\t\t\t\tarr[k] = right[j]\n\t\t\t\tfor n in range(i, len(left)):\n\t\t\t\t\ttemp = leftcount[n]\n\t\t\t\t\tcntdict[temp] = cntdict[temp] + 1\n\t\t\t\tcntarr[k] = rightcount[j]\n\t\t\t\tj = j + 1\n\t\t\telse:\n\t\t\t\tarr[k] = left[i]\n\t\t\t\tcntarr[k] = leftcount[i]\n\t\t\t\ti = i + 1\n\t\t\tk = k + 1\n\t\twhile i < len(left):\n\t\t\tarr[k] = left[i]\n\t\t\tcntarr[k] = leftcount[i]\n\t\t\ti = i + 1\n\t\t\tk = k + 1\n\t\twhile j < len(right):\n\t\t\tarr[k] = right[j]\n\t\t\tcntarr[k] = rightcount[j]\n\t\t\tj = j + 1\n\t\t\tk = k + 1\n\ndef smaller(arr):\n\tposarr = [i for i in range(len(arr))]\n\tcntdict = {i: 0 for i in range(len(arr))}\n\tcountsort(arr, posarr, cntdict)\n\tsoln = []\n\tfor i in range(len(arr)):\n\t\tsoln.append(cntdict[i])\n\treturn soln\n"], "public_test_cases": [{"input": [[5, 4, 3, 2, 1]], "output": [4, 3, 2, 1, 0], "type": "functional"}, {"input": [[1, 2, 0]], "output": [1, 1, 0], "type": "functional"}, {"input": [[1, 2, 3]], "output": [0, 0, 0], "type": "functional"}], "test_cases": [{"input": [[5, 4, 3, 2, 1]], "output": [[4, 3, 2, 1, 0]], "type": "functional"}, {"input": [[1, 2, 3]], "output": [[0, 0, 0]], "type": "functional"}, {"input": [[1, 2, 0]], "output": [[1, 1, 0]], "type": "functional"}, {"input": [[1, 2, 1]], "output": [[0, 1, 0]], "type": "functional"}, {"input": [[1, 1, -1, 0, 0]], "output": [[3, 3, 0, 0, 0]], "type": "functional"}, {"input": [[5, 4, 7, 9, 2, 4, 4, 5, 6]], "output": [[4, 1, 5, 5, 0, 0, 0, 0, 0]], "type": "functional"}], "problem_id": "taco_train_428", "metadata": {"func_name": "smaller", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 6}, "generated_solutions": []}
{"problem": "# RoboScript #2 - Implement the RS1 Specification\n\n## Disclaimer\n\nThe story presented in this Kata Series is purely fictional; any resemblance to actual programming languages, products, organisations or people should be treated as purely coincidental.\n\n## About this Kata Series\n\nThis Kata Series is based on a fictional story about a computer scientist and engineer who owns a firm that sells a toy robot called MyRobot which can interpret its own (esoteric) programming language called RoboScript.  Naturally, this Kata Series deals with the software side of things (I'm afraid Codewars cannot test your ability to build a physical robot!).\n\n## Story\n\nNow that you've built your own code editor for RoboScript with appropriate syntax highlighting to make it look like serious code, it's time to properly implement RoboScript so that our MyRobots can execute any RoboScript provided and move according to the will of our customers.  Since this is the first version of RoboScript, let's call our specification RS1 (like how the newest specification for JavaScript is called ES6 :p)\n\n## Task\n\nWrite an interpreter for RS1 called `execute()` which accepts 1 required argument `code`, the RS1 program to be executed.  The interpreter should return a string representation of the smallest 2D grid containing the full path that the MyRobot has walked on (explained in more detail later).\n\nInitially, the robot starts at the middle of a 1x1 grid.  Everywhere the robot walks it will leave a path `\"*\"`.  If the robot has not been at a particular point on the grid then that point will be represented by a whitespace character `\" \"`.  So if the RS1 program passed in to `execute()` is empty, then:\n\n```\n\"\"  -->  \"*\"\n```\n\nThe robot understands 3 major commands:\n\n- `F` - Move forward by 1 step in the direction that it is currently pointing.  Initially, the robot faces to the right.\n- `L` - Turn \"left\" (i.e. **rotate** 90 degrees **anticlockwise**)\n- `R` - Turn \"right\" (i.e. **rotate** 90 degrees **clockwise**)\n\nAs the robot moves forward, if there is not enough space in the grid, the grid should expand accordingly. So:\n\n```\n\"FFFFF\"  -->  \"******\"\n```\n\nAs you will notice, 5 `F` commands in a row should cause your interpreter to return a string containing 6 `\"*\"`s in a row.  This is because initially, your robot is standing at the middle of the 1x1 grid facing right.  It leaves a mark on the spot it is standing on, hence the first `\"*\"`.  Upon the first command, the robot moves 1 unit to the right.  Since the 1x1 grid is not large enough, your interpreter should expand the grid 1 unit to the right.  The robot then leaves a mark on its newly arrived destination hence the second `\"*\"`.  As this process is repeated 4 more times, the grid expands 4 more units to the right and the robot keeps leaving a mark on its newly arrived destination so by the time the entire program is executed, 6 \"squares\" have been marked `\"*\"` from left to right.\n\nEach row in your grid must be separated from the next by a CRLF (`\\r\\n`).  Let's look at another example:\n\n```\n\"FFFFFLFFFFFLFFFFFLFFFFFL\"  -->  \"******\\r\\n*    *\\r\\n*    *\\r\\n*    *\\r\\n*    *\\r\\n******\"\n```\n\nSo the grid will look like this:\n```\n******\n*    *\n*    *\n*    *\n*    *\n******\n```\n\nThe robot moves 5 units to the right, then turns left, then moves 5 units upwards, then turns left again, then moves 5 units to the left, then turns left again and moves 5 units downwards, returning to the starting point before turning left one final time.  Note that the marks do **not** disappear no matter how many times the robot steps on them, e.g. the starting point is still marked `\"*\"` despite the robot having stepped on it twice (initially and on the last step).\n\nAnother example:\n\n```\n\"LFFFFFRFFFRFFFRFFFFFFF\"  -->  \"    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   \"\n```\nSo the grid will look like this:\n```\n    ****\n    *  *\n    *  *\n********\n    *\n    *\n```\n\nInitially the robot turns left to face upwards, then moves upwards 5 squares, then turns right and moves 3 squares, then turns right again (to face downwards) and move 3 squares, then finally turns right again and moves 7 squares.\n\nSince you've realised that it is probably quite inefficient to repeat certain commands over and over again by repeating the characters (especially the `F` command - what if you want to move forwards 20 steps?), you decide to allow a shorthand notation in the RS1 specification which allows your customers to postfix a non-negative integer onto a command to specify how many times an instruction is to be executed:\n\n- `Fn` - Execute the `F` command `n` times (NOTE: `n` *may* be more than 1 digit long!)\n- `Ln` - Execute `L` n times\n- `Rn` - Execute `R` n times\n\nSo the example directly above can also be written as:\n\n```\n\"LF5RF3RF3RF7\"\n```\n\nThese 5 example test cases have been included for you :)\n\n## Kata in this Series\n\n1. [RoboScript #1 - Implement Syntax Highlighting](https://www.codewars.com/kata/roboscript-number-1-implement-syntax-highlighting)\n2. **RoboScript #2 - Implement the RS1 Specification**\n3. [RoboScript #3 - Implement the RS2 Specification](https://www.codewars.com/kata/58738d518ec3b4bf95000192)\n4. [RoboScript #4 - RS3 Patterns to the Rescue](https://www.codewars.com/kata/594b898169c1d644f900002e)\n5. [RoboScript #5 - The Final Obstacle (Implement RSU)](https://www.codewars.com/kata/5a12755832b8b956a9000133)", "solutions": ["from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute(code):\n\t(pos, dirs) = ((0, 0), deque([(0, 1), (1, 0), (0, -1), (-1, 0)]))\n\tseens = {pos}\n\tfor (act, n) in TOKENIZER.findall(code):\n\t\t(s, r) = (act[0], int(n or '1') + len(act) - 1)\n\t\tif s == 'F':\n\t\t\tfor _ in range(r):\n\t\t\t\tpos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n\t\t\t\tseens.add(pos)\n\t\telse:\n\t\t\tdirs.rotate(r % 4 * (-1) ** (s == 'R'))\n\t(miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n\t(miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n\treturn '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n", "import re\nDIRS = [(1, 0), (0, 1), (-1, 0), (0, -1)] * 2\n\ndef execute(code):\n\t(grid, (dx, dy)) = ({(0, 0)}, DIRS[0])\n\tx = y = xm = ym = xM = yM = 0\n\tfor (dir, n) in re.findall('([FLR])(\\\\d*)', code):\n\t\tfor _ in range(int(n or '1')):\n\t\t\tif dir == 'L':\n\t\t\t\t(dx, dy) = DIRS[DIRS.index((dx, dy)) - 1]\n\t\t\tif dir == 'R':\n\t\t\t\t(dx, dy) = DIRS[DIRS.index((dx, dy)) + 1]\n\t\t\tif dir == 'F':\n\t\t\t\tx += dx\n\t\t\t\ty += dy\n\t\t\t\tgrid.add((x, y))\n\t\t\t\t(xm, ym, xM, yM) = (min(xm, x), min(ym, y), max(xM, x), max(yM, y))\n\treturn '\\r\\n'.join((''.join((' *'[(x, y) in grid] for x in range(xm, xM + 1))) for y in range(ym, yM + 1)))\n", "import re\n\ndef execute(code):\n\tif code == '':\n\t\treturn '*'\n\tturn_right = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\tturn_left = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\tpath = re.findall('F\\\\d+|F|L\\\\d+|L|R\\\\d+|R', code)\n\tmax_size = sum([1 if j == 'F' else int(j[1:]) for j in path if 'F' in j]) * 2\n\ttable = [[' '] * (max_size + 1) for i in range(max_size + 1)]\n\t(x, y) = (max_size // 2, max_size // 2)\n\ttable[x][y] = '*'\n\t(f1, f2) = (0, 1)\n\tfor way in path:\n\t\tif 'R' in way:\n\t\t\tfor i in range(1 if way == 'R' else int(way[1:])):\n\t\t\t\tcur_pos = [pos for (pos, coords) in enumerate(turn_right) if coords == [f1, f2]][0]\n\t\t\t\t(f1, f2) = turn_right[0] if cur_pos == 3 else turn_right[cur_pos + 1]\n\t\tif 'L' in way:\n\t\t\tfor i in range(1 if way == 'L' else int(way[1:])):\n\t\t\t\tcur_pos = [pos for (pos, coords) in enumerate(turn_left) if coords == [f1, f2]][0]\n\t\t\t\t(f1, f2) = turn_left[0] if cur_pos == 3 else turn_left[cur_pos + 1]\n\t\tif 'F' in way:\n\t\t\tfor i in range(1 if way == 'F' else int(way[1:])):\n\t\t\t\tx += 1 * f1\n\t\t\t\ty += 1 * f2\n\t\t\t\ttable[x][y] = '*'\n\tsolution = [i for i in table if '*' in i]\n\tsolution = [i for i in zip(*solution[:]) if '*' in i]\n\tfor i in range(3):\n\t\tsolution = list(zip(*solution[:]))\n\tfinal_way = [''.join([j for j in i]) for i in solution]\n\treturn '\\r\\n'.join(final_way)\n", "import re\nfrom enum import Enum\nfrom operator import itemgetter\nfrom typing import List, Tuple, Set, Generator\nCell = Tuple[int, int]\n\nclass Direction(Enum):\n\tUP = (0, 1)\n\tDOWN = (0, -1)\n\tRIGHT = (1, 0)\n\tLEFT = (-1, 0)\n\ndef execute(code: str) -> str:\n\tvisited_cells = visit_cells(code)\n\tpath = draw_path(visited_cells)\n\treturn path\n\ndef visit_cells(code: str) -> Set[Cell]:\n\tvisited_cells = [(0, 0)]\n\tdirection = Direction.RIGHT\n\tfor (action, n_times) in code_interpreter(code):\n\t\tif action == 'F':\n\t\t\tnew_cells = move_forward(visited_cells[-1], direction, n_times)\n\t\t\tvisited_cells.extend(new_cells)\n\t\telse:\n\t\t\tdirection = make_turn(direction, action, n_times)\n\treturn set(visited_cells)\n\ndef code_interpreter(code: str) -> Generator[Tuple[str, int], None, None]:\n\tfor move in re.finditer('([LRF])(\\\\d*)', code):\n\t\taction = move.group(1)\n\t\ttimes = int(move.group(2)) if move.group(2) else 1\n\t\tyield (action, times)\n\ndef move_forward(position: Cell, direction: Direction, n_moves: int) -> List[Cell]:\n\t(px, py) = position\n\t(dx, dy) = direction.value\n\treturn [(px + i * dx, py + i * dy) for i in range(1, n_moves + 1)]\n\ndef make_turn(start: Direction, side: str, n_turns: int) -> Direction:\n\tordering = [Direction.RIGHT, Direction.DOWN, Direction.LEFT, Direction.UP]\n\tstep = 1 if side == 'R' else -1\n\treturn ordering[(ordering.index(start) + step * n_turns) % len(ordering)]\n\ndef draw_path(visited_cells: Set[Cell]) -> str:\n\t(max_x, min_x, max_y, min_y) = find_cells_boundaries(visited_cells)\n\trectangle = list()\n\tfor y in range(max_y, min_y - 1, -1):\n\t\trow = ['*' if (x, y) in visited_cells else ' ' for x in range(min_x, max_x + 1)]\n\t\trectangle.append(''.join(row))\n\treturn '\\r\\n'.join(rectangle)\n\ndef find_cells_boundaries(visited_cells: Set[Cell]) -> Tuple[int, int, int, int]:\n\t(max_x, _) = max(visited_cells, key=itemgetter(0))\n\t(min_x, _) = min(visited_cells, key=itemgetter(0))\n\t(_, max_y) = max(visited_cells, key=itemgetter(1))\n\t(_, min_y) = min(visited_cells, key=itemgetter(1))\n\treturn (max_x, min_x, max_y, min_y)\n", "import re\nleft = {'right': 'up', 'up': 'left', 'left': 'down', 'down': 'right'}\nright = {'right': 'down', 'down': 'left', 'left': 'up', 'up': 'right'}\n\ndef execute(s):\n\t(s, direction) = (re.sub('([RFL])(\\\\d+)', lambda x: x.group(1) * int(x.group(2)), s), 'right')\n\t(p, p1, li) = (0, 0, [[0, 0]])\n\tfor i in s:\n\t\tif i == 'L':\n\t\t\tdirection = left[direction]\n\t\tif i == 'R':\n\t\t\tdirection = right[direction]\n\t\tif i == 'F':\n\t\t\tp1 += (1 if direction == 'right' else -1) if direction in ['left', 'right'] else 0\n\t\t\tp += (1 if direction == 'down' else -1) if direction in ['up', 'down'] else 0\n\t\t\tli.append([p, p1])\n\t(m, n) = (abs(min(li, key=lambda x: x[0])[0]) + max(li, key=lambda x: x[0])[0], abs(min(li, key=lambda x: x[1])[1]) + max(li, key=lambda x: x[1])[1])\n\t(p, p1, grid) = (abs(min(li, key=lambda x: x[0])[0]), abs(min(li, key=lambda x: x[1])[1]), [[' ' for _ in range(n + 1)] for _ in range(m + 1)])\n\tfor (i, j) in li:\n\t\tgrid[p + i][p1 + j] = '*'\n\treturn '\\r\\n'.join([''.join(i) for i in grid])\n", "import numpy as np\n\ndef switch(argument):\n\tswitcher = {'F': 0, 'L': -1, 'R': 1}\n\treturn switcher.get(argument, '')\n\ndef resize(p_matrix, num, axis, dir):\n\tif axis == 1:\n\t\tright = np.zeros((p_matrix.shape[0], num))\n\t\tleft = p_matrix\n\t\tif dir == 2:\n\t\t\t(right, left) = (left, right)\n\t\tre_matrix = np.append(left, right, axis)\n\telse:\n\t\ttop = np.zeros((num, p_matrix.shape[1]))\n\t\tbot = p_matrix\n\t\tif dir == 1:\n\t\t\t(top, bot) = (bot, top)\n\t\tre_matrix = np.append(top, bot, axis)\n\treturn re_matrix\n\ndef mk_matrix(trace):\n\tp_matrix = np.full((1, 1), 1)\n\tpos = [0, 0]\n\tfor i in range(len(trace)):\n\t\tdir = trace[i][0]\n\t\tstep = trace[i][1]\n\t\tif step != 0:\n\t\t\tif dir == 0:\n\t\t\t\tif pos[1] + step + 1 > p_matrix.shape[1]:\n\t\t\t\t\tp_matrix = resize(p_matrix, pos[1] + step - p_matrix.shape[1] + 1, 1, dir)\n\t\t\t\tp_matrix[pos[0], pos[1] + 1:pos[1] + step + 1] = 1\n\t\t\t\tpos[1] = pos[1] + step\n\t\t\telif dir == 1:\n\t\t\t\tif pos[0] + step + 1 > p_matrix.shape[0]:\n\t\t\t\t\tp_matrix = resize(p_matrix, pos[0] + step - p_matrix.shape[0] + 1, 0, dir)\n\t\t\t\tp_matrix[pos[0] + 1:pos[0] + 1 + step, pos[1]] = 1\n\t\t\t\tpos[0] = pos[0] + step\n\t\t\telif dir == 2:\n\t\t\t\tif pos[1] - step < 0:\n\t\t\t\t\tp_matrix = resize(p_matrix, step - pos[1], 1, dir)\n\t\t\t\t\tpos[1] = step\n\t\t\t\tp_matrix[pos[0], pos[1] - step:pos[1]] = 1\n\t\t\t\tpos[1] = pos[1] - step\n\t\t\telse:\n\t\t\t\tif pos[0] - step < 0:\n\t\t\t\t\tp_matrix = resize(p_matrix, step - pos[0], 0, dir)\n\t\t\t\t\tpos[0] = step\n\t\t\t\tp_matrix[pos[0] - step:pos[0], pos[1]] = 1\n\t\t\t\tpos[0] = pos[0] - step\n\treturn p_matrix\n\ndef tracing(path):\n\tdir = 0\n\ttrace = []\n\tfor j in range(len(path)):\n\t\tstep = 0\n\t\tif path[j][0] == 0:\n\t\t\tif len(path[j]) == 2:\n\t\t\t\tstep = path[j][1]\n\t\t\telse:\n\t\t\t\tstep = 1\n\t\telif len(path[j]) == 2:\n\t\t\tdir = (path[j][0] * path[j][1] + dir) % 4\n\t\telse:\n\t\t\tdir = (dir + path[j][0]) % 4\n\t\ttrace.append([dir, step])\n\treturn trace\n\ndef pathing(code):\n\tpath = []\n\tway = -1\n\tnum = -1\n\tfor i in range(len(code)):\n\t\tif i < num:\n\t\t\tcontinue\n\t\tqnt = ''\n\t\tnum = i\n\t\tif code[i].isdecimal():\n\t\t\tif num < len(code):\n\t\t\t\twhile code[num].isdecimal():\n\t\t\t\t\tqnt += code[num]\n\t\t\t\t\tif num + 1 >= len(code):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tnum += 1\n\t\t\t\tif len(path[way]) < 2:\n\t\t\t\t\tlength = int(qnt, 10)\n\t\t\t\t\tpath[way].append(length)\n\t\telse:\n\t\t\tway += 1\n\t\t\tpath.append([])\n\t\t\tpath[way].append(switch(code[i]))\n\treturn path\n\ndef str_mx(matrix):\n\tstr = []\n\tsubm = np.full(matrix.shape, ' ')\n\tfor i in range(matrix.shape[0]):\n\t\tfor j in range(matrix.shape[1]):\n\t\t\tif matrix[i][j]:\n\t\t\t\tsubm[i][j] = '*'\n\t\tif i > 0:\n\t\t\tstr.append('\\r\\n')\n\t\tstr.append(''.join(subm[i]))\n\treturn ''.join(str)\n\ndef execute(code):\n\tpath = pathing(code)\n\ttrace = tracing(path)\n\tmatrix = mk_matrix(trace)\n\tprint(matrix)\n\tstr = str_mx(matrix)\n\treturn str\n", "def execute(codes):\n\tNums = '0123456789'\n\tcode = ''\n\tt = 0\n\tc = 0\n\twhile t < len(codes):\n\t\tChar = 0\n\t\tc = 1\n\t\tif t < len(codes) - 1:\n\t\t\tfor g in codes[t + 1:]:\n\t\t\t\tif g in Nums:\n\t\t\t\t\tChar += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\t\tc = int(codes[t + 1:t + Char + 1])\n\t\tcode += codes[t] * c\n\t\tt += 1 + Char\n\tXs = 0\n\tYs = 0\n\tX = []\n\tY = []\n\tYmin = 0\n\tStep = [[0, 0]]\n\tRotation = 0\n\tArr = []\n\tOut = ''\n\tfor i in range(len(code)):\n\t\tif code[i] == 'L':\n\t\t\tRotation += 90\n\t\telif code[i] == 'R':\n\t\t\tRotation += -90\n\t\tif Rotation > 180:\n\t\t\twhile Rotation > 180:\n\t\t\t\tRotation += -360\n\t\telif Rotation < -180:\n\t\t\twhile Rotation < -180:\n\t\t\t\tRotation += 360\n\t\tif code[i] == 'F':\n\t\t\tif Rotation == 0:\n\t\t\t\tXs += 1\n\t\t\telif Rotation == -180 or Rotation == 180:\n\t\t\t\tXs += -1\n\t\t\telif Rotation == 90:\n\t\t\t\tYs += 1\n\t\t\telif Rotation == -90:\n\t\t\t\tYs += -1\n\t\t\tStep.append([Xs, Ys])\n\tfor u in Step:\n\t\tX.append(u[0])\n\t\tY.append(u[1])\n\tfor j in range(len(Step)):\n\t\tStep[j][0] = Step[j][0] + min(X) * -1\n\t\tStep[j][1] = Step[j][1] + min(Y) * -1\n\tfor k in range(max(Y) - min(Y) + 1):\n\t\tArr.append([' '] * (max(X) - min(X) + 1))\n\tfor l in Step:\n\t\tArr[max(Y) - min(Y) - l[1]][l[0]] = '*'\n\tfor n in range(len(Arr)):\n\t\tfor p in range(max(X) - min(X) + 1):\n\t\t\tOut += Arr[n][p]\n\t\tOut += '\\r\\n'\n\tOut = Out[:-2]\n\treturn Out\n", "def execute(code):\n\t(R, r, c, dr, dc) = ({(0, 0)}, 0, 0, 0, 1)\n\tD = {(1, 0): {'R': (0, -1), 'L': (0, 1)}, (-1, 0): {'R': (0, 1), 'L': (0, -1)}, (0, 1): {'R': (1, 0), 'L': (-1, 0)}, (0, -1): {'R': (-1, 0), 'L': (1, 0)}}\n\tfor cmd in code.replace('R', ' R').replace('L', ' L').replace('F', ' F').strip().split():\n\t\t(cmd, n) = (cmd[:1], int(cmd[1:]) if cmd[1:] else 1)\n\t\tfor _ in range(n):\n\t\t\tif cmd in 'RL':\n\t\t\t\t(dr, dc) = D[dr, dc][cmd]\n\t\t\telse:\n\t\t\t\t(r, c) = (r + dr, c + dc)\n\t\t\t\tR.add((r, c))\n\tmnr = min((r for (r, _) in R))\n\tmnc = min((c for (_, c) in R))\n\tR = {(r - mnr, c - mnc) for (r, c) in R}\n\tmxr = max((r for (r, _) in R))\n\tmxc = max((c for (_, c) in R))\n\treturn '\\r\\n'.join((''.join((' *'[(r, c) in R] for c in range(mxc + 1))) for r in range(mxr + 1)))\n", "import re\n\ndef update_grid(px, py, grid):\n\theight = len(grid)\n\twidth = len(grid[0])\n\tif px < 0:\n\t\tpx += 1\n\t\tfor y in range(height):\n\t\t\tgrid[y] = ' ' + grid[y]\n\tif px >= width:\n\t\tfor y in range(height):\n\t\t\tgrid[y] = grid[y] + ' '\n\tif py < 0:\n\t\tpy += 1\n\t\tgrid.insert(0, ' ' * width)\n\tif py >= height:\n\t\tgrid.append(' ' * width)\n\tgrid[py] = grid[py][:px] + '*' + grid[py][px + 1:]\n\treturn (px, py, grid)\n\ndef execute(code):\n\tgrid = ['*']\n\t(x, y) = (0, 0)\n\tfacing = (1, 0)\n\twhile code:\n\t\tmatch = re.match('([FLR])(\\\\d*)', code)\n\t\tcode = re.sub('^([FLR])(\\\\d*)', '', code)\n\t\top = match[1]\n\t\trep = int(match[2] or '1')\n\t\tfor i in range(rep):\n\t\t\tif op == 'F':\n\t\t\t\tx += facing[0]\n\t\t\t\ty += facing[1]\n\t\t\t\t(x, y, grid) = update_grid(x, y, grid)\n\t\t\tif op == 'L':\n\t\t\t\tfacing = (facing[1], -facing[0])\n\t\t\tif op == 'R':\n\t\t\t\tfacing = (-facing[1], facing[0])\n\treturn '\\r\\n'.join(grid)\n", "BLANK = ' '\nFILLCHAR = '*'\n\ndef pad_mtx(M, side='e'):\n\tif side == 'w':\n\t\tfor i in range(len(M)):\n\t\t\tM[i] = [BLANK] + M[i][::1]\n\telif side == 'e':\n\t\tfor i in range(len(M)):\n\t\t\tM[i] += [BLANK]\n\telif side == 'n':\n\t\tM.insert(0, [BLANK for _ in range(len(M[0]))])\n\telif side == 's':\n\t\tM.append([BLANK for _ in range(len(M[0]))])\n\ndef move(mtx, pos, drxn):\n\tif drxn == 'e':\n\t\tpos[1] += 1\n\telif drxn == 'w':\n\t\tpos[1] -= 1\n\telif drxn == 's':\n\t\tpos[0] += 1\n\telif drxn == 'n':\n\t\tpos[0] -= 1\n\telse:\n\t\traise ValueError('Direction unrecognized.')\n\ttry:\n\t\tif any((x < 0 for x in pos)):\n\t\t\traise ValueError\n\t\telse:\n\t\t\tmtx[pos[0]][pos[1]] = FILLCHAR\n\texcept Exception:\n\t\tpad_mtx(mtx, side=drxn)\n\t\tif drxn == 'n':\n\t\t\tpos[0] += 1\n\t\tif drxn == 'w':\n\t\t\tpos[1] += 1\n\t\tmtx[pos[0]][pos[1]] = FILLCHAR\n\ndef rotate(current, turn):\n\tdirections = ['e', 's', 'w', 'n']\n\tturns = {'L': -1, 'R': 1}\n\tidx = directions.index(current)\n\treturn directions[(idx + turns[turn]) % len(directions)]\n\ndef execute(code):\n\tdirections = ['e', 's', 'w', 'n']\n\tpath = [[FILLCHAR]]\n\tpos = [0, 0]\n\tdrxn = 'e'\n\ti = 0\n\twhile i < len(code):\n\t\tnum = ''\n\t\tif i != len(code) - 1 and code[i + 1].isdigit():\n\t\t\tj = i + 1\n\t\t\twhile j < len(code) and code[j].isdigit():\n\t\t\t\tnum += code[j]\n\t\t\t\tj += 1\n\t\t\tfor _ in range(int(num)):\n\t\t\t\tif code[i] in 'LR':\n\t\t\t\t\tdrxn = rotate(drxn, code[i])\n\t\t\t\telif code[i] == 'F':\n\t\t\t\t\tmove(path, pos, drxn)\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\telif code[i] == 'F':\n\t\t\tmove(path, pos, drxn)\n\t\telif code[i] in 'LR':\n\t\t\tdrxn = rotate(drxn, code[i])\n\t\ti += 1\n\treturn '\\r\\n'.join((''.join(row) for row in path))\n"], "public_test_cases": [{"input": [""], "output": ["*"], "type": "functional"}, {"input": ["FFFFF"], "output": ["******"], "type": "functional"}, {"input": ["FFFFFLFFFFFLFFFFFLFFFFFL"], "output": ["******\r\n*    *\r\n*    *\r\n*    *\r\n*    *\r\n******"], "type": "functional"}, {"input": ["LFFFFFRFFFRFFFRFFFFFFF"], "output": ["    ****\r\n    *  *\r\n    *  *\r\n********\r\n    *   \r\n    *   "], "type": "functional"}, {"input": ["LF5RF3RF3RF7"], "output": ["    ****\r\n    *  *\r\n    *  *\r\n********\r\n    *   \r\n    *   "], "type": "functional"}], "test_cases": [{"input": [""], "output": ["*"], "type": "functional"}, {"input": ["FFFFF"], "output": ["******"], "type": "functional"}, {"input": ["FFFFFLFFFFFLFFFFFLFFFFFL"], "output": ["******\r\n*    *\r\n*    *\r\n*    *\r\n*    *\r\n******"], "type": "functional"}, {"input": ["LFFFFFRFFFRFFFRFFFFFFF"], "output": ["    ****\r\n    *  *\r\n    *  *\r\n********\r\n    *   \r\n    *   "], "type": "functional"}, {"input": ["LF5RF3RF3RF7"], "output": ["    ****\r\n    *  *\r\n    *  *\r\n********\r\n    *   \r\n    *   "], "type": "functional"}, {"input": ["FFFLLFFFFFFRRFFFLFFFRRFFFFFFFF"], "output": ["   *   \r\n   *   \r\n   *   \r\n*******\r\n   *   \r\n   *   \r\n   *   \r\n   *   \r\n   *   "], "type": "functional"}, {"input": ["F3L2F6R2F3LF3R2F8"], "output": ["   *   \r\n   *   \r\n   *   \r\n*******\r\n   *   \r\n   *   \r\n   *   \r\n   *   \r\n   *   "], "type": "functional"}, {"input": ["F2FLLF3F3R2FFFLF2FRRF3F2F2F"], "output": ["   *   \r\n   *   \r\n   *   \r\n*******\r\n   *   \r\n   *   \r\n   *   \r\n   *   \r\n   *   "], "type": "functional"}, {"input": ["FFLFFFLFFFFLFFFFFLFFFFFFLFFFFFFFLFFFFFFFFLFFFFFFFFFLFFFFFFFFFF"], "output": ["*********  \r\n*       *  \r\n* ***** *  \r\n* *   * *  \r\n* *   * *  \r\n* * *** *  \r\n* *     *  \r\n* *******  \r\n*          \r\n***********"], "type": "functional"}, {"input": ["F2LF3LF4LF5LF6LF7LF8LF9LF10"], "output": ["*********  \r\n*       *  \r\n* ***** *  \r\n* *   * *  \r\n* *   * *  \r\n* * *** *  \r\n* *     *  \r\n* *******  \r\n*          \r\n***********"], "type": "functional"}, {"input": ["FFFFLFFFFRFFFFRFFFFLFFFFLFFFFRFFFFRFFFFLFFFFLFFFFRFFFFRFFFF"], "output": ["    *****   *****   *****\r\n    *   *   *   *   *   *\r\n    *   *   *   *   *   *\r\n    *   *   *   *   *   *\r\n*****   *****   *****   *"], "type": "functional"}, {"input": ["F4LF4RF4RF4LF4LF4RF4RF4LF4LF4RF4RF4"], "output": ["    *****   *****   *****\r\n    *   *   *   *   *   *\r\n    *   *   *   *   *   *\r\n    *   *   *   *   *   *\r\n*****   *****   *****   *"], "type": "functional"}], "problem_id": "taco_train_6563", "metadata": {"func_name": "execute", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 5, "num_original_tests": 12}, "generated_solutions": []}
{"problem": "Given a credit card number we can determine who the issuer/vendor is with a few basic knowns.\n\n```if:python\nComplete the function `get_issuer()` that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`.\n```\n```if-not:python\nComplete the function `getIssuer()` that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`.\n```\n```if:typescript\nWhere `Issuer` is defined with the following enum type.\n~~~typescript\nenum Issuer {\n  VISA = 'VISA',\n  AMEX = 'AMEX',\n  Mastercard = 'Mastercard',\n  Discover = 'Discover',\n  Unknown = 'Unknown',\n}\n~~~\n```\n\n```markdown\n| Card Type  | Begins With          | Number Length |\n|------------|----------------------|---------------|\n| AMEX       | 34 or 37             | 15            |\n| Discover   | 6011                 | 16            |\n| Mastercard | 51, 52, 53, 54 or 55 | 16            |\n| VISA       | 4                    | 13 or 16      |\n```\n\n```if:c,cpp\n**C/C++ note:** The return value in C is not freed.\n```\n\n## Examples\n\n```if-not:python\n~~~js\ngetIssuer(4111111111111111) == \"VISA\"\ngetIssuer(4111111111111) == \"VISA\"\ngetIssuer(4012888888881881) == \"VISA\"\ngetIssuer(378282246310005) == \"AMEX\"\ngetIssuer(6011111111111117) == \"Discover\"\ngetIssuer(5105105105105100) == \"Mastercard\"\ngetIssuer(5105105105105106) == \"Mastercard\"\ngetIssuer(9111111111111111) == \"Unknown\"\n~~~\n```\n```if:python\n~~~py\nget_issuer(4111111111111111) == \"VISA\"\nget_issuer(4111111111111) == \"VISA\"\nget_issuer(4012888888881881) == \"VISA\"\nget_issuer(378282246310005) == \"AMEX\"\nget_issuer(6011111111111117) == \"Discover\"\nget_issuer(5105105105105100) == \"Mastercard\"\nget_issuer(5105105105105106) == \"Mastercard\"\nget_issuer(9111111111111111) == \"Unknown\"\n~~~\n```", "solutions": ["def get_issuer(number):\n\ts = str(number)\n\treturn 'AMEX' if len(s) == 15 and s[:2] in ('34', '37') else 'Discover' if len(s) == 16 and s.startswith('6011') else 'Mastercard' if len(s) == 16 and s[0] == '5' and (s[1] in '12345') else 'VISA' if len(s) in [13, 16] and s[0] == '4' else 'Unknown'\n", "VENDORS = [['AMEX', (34, 37), (15,)], ['Discover', (6011,), (16,)], ['Mastercard', range(51, 56), (16,)], ['VISA', (4,), (13, 16)]]\n\ndef get_issuer(number):\n\treturn next((vendor[0] for vendor in VENDORS if len(str(number)) in vendor[2] and any((str(number).startswith(str(start)) for start in vendor[1]))), 'Unknown')\n", "import re\nREGEX = re.compile('\\n(?P<AMEX>3[47]\\\\d{13}$) |\\n(?P<Discover>6011\\\\d{12}$) |\\n(?P<Mastercard>5[1-5]\\\\d{14}$) |\\n(?P<VISA>(?:4\\\\d{15}|4\\\\d{12})$)', re.VERBOSE)\n\ndef get_issuer(card_num):\n\ttry:\n\t\treturn next((k for (k, v) in REGEX.match(str(card_num)).groupdict().items() if v is not None))\n\texcept AttributeError:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tcard = str(number)\n\tnums = len(card)\n\tif card[:2] in ('34', '37') and nums == 15:\n\t\treturn 'AMEX'\n\telif card[:4] == '6011' and nums == 16:\n\t\treturn 'Discover'\n\telif 51 <= int(card[:2]) <= 55 and nums == 16:\n\t\treturn 'Mastercard'\n\telif card[0] == '4' and nums in (13, 16):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "ISSUERS = {((34, 37), (15,)): 'AMEX', ((6011,), (16,)): 'Discover', ((51, 52, 53, 54, 55), (16,)): 'Mastercard', ((4,), (13, 16)): 'VISA'}\n\ndef get_issuer(number):\n\treturn next((issuer for ((starts, lengths), issuer) in ISSUERS.items() if str(number).startswith(tuple(map(str, starts))) and len(str(number)) in lengths), 'Unknown')\n", "from collections import namedtuple\nIssuer = namedtuple('Issuer', 'name, begins, length')\n\ndef get_issuer(number):\n\tissuers = [Issuer('AMEX', [34, 37], [15]), Issuer('Discover', [6011], [16]), Issuer('Mastercard', [51, 52, 53, 54, 55], [16]), Issuer('VISA', [4], [13, 16])]\n\tnumber_str = str(number)\n\tfor issuer in issuers:\n\t\tif any([number_str.startswith(str(n)) for n in issuer.begins]) and len(number_str) in issuer.length:\n\t\t\treturn issuer.name\n\treturn 'Unknown'\n", "def get_issuer(number):\n\tnumber = number // 1000000000000\n\tif number == 4:\n\t\treturn 'VISA'\n\tif number == 6011:\n\t\treturn 'Discover'\n\tnumber = number // 10\n\tif number == 34 or number == 37:\n\t\treturn 'AMEX'\n\tif 50 < number // 10 < 56:\n\t\treturn 'Mastercard'\n\tif number // 100 == 4:\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "from typing import Tuple\n\nclass Card:\n\n\tdef __init__(self, name: str, begins_with: Tuple[int, ...], number_length: Tuple[int, ...]):\n\t\tself.name = name\n\t\tself.begins_with = list(map(str, begins_with))\n\t\tself.number_length = number_length\n\n\tdef is_valid(self, number: str) -> bool:\n\t\treturn any((number.startswith(b) for b in self.begins_with)) and len(number) in self.number_length\nCARDS = (Card('AMEX', (34, 37), (15,)), Card('Discover', (6011,), (16,)), Card('Mastercard', (51, 52, 53, 54, 55), (16,)), Card('VISA', (4,), (13, 16)))\n\ndef get_issuer(number: int):\n\tn = str(number)\n\treturn next((c.name for c in CARDS if c.is_valid(n)), 'Unknown')\n", "from re import match\n\ndef get_issuer(number):\n\tnumber = str(number)\n\tif match('^3[4|7]\\\\d{13}$', number):\n\t\treturn 'AMEX'\n\tif match('^6011\\\\d{12}$', number):\n\t\treturn 'Discover'\n\tif match('^5[1-5]\\\\d{14}$', number):\n\t\treturn 'Mastercard'\n\tif match('^4(\\\\d{12}|\\\\d{15})$', number):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(n):\n\tn = str(n)\n\tif n[:1] == '4' and (len(n) == 13 or len(n) == 16):\n\t\treturn 'VISA'\n\tif (n[:2] == '34' or n[:2] == '37') and len(n) == 15:\n\t\treturn 'AMEX'\n\tif n[:4] == '6011' and len(n) == 16:\n\t\treturn 'Discover'\n\tif n[:1] == '5' and int(n[1]) < 6 and (len(n) == 16):\n\t\treturn 'Mastercard'\n\treturn 'Unknown'\n", "import re\n\ndef get_issuer(number):\n\tfor (n, r) in (('AMEX', '3[47].{13}'), ('Discover', '6011.{12}'), ('Mastercard', '5[1-5].{14}'), ('VISA', '4(...){4,5}')):\n\t\tif re.fullmatch(r, str(number)):\n\t\t\treturn n\n\treturn 'Unknown'\n", "from math import log\n\ndef get_issuer(number):\n\tlength = int(log(number, 10) + 1)\n\t(first_one, first_two, first_four) = (number // 10 ** (length - 1), number // 10 ** (length - 2), number // 10 ** (length - 4))\n\tif length == 16:\n\t\tif first_one == 4:\n\t\t\treturn 'VISA'\n\t\tif first_two in range(51, 56):\n\t\t\treturn 'Mastercard'\n\t\tif first_four == 6011:\n\t\t\treturn 'Discover'\n\telif length == 15:\n\t\tif first_two in (34, 37):\n\t\t\treturn 'AMEX'\n\telif length == 13:\n\t\tif first_one == 4:\n\t\t\treturn 'VISA'\n\treturn 'Unknown'\n", "import re\nissuers = (('AMEX', '3[47].{13}'), ('Discover', '6011.{12}'), ('Mastercard', '5[1-5].{14}'), ('VISA', '4(...){4,5}'), ('Unknown', '.*'))\n\ndef get_issuer(number):\n\treturn next((name for (name, regex) in issuers if re.fullmatch(regex, str(number))))\n", "def get_issuer(number):\n\tcard = str(number)\n\tln = len(card)\n\treturn 'AMEX' if card[:2] in ('34', '37') and ln == 15 else 'Discover' if card[:4] == '6011' and ln == 16 else 'Mastercard' if '50' < card[:2] < '56' and ln == 16 else 'VISA' if card[:1] == '4' and ln in (13, 16) else 'Unknown'\n", "def get_issuer(number):\n\tn = str(number)\n\treturn ['Unknown', 'AMEX', 'Discover', 'Mastercard', 'VISA'][(len(n) == 15 and n[:2] in ['34', '37']) + 2 * (len(n) == 16 and n[:4] == '6011') + 3 * (len(n) == 16 and n[:2] in ['51', '52', '53', '54', '55']) + 4 * (len(n) in [13, 16] and n[0] == '4')]\n", "def get_issuer(number):\n\tn = str(number)\n\tif n[0] == '4' and (len(n) == 16 or len(n) == 13):\n\t\treturn 'VISA'\n\tif n[0] == '5' and n[1] in '12345' and (len(n) == 16):\n\t\treturn 'Mastercard'\n\tif n[0:4] == '6011' and len(n) == 16:\n\t\treturn 'Discover'\n\tif n[0] == '3' and n[1] in '47' and (len(n) == 15):\n\t\treturn 'AMEX'\n\treturn 'Unknown'\n", "def get_issuer(n):\n\tn = str(n)\n\tif n[:2] in ['34', '37'] and len(n) == 15:\n\t\treturn 'AMEX'\n\telif n[:4] == '6011' and len(n) == 16:\n\t\treturn 'Discover'\n\telif n[:2] in ['51', '52', '53', '54', '55'] and len(n) == 16:\n\t\treturn 'Mastercard'\n\telif n[0] == '4' and len(n) in [13, 16]:\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(m):\n\tm = str(m)\n\tif int(m[0:2]) in (34, 37) and len(m) == 15:\n\t\treturn 'AMEX'\n\telif int(m[0:4]) == 6011 and len(m) == 16:\n\t\treturn 'Discover'\n\telif int(m[0:2]) in range(50, 56) and len(m) == 16:\n\t\treturn 'Mastercard'\n\telif int(m[0]) == 4 and len(m) in (13, 16):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tprint(number)\n\tif len(str(number)) < 13:\n\t\treturn 'Unknown'\n\telif str(number)[0] == '4' and (len(str(number)) == 13 or len(str(number)) == 16):\n\t\treturn 'VISA'\n\telif str(number)[:4] == '6011':\n\t\treturn 'Discover'\n\telse:\n\t\treturn {'34': 'AMEX', '37': 'AMEX', '51': 'Mastercard', '52': 'Mastercard', '53': 'Mastercard', '54': 'Mastercard', '55': 'Mastercard'}.get(str(number)[:2], 'Unknown')\n", "def get_issuer(number):\n\tcard_str = str(number)\n\tmaster_card_prefix = list(range(51, 56))\n\tif card_str[0] == '4':\n\t\tif len(card_str) == 13 or len(card_str) == 16:\n\t\t\treturn 'VISA'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif card_str[0:2] == '34' or card_str[0:2] == '37':\n\t\tif len(card_str) == 15:\n\t\t\treturn 'AMEX'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif card_str[0:4] == '6011':\n\t\tif len(card_str) == 16:\n\t\t\treturn 'Discover'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif int(card_str[0:2]) in master_card_prefix:\n\t\tif len(card_str) == 16:\n\t\t\treturn 'Mastercard'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tnumber = [int(x) for x in str(number)]\n\tlength = len(number)\n\tif number[0] == 4 and length == 13 or (number[0] == 4 and length == 16):\n\t\treturn 'VISA'\n\telif number[0] == 3 and number[1] == 4 or ((number[0] == 3 and number[1] == 7) and length == 15):\n\t\treturn 'AMEX'\n\telif number[0] == 5 and (number[1] == 1 or number[1] == 2 or number[1] == 3 or (number[1] == 4) or (number[1] == 5)) and (length == 16):\n\t\treturn 'Mastercard'\n\telif number[0] == 6 and number[1] == 0 and (number[2] == 1) and (number[3] == 1) and (length == 16):\n\t\treturn 'Discover'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\ts = str(number)\n\tif s.startswith('34') or (s.startswith('37') and len(s) == 15):\n\t\treturn 'AMEX'\n\tif s.startswith('6011') and len(s) == 16:\n\t\treturn 'Discover'\n\tif int(s[:2]) in range(51, 56) and len(s) == 16:\n\t\treturn 'Mastercard'\n\tif s.startswith('4') and (len(s) == 13 or len(s) == 16):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\tif str(number).startswith('34') or (str(number).startswith('37') and len(str(number)) == 15):\n\t\treturn 'AMEX'\n\tif str(number).startswith('6011') and len(str(number)) == 16:\n\t\treturn 'Discover'\n\tif str(number).startswith('5') and int(str(number)[1]) < 6 and (len(str(number)) == 16):\n\t\treturn 'Mastercard'\n\tif str(number).startswith('4') and (len(str(number)) == 13 or len(str(number)) == 16):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tnumber = str(number)\n\tif len(number) == 15 and (number.startswith('34') or number.startswith('37')):\n\t\treturn 'AMEX'\n\telif len(number) == 16 and number.startswith('6011'):\n\t\treturn 'Discover'\n\telif len(number) == 16 and (number.startswith('51') or number.startswith('52') or number.startswith('53') or number.startswith('54') or number.startswith('55')):\n\t\treturn 'Mastercard'\n\telif (len(number) == 13 or len(number) == 16) and number.startswith('4'):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "import re\n\ndef get_issuer(number):\n\tp = re.compile('^(?P<VISA>4(\\\\d{15}|\\\\d{12})$)|(?P<AMEX>^(34|37)\\\\d{13}$)|(?P<Mastercard>5[1-5]\\\\d{14}$)|(?P<Discover>6011\\\\d{12}$)').match(str(number))\n\treturn [k for (k, v) in p.groupdict().items() if v][0] if p else 'Unknown'\n", "def get_issuer(n):\n\tprint(str(n))\n\tif str(n)[0] == '4' and (len(str(n)) == 13 or len(str(n)) == 16):\n\t\treturn 'VISA'\n\tif str(n)[0:4] == '6011' and len(str(n)) == 16:\n\t\treturn 'Discover'\n\tif str(n)[0] == '5' and str(n)[1] in '12345' and (len(str(n)) == 16):\n\t\treturn 'Mastercard'\n\tif str(n)[0:2] == '34' or str(n)[0:2] == '37':\n\t\treturn 'AMEX'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tlst = list(str(number))\n\tn_len = len(lst)\n\tif (lst[0:2] == ['3', '4'] or lst[0:2] == ['3', '7']) and n_len == 15:\n\t\treturn 'AMEX'\n\telif lst[0:4] == ['6', '0', '1', '1'] and n_len == 16:\n\t\treturn 'Discover'\n\telif (lst[0] == '5' and lst[1] in ('1', '2', '3', '4', '5')) and n_len == 16:\n\t\treturn 'Mastercard'\n\telif lst[0] == '4' and (n_len == 13 or n_len == 16):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tif str(number)[0] == '3' and str(number)[1] == '4' or (str(number)[1] == '7' and len(str(number)) == 15):\n\t\treturn 'AMEX'\n\telif len(str(number)) == 16 and str(number)[0:4] == '6011':\n\t\treturn 'Discover'\n\telif len(str(number)) == 16 and str(number)[0] == '5' and (str(number)[1] == '1' or str(number)[1] == '2' or str(number)[1] == '3' or (str(number)[1] == '4') or (str(number)[1] == '5')):\n\t\treturn 'Mastercard'\n\telif (len(str(number)) == 13 or len(str(number)) == 16) and str(number)[0] == '4':\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\n\tdef helper(n, x):\n\t\treturn str(n).startswith(x)\n\tL = len(str(number))\n\tif L == 15 and (helper(number, '34') or helper(number, '37')):\n\t\treturn 'AMEX'\n\telif L == 16 and helper(number, '6011'):\n\t\treturn 'Discover'\n\telif L == 16 and max([helper(number, str(i)) for i in range(51, 56)]) == 1:\n\t\treturn 'Mastercard'\n\telif (L == 13 or L == 16) and helper(number, '4'):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tstrng = str(number)\n\tif len(strng) == 16:\n\t\tif strng[0:4] in ['6011']:\n\t\t\treturn 'Discover'\n\t\tif strng[0:2] in ['51', '52', '53', '54', '55']:\n\t\t\treturn 'Mastercard'\n\t\tif strng[0] in ['4']:\n\t\t\treturn 'VISA'\n\telif len(strng) == 15:\n\t\tif strng[0:2] in ['34', '37']:\n\t\t\treturn 'AMEX'\n\telif len(strng) == 13:\n\t\tif strng[0] in ['4']:\n\t\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(n):\n\tn = str(n)\n\tif (n.startswith('34') or n.startswith('37')) and len(n) == 15:\n\t\treturn 'AMEX'\n\telif n.startswith('6011') and len(n) == 16:\n\t\treturn 'Discover'\n\telif 50 < int(n[:2]) < 56 and len(n) == 16:\n\t\treturn 'Mastercard'\n\telif n.startswith('4') and len(n) in [13, 16]:\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\ts = str(number)\n\tl = len(s)\n\tif l == 15 and s[:2] in ('34', '37'):\n\t\treturn 'AMEX'\n\tif l == 16 and s.startswith('6011'):\n\t\treturn 'Discover'\n\tif l == 16 and 51 <= int(s[:2]) <= 55:\n\t\treturn 'Mastercard'\n\tif l in (13, 16) and s.startswith('4'):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(n):\n\tif str(n)[:2] in ('34', '37') and len(str(n)) == 15:\n\t\treturn 'AMEX'\n\tif str(n)[:4] == '6011' and len(str(n)) == 16:\n\t\treturn 'Discover'\n\tif int(str(n)[:2]) in range(51, 56) and len(str(n)) == 16:\n\t\treturn 'Mastercard'\n\tif str(n)[0] == '4' and len(str(n)) in (13, 16):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\tissuer = {'AMEX': ([34, 37], [15]), 'Discover': ([6011], [16]), 'Mastercard': ([51, 52, 53, 54, 55], [16]), 'VISA': ([4], [13, 16])}\n\tfor i in issuer:\n\t\tfor j in issuer[i][0]:\n\t\t\tif str(number).startswith(str(j)) and len(str(number)) in issuer[i][1]:\n\t\t\t\treturn i\n\treturn 'Unknown'\n", "import re\n\ndef get_issuer(number):\n\tprint(number)\n\tif re.search('^3(4|7)\\\\d{13}\\\\Z', str(number)):\n\t\treturn 'AMEX'\n\tif re.search('^6011\\\\d{12}\\\\Z', str(number)):\n\t\treturn 'Discover'\n\tif re.search('^5[1-5]\\\\d{14}\\\\Z', str(number)) != None:\n\t\treturn 'Mastercard'\n\tif re.search('^4(\\\\d{12}|\\\\d{15})\\\\Z', str(number)):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\ts = str(number)\n\tif len(s) == 15 and s[:2] in ['34', '37']:\n\t\treturn 'AMEX'\n\tif len(s) == 16:\n\t\tif s.startswith('6011'):\n\t\t\treturn 'Discover'\n\t\tif s[:2] in ['51', '52', '53', '54', '55']:\n\t\t\treturn 'Mastercard'\n\tif len(s) in [13, 16] and s[0] == '4':\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\ts = str(number)\n\tl = len(s)\n\treturn {s[:2] in ('34', '37') and l == 15: 'AMEX', s[:4] == '6011' and l == 16: 'Discover', s[:2] in ('51', '52', '53', '54', '55') and l == 16: 'Mastercard', s[0] == '4' and (l == 13 or l == 16): 'VISA'}.get(True, 'Unknown')\n", "def get_issuer(number):\n\tn = str(number)\n\tm = len(n)\n\tif n[:2] in ('34', '37') and m == 15:\n\t\treturn 'AMEX'\n\tif n[:4] in '6011' and m == 16:\n\t\treturn 'Discover'\n\tif n[:2] in ('51', '52', '53', '54', '55') and m == 16:\n\t\treturn 'Mastercard'\n\tif n[:1] in '4' and m in (13, 16):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\ttry:\n\t\ts = str(number)\n\t\tif (s.startswith('34') or s.startswith('37')) and len(s) == 15:\n\t\t\treturn 'AMEX'\n\t\tif s.startswith('6011') and len(s) == 16:\n\t\t\treturn 'Discover'\n\t\tif int(s[0]) == 5 and int(s[1]) in [1, 2, 3, 4, 5] and (len(s) == 16):\n\t\t\treturn 'Mastercard'\n\t\tif s.startswith('4') and (len(s) == 13 or len(s) == 16):\n\t\t\treturn 'VISA'\n\t\treturn 'Unknown'\n\texcept:\n\t\treturn 'Unknown'\n", "import re\n\ndef get_issuer(number):\n\tsnum = str(number)\n\tif len(snum) == 15 and re.search('^3(4|7)', snum) != None:\n\t\treturn 'AMEX'\n\tif len(snum) == 16 and re.search('^6011', snum) != None:\n\t\treturn 'Discover'\n\tif len(snum) == 16 and re.search('^5([1-5])', snum) != None:\n\t\treturn 'Mastercard'\n\tif (len(snum) == 13 or len(snum) == 16) and re.search('^4', snum) != None:\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\timport re\n\ttry:\n\t\tgroups = re.match('((?:34|37)\\\\d{13})|(6011\\\\d{12})|(5[1-5]\\\\d{14})|(4(?:\\\\d{12}|\\\\d{15})$)', str(number)).groups()\n\texcept AttributeError:\n\t\treturn 'Unknown'\n\tif groups[0] is not None:\n\t\treturn 'AMEX'\n\telif groups[1] is not None:\n\t\treturn 'Discover'\n\telif groups[2] is not None:\n\t\treturn 'Mastercard'\n\telif groups[3] is not None:\n\t\treturn 'VISA'\n", "from re import match\n\ndef get_issuer(number):\n\ts = str(number)\n\treturn 'AMEX' if match('^3[47](\\\\d){13}$', s) else 'Discover' if match('^6011(\\\\d){12}$', s) else 'Mastercard' if match('^5[1-5](\\\\d){14}$', s) else 'VISA' if match('^4(\\\\d){12}$', s) or match('^4(\\\\d){15}$', s) else 'Unknown'\n", "def get_issuer(n):\n\t(n, siz) = (str(n), len(str(n)))\n\tif siz == 15 and n.startswith(('34', '37')):\n\t\treturn 'AMEX'\n\tif siz == 16 and n.startswith('6011'):\n\t\treturn 'Discover'\n\tif siz == 16 and n.startswith(('51', '52', '53', '54', '55')):\n\t\treturn 'Mastercard'\n\tif (siz == 16 or siz == 13) and n.startswith('4'):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "def get_issuer(number):\n\tif len(str(number)) == 15:\n\t\treturn 'AMEX' if str(number)[:2] in ['34', '37'] else 'Unknown'\n\telif len(str(number)) in [13, 16]:\n\t\tif str(number)[:4] == '6011':\n\t\t\treturn 'Discover'\n\t\telif str(number)[:2] in list(map(str, range(51, 56))):\n\t\t\treturn 'Mastercard'\n\t\telif str(number)[0] == '4':\n\t\t\treturn 'VISA'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tnum = str(number)\n\tif (num[:2] == '34' or num[:2] == '37') and len(num) == 15:\n\t\treturn 'AMEX'\n\telif num[:4] == '6011' and len(num) == 16:\n\t\treturn 'Discover'\n\telif num[:2] in ['51', '52', '53', '54', '55'] and len(num) == 16:\n\t\treturn 'Mastercard'\n\telif num[:1] == '4' and (len(num) == 16 or len(num) == 13):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n", "L = {}\nfor s in ('AMEX_34 37_15', 'Discover_6011_16', 'Mastercard_51 52 53 54 55_16', 'VISA_4_13_16'):\n\t(a, b, *c) = s.split('_')\n\tL[a] = (b.split(' '), tuple(map(int, c)))\n\ndef get_issuer(n):\n\ts = str(n)\n\tfor k in L:\n\t\t(ps, ls) = L[k]\n\t\tif len(s) in ls and any((s.startswith(p) for p in ps)):\n\t\t\treturn k\n\treturn 'Unknown'\n", "def get_issuer(number):\n\tb = list(str(number))\n\tif len(b) < 13:\n\t\treturn 'Unknown'\n\telif len(b) > 16:\n\t\treturn 'Unknown'\n\telif len(b) == 14:\n\t\treturn 'Unknown'\n\telif b[0] == '3':\n\t\tif b[1] == '4' or b[1] == '7':\n\t\t\tif len(b) == 15:\n\t\t\t\treturn 'AMEX'\n\t\t\telif len(b) == 13:\n\t\t\t\treturn 'Unknown'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif b[0] == '6':\n\t\tif b[1] == '0':\n\t\t\tif b[2] == '1':\n\t\t\t\tif b[3] == '1':\n\t\t\t\t\tif len(b) == 16:\n\t\t\t\t\t\treturn 'Discover'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif b[0] == '5':\n\t\tif b[1] == '6':\n\t\t\treturn 'Unknown'\n\t\telif b[1] == '1' or b[1] == '2' or b[1] == '3' or (b[1] == '4') or (b[1] == '5'):\n\t\t\tif len(b) == 16:\n\t\t\t\treturn 'Mastercard'\n\t\t\telse:\n\t\t\t\treturn 'Unknown'\n\telif b[0] == '4':\n\t\tif len(b) == 13:\n\t\t\treturn 'VISA'\n\t\telif len(b) == 16:\n\t\t\treturn 'VISA'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tnumber = str(number)\n\tif len(number) == 15 and number[:2] in ('34', '37'):\n\t\treturn 'AMEX'\n\tif len(number) == 16 and number[:4] == '6011':\n\t\treturn 'Discover'\n\tif len(number) == 16 and '51' <= number[:2] <= '55':\n\t\treturn 'Mastercard'\n\tif len(number) in (13, 16) and number[0] == '4':\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tcard_types = {'AMEX': {'begin': ('34', '37'), 'num_len': '15'}, 'Discover': {'begin': '6011', 'num_len': '16'}, 'Mastercard': {'begin': ('51', '52', '53', '54', '55'), 'num_len': '16'}, 'VISA': {'begin': '4', 'num_len': ('13', '16')}}\n\tfor (k, v) in card_types.items():\n\t\tif str(number).startswith(v['begin']) and str(len(str(number))) in v['num_len']:\n\t\t\treturn k\n\treturn 'Unknown'\n", "def get_issuer(number):\n\tAMEX_FIRST_DIGITS = ('34', '37')\n\tDISCOVER_FIRST_DIGITS = '6011'\n\tMASTERCARD_FIRST_DIGITS = ('51', '52', '53', '54', '55')\n\tVISA_FIRST_DIGITS = '4'\n\tnumber = str(number)\n\tif number.startswith(AMEX_FIRST_DIGITS) and len(number) == 15:\n\t\treturn 'AMEX'\n\telif number.startswith(DISCOVER_FIRST_DIGITS) and len(number) == 16:\n\t\treturn 'Discover'\n\telif number.startswith(MASTERCARD_FIRST_DIGITS) and len(number) == 16:\n\t\treturn 'Mastercard'\n\telif number.startswith(VISA_FIRST_DIGITS) and len(number) in (13, 16):\n\t\treturn 'VISA'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tcard = list((int(x) for x in str(number)))\n\tif len(card) == 15:\n\t\tif card[0] == 3:\n\t\t\tif card[1] == 4 or card[1] == 7:\n\t\t\t\treturn 'AMEX'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif len(card) == 13:\n\t\tif card[0] == 4:\n\t\t\treturn 'VISA'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif len(card) == 16:\n\t\tif card[0:4] == [6, 0, 1, 1]:\n\t\t\treturn 'Discover'\n\t\telif card[0] == 4:\n\t\t\treturn 'VISA'\n\t\telif card[0] == 5:\n\t\t\tif card[1] in range(1, 6):\n\t\t\t\treturn 'Mastercard'\n\t\t\telse:\n\t\t\t\treturn 'Unknown'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tn = str(number)\n\tif n[0:2] == '34' or (n[0:2] == '37' and len(n) == 15):\n\t\treturn 'AMEX'\n\telif n[0] == '4' and (len(n) == 13 or len(n) == 16):\n\t\treturn 'VISA'\n\telif n[0] == '5' and len(n) == 16:\n\t\tif 1 <= int(n[1]) <= 5:\n\t\t\treturn 'Mastercard'\n\t\telse:\n\t\t\treturn 'Unknown'\n\telif n[0:4] == '6011' and len(n) == 16:\n\t\treturn 'Discover'\n\telse:\n\t\treturn 'Unknown'\n", "def get_issuer(number):\n\tn = str(number)\n\tlength = len(n)\n\tif int(n[:2]) in [34, 37] and length == 15:\n\t\treturn 'AMEX'\n\telif n.startswith('6011') and length == 16:\n\t\treturn 'Discover'\n\telif int(n[:2]) in range(51, 56) and length == 16:\n\t\treturn 'Mastercard'\n\telif n[0] == '4' and (length == 13 or length == 16):\n\t\treturn 'VISA'\n\treturn 'Unknown'\n"], "public_test_cases": [{"input": [4111111111111111], "output": ["VISA"], "type": "functional"}, {"input": [4111111111111], "output": ["VISA"], "type": "functional"}, {"input": [4012888888881881], "output": ["VISA"], "type": "functional"}, {"input": [378282246310005], "output": ["AMEX"], "type": "functional"}, {"input": [6011111111111117], "output": ["Discover"], "type": "functional"}, {"input": [5105105105105100], "output": ["Mastercard"], "type": "functional"}, {"input": [5105105105105106], "output": ["Mastercard"], "type": "functional"}, {"input": [9111111111111111], "output": ["Unknown"], "type": "functional"}], "test_cases": [{"input": [4111111111111111], "output": ["VISA"], "type": "functional"}, {"input": [4111111111111], "output": ["VISA"], "type": "functional"}, {"input": [4012888888881881], "output": ["VISA"], "type": "functional"}, {"input": [41111111111111], "output": ["Unknown"], "type": "functional"}, {"input": [411111111111111], "output": ["Unknown"], "type": "functional"}, {"input": [378282246310005], "output": ["AMEX"], "type": "functional"}, {"input": [348282246310005], "output": ["AMEX"], "type": "functional"}, {"input": [6011111111111117], "output": ["Discover"], "type": "functional"}, {"input": [5105105105105100], "output": ["Mastercard"], "type": "functional"}, {"input": [5105105105105106], "output": ["Mastercard"], "type": "functional"}, {"input": [5205105105105106], "output": ["Mastercard"], "type": "functional"}, {"input": [5305105105105106], "output": ["Mastercard"], "type": "functional"}, {"input": [5405105105105106], "output": ["Mastercard"], "type": "functional"}, {"input": [5505105105105106], "output": ["Mastercard"], "type": "functional"}, {"input": [9111111111111111], "output": ["Unknown"], "type": "functional"}, {"input": [5605105105105106], "output": ["Unknown"], "type": "functional"}], "problem_id": "taco_train_6267", "metadata": {"func_name": "get_issuer", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 8, "num_original_tests": 16}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nThe concept of \"[smooth number](https://en.wikipedia.org/wiki/Smooth_number)\" is applied to all those numbers whose prime factors are lesser than or equal to `7`: `60` is a smooth number (`2 * 2 * 3 * 5`), `111` is not (`3 * 37`).\n\nMore specifically, smooth numbers are classified by their highest prime factor and your are tasked with writing a `isSmooth`/`is_smooth` function that returns a string with this classification as it follows:\n\n* 2-smooth numbers should be all defined as a `\"power of 2\"`, as they are merely that;\n* 3-smooth numbers are to return a result of `\"3-smooth\"`;\n* 5-smooth numbers will be labelled as `\"Hamming number\"`s (incidentally, you might appreciate [this nice kata on them](https://www.codewars.com/kata/hamming-numbers));\n* 7-smooth numbers are classified as `\"humble numbers\"`s;\n* for all the other numbers, just return `non-smooth`.\n\nExamples:\n```python\nis_smooth(16) == \"power of 2\"\nis_smooth(36) == \"3-smooth\"\nis_smooth(60) == \"Hamming number\"\nis_smooth(98) == \"humble number\"\nis_smooth(111) == \"non-smooth\"\n```\nThe provided input `n` is always going to be a positive number `> 1`.\n\nWrite your solution by modifying this code:\n\n```python\ndef is_smooth(n):\n\t\n```\n\nYour solution should implemented in the function \"is_smooth\". The inputs will be passed to it and it should return the correct solution.\n\n\nNow solve the problem and return the code.", "solutions": ["```python\ndef is_smooth(n):\n\tfor x in [2, 3, 5, 7]:\n\t\twhile n % x == 0:\n\t\t\tn //= x\n\t\tif n == 1:\n\t\t\treturn ('power of 2', '3-smooth', 'Hamming number', 'humble number')[(2 < x) + (3 < x) + (5 < x)]\n\treturn 'non-smooth'\n\n```"], "public_test_cases": [{"input": [16], "output": ["power of 2"], "type": "functional"}, {"input": [36], "output": ["3-smooth"], "type": "functional"}, {"input": [60], "output": ["Hamming number"], "type": "functional"}, {"input": [98], "output": ["humble number"], "type": "functional"}, {"input": [111], "output": ["non-smooth"], "type": "functional"}], "test_cases": [{"input": [16], "output": ["power of 2"], "type": "functional"}, {"input": [36], "output": ["3-smooth"], "type": "functional"}, {"input": [60], "output": ["Hamming number"], "type": "functional"}, {"input": [98], "output": ["humble number"], "type": "functional"}, {"input": [111], "output": ["non-smooth"], "type": "functional"}, {"input": [4096], "output": ["power of 2"], "type": "functional"}, {"input": [729], "output": ["3-smooth"], "type": "functional"}, {"input": [3125], "output": ["Hamming number"], "type": "functional"}, {"input": [7], "output": ["humble number"], "type": "functional"}, {"input": [17], "output": ["non-smooth"], "type": "functional"}], "problem_id": "primeintellect_train_6068", "metadata": {"func_name": "is_smooth", "config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 5, "num_original_tests": 10}, "generated_solutions": []}
{"problem": "# Longest Palindromic Substring (Linear)\n\nA palindrome is a word, phrase, or sequence that reads the same backward as forward, e.g.,\n'madam' or 'racecar'. Even the letter 'x' is considered a palindrome. \n\nFor this Kata, you are given a string ```s```. Write a function that returns the longest _contiguous_ palindromic substring in ```s``` (it could be the entire string). In the event that there are multiple longest palindromic substrings, return the first to occur.\n\nI'm not trying to trick you here:\n- You can assume that all inputs are valid strings.\n- Only the letters a-z will be used, all lowercase (your solution should, in theory, extend to more than just the letters a-z though). \n\n**NOTE:** Quadratic asymptotic complexity _(O(N^2))_ or above will __NOT__ work here.\n\n-----\n\n## Examples\n\n### Basic Tests\n\n```\nInput: \"babad\"\nOutput: \"bab\"\n(Note: \"bab\" occurs before \"aba\")\n```\n```\nInput: \"abababa\"\nOutput: \"abababa\"\n```\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n### Edge Cases\n\n```\nInput: \"ab\"\nOutput: \"a\"\n```\n```\nInput: \"\"\nOutput: \"\"\n```\n-----\n\n## Testing\n\nAlong with the example tests given:\n\n - There are **500** tests using strings of length in range [1 - 1,000]\n - There are **50** tests using strings of length in range [1,000 - 10,000]\n - There are **5** tests using strings of length in range [10,000 - 100,000]\n \nAll test cases can be passed within 10 seconds, but non-linear solutions will time out every time. _Linear performance is essential_. \n\n## Good Luck!\n\n-----\n\nThis problem was inspired by [this](https://leetcode.com/problems/longest-palindromic-substring/) challenge on LeetCode. Except this is the performance version :^)", "solutions": ["def longest_palindrome(s, sep=' '):\n\tt = sep + sep.join(s) + sep\n\tr = 0\n\tc = 0\n\tspans = []\n\tfor (i, _) in enumerate(t):\n\t\tspan = min(spans[2 * c - i], r - i - 1) if i < r else 0\n\t\twhile span <= i < len(t) - span and t[i - span] == t[i + span]:\n\t\t\tspan += 1\n\t\t(r, c) = max((r, c), (i + span, i))\n\t\tspans.append(span)\n\tspan = max(spans)\n\tmiddle = spans.index(span)\n\treturn t[middle - span + 1:middle + span].replace(sep, '')\n", "def longest_palindrome(s):\n\tif s == '':\n\t\tt = '^#$'\n\telse:\n\t\tt = '^#' + '#'.join(s) + '#$'\n\tc = 0\n\tr = 0\n\tp = [0] * len(t)\n\tfor i in range(1, len(t) - 1):\n\t\tmirror = 2 * c - i\n\t\tp[i] = max(0, min(r - i, p[mirror]))\n\t\twhile t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n\t\t\tp[i] += 1\n\t\tif i + p[i] > r:\n\t\t\tc = i\n\t\t\tr = i + p[i]\n\t(k, i) = (0, 0)\n\tfor (j, e) in enumerate(p):\n\t\tif e > k:\n\t\t\t(k, i) = (e, j)\n\t(deb, fin) = ((i - k) // 2, (i + k) // 2)\n\treturn s[deb:fin]\n", "def longest_palindrome(s):\n\tif is_palindrome(s):\n\t\treturn s\n\tmax_pal = ''\n\tfor i in range(len(s)):\n\t\ttemp = check(i, i, s)\n\t\tif len(max_pal) < len(temp):\n\t\t\tmax_pal = temp\n\treturn max_pal\n\ndef check(li, ri, s):\n\tif li > 0 and ri < len(s):\n\t\tif is_palindrome(s[li - 1:ri + 2]):\n\t\t\treturn check(li - 1, ri + 1, s)\n\t\telif is_palindrome(s[li:ri + 2]):\n\t\t\treturn check(li, ri + 1, s)\n\t\telif is_palindrome(s[li - 1:ri + 1]):\n\t\t\treturn check(li - 1, ri, s)\n\treturn s[li:ri + 1]\n\ndef is_palindrome(s):\n\treturn s == s[::-1]\n", "import re\n\ndef longest_palindrome(string):\n\tif len(string) < 2:\n\t\treturn string\n\tstring = '|' + '|'.join(string) + '|'\n\tLPS = [0 for _ in range(len(string))]\n\tC = 0\n\tR = 0\n\tfor i in range(len(string)):\n\t\tiMirror = 2 * C - i\n\t\tif R > i:\n\t\t\tLPS[i] = min(R - i, LPS[iMirror])\n\t\telse:\n\t\t\tLPS[i] = 0\n\t\ttry:\n\t\t\twhile string[i + 1 + LPS[i]] == string[i - 1 - LPS[i]]:\n\t\t\t\tLPS[i] += 1\n\t\texcept:\n\t\t\tpass\n\t\tif i + LPS[i] > R:\n\t\t\tC = i\n\t\t\tR = i + LPS[i]\n\t(r, c) = (max(LPS), LPS.index(max(LPS)))\n\treturn string[c - r:c + r].replace('|', '')\n", "def modi(s):\n\treturn ''.join(['#' + i for i in s]) + '#'\n\ndef demodi(s):\n\treturn ''.join([i for i in s if i != '#'])\n\ndef longest_palindrome(s):\n\ts = modi(s)\n\t(lenth, c, r, maxl, p) = (len(s), 0, 0, 0, [0] * len(s))\n\tfor i in range(lenth):\n\t\tmir = 2 * c - i\n\t\tif i < r:\n\t\t\tp[i] = min(r - i, p[mir])\n\t\t(a, b) = (i + (1 + p[i]), i - (1 + p[i]))\n\t\twhile a < lenth and b >= 0 and (s[a] == s[b]):\n\t\t\tp[i] += 1\n\t\t\ta += 1\n\t\t\tb -= 1\n\t\tif i + p[i] > r:\n\t\t\tc = i\n\t\t\tr = i + p[i]\n\t\t\tif p[i] > maxl:\n\t\t\t\tmaxl = p[i]\n\tmai = p.index(maxl)\n\treturn demodi(s[mai - maxl:mai + maxl + 1])\n", "def get_func(s, i):\n\t(p2, p3) = ('', '')\n\t(s2, s3) = (s[i:i + 2], s[i:i + 3])\n\tif s2[0] == s2[-1]:\n\t\tp2 = s2\n\t\t(u, v) = (i - 1, i + 2)\n\t\twhile u > -1 and v < len(s):\n\t\t\tif s[u] != s[v]:\n\t\t\t\tbreak\n\t\t\tp2 = s[u] + p2 + s[v]\n\t\t\t(u, v) = (u - 1, v + 1)\n\tif s3[0] == s3[-1]:\n\t\tp3 = s3\n\t\t(u, v) = (i - 1, i + 3)\n\t\twhile u > -1 and v < len(s):\n\t\t\tif s[u] != s[v]:\n\t\t\t\tbreak\n\t\t\tp3 = s[u] + p3 + s[v]\n\t\t\t(u, v) = (u - 1, v + 1)\n\treturn p3 if len(p3) > len(p2) else p2\n\ndef set_pal(p, idxp, pal, idx):\n\tif len(p) > len(pal) or (len(p) == len(pal) and idxp < idx):\n\t\t(pal, idx) = (p, idxp)\n\treturn (pal, idx)\n\ndef longest_palindrome(s):\n\tif len(s) < 2:\n\t\treturn s\n\tpal = s[0]\n\tidx = 1\n\tj = len(s) // 2 - 1\n\tk = j + 1\n\tif len(s) > 3:\n\t\tfor i in range(j):\n\t\t\t(pal, idx) = set_pal(get_func(s, j - i - 1), j - i, pal, idx)\n\t\t\t(pal, idx) = set_pal(get_func(s, k + i - 1), k + i, pal, idx)\n\t\t\tif len(s) < len(pal) + 2 * i:\n\t\t\t\tbreak\n\tif len(pal) < 3 and len(s) % 2 != 0:\n\t\t(pal, idx) = set_pal(get_func(s, len(s) - 3), len(s) - 2, pal, idx)\n\tif len(pal) < 2:\n\t\tsub = s[len(s) - 2:len(s)]\n\t\tif sub[0] == sub[-1]:\n\t\t\tpal = sub\n\treturn pal\n", "def longest_palindrome(s):\n\ts = '_' + '_'.join(s) + '_'\n\tn = len(s)\n\ta = [0] * n\n\trb = ml = mctr = ctr = c = 0\n\tfor i in range(1, n):\n\t\ta[i] = min(rb - i, a[2 * ctr - i]) if rb > i else 1\n\t\tc = a[i]\n\t\twhile i + c < n and i >= c and (s[i - c] == s[i + c]):\n\t\t\tc += 1\n\t\ta[i] = c\n\t\tif i + c > rb:\n\t\t\trb = i + c\n\t\t\tctr = i\n\t\tif c > ml:\n\t\t\tml = c\n\t\t\tmctr = i\n\treturn s[mctr - ml + 1:mctr + ml].replace('_', '')\n", "def longest_palindrome(S):\n\tT = [0] * (2 * len(S) + 3)\n\tsen_char = '@'\n\tstart_sen = '!'\n\tend_sen = '#'\n\tfor i in range(len(T)):\n\t\tif i == 0:\n\t\t\tT[i] = start_sen\n\t\telif i % 2 == 0 and i < len(T) - 1:\n\t\t\ts_index = (i - 1) // 2\n\t\t\tT[i] = S[s_index]\n\t\telif i % 2 == 1 and i < len(T) - 1:\n\t\t\tT[i] = sen_char\n\t\telse:\n\t\t\tT[i] = end_sen\n\tP = [0] * len(T)\n\tcenter = right = 0\n\tmax_len = index = 0\n\tfor i in range(1, len(T) - 1):\n\t\tmirror = 2 * center - i\n\t\tif i < right:\n\t\t\tP[i] = min(right - i, P[mirror])\n\t\twhile T[i + P[i] + 1] == T[i - (P[i] + 1)]:\n\t\t\tP[i] += 1\n\t\tif i + P[i] > right:\n\t\t\tright = i + P[i]\n\t\t\tcenter = i\n\t\tif P[i] > max_len:\n\t\t\tmax_len = P[i]\n\t\t\tindex = i\n\tt_arr = T[index - max_len:index + max_len + 1]\n\tword_arr = [c for c in t_arr if c != sen_char and c != start_sen and (c != end_sen)]\n\tword = ''.join(word_arr)\n\treturn word\n", "def longest_palindrome(s):\n\tn = len(s)\n\tif n <= 1:\n\t\treturn s\n\t(max, index) = (0, -1)\n\t(max2, index2) = (0, -1)\n\td1 = [0] * n\n\t(i, l, r) = (0, 0, -1)\n\twhile i < n:\n\t\tif i > r:\n\t\t\tk = 1\n\t\telse:\n\t\t\tk = min(d1[l + r - i], r - i + 1)\n\t\twhile 0 <= i - k and i + k < n and (s[i - k] == s[i + k]):\n\t\t\tk += 1\n\t\tif k > max:\n\t\t\t(max, index) = (k, i)\n\t\td1[i] = k\n\t\tk -= 1\n\t\tif i + k > r:\n\t\t\t(l, r) = (i - k, i + k)\n\t\ti += 1\n\td2 = [0] * n\n\t(i, l, r) = (0, 0, -1)\n\twhile i < n:\n\t\tif i > r:\n\t\t\tk = 0\n\t\telse:\n\t\t\tk = min(d2[l + r - i + 1], r - i + 1)\n\t\twhile 0 <= i - k - 1 and i + k < n and (s[i - k - 1] == s[i + k]):\n\t\t\tk += 1\n\t\tif k > max2:\n\t\t\t(max2, index2) = (k, i)\n\t\td2[i] = k\n\t\tk -= 1\n\t\tif i + k > r:\n\t\t\t(l, r) = (i - k - 1, i + k)\n\t\ti += 1\n\tindex = index - max + 1\n\tmax = 2 * max - 1\n\tindex2 -= max2\n\tmax2 *= 2\n\t(start, ln) = (0, 0)\n\tif max == max2:\n\t\tif index <= index2:\n\t\t\t(start, ln) = (index, max)\n\t\telse:\n\t\t\t(start, ln) = (index2, max2)\n\telif max > max2:\n\t\t(start, ln) = (index, max)\n\telse:\n\t\t(start, ln) = (index2, max2)\n\treturn s[start:start + ln]\n", "def longest_palindrome(s):\n\ttst = '#'.join('^{}$'.format(s))\n\tn = len(tst)\n\tp = [0] * n\n\tc = 0\n\tr = 0\n\tfor i in range(1, n - 1):\n\t\tp[i] = r > i and min(r - i, p[2 * c - i])\n\t\twhile tst[i + 1 + p[i]] == tst[i - 1 - p[i]]:\n\t\t\tp[i] += 1\n\t\tif i + p[i] > r:\n\t\t\t(c, r) = (i, i + p[i])\n\t(mx, ctri) = max(((n, -i) for (i, n) in enumerate(p)))\n\treturn s[(-ctri - mx) // 2:(-ctri + mx) // 2]\n"], "public_test_cases": [{"input": ["babad"], "output": ["bab"], "type": "functional"}, {"input": ["abababa"], "output": ["abababa"], "type": "functional"}, {"input": ["cbbd"], "output": ["bb"], "type": "functional"}, {"input": ["ab"], "output": ["a"], "type": "functional"}, {"input": [""], "output": [""], "type": "functional"}], "test_cases": [{"input": ["babad"], "output": ["bab"], "type": "functional"}, {"input": ["madam"], "output": ["madam"], "type": "functional"}, {"input": ["dde"], "output": ["dd"], "type": "functional"}, {"input": ["ababbab"], "output": ["babbab"], "type": "functional"}, {"input": ["abababa"], "output": ["abababa"], "type": "functional"}, {"input": ["banana"], "output": ["anana"], "type": "functional"}, {"input": ["abba"], "output": ["abba"], "type": "functional"}, {"input": ["cbbd"], "output": ["bb"], "type": "functional"}, {"input": ["zz"], "output": ["zz"], "type": "functional"}, {"input": ["dddd"], "output": ["dddd"], "type": "functional"}, {"input": [""], "output": [""], "type": "functional"}, {"input": ["abcdefghijklmnopqrstuvwxyz"], "output": ["a"], "type": "functional"}, {"input": ["ttaaftffftfaafatf"], "output": ["aaftffftfaa"], "type": "functional"}, {"input": ["bbaaacc"], "output": ["aaa"], "type": "functional"}, {"input": ["m"], "output": ["m"], "type": "functional"}], "problem_id": "taco_train_7030", "metadata": {"func_name": "longest_palindrome", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 5, "num_original_tests": 15}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\n#It's show time!\nArchers have gathered from all around the world to participate in the Arrow Function Faire. But the faire will only start if there are archers signed and if they all have enough arrows in their quivers - at least 5 is the requirement! Are all the archers ready?\n\n#Reference\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n\n#Argument\n`archers` is an array of integers, in which each element corresponds to the number of arrows each archer has.\n\n#Return\nYour function must return `true` if the requirements are met or `false` otherwise.\n\n#Examples\n`archersReady([1, 2, 3, 4, 5, 6, 7, 8])` returns `false` because there are archers with not enough arrows.\n\n`archersReady([5, 6, 7, 8])` returns `true`.\n\nWrite your solution by modifying this code:\n\n```python\ndef archers_ready(archers):\n\t\n```\n\nYour solution should implemented in the function \"archers_ready\". The inputs will be passed to it and it should return the correct solution.\n\n\nNow solve the problem and return the code.", "solutions": ["```python\ndef archers_ready(archers):\n\treturn all((i >= 5 for i in archers)) if archers else False\n\n```"], "public_test_cases": [{"input": [[1, 2, 3, 4, 5, 6, 7, 8]], "output": [false], "type": "functional"}, {"input": [[5, 6, 7, 8]], "output": [true], "type": "functional"}], "test_cases": [{"input": [[]], "output": [false], "type": "functional"}, {"input": [[1, 2, 3, 4]], "output": [false], "type": "functional"}, {"input": [[5, 6, 7, 8]], "output": [true], "type": "functional"}, {"input": [[5, 6, 7, 4]], "output": [false], "type": "functional"}, {"input": [[1, 2, 3, 4, 5, 6, 7, 8]], "output": [false], "type": "functional"}], "problem_id": "primeintellect_train_14558", "metadata": {"func_name": "archers_ready", "config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 5}, "generated_solutions": []}
{"problem": "You have been speeding on a motorway and a police car had to stop you. The policeman is a funny guy that likes to play games. Before issuing penalty charge notice he gives you a choice to change your penalty. \n\nYour penalty charge is a combination of numbers like: speed of your car, speed limit in the area, speed of the police car chasing you, the number of police cars involved, etc.  So, your task is to combine the given numbers and make the penalty charge to be as small as possible.      \n\nFor example, if  you are given numbers  ```[45, 30, 50, 1]``` your best choice is ```1304550```\n\n\nExamples:\n```Python\n['45', '30', '50', '1'] => '1304550'\n\n['100', '10', '1'] => '100101'\n\n['32', '3'] => '323'\n```", "solutions": ["def penalty(lst):\n\t(lst, maxLen) = (list(map(str, lst)), max(map(len, lst)))\n\treturn ''.join(sorted(lst, key=lambda s: s.ljust(maxLen, s[-1])))\n", "def penalty(a_list):\n\treturn ''.join(sorted(a_list, key=lambda n: n + n[:1]))\n", "penalty = lambda a: ''.join(sorted(a, key=lambda n: 2 * n))\n", "def penalty(a_list):\n\tfor i in range(len(a_list)):\n\t\tfor j in range(i + 1, len(a_list)):\n\t\t\t(a, b) = (a_list[i], a_list[j])\n\t\t\tif int(a + b) >= int(b + a):\n\t\t\t\t(a_list[i], a_list[j]) = (b, a)\n\ts = ''\n\tfor k in a_list:\n\t\ts += k\n\treturn s\n", "import functools\n\ndef penalty(lis):\n\tcustom = lambda i, j: -1 if str(j) + str(i) > str(i) + str(j) else 1\n\tres = sorted(lis, key=functools.cmp_to_key(custom))\n\treturn ''.join(map(str, res))\n", "def penalty(nos):\n\tprint(nos)\n\tpos = 0\n\tret = []\n\tfor x in range(len(nos)):\n\t\tlow = 10\n\t\ttmp = ''\n\t\tfor x in nos:\n\t\t\tif int(x[0]) <= int(low):\n\t\t\t\tif tmp != '':\n\t\t\t\t\ttmp = getLowest(tmp, x)\n\t\t\t\telse:\n\t\t\t\t\ttmp = x\n\t\t\t\tlow = tmp[0]\n\t\tret.append(tmp)\n\t\tnos.remove(tmp)\n\treturn ''.join(ret)\n\ndef getLowest(s1, s2):\n\tres = {s1: s1, s2: s2}\n\tif len(s2) < len(s1):\n\t\tres[s2] = equalPad(s2, len(s1))\n\telif len(s2) > len(s1):\n\t\tres[s1] = equalPad(s1, len(s2))\n\tfor x in range(len(res[s1])):\n\t\tif res[s1][x] < res[s2][x]:\n\t\t\treturn s1\n\t\telif res[s2][x] < res[s1][x]:\n\t\t\treturn s2\n\treturn s1\n\ndef equalPad(s0, w):\n\treturn s0.ljust(w, s0[-1])\n", "def penalty(p):\n\tn = len(max(p, key=int))\n\treturn ''.join(sorted(p, key=lambda x: (x.ljust(n, x[-1]), -len(x))))\n", "def penalty(a_list):\n\treturn ''.join(sorted(a_list, key=lambda x: x * 10))\n", "from functools import cmp_to_key\n\ndef cmp_func(a, b):\n\t(ab, ba) = (a + b, b + a)\n\treturn (ab > ba) - (ab < ba)\n\ndef penalty(l):\n\treturn ''.join(sorted(l, key=cmp_to_key(cmp_func)))\n"], "public_test_cases": [{"input": [["45", "30", "50", "1"]], "output": ["1304550"], "type": "functional"}, {"input": [["100", "10", "1"]], "output": ["100101"], "type": "functional"}, {"input": [["32", "3"]], "output": ["323"], "type": "functional"}], "test_cases": [{"input": [["45", "30", "50", "1"]], "output": ["1304550"], "type": "functional"}, {"input": [["100", "10", "1"]], "output": ["100101"], "type": "functional"}, {"input": [["32", "3"]], "output": ["323"], "type": "functional"}, {"input": [["70", "46", "4", "19"]], "output": ["1944670"], "type": "functional"}, {"input": [["71", "82", "42", "34", "90"]], "output": ["3442718290"], "type": "functional"}, {"input": [["31", "97", "6", "78"]], "output": ["3167897"], "type": "functional"}, {"input": [["72", "7", "7", "78", "79", "709", "94"]], "output": ["7097277787994"], "type": "functional"}], "problem_id": "taco_train_6660", "metadata": {"func_name": "penalty", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 7}, "generated_solutions": []}
{"problem": "You love coffee and want to know what beans you can afford to buy it.\n\nThe first argument to your search function will be a number which represents your budget.\n\nThe second argument will be an array of coffee bean prices.\n\nYour 'search' function should return the stores that sell coffee within your budget. \n\nThe search function should return a string of prices for the coffees beans you can afford. The prices in this string are to be sorted in ascending order.", "solutions": ["def search(budget, prices):\n\treturn ','.join((str(a) for a in sorted(prices) if a <= budget))\n", "search = lambda budget, prices: ','.join(map(str, sorted([x for x in prices if x <= budget])))\n", "def search(budget, prices):\n\treturn ','.join(map(str, sorted([n for n in prices if n <= budget])))\n", "def search(budget, prices):\n\treturn ','.join(map(str, sorted(filter(float(budget).__ge__, prices))))\n", "search = lambda b, p: ','.join((str(i) for i in sorted(p) if i <= b))\n", "def search(b, p):\n\treturn ','.join(map(str, sorted((c for c in p if c <= b))))\n", "def search(budget, prices):\n\treturn ','.join((str(num) for num in sorted(prices) if num <= budget))\n", "def search(budget, prices):\n\tprices.sort()\n\treturn ','.join((str(x) for x in prices if x <= budget))\n", "def search(budget, prices):\n\treturn ','.join((str(price) for price in sorted(prices) if price <= budget))\n"], "public_test_cases": [{"input": [3, [6, 1, 2, 9, 2]], "output": ["1,2,2"], "type": "functional"}, {"input": [14, [7, 3, 23, 9, 14, 20, 7]], "output": ["3,7,7,9,14"], "type": "functional"}], "test_cases": [{"input": [3, [6, 1, 2, 9, 2]], "output": ["1,2,2"], "type": "functional"}, {"input": [14, [7, 3, 23, 9, 14, 20, 7]], "output": ["3,7,7,9,14"], "type": "functional"}, {"input": [0, [6, 1, 2, 9, 2]], "output": [""], "type": "functional"}, {"input": [10, []], "output": [""], "type": "functional"}, {"input": [24, [24, 0, 100, 2, 5]], "output": ["0,2,5,24"], "type": "functional"}, {"input": [24, [2.7, 0, 100.9, 1, 5.5]], "output": ["0,1,2.7,5.5"], "type": "functional"}, {"input": [-1, [1, 2, 3, 4]], "output": [""], "type": "functional"}, {"input": [-1, [-1, 0, 1, 2, 3, 4]], "output": ["-1"], "type": "functional"}, {"input": [14, [17, 33, 23, 19, 19, 20, 17]], "output": [""], "type": "functional"}, {"input": [14, [13, 15, 14, 14, 15, 13]], "output": ["13,13,14,14"], "type": "functional"}], "problem_id": "taco_train_6525", "metadata": {"func_name": "search", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 10}, "generated_solutions": []}
{"problem": "Your task is to calculate logical value of boolean array. Test arrays are one-dimensional and their size is in the range 1-50.\n\nLinks referring to logical operations: [AND](https://en.wikipedia.org/wiki/Logical_conjunction), [OR](https://en.wikipedia.org/wiki/Logical_disjunction) and [XOR](https://en.wikipedia.org/wiki/Exclusive_or).\n\nYou should begin at the first value, and repeatedly apply the logical operation across the remaining elements in the array sequentially.\n\nFirst Example:\n\nInput: true, true, false, operator: AND\n\nSteps: true AND true -> true, true AND false -> false\n\nOutput: false\n\nSecond Example:\n\nInput: true, true, false, operator: OR\n\nSteps: true OR true -> true, true OR false -> true\n\nOutput: true\n\nThird Example:\n\nInput: true, true, false, operator: XOR\n\nSteps: true XOR true -> false, false XOR false -> false\n\nOutput: false\n___\n\nInput:\n\nboolean array, string with operator' s name: 'AND', 'OR', 'XOR'.\n\nOutput:\n\ncalculated boolean", "solutions": ["import operator\nfrom functools import reduce\nOPS = {'AND': operator.and_, 'OR': operator.or_, 'XOR': operator.xor}\n\ndef logical_calc(array, op):\n\treturn reduce(OPS[op], array)\n", "def logical_calc(array, op):\n\tops = {'AND': lambda x, y: x & y, 'OR': lambda x, y: x | y, 'XOR': lambda x, y: x ^ y}\n\tfrom functools import reduce\n\treturn reduce(ops[op], array)\n", "def logical_calc(array, op):\n\tres = array[0]\n\tfor x in array[1:]:\n\t\tif op == 'AND':\n\t\t\tres &= x\n\t\telif op == 'OR':\n\t\t\tres |= x\n\t\telse:\n\t\t\tres ^= x\n\treturn res\n", "def logical_calc(array, op):\n\ts = ' ' + op.lower().replace('xor', '^') + ' '\n\treturn eval(s.join((str(x) for x in array)))\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\treturn reduce(lambda x, y: {'OR': x or y, 'AND': x and y, 'XOR': x ^ y}[op], array)\n", "def logical_calc(array, op):\n\tres = array[0]\n\tfor i in array[1:]:\n\t\tif op == 'AND':\n\t\t\tres = res and i\n\t\telif op == 'OR':\n\t\t\tres = res or i\n\t\telif op == 'XOR':\n\t\t\tres = res != i\n\treturn res\n", "def logical_calc(array, op):\n\tresult = False\n\tif len(array) == 1:\n\t\treturn array[0]\n\tif op == 'AND':\n\t\tresult = array[0] and array[1]\n\tif op == 'OR':\n\t\tresult = array[0] or array[1]\n\tif op == 'XOR':\n\t\tresult = array[0] ^ array[1]\n\tfor n in range(2, len(array)):\n\t\tif op == 'AND':\n\t\t\tresult = result and array[n]\n\t\tif op == 'OR':\n\t\t\tresult = result or array[n]\n\t\tif op == 'XOR':\n\t\t\tresult = result ^ array[n]\n\treturn result\n", "def logical_calc(array, op):\n\treturn {'AND': all(array), 'OR': any(array)}.get(op) if op != 'XOR' else __import__('functools').reduce(lambda x, y: x ^ y, array)\n", "def logical_calc(arr, op):\n\treturn eval((' ^ ' if op == 'XOR' else ' ' + op.lower() + ' ').join((str(x) for x in arr)))\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn reduce(lambda x, y: x and y, array)\n\telif op == 'OR':\n\t\treturn reduce(lambda x, y: x or y, array)\n\telse:\n\t\treturn reduce(lambda x, y: x ^ y, array)\n", "ops = {'AND': '&', 'OR': '|', 'XOR': '^'}\n\ndef logical_calc(array, op):\n\treturn bool(eval(ops[op].join([str(int(i)) for i in array])))\n", "from operator import and_, or_, xor\nfrom functools import reduce\nlogical_calc = lambda xs, op: reduce({'AND': and_, 'OR': or_, 'XOR': xor}.get(op), xs)\n", "import operator\nfrom functools import reduce\n\ndef logical_calc(array, op):\n\top = '__{}__'.format(op.lower())\n\top = getattr(operator, op)\n\treturn reduce(op, array)\n", "def logical_calc(array, op):\n\treturn eval({'AND': '&', 'OR': '|', 'XOR': '^'}[op].join(map(str, array)))\n", "from functools import reduce\nfrom operator import ixor\nfrom typing import List\n\ndef logical_calc(array: List[bool], op: str) -> bool:\n\treturn {'AND': lambda : all(array), 'OR': lambda : any(array), 'XOR': lambda : reduce(ixor, array)}.get(op)()\n", "def logical_calc(array, op):\n\tout = array.pop(0)\n\tfor x in array:\n\t\tout = {'AND': x & out, 'OR': x | out, 'XOR': x ^ out}[op]\n\treturn out\n", "def logical_calc(array, op):\n\treturn {'AND': all, 'OR': any, 'XOR': lambda a: sum(a) % 2}[op](array)\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\tfor item in array:\n\t\t\tif item is False:\n\t\t\t\treturn False\n\t\treturn True\n\telif op == 'OR':\n\t\tfor item in array:\n\t\t\tif item is True:\n\t\t\t\treturn True\n\t\treturn False\n\telse:\n\t\ta = len([a for a in array if a is True])\n\t\tif a % 2 != 0 and a > 0:\n\t\t\treturn True\n\t\treturn False\n", "from functools import reduce\nlogical_calc = lambda array, op: reduce(lambda a, b: a and b if op == 'AND' else a or b if op == 'OR' else a != b, array)\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn all(array)\n\telif op == 'OR':\n\t\treturn any(array)\n\telse:\n\t\treturn sum(array) % 2 == 1\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn False not in array\n\tif op == 'OR':\n\t\treturn True in array\n\tresult = array[0]\n\tfor index in range(1, len(array)):\n\t\tresult ^= array[index]\n\treturn result\n", "def logical_calc(arr, op):\n\treturn all(arr) if op == 'AND' else any(arr) if op == 'OR' else arr.count(True) % 2\n", "def logical_calc(array, op):\n\treturn eval({'AND': '&', 'OR': '|'}.get(op, '^').join((str(i) for i in array)))\n", "import functools\n\ndef logical_calc(array, op):\n\treturn {'AND': all, 'OR': any, 'XOR': xor}[op](array)\n\ndef xor(array):\n\treturn functools.reduce(lambda x, y: x != y, array)\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn all((boolian for boolian in array))\n\telif op == 'OR':\n\t\treturn any((boolian for boolian in array))\n\telse:\n\t\treturn sum(array) % 2\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn all(array)\n\telif op == 'OR':\n\t\treturn any(array)\n\telse:\n\t\treturn array.count(True) % 2\n", "def logical_calc(array, op):\n\tans = array[0]\n\tfor i in array[1:]:\n\t\tif op == 'AND':\n\t\t\tans = ans & i\n\t\telif op == 'OR':\n\t\t\tans = ans | i\n\t\telse:\n\t\t\tans = ans ^ i\n\treturn ans\n", "def logical_calc(array, op):\n\tans = array[0]\n\tfor operator in array[1:]:\n\t\tif op == 'AND':\n\t\t\tans = ans and operator\n\t\telif op == 'OR':\n\t\t\tans = ans or operator\n\t\telse:\n\t\t\tans = ans ^ operator\n\treturn ans\n", "def logical_calc(arr, op):\n\tanswer = arr[0]\n\tif op == 'AND':\n\t\tfor i in range(len(arr) - 1):\n\t\t\tanswer &= arr[i + 1]\n\tif op == 'OR':\n\t\tfor i in range(len(arr) - 1):\n\t\t\tanswer |= arr[i + 1]\n\tif op == 'XOR':\n\t\tfor i in range(len(arr) - 1):\n\t\t\tanswer ^= arr[i + 1]\n\treturn answer\n", "def logical_calc(array, op):\n\tcurr = array[0]\n\tfor x in range(1, len(array)):\n\t\tif op == 'AND':\n\t\t\tcurr = array[x] and curr\n\t\tif op == 'OR':\n\t\t\tcurr = array[x] or curr\n\t\tif op == 'XOR':\n\t\t\tcurr = array[x] and (not curr) or (not array[x] and curr)\n\treturn curr\n", "def logical_calc(array, op):\n\tstart = array[0]\n\tfor i in range(1, len(array)):\n\t\tif op == 'AND':\n\t\t\tstart = start and array[i]\n\t\telif op == 'OR':\n\t\t\tstart = start or array[i]\n\t\telif op == 'XOR':\n\t\t\tif start == array[i]:\n\t\t\t\tstart = False\n\t\t\telse:\n\t\t\t\tstart = True\n\treturn start\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn not False in array\n\telif op == 'OR':\n\t\treturn True in array\n\telif op == 'XOR':\n\t\treturn array.count(True) % 2 != 0\n", "def logical_calc(array, op):\n\tops = {'XOR': ' ^ ', 'AND': ' and ', 'OR': ' or '}\n\treturn eval(ops[op].join([str(v) for v in array]))\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\treturn all(array) if op == 'AND' else any(array) if op == 'OR' else reduce(lambda x, y: x != y, array)\n", "def logical_calc(array, op):\n\tstate = None\n\toperation = None\n\tif op == 'AND':\n\t\tfor i in range(len(array)):\n\t\t\tstate = array[i] if i == 0 else state and array[i]\n\telif op == 'OR':\n\t\tfor i in range(len(array)):\n\t\t\tstate = array[i] if i == 0 else state or array[i]\n\telif op == 'XOR':\n\t\tfor i in range(len(array)):\n\t\t\tstate = array[i] if i == 0 else state ^ array[i]\n\telse:\n\t\treturn f'input - {op} - not recognized'\n\treturn state\n", "def logical_calc(array, op):\n\tprint(array)\n\tprint(op)\n\tprint(len(array))\n\tcount_True = 0\n\tcount_False = 0\n\tfor line in array:\n\t\tif line == True:\n\t\t\tcount_True += 1\n\t\telse:\n\t\t\tcount_False += 1\n\tprint(count_False)\n\tprint(count_True)\n\tif op == 'AND':\n\t\tif count_True == len(array):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telif op == 'OR':\n\t\tif count_False == len(array):\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n\telif op == 'XOR':\n\t\tif count_True % 2 == 0:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n", "def logical_calc(array, op):\n\tif len(array) == 1:\n\t\treturn array[0]\n\telse:\n\t\tif op.lower() == 'and':\n\t\t\ts = array[0] & array[1]\n\t\t\tfor i in range(2, len(array)):\n\t\t\t\ts = s & array[i]\n\t\t\treturn s\n\t\telif op.lower() == 'or':\n\t\t\ts = array[0] | array[1]\n\t\t\tfor i in range(2, len(array)):\n\t\t\t\ts = s | array[i]\n\t\t\treturn s\n\t\tif op.lower() == 'xor':\n\t\t\ts = array[0] ^ array[1]\n\t\t\tfor i in range(2, len(array)):\n\t\t\t\ts = s ^ array[i]\n\t\t\treturn s\n", "logical_calc = lambda a, o: __import__('functools').reduce({'AND': lambda a, b: a & b, 'OR': lambda a, b: a | b, 'XOR': lambda a, b: a ^ b}[o], a, o == 'AND')\n", "def logical_calc(array, op):\n\tbool = array[0]\n\tfor x in range(1, len(array)):\n\t\tif op == 'AND':\n\t\t\tbool = array[x] & bool\n\t\tif op == 'OR':\n\t\t\tbool = array[x] | bool\n\t\tif op == 'XOR':\n\t\t\tbool = array[x] ^ bool\n\treturn bool\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\toperators = {'AND': all(array), 'OR': any(array), 'XOR': reduce(lambda x, y: x ^ y, array)}\n\treturn operators[op]\n", "dict = {True: 1, False: 2}\n\ndef logical_calc(array, op):\n\tprint(array, op)\n\tarrn = []\n\tlength = len(array)\n\tfor x in array:\n\t\tarrn.append(dict[x])\n\tif op == 'XOR':\n\t\tif sum(arrn) == 1:\n\t\t\treturn True\n\t\telif sum(arrn) == 2:\n\t\t\treturn False\n\t\telse:\n\t\t\ti = 0\n\t\t\tx = array[0]\n\t\t\twhile i < len(array) - 1:\n\t\t\t\tx = x == array[i + 1]\n\t\t\t\ti += 1\n\t\t\tif x:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\treturn True\n\telif sum(arrn) == length and op == 'AND':\n\t\treturn True\n\telif array.count(False) == length:\n\t\treturn False\n\telif (sum(arrn) != length or sum(arrn) != length * 2) and op == 'OR':\n\t\treturn True\n\telse:\n\t\treturn False\n", "def logical_calc(array, op):\n\tprint(array, op)\n\tif op == 'AND':\n\t\tif array.count(False):\n\t\t\treturn False\n\telif op == 'OR':\n\t\tif array.count(True) == 0:\n\t\t\treturn False\n\telif array.count(True) % 2 == 0:\n\t\treturn False\n\treturn True\n", "import distutils\n\ndef quick_op(op, old, new):\n\tif op == 'AND':\n\t\treturn old and new\n\telif op == 'OR':\n\t\treturn old or new\n\telif op == 'XOR':\n\t\treturn old ^ new\n\ndef logical_calc(array, op):\n\tlatest_operation = array[0]\n\tarray.pop(0)\n\tfor item in array:\n\t\tlatest_operation = quick_op(op, latest_operation, item)\n\treturn latest_operation\n", "def logical_calc(array, op):\n\tif op == 'XOR':\n\t\tresult = array[0]\n\t\tfor element in array[1:]:\n\t\t\tif element == result:\n\t\t\t\tresult = False\n\t\t\telse:\n\t\t\t\tresult = True\n\t\treturn result\n\treturn all(array) if op == 'AND' else any(array)\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\toper = op.lower() if op != 'XOR' else '^'\n\treturn reduce(lambda x, y: eval(f'{x} {oper} {y}'), array)\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn array.count(False) == 0\n\telif op == 'OR':\n\t\treturn array.count(True) != 0\n\telse:\n\t\treturn array.count(True) % 2 == 1\n", "from operator import __and__, __or__, __xor__\noperators = {'AND': __and__, 'OR': __or__, 'XOR': __xor__}\n\ndef logical_calc(arr, op):\n\tacc = arr[0]\n\tfor item in arr[1:]:\n\t\tacc = operators[op](acc, item)\n\treturn acc\n", "from operator import and_\nfrom operator import or_\nfrom operator import xor\nfrom functools import reduce\n\ndef logical_calc(array, op):\n\tif op == 'XOR':\n\t\treturn reduce(xor, array)\n\telif op == 'AND':\n\t\treturn reduce(and_, array)\n\telif op == 'OR':\n\t\treturn reduce(or_, array)\n", "def logical_calc(array, op):\n\tbool = array[0] == True\n\tfor i in range(1, len(array)):\n\t\tif op == 'AND':\n\t\t\tbool = bool & array[i]\n\t\telif op == 'OR':\n\t\t\tbool = bool | array[i]\n\t\telif op == 'XOR':\n\t\t\tbool = bool ^ array[i]\n\treturn bool == True\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\tfor bool in array:\n\t\t\tif bool == False:\n\t\t\t\treturn False\n\t\treturn True\n\telif op == 'OR':\n\t\tfor bool in array:\n\t\t\tif bool == True:\n\t\t\t\treturn True\n\t\treturn False\n\telse:\n\t\taux = array[0]\n\t\ti = 1\n\t\twhile i < len(array):\n\t\t\tif aux != array[i]:\n\t\t\t\taux = True\n\t\t\telse:\n\t\t\t\taux = False\n\t\t\ti += 1\n\t\treturn aux\n", "def logical_calc(array, op):\n\treturn eval(' {} '.format({'AND': 'and', 'OR': 'or'}.get(op, '^')).join((str(x) for x in array)))\n", "def logical_calc(array, op):\n\tval = array.pop()\n\tfor i in array:\n\t\tif op == 'AND':\n\t\t\tif not i:\n\t\t\t\treturn False\n\t\telif op == 'OR':\n\t\t\tif i:\n\t\t\t\treturn True\n\t\telse:\n\t\t\tval ^= i\n\treturn val\n", "def logical_calc(array, op):\n\tprint(array, op)\n\tif op == 'AND':\n\t\treturn False not in array\n\tif op == 'OR':\n\t\treturn True in array or (True in array and False in array)\n\tif op == 'XOR':\n\t\treturn array.count(True) % 2 != 0 or (True in array and array.count(False) % 2 != 0)\n", "def logical_calc(array, op):\n\tif op == 'XOR':\n\t\top = '^'\n\top = op.lower()\n\tarray = [str(i) for i in array]\n\tarr2 = []\n\tfor i in range(len(array)):\n\t\tarr2.append(array[i])\n\t\tarr2.append(op)\n\tarr2 = arr2[0:-1]\n\treturn eval(' '.join(arr2))\n", "import functools\n\ndef logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn functools.reduce(lambda prev, curr: prev and curr, array)\n\tif op == 'OR':\n\t\treturn functools.reduce(lambda prev, curr: prev or curr, array)\n\tif op == 'XOR':\n\t\treturn functools.reduce(lambda prev, curr: prev ^ curr, array)\n", "def logical_calc(array, op):\n\tif False in array and op == 'AND':\n\t\treturn False\n\telif op == 'AND':\n\t\treturn True\n\telif True in array and op == 'OR':\n\t\treturn True\n\telif op == 'OR':\n\t\treturn False\n\telif int(array.count(True)) % 2 == 0 and int(array.count(False)) % 2 == 0 and (op == 'XOR'):\n\t\treturn False\n\telif int(array.count(True)) % 2 == 1 and op == 'XOR':\n\t\treturn True\n\telif int(array.count(False)) % 2 == 1 and int(array.count(True)) % 2 == 1 and (op == 'XOR'):\n\t\treturn False\n\telif int(array.count(False)) % 2 == 1 and op == 'XOR':\n\t\treturn False\n", "def logical_calc(array, op):\n\tlog = array[0]\n\tfor i in array[1:51]:\n\t\tif op == 'AND':\n\t\t\tlog = log and i\n\t\telif op == 'OR':\n\t\t\tlog = log or i\n\t\telse:\n\t\t\tlog = log ^ i\n\treturn log\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn False not in array\n\telif op == 'OR':\n\t\treturn True in array\n\telif op == 'XOR':\n\t\ts1 = sum(array)\n\t\tif s1 % 2 == 0:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n", "def logical_calc(array, op):\n\tbool = array[0]\n\tif op == 'AND':\n\t\tfor n in range(len(array) - 1):\n\t\t\tbool = bool and array[n + 1]\n\telif op == 'OR':\n\t\tfor n in range(len(array) - 1):\n\t\t\tbool = bool or array[n + 1]\n\telif op == 'XOR':\n\t\tfor n in range(len(array) - 1):\n\t\t\tbool = (bool or array[n + 1]) and (not (bool and array[n + 1]))\n\telse:\n\t\tbool = False\n\treturn bool\n", "def logical_calc(array, op):\n\tlogic = ''\n\tif op == 'XOR':\n\t\top = '^'\n\tfor x in array[0:len(array) - 1]:\n\t\tlogic = logic + ' ' + str(x) + ' ' + op.lower()\n\tlogic = logic + ' ' + str(array[-1])\n\tans = eval(logic.strip())\n\treturn ans\n", "def logical_calc(arr, log):\n\tx = {'AND': 'and', 'OR': 'or', 'XOR': '!='}\n\ty = arr.pop(0)\n\twhile len(arr) > 0:\n\t\ty = eval(str(y) + f' {x[log]} ' + str(arr.pop(0)))\n\treturn y\n", "def xor(a, b):\n\treturn a + b - 2 * a * b\n\ndef logical_calc(array, op):\n\tif op == 'OR':\n\t\tresult = array[0]\n\t\tfor value in range(1, len(array)):\n\t\t\tresult = result or array[value]\n\t\treturn result\n\tif op == 'AND':\n\t\tresult = array[0]\n\t\tfor value in range(1, len(array)):\n\t\t\tresult = result and array[value]\n\t\treturn result\n\tif op == 'XOR':\n\t\tresult = array[0]\n\t\tfor value in range(1, len(array)):\n\t\t\tresult = xor(result, array[value])\n\t\treturn result\n", "def logical_calc(array, op):\n\ta = array[0]\n\tif op == 'AND':\n\t\tfor i in range(len(array) - 1):\n\t\t\ta = a and array[i + 1]\n\t\treturn bool(a)\n\telif op == 'OR':\n\t\tfor i in range(len(array) - 1):\n\t\t\ta = a or array[i + 1]\n\t\treturn bool(a)\n\telif op == 'XOR':\n\t\tfor i in range(len(array) - 1):\n\t\t\ta = a != array[i + 1]\n\t\treturn bool(a)\n", "def logical_calc(array, op):\n\tprint((array, op))\n\tif op == 'AND':\n\t\treturn not False in array\n\tif op == 'OR':\n\t\treturn True in array\n\tstatus = False\n\tfor bool in array:\n\t\tstatus = bool ^ status\n\treturn status\n", "import functools\n\ndef logical_calc(array, op):\n\tarr = {'AND': lambda a, b: a and b, 'OR': lambda a, b: a or b, 'XOR': lambda a, b: a != b}\n\treturn functools.reduce(arr[op], array)\n", "def logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn all(array)\n\telif op == 'OR':\n\t\treturn any(array)\n\telif op == 'XOR':\n\t\treturn array.count(True) % 2 != 0\n", "def logical_calc(array, op):\n\treturn eval(f\" {(op.lower() if op != 'XOR' else '^')} \".join(map(str, array)))\n", "from operator import __and__, __or__, __xor__\nfrom functools import reduce\n\ndef logical_calc(a, op):\n\tif op == 'AND':\n\t\treturn reduce(__and__, a)\n\tif op == 'OR':\n\t\treturn reduce(__or__, a)\n\telse:\n\t\treturn reduce(__xor__, a)\n", "def logical_calc(array, op):\n\timport functools\n\tif op == 'AND':\n\t\treturn functools.reduce(lambda i, j: i and j, array)\n\telif op == 'OR':\n\t\treturn functools.reduce(lambda i, j: i or j, array)\n\telif op == 'XOR':\n\t\treturn functools.reduce(lambda i, j: i ^ j, array)\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\tif op == 'AND':\n\t\treturn reduce(lambda a, b: a and b, array)\n\tif op == 'OR':\n\t\treturn reduce(lambda a, b: a or b, array)\n\treturn reduce(lambda a, b: a ^ b, array)\n", "from functools import reduce\n\ndef logical_calc(array, op):\n\tif op == 'XOR':\n\t\top = '^'\n\treturn reduce(lambda a, b: eval(str(a) + ' ' + op.lower() + ' ' + str(b)), array)\n", "def logical_calc(array, op):\n\tc = len(array)\n\tres = array[0]\n\tfor i in range(c - 1):\n\t\tif op == 'AND':\n\t\t\tres = res and array[i + 1]\n\t\tif op == 'OR':\n\t\t\tres = res or array[i + 1]\n\t\tif op == 'XOR':\n\t\t\tres = res != array[i + 1]\n\treturn res\n", "def logical_calc(array, op):\n\tres = array[0]\n\tif op == 'AND':\n\t\tfor i in range(1, len(array)):\n\t\t\tres *= array[i]\n\telif op == 'OR':\n\t\tfor i in range(1, len(array)):\n\t\t\tres |= array[i]\n\telse:\n\t\tfor i in range(1, len(array)):\n\t\t\tres ^= array[i]\n\treturn res\n", "def logical_calc(array, op):\n\top = op.lower()\n\tif op == 'xor':\n\t\top = '!='\n\tfor id in range(len(array) - 1):\n\t\tarray[id + 1] = eval(str(array[id]) + ' ' + op + ' ' + str(array[id + 1]))\n\treturn array[-1]\n", "def logical_calc(ar, op):\n\tif op == 'AND':\n\t\treturn False not in ar\n\telif op == 'OR':\n\t\treturn True in ar\n\telif op == 'XOR':\n\t\tif len(ar) == 2:\n\t\t\treturn not ar[0] == ar[1]\n\t\telif len(ar) > 2:\n\t\t\ta = ar.pop(0)\n\t\t\tb = ar.pop(0)\n\t\t\tar.insert(0, not a == b)\n\t\t\treturn logical_calc(ar, op)\n\t\telif len(ar) == 1:\n\t\t\treturn ar[0]\n"], "public_test_cases": [{"input": [[true, true, false], "AND"], "output": [false], "type": "functional"}, {"input": [[true, true, false], "OR"], "output": [true], "type": "functional"}, {"input": [[true, true, false], "XOR"], "output": [false], "type": "functional"}], "test_cases": [{"input": [[true, true, true, false], "AND"], "output": [false], "type": "functional"}, {"input": [[true, true, true, false], "OR"], "output": [true], "type": "functional"}, {"input": [[true, true, true, false], "XOR"], "output": [true], "type": "functional"}, {"input": [[true, true, false, false], "AND"], "output": [false], "type": "functional"}, {"input": [[true, true, false, false], "OR"], "output": [true], "type": "functional"}, {"input": [[true, true, false, false], "XOR"], "output": [false], "type": "functional"}, {"input": [[true, false, false, false], "AND"], "output": [false], "type": "functional"}, {"input": [[true, false, false, false], "OR"], "output": [true], "type": "functional"}, {"input": [[true, false, false, false], "XOR"], "output": [true], "type": "functional"}, {"input": [[true, true], "AND"], "output": [true], "type": "functional"}, {"input": [[true, true], "OR"], "output": [true], "type": "functional"}, {"input": [[true, true], "XOR"], "output": [false], "type": "functional"}, {"input": [[false, false], "AND"], "output": [false], "type": "functional"}, {"input": [[false, false], "OR"], "output": [false], "type": "functional"}, {"input": [[false, false], "XOR"], "output": [false], "type": "functional"}, {"input": [[false], "AND"], "output": [false], "type": "functional"}, {"input": [[false], "OR"], "output": [false], "type": "functional"}, {"input": [[false], "XOR"], "output": [false], "type": "functional"}, {"input": [[true], "AND"], "output": [true], "type": "functional"}, {"input": [[true], "OR"], "output": [true], "type": "functional"}, {"input": [[true], "XOR"], "output": [true], "type": "functional"}], "problem_id": "taco_train_627", "metadata": {"func_name": "logical_calc", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 21}, "generated_solutions": []}
{"problem": "Write a function which takes a number and returns the corresponding ASCII char for that value.\n\nExample: \n\n~~~if-not:java,racket\n```\nget_char(65) # => 'A'\n```\n~~~\n~~~if:java\n~~~\n~~~if:racket\n~~~\n\nFor ASCII table, you can refer to http://www.asciitable.com/", "solutions": ["def get_char(c):\n\treturn chr(c)\n", "get_char = chr\n", "def get_char(value):\n\treturn chr(value)\n", "get_char = lambda c: chr(c)\n", "def get_char(num_of_char):\n\treturn chr(num_of_char)\n", "def get_char(c: int) -> str:\n\treturn chr(c)\n", "import unittest\n\ndef get_char(c):\n\treturn chr(c)\n\nclass TestGetChar(unittest.TestCase):\n\n\tdef test_get_char_should_return_capital_a_when_given_c_is_65(self):\n\t\tself.assertEqual(get_char(65), 'A')\n", "def get_char(c):\n\tstring = chr(c)\n\treturn string\n", "def get_char(c):\n\tn = chr(c)\n\treturn n\n", "def get_char(c):\n\tprint(chr(c))\n\treturn chr(c)\n", "def get_char(c):\n\tascii_char = chr(c)\n\treturn ascii_char\n", "def get_char(c):\n\td = str(chr(c))\n\treturn d\n", "def get_char(c):\n\tkey = chr(c)\n\treturn key\n", "def get_char(c):\n\tf = chr(c)\n\treturn f\n", "def get_char(lie_sheen_sober):\n\treturn chr(lie_sheen_sober)\n", "def get_char(c):\n\tresult = chr(c)\n\treturn result\n", "def get_char(c):\n\ta = str(chr(c))\n\treturn a\n", "get_char = lambda n: chr(n)\n", "def get_char(c):\n\tt = chr(c)\n\treturn t\n", "def get_char(c):\n\toutput = chr(c)\n\treturn output\n", "def get_char(c):\n\tASCII = '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\\xad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n\treturn ASCII[c]\n", "from builtins import chr as get_char\n", "def get_char(c):\n\treturn '{:c}'.format(c)\n", "def get_char(c):\n\treturn '%c' % c\n", "def get_char(c):\n\treturn bytes.fromhex(hex(c)[2:]).decode(encoding='latin1')\n", "def get_char(c):\n\treturn '{0:{base}}'.format(c, base='c')\n", "def get_char(ascii_value: int) -> str:\n\treturn chr(ascii_value)\n", "def get_char(c):\n\treturn [chr(i) for i in range(255)][c]\n", "def get_char(c):\n\treturn chr(ord(chr(c)))\n", "def get_char(c):\n\tascii = [chr(x) for x in range(0, 256)]\n\treturn ascii[c]\n", "def get_char(c):\n\tmyascii = {}\n\tmyascii['32'] = ' '\n\tmyascii['33'] = '!'\n\tmyascii['34'] = '\"'\n\tmyascii['35'] = '#'\n\tmyascii['36'] = '$'\n\tmyascii['37'] = '%'\n\tmyascii['38'] = '&'\n\tmyascii['39'] = ''\n\tmyascii['40'] = '('\n\tmyascii['41'] = ')'\n\tmyascii['42'] = '*'\n\tmyascii['43'] = '+'\n\tmyascii['44'] = ','\n\tmyascii['45'] = '-'\n\tmyascii['46'] = '.'\n\tmyascii['47'] = '/'\n\tmyascii['48'] = '0'\n\tmyascii['49'] = '1'\n\tmyascii['50'] = '2'\n\tmyascii['51'] = '3'\n\tmyascii['52'] = '4'\n\tmyascii['53'] = '5'\n\tmyascii['54'] = '6'\n\tmyascii['55'] = '7'\n\tmyascii['56'] = '8'\n\tmyascii['57'] = '9'\n\tmyascii['58'] = ':'\n\tmyascii['59'] = ';'\n\tmyascii['60'] = '<'\n\tmyascii['61'] = '='\n\tmyascii['62'] = '>'\n\tmyascii['63'] = '?'\n\tmyascii['64'] = '@'\n\tmyascii['65'] = 'A'\n\tmyascii['66'] = 'B'\n\tmyascii['67'] = 'C'\n\tmyascii['68'] = 'D'\n\tmyascii['69'] = 'E'\n\tmyascii['70'] = 'F'\n\tmyascii['71'] = 'G'\n\tmyascii['72'] = 'H'\n\tmyascii['73'] = 'I'\n\tmyascii['74'] = 'J'\n\tmyascii['75'] = 'K'\n\tmyascii['76'] = 'L'\n\tmyascii['77'] = 'M'\n\tmyascii['78'] = 'N'\n\tmyascii['79'] = 'O'\n\tmyascii['80'] = 'P'\n\tmyascii['81'] = 'Q'\n\tmyascii['82'] = 'R'\n\tmyascii['83'] = 'S'\n\tmyascii['84'] = 'T'\n\tmyascii['85'] = 'U'\n\tmyascii['86'] = 'V'\n\tmyascii['87'] = 'W'\n\tmyascii['88'] = 'X'\n\tmyascii['89'] = 'Y'\n\tmyascii['90'] = 'Z'\n\tmyascii['91'] = '['\n\tmyascii['92'] = '\\\\'\n\tmyascii['93'] = ']'\n\tmyascii['94'] = '^'\n\tmyascii['95'] = '_'\n\tmyascii['96'] = '`'\n\tmyascii['97'] = 'a'\n\tmyascii['98'] = 'b'\n\tmyascii['99'] = 'c'\n\tmyascii['100'] = 'd'\n\tmyascii['101'] = 'e'\n\tmyascii['102'] = 'f'\n\tmyascii['103'] = 'g'\n\tmyascii['104'] = 'h'\n\tmyascii['105'] = 'i'\n\tmyascii['106'] = 'j'\n\tmyascii['107'] = 'k'\n\tmyascii['108'] = 'l'\n\tmyascii['109'] = 'm'\n\tmyascii['110'] = 'n'\n\tmyascii['111'] = 'o'\n\tmyascii['112'] = 'p'\n\tmyascii['113'] = 'q'\n\tmyascii['114'] = 'r'\n\tmyascii['115'] = 's'\n\tmyascii['116'] = 't'\n\tmyascii['117'] = 'u'\n\tmyascii['118'] = 'v'\n\tmyascii['119'] = 'w'\n\tmyascii['120'] = 'x'\n\tmyascii['121'] = 'y'\n\tmyascii['122'] = 'z'\n\tmyascii['123'] = '{'\n\tmyascii['124'] = '|'\n\tmyascii['125'] = '}'\n\tmyascii['126'] = '~'\n\tif c in myascii:\n\t\tout = myascii[str(c)]\n\telse:\n\t\tout = chr(c)\n\treturn out\n", "ascii = ['\\x00', '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\x07', '\\x08', '\\t', '\\n', '\\x0b', '\\x0c', '\\r', '\\x0e', '\\x0f', '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16', '\\x17', '\\x18', '\\x19', '\\x1a', '\\x1b', '\\x1c', '\\x1d', '\\x1e', '\\x1f', ' ', '!', '\"', '#', '$', '%', '&', \"'\", '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\\x7f', '\\x80', '\\x81', '\\x82', '\\x83', '\\x84', '\\x85', '\\x86', '\\x87', '\\x88', '\\x89', '\\x8a', '\\x8b', '\\x8c', '\\x8d', '\\x8e', '\\x8f', '\\x90', '\\x91', '\\x92', '\\x93', '\\x94', '\\x95', '\\x96', '\\x97', '\\x98', '\\x99', '\\x9a', '\\x9b', '\\x9c', '\\x9d', '\\x9e', '\\x9f', '\\xa0', '\u00a1', '\u00a2', '\u00a3', '\u00a4', '\u00a5', '\u00a6', '\u00a7', '\u00a8', '\u00a9', '\u00aa', '\u00ab', '\u00ac', '\\xad', '\u00ae', '\u00af', '\u00b0', '\u00b1', '\u00b2', '\u00b3', '\u00b4', '\u00b5', '\u00b6', '\u00b7', '\u00b8', '\u00b9', '\u00ba', '\u00bb', '\u00bc', '\u00bd', '\u00be', '\u00bf', '\u00c0', '\u00c1', '\u00c2', '\u00c3', '\u00c4', '\u00c5', '\u00c6', '\u00c7', '\u00c8', '\u00c9', '\u00ca', '\u00cb', '\u00cc', '\u00cd', '\u00ce', '\u00cf', '\u00d0', '\u00d1', '\u00d2', '\u00d3', '\u00d4', '\u00d5', '\u00d6', '\u00d7', '\u00d8', '\u00d9', '\u00da', '\u00db', '\u00dc', '\u00dd', '\u00de', '\u00df', '\u00e0', '\u00e1', '\u00e2', '\u00e3', '\u00e4', '\u00e5', '\u00e6', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ec', '\u00ed', '\u00ee', '\u00ef', '\u00f0', '\u00f1', '\u00f2', '\u00f3', '\u00f4', '\u00f5', '\u00f6', '\u00f7', '\u00f8', '\u00f9', '\u00fa', '\u00fb', '\u00fc', '\u00fd', '\u00fe', '\u00ff']\n\ndef get_char(c):\n\treturn ascii[c] if c in range(len(ascii)) else ''\n", "def get_char(c):\n\tprint(c)\n\ttry:\n\t\tasciiDict = {i: chr(i) for i in range(256)}\n\t\treturn asciiDict[c]\n\texcept:\n\t\treturn None\n", "def get_char(c):\n\tres = chr(c)\n\treturn res\n", "def get_char(c):\n\tg = chr(c)\n\treturn g\n", "def get_char(c):\n\tif c < 0 or c > 255:\n\t\tprint('ASCII out of range')\n\t\treturn -1\n\treturn chr(c)\n", "def get_char(c):\n\tascii_code = chr(c)\n\treturn ascii_code\n", "def get_char(c):\n\tb = chr(c)\n\treturn b\n", "def get_char(num):\n\treturn chr(num)\n", "def get_char(ascii):\n\treturn chr(ascii)\n", "get_char = lambda i: chr(i)\n", "def get_char(c):\n\tx = chr(c)\n\treturn x\n", "def get_char(c):\n\tif c:\n\t\treturn chr(c)\n", "def get_char(c):\n\tanswer = str(chr(c))\n\treturn answer\n", "def get_char(c):\n\tletter = chr(c)\n\treturn letter\n", "def get_char(c):\n\treturn chr(c)\nget_char(65)\n", "def get_char(c):\n\tcharacter = chr(c)\n\treturn character\n", "def get_char(n):\n\treturn chr(n)\n", "get_char = lambda x: chr(x)\n", "import html\n\ndef get_char(c):\n\treturn chr(c)\n", "def get_char(c):\n\tASCII = chr(c)\n\treturn ASCII\n", "def get_char(c):\n\tchar = chr(c)\n\treturn char\n"], "public_test_cases": [{"input": [65], "output": ["A"], "type": "functional"}], "test_cases": [{"input": [65], "output": ["A"], "type": "functional"}, {"input": [33], "output": ["!"], "type": "functional"}, {"input": [34], "output": ["\""], "type": "functional"}, {"input": [35], "output": ["#"], "type": "functional"}, {"input": [36], "output": ["$"], "type": "functional"}, {"input": [37], "output": ["%"], "type": "functional"}, {"input": [38], "output": ["&"], "type": "functional"}], "problem_id": "taco_train_64", "metadata": {"func_name": "get_char", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 7}, "generated_solutions": []}
{"problem": "## Objective\n\nGiven a number `n` we will define it's sXORe to be `0 XOR 1 XOR 2 ... XOR n` where `XOR` is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nWrite a function that takes `n` and returns it's sXORe.\n\n## Examples\n|    n    | sXORe n\n|---------|--------         \n| 0       | 0\n| 1       | 1\n| 50      | 51\n| 1000000 | 1000000\n---", "solutions": ["def sxore(n):\n\treturn [n, 1, n + 1, 0][n % 4]\n", "def sxore(n):\n\tres = {0: n, 1: 1, 2: n + 1, 3: 0}\n\treturn res[n % 4]\n", "sxore = lambda n: {n % 4 == 0: n, n % 4 == 1: 1, n % 4 == 2: n + 1}.get(True, 0)\n", "sxore = lambda n: (n, 1, n + 1, 0)[n % 4]\n", "def sxore(n):\n\treturn n >> 1 & 1 ^ (1 if n & 1 else n)\n", "d = {0: lambda x: x, 1: lambda x: 1, 2: lambda x: x // 4 * 4 + 3, 3: lambda x: 0}\n\ndef sxore(n):\n\treturn d[n % 4](n)\n", "def sxore(n):\n\tm = n % 4\n\tif m == 0:\n\t\treturn n\n\tif m == 1:\n\t\treturn 1\n\tif m == 2:\n\t\treturn n + 1\n\treturn 0\n"], "public_test_cases": [{"input": [0], "output": [0], "type": "functional"}, {"input": [1], "output": [1], "type": "functional"}, {"input": [50], "output": [51], "type": "functional"}, {"input": [1000000], "output": [1000000], "type": "functional"}], "test_cases": [{"input": [0], "output": [0], "type": "functional"}, {"input": [1], "output": [1], "type": "functional"}, {"input": [2], "output": [3], "type": "functional"}, {"input": [50], "output": [51], "type": "functional"}, {"input": [1000000], "output": [1000000], "type": "functional"}, {"input": [1000001], "output": [1], "type": "functional"}, {"input": [9999999999999999999999999], "output": [0], "type": "functional"}], "problem_id": "taco_train_6478", "metadata": {"func_name": "sxore", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 4, "num_original_tests": 7}, "generated_solutions": []}
{"problem": "The magic sum of 3s is calculated on an array by summing up odd numbers which include the digit `3`. Write a function `magic_sum` which accepts an array of integers and returns the sum.\n\n*Example:* `[3, 12, 5, 8, 30, 13]` results in `16` (`3` + `13`)\n\nIf the sum cannot be calculated, `0` should be returned.", "solutions": ["def magic_sum(arr):\n\treturn arr and sum((x for x in arr if x % 2 and '3' in str(x))) or 0\n", "def magic_sum(arr):\n\tif arr == None:\n\t\treturn 0\n\treturn sum(list(filter(lambda x: x % 2 == 1 and '3' in str(x), arr)))\n", "def magic_sum(arr):\n\n\tdef check(x):\n\t\treturn x % 2 and '3' in str(x)\n\treturn sum((x for x in arr if check(x))) if arr else 0\n", "def magic_sum(arr):\n\treturn sum((i for i in arr if i % 2 == 1 and '3' in str(i))) if arr else 0\n", "def magic_sum(arr):\n\treturn sum((n for n in arr if n % 2 and '3' in str(n))) if arr else 0\n", "magic_sum = lambda a: sum((n % 2 * n * ('3' in str(n)) for n in a or []))\n", "def magic_sum(arr):\n\treturn sum((v for v in arr if '3' in set(str(v)) and v % 2)) if arr else 0\n", "def magic_sum(arr):\n\tif arr == None or arr == []:\n\t\treturn 0\n\toutput = 0\n\tfor num in arr:\n\t\tif '3' in str(num) and num % 2 == 1:\n\t\t\toutput += num\n\t\telse:\n\t\t\tpass\n\treturn output\n"], "public_test_cases": [{"input": [[3, 12, 5, 8, 30, 13]], "output": [16], "type": "functional"}], "test_cases": [{"input": [[3]], "output": [3], "type": "functional"}, {"input": [[3, 13]], "output": [16], "type": "functional"}, {"input": [[30, 34, 330]], "output": [0], "type": "functional"}, {"input": [[3, 12, 5, 8, 30, 13]], "output": [16], "type": "functional"}, {"input": [[]], "output": [0], "type": "functional"}, {"input": [null], "output": [0], "type": "functional"}], "problem_id": "taco_train_201", "metadata": {"func_name": "magic_sum", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 6}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nMy friend wants a new band name for her band. She like bands that use the formula: \"The\" + a noun with the first letter capitalized, for example:\n\n`\"dolphin\" -> \"The Dolphin\"`\n\nHowever, when a noun STARTS and ENDS with the same letter, she likes to repeat the noun twice and connect them together with the first and last letter, combined into one word (WITHOUT \"The\" in front), like this:\n\n`\"alaska\" -> \"Alaskalaska\"`\n\nComplete the function that takes a noun as a string, and returns her preferred band name written as a string.\n\nWrite your solution by modifying this code:\n\n```python\ndef band_name_generator(name):\n\t\n```\n\nYour solution should implemented in the function \"band_name_generator\". The inputs will be passed to it and it should return the correct solution.\n\n\nNow solve the problem and return the code.", "solutions": ["```python\ndef band_name_generator(name):\n\treturn name.capitalize() + name[1:] if name[0] == name[-1] else 'The ' + name.capitalize()\n\n```"], "public_test_cases": [{"input": ["dolphin"], "output": ["The Dolphin"], "type": "functional"}, {"input": ["alaska"], "output": ["Alaskalaska"], "type": "functional"}, {"input": ["knife"], "output": ["The Knife"], "type": "functional"}, {"input": ["tart"], "output": ["Tartart"], "type": "functional"}], "test_cases": [{"input": ["knife"], "output": ["The Knife"], "type": "functional"}, {"input": ["tart"], "output": ["Tartart"], "type": "functional"}, {"input": ["sandles"], "output": ["Sandlesandles"], "type": "functional"}, {"input": ["bed"], "output": ["The Bed"], "type": "functional"}, {"input": ["qq"], "output": ["Qqq"], "type": "functional"}], "problem_id": "primeintellect_train_6792", "metadata": {"func_name": "band_name_generator", "config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 4, "num_original_tests": 5}, "generated_solutions": []}
{"problem": "The AKS algorithm for testing whether a number is prime is a polynomial-time test based on the following theorem: \n\nA number p is prime if and only if all the coefficients of the polynomial expansion of `(x \u2212 1)^p \u2212 (x^p \u2212 1)` are divisible by `p`.\n\nFor example, trying `p = 3`:\n\n     (x \u2212 1)^3 \u2212 (x^3 \u2212 1) = (x^3 \u2212 3x^2 + 3x \u2212 1) \u2212 (x^3 \u2212 1) = \u2212 3x^2 + 3x \n    \nAnd all the coefficients are divisible by 3, so 3 is prime.\n\nYour task is to code the test function, wich will be given an integer and should return true or false based on the above theorem. You should efficiently calculate every coefficient one by one and stop when a coefficient is not divisible by p to avoid pointless calculations. The easiest way to calculate coefficients is to take advantage of binomial coefficients: http://en.wikipedia.org/wiki/Binomial_coefficient and pascal triangle: http://en.wikipedia.org/wiki/Pascal%27s_triangle . \n\nYou should also take advantage of the symmetry of binomial coefficients. You can look at these kata: http://www.codewars.com/kata/pascals-triangle and http://www.codewars.com/kata/pascals-triangle-number-2\n\nThe kata here only use the simple theorem. The general AKS test is way more complex.  The simple approach is a good exercie but impractical. The general AKS test will be the subject of another kata as it is one of the best performing primality test algorithms.\n\nThe main problem of this algorithm is the big numbers emerging from binomial coefficients in the polynomial expansion. As usual Javascript reach its limit on big integer very fast. (This simple algorithm is far less performing than a trivial algorithm here). You can compare the results with those of this kata: http://www.codewars.com/kata/lucas-lehmer-test-for-mersenne-primes Here, javascript can barely treat numbers bigger than 50, python can treat M13 but not M17.", "solutions": ["def aks_test(p):\n\tlst = []\n\tfor i in range(2, p + 1):\n\t\tfor j in lst:\n\t\t\tif i % j == 0:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tlst.append(i)\n\tif p in lst:\n\t\treturn True\n\telse:\n\t\treturn False\n", "import math\n\ndef aks_test(p):\n\tcenter = math.factorial(p // 2) * math.factorial(p - p // 2)\n\tif center % p == 0:\n\t\treturn False\n\treturn True\n", "def aks_test(p):\n\treturn p >= 2 and all((p % d != 0 for d in range(2, int(p ** 0.5) + 1)))\n", "P = [2] + [p for p in range(3, 500000, 2) if all((p % v for v in range(3, int(p ** 0.5 + 1), 2)))]\nS = set(P)\n\ndef aks_test(p):\n\treturn p in S or (p > 2 and p & 1 and all((p % v for v in P)))\n", "from math import factorial\n\ndef aks_test(p):\n\tif p in (1, 2):\n\t\treturn p == 2\n\tf = p\n\tfor k in range(1, 1 + p // 2):\n\t\tif f % p:\n\t\t\treturn False\n\t\tf *= p - k\n\t\tf //= k + 1\n\treturn True\n", "def aks_test(n):\n\tif n <= 1:\n\t\treturn False\n\tif n <= 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\ti = 5\n\twhile i * i <= n:\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\n"], "public_test_cases": [{"input": [3], "output": [true], "type": "functional"}], "test_cases": [{"input": [3], "output": [true], "type": "functional"}, {"input": [4], "output": [false], "type": "functional"}, {"input": [5], "output": [true], "type": "functional"}, {"input": [7], "output": [true], "type": "functional"}, {"input": [10], "output": [false], "type": "functional"}, {"input": [33], "output": [false], "type": "functional"}, {"input": [101], "output": [true], "type": "functional"}, {"input": [1], "output": [false], "type": "functional"}, {"input": [2], "output": [true], "type": "functional"}, {"input": [11213], "output": [true], "type": "functional"}, {"input": [8191], "output": [true], "type": "functional"}, {"input": [8192], "output": [false], "type": "functional"}], "problem_id": "taco_train_6288", "metadata": {"func_name": "aks_test", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 12}, "generated_solutions": []}
{"problem": "An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n**Note:** anagrams are case insensitive\n\nComplete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n\n\n## Examples\n\n* `\"foefet\"` is an anagram of `\"toffee\"`\n\n* `\"Buckethead\"` is an anagram of `\"DeathCubeK\"`", "solutions": ["def is_anagram(test, original):\n\treturn sorted(original.lower()) == sorted(test.lower())\n", "from collections import Counter\n\ndef is_anagram(test, original):\n\treturn Counter(test.lower()) == Counter(original.lower())\n", "def is_anagram(test, original):\n\treturn sorted(test.upper()) == sorted(original.upper())\n", "def is_anagram(test, original):\n\t(test_dict, original_dict) = ({}, {})\n\tfor i in test.lower():\n\t\ttest_dict[i] = test_dict.get(i, 0) + 1\n\tfor i in original.lower():\n\t\toriginal_dict[i] = original_dict.get(i, 0) + 1\n\treturn test_dict == original_dict\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\tcount = [0] * 26\n\tfor i in range(len(test)):\n\t\tcount[(ord(test[i]) & 31) - 1] += 1\n\t\tcount[(ord(original[i]) & 31) - 1] -= 1\n\treturn not any(count)\n", "def is_anagram(test, original):\n\ta = sorted(test.lower())\n\tb = sorted(original.lower())\n\tc = ''.join(a)\n\td = ''.join(b)\n\tif c == d:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tgo = len(test) == len(original)\n\tarr = []\n\tif go:\n\t\tfor i in test:\n\t\t\tarr.append(i.lower() in original.lower())\n\t\treturn False not in arr\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\tfor l in test.lower():\n\t\tif l not in original.lower():\n\t\t\treturn False\n\treturn True\n", "from operator import eq\nfrom collections import Counter\n\ndef is_anagram(test, original):\n\treturn eq(*map(Counter, map(str.lower, (test, original))))\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\treturn sorted(test.lower()) == sorted(original.lower())\n", "def is_anagram(test, original):\n\tif sorted(test.lower()) == sorted(original.lower()):\n\t\treturn True\n\telse:\n\t\treturn False\n", "is_anagram = lambda t, o: sorted(t.lower()) == sorted(o.lower())\n", "aprime = {'a': 2, 'c': 5, 'b': 3, 'e': 11, 'd': 7, 'g': 17, 'f': 13, 'i': 23, 'h': 19, 'k': 31, 'j': 29, 'm': 41, 'l': 37, 'o': 47, 'n': 43, 'q': 59, 'p': 53, 's': 67, 'r': 61, 'u': 73, 't': 71, 'w': 83, 'v': 79, 'y': 97, 'x': 89, 'z': 101}\n\ndef aprime_sum(str):\n\tstrChList = list(str.lower())\n\treturn sum([aprime[x] for x in strChList])\n\ndef is_anagram(test, original):\n\tif aprime_sum(test) == aprime_sum(original):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\treturn set(original.lower()) == set(test.lower()) if len(test) == len(original) else False\n", "def is_anagram(test, original):\n\ta = list(test.lower())\n\ts = list(original.lower())\n\tif len(a) != len(s):\n\t\treturn False\n\telse:\n\t\tfor i in a:\n\t\t\tcond = False\n\t\t\tk = 0\n\t\t\twhile k != len(s) and cond == False:\n\t\t\t\tif i == s[k]:\n\t\t\t\t\ta.remove(i)\n\t\t\t\t\ts.remove(i)\n\t\t\t\t\tcond = True\n\t\t\t\tk += 1\n\t\t\tif cond == False:\n\t\t\t\treturn False\n\t\tif len(a) != len(s):\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n", "def is_anagram(test, original):\n\tflag = 0\n\tif len(test) != len(original):\n\t\treturn False\n\telse:\n\t\tfor i in test.lower():\n\t\t\tif i not in original.lower():\n\t\t\t\tflag = 1\n\t\t\telse:\n\t\t\t\tcontinue\n\t\tif flag == 1:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n", "def is_anagram(test, original):\n\n\tdef to_dict(word):\n\t\tdictionary = {}\n\t\tfor w in word.lower():\n\t\t\tif w not in dictionary:\n\t\t\t\tdictionary[w] = 0\n\t\t\telse:\n\t\t\t\tdictionary[w] += 1\n\t\treturn dictionary\n\treturn to_dict(test) == to_dict(original)\n", "is_anagram = lambda a, b, s=sorted: s(a.lower()) == s(b.lower())\n", "def is_anagram(s, l):\n\tn = len(s)\n\tif len(l) != n:\n\t\treturn False\n\ts = s.lower()\n\tl = l.lower()\n\th = [0 for x in range(26)]\n\tfor i in range(n):\n\t\th[ord(s[i]) - 97] += 1\n\t\th[ord(l[i]) - 97] -= 1\n\treturn h.count(0) == 26\n", "def is_anagram(test: str, original: str) -> bool:\n\treturn all([all([_ in original.lower() for _ in test.lower()]), len(test) == len(original)])\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\ttestcount = 0\n\tfor i in test:\n\t\tif i in original:\n\t\t\ttestcount += 1\n\toriginalcount = 0\n\tfor i in original:\n\t\tif i in test:\n\t\t\toriginalcount += 1\n\tif testcount == originalcount and testcount == len(test) and (originalcount == len(original)):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) == len(original):\n\t\ttest = test.lower()\n\t\toriginal = original.lower()\n\t\tcount = 0\n\t\tfor char in test:\n\t\t\tif char in original:\n\t\t\t\tcount += 1\n\t\tif count == len(test):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest_list = []\n\toriginal_list = []\n\tfor i in test.lower():\n\t\ttest_list.append(i)\n\tfor i in original.lower():\n\t\toriginal_list.append(i)\n\ttest_list.sort()\n\toriginal_list.sort()\n\tprint(test_list)\n\tprint(original_list)\n\tif test_list == original_list:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\tletters = {}\n\tfor i in test.lower():\n\t\tif i in letters:\n\t\t\tletters[i] += 1\n\t\telse:\n\t\t\tletters[i] = 1\n\tfor i in original.lower():\n\t\tif i not in letters:\n\t\t\treturn False\n\t\tif original.lower().count(i) != letters[i]:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(t, o):\n\treturn sorted([*t.lower()]) == sorted([*o.lower()])\n", "def is_anagram(test, original):\n\tx = list(test.lower())\n\ty = list(original.lower())\n\tx = sorted(x)\n\ty = sorted(y)\n\tif x == y:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\ta = sorted(test.lower())\n\tb = sorted(original.lower())\n\tif a == b:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tsorted_test = sorted(list(test.lower()))\n\tsorted_original = sorted(list(original.lower()))\n\treturn sorted_test == sorted_original\n", "def is_anagram(test, original):\n\tletters = [c for c in test.lower()]\n\tfor char in original.lower():\n\t\tif char in letters:\n\t\t\tdel letters[letters.index(char)]\n\t\telse:\n\t\t\treturn False\n\treturn not bool(len(letters))\n", "import collections\n\ndef is_anagram(test, original):\n\treturn collections.Counter([i.lower() for i in sorted(test)]) == collections.Counter([i.lower() for i in sorted(original)])\n", "def is_anagram(test, original):\n\ttest_set = sorted(test.lower())\n\toriginal_set = sorted(original.lower())\n\tif test_set == original_set:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tt = sorted(test.lower())\n\to = sorted(original.lower())\n\tif t == o:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tnew_test = test.lower()\n\tnew_original = original.lower()\n\tsortedTest = sorted(new_test)\n\tsortedOriginal = sorted(new_original)\n\tfor letters in new_test:\n\t\tif letters in new_original and len(new_test) == len(new_original) and (sortedOriginal == sortedTest):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n", "def is_anagram(test, original):\n\ttest_word_freq = {}\n\toriginal_word_freq = {}\n\ttest = test.lower()\n\toriginal = original.lower()\n\tif len(test) == len(original):\n\t\tfor (idx, letter) in enumerate(test):\n\t\t\tif letter not in test_word_freq:\n\t\t\t\ttest_word_freq[letter] = 1\n\t\t\telse:\n\t\t\t\ttest_word_freq[letter] += 1\n\t\tfor (idx, lett) in enumerate(original):\n\t\t\tif lett not in original_word_freq:\n\t\t\t\toriginal_word_freq[lett] = 1\n\t\t\telse:\n\t\t\t\toriginal_word_freq[lett] += 1\n\t\tprint(original_word_freq)\n\t\tprint(test_word_freq)\n\t\tfor (k, v) in list(test_word_freq.items()):\n\t\t\tif k not in original_word_freq:\n\t\t\t\treturn False\n\t\t\tif v != original_word_freq[k]:\n\t\t\t\treturn False\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tfirst = [i.lower() for i in test]\n\tsecond = [i.lower() for i in original]\n\treturn sorted(first) == sorted(second)\n", "def is_anagram(test, original):\n\tlist_test = []\n\tlist_original = []\n\tfor i in test.lower():\n\t\tlist_test += i\n\tfor i in original.lower():\n\t\tlist_original += i\n\tif len(list_test) == len(list_original):\n\t\tlist_test.sort()\n\t\tlist_original.sort()\n\t\tif list_test == list_original:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\treturn True if sorted([letter for letter in test.lower()]) == sorted([letter for letter in original.lower()]) else False\n", "def is_anagram(test, original):\n\tt = list(test.lower())\n\tto = ''.join(sorted(t))\n\to = list(original.lower())\n\too = ''.join(sorted(o))\n\tif to == oo:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tletterCount = dict.fromkeys('abcdefghijklmnopqrstuvwxyz', 0)\n\tfor c in test.lower():\n\t\tletterCount[c] += 1\n\tfor c in original.lower():\n\t\tletterCount[c] -= 1\n\tfor value in list(letterCount.values()):\n\t\tif value != 0:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(a_str, b_str):\n\tif len(a_str) == len(b_str):\n\t\ta_list = list(a_str.lower())\n\t\tb_list = list(b_str.lower())\n\t\tfor char in a_list:\n\t\t\tif char in b_list:\n\t\t\t\tb_list.remove(char)\n\t\tif not b_list:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\telse:\n\t\ttest = test.lower()\n\t\toriginal = original.lower()\n\t\tcounter_original = [0] * 26\n\t\tcounter_test = [0] * 26\n\t\tfor i in test:\n\t\t\tcounter_test[ord(i) - 97] += 1\n\t\tfor i in original:\n\t\t\tcounter_original[ord(i) - 97] += 1\n\treturn counter_test == counter_original\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tnewList = [ord(c) for c in test]\n\tnewList.sort()\n\tnewList2 = [ord(b) for b in original]\n\tnewList2.sort()\n\tif newList == newList2:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tcounterTest = [0] * 255\n\tcounterOri = [0] * 255\n\tfor i in range(len(test)):\n\t\tcounterTest[ord(test[i].lower())] += 1\n\tfor i in range(len(original)):\n\t\tcounterOri[ord(original[i].lower())] += 1\n\tif counterOri == counterTest:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = test.upper()\n\toriginal = original.upper()\n\tif sorted(test) == sorted(original):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) == len(original):\n\t\ttest = test.lower()\n\t\toriginal = original.lower()\n\t\tfor i in test:\n\t\t\tif original.find(i) == -1:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\ttest.replace(i, '')\n\t\t\t\toriginal.replace(i, '')\n\telse:\n\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tcounter1 = [0] * 255\n\tcounter2 = [0] * 255\n\tfor i in range(len(test)):\n\t\tcounter1[ord(test[i].lower())] += 1\n\tfor i in range(len(original)):\n\t\tcounter2[ord(original[i].lower())] += 1\n\treturn counter1 == counter2\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tfor x in range(len(test)):\n\t\tif test.count(test[x]) != original.count(test[x]):\n\t\t\treturn False\n\tfor x in range(len(original)):\n\t\tif test.count(original[x]) != original.count(original[x]):\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tnT = len(test)\n\tnO = len(original)\n\tif nO == nT:\n\t\tcounterT = [0] * (255 + 1)\n\t\tcounterO = [0] * (255 + 1)\n\t\tfor x in range(nT):\n\t\t\tcounterT[ord(test[x])] += 1\n\t\t\tcounterO[ord(original[x])] += 1\n\t\tif counterT == counterO:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tn = len(original)\n\tif n != len(test):\n\t\treturn False\n\tcounterTest = [0] * 255\n\tcounterOrig = [0] * 255\n\tfor i in range(n):\n\t\tcounterTest[ord(test[i].lower())] += 1\n\t\tcounterOrig[ord(original[i].lower())] += 1\n\treturn True if ''.join(map(str, counterTest)) == ''.join(map(str, counterOrig)) else False\n", "def is_anagram(test, original):\n\treturn sorted([n.lower() for n in test]) == sorted([n.lower() for n in original])\n", "def is_anagram(word_o, test_o):\n\tis_anagram = True\n\tword = word_o.lower()\n\ttest = test_o.lower()\n\tif len(word) != len(test):\n\t\tis_anagram = False\n\talist = list(test.lower())\n\tpos1 = 0\n\twhile pos1 < len(word) and is_anagram:\n\t\tpos2 = 0\n\t\tfound = False\n\t\twhile pos2 < len(alist) and (not found):\n\t\t\tif word[pos1] == alist[pos2]:\n\t\t\t\tfound = True\n\t\t\telse:\n\t\t\t\tpos2 = pos2 + 1\n\t\tif found:\n\t\t\talist[pos2] = None\n\t\telse:\n\t\t\tis_anagram = False\n\t\tpos1 = pos1 + 1\n\treturn is_anagram\n", "def is_anagram(test, original):\n\tl1 = list(test.lower())\n\tl2 = list(original.lower())\n\tif len(l1) == len(l2):\n\t\tfor i in l1:\n\t\t\tif i in l2:\n\t\t\t\tl2.remove(i)\n\t\t\telse:\n\t\t\t\treturn False\n\telse:\n\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tfor i in test.lower():\n\t\tif i in original.lower() and len(test) == len(original):\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest_list = [letter1 for letter1 in test.lower()]\n\torig_list = [letter2 for letter2 in original.lower()]\n\tif sorted(test_list) == sorted(orig_list):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tt = sorted(test.lower())\n\to = sorted(original.lower())\n\tif t == o:\n\t\tprint('true')\n\t\treturn True\n\telse:\n\t\tprint('false')\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = [i.lower() for i in test]\n\toriginal = [j.lower() for j in original]\n\ttest.sort()\n\toriginal.sort()\n\treturn test == original\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tif len(test) != len(original):\n\t\treturn False\n\tfor x in test:\n\t\tif test.count(x) == original.count(x):\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tnew_test = list(test)\n\tnew_original = list(original)\n\tnew_test.sort()\n\tnew_original.sort()\n\tif new_test == new_original:\n\t\treturn True\n\treturn False\n\tpass\n", "def is_anagram(test, original):\n\treturn set(test.upper()) == set(original.upper()) and len(test) == len(original)\n", "is_anagram = lambda test, original: True if sorted(original.lower()) == sorted(test.lower()) else False\n", "def is_anagram(test, original):\n\toriginalLower = [val for val in original.lower()]\n\tarr = test.lower()\n\tif len(arr) != len(originalLower):\n\t\treturn False\n\tfor element in arr:\n\t\tif element not in originalLower:\n\t\t\treturn False\n\t\telse:\n\t\t\toriginalLower.remove(element)\n\treturn True\n", "def is_anagram(test, original):\n\tn1 = len(test)\n\tn2 = len(original)\n\tif n1 != n2:\n\t\treturn False\n\tstr1 = sorted(test.lower())\n\tstr2 = sorted(original.lower())\n\tfor i in range(0, n1):\n\t\tif str1[i] != str2[i]:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest_l = list(test.lower())\n\toriginal_l = list(original.lower())\n\ttest_l.sort()\n\toriginal_l.sort()\n\tif test_l == original_l:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = list(test.lower())\n\toriginal = list(original.lower())\n\tif len(test) != len(original):\n\t\treturn False\n\tfor word in test:\n\t\tfor word2 in original:\n\t\t\tif word == word2:\n\t\t\t\toriginal.remove(word2)\n\t\t\t\tbreak\n\tif len(original) == 0:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ta = sorted(list(test.lower()))\n\tb = sorted(list(original.lower()))\n\tif a == b:\n\t\tprint(f'The word {test} is an anagram of {original}')\n\t\treturn True\n\telse:\n\t\tprint(f'Characters do not match for test case {test}, {original}')\n\t\treturn False\n", "def is_anagram(test, original):\n\n\tdef to_list(string):\n\t\tlisted = []\n\t\tfor i in range(len(string)):\n\t\t\tlisted.append(string[i])\n\t\treturn listed\n\treturn str(sorted(to_list(test.lower()))) == str(sorted(to_list(original.lower())))\n", "def is_anagram(test, original):\n\ttest = list(test.lower())\n\ttest.sort()\n\toriginal = list(original.lower())\n\toriginal.sort()\n\tif original != test or len(test) != len(original):\n\t\treturn False\n\telse:\n\t\treturn True\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\ttest = sorted(test.lower())\n\toriginal = sorted(original.lower())\n\tfor i in range(len(test)):\n\t\tif test[i] != original[i]:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tresult = True if len(test) == len(original) else False\n\tfor letter in test.upper():\n\t\tresult = False if letter not in original.upper() else result\n\treturn result\n", "def is_anagram(test, original):\n\tif len(original) != len(test):\n\t\treturn False\n\ttest = test.lower()\n\toriginal = original.lower()\n\tfor letter in original:\n\t\tif original.count(letter) != test.count(letter):\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tif sorted(test.lower()) == sorted(original.lower()):\n\t\treturn True\n\telif test != original:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest_list = sorted(list(test.lower()))\n\toriginal_list = sorted(list(original.lower()))\n\tif test_list == original_list:\n\t\treturn True\n\tif test_list != original_list:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tt = list(test)\n\to = list(original)\n\tt.sort()\n\to.sort()\n\treturn t == o\n", "def is_anagram(test, original):\n\tt = test.lower()\n\to = [*original.lower()]\n\tif len(t) != len(o):\n\t\treturn False\n\tfor c in t:\n\t\tif c in o:\n\t\t\to.remove(c)\n\t\telse:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tif len(test) > len(original) or len(test) < len(original):\n\t\treturn False\n\tres = ''\n\tcounter = 0\n\tsortedTest = sorted(test.lower())\n\tsortedOriginal = sorted(original.lower())\n\tfor i in range(0, len(sortedTest)):\n\t\tif sortedTest[i] != sortedOriginal[i]:\n\t\t\tres = False\n\t\t\tbreak\n\t\telse:\n\t\t\tres = True\n\treturn res\n", "from collections import Counter as C\n\ndef is_anagram(test, original):\n\treturn C(test.lower()) == C(original.lower())\n", "def is_anagram(test, original):\n\tsort1 = sorted(test.lower())\n\tsort2 = sorted(original.lower())\n\tif ''.join(sort2) == ''.join(sort1):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttheTest = test.lower()\n\ttheOriginal = original.lower()\n\tif len(theTest) != len(theOriginal):\n\t\treturn False\n\telse:\n\t\tindex = 0\n\t\tlengthCheck = 0\n\t\tarray = [None] * len(theTest)\n\t\tfor i in theOriginal:\n\t\t\tarray[index] = i\n\t\t\tindex += 1\n\t\tfor j in theTest:\n\t\t\ttestLength = len(theTest)\n\t\t\tif j in array:\n\t\t\t\tlengthCheck += 1\n\t\t\telse:\n\t\t\t\treturn False\n\t\tif lengthCheck == testLength:\n\t\t\treturn True\n", "def is_anagram(tst, org):\n\ttst = tst.lower()\n\torg = org.lower()\n\tif len(tst) != len(org):\n\t\treturn False\n\tfor i in org:\n\t\tif tst.count(i) != org.count(i):\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\telif sorted(test.casefold()) == sorted(original.casefold()):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tletters_original = sorted(list(original.upper()))\n\tletters_test = sorted(list(test.upper()))\n\treturn letters_original == letters_test\n", "def is_anagram(test, original):\n\treturn len(test) == len(original) and all([i in original.lower() for i in test.lower()])\n", "def is_anagram(test, original):\n\torg1 = [x.lower() for x in original]\n\torg2 = [y.lower() for y in test]\n\torg1.sort()\n\torg2.sort()\n\tif org1 == org2:\n\t\treturn True\n\treturn False\n", "def is_anagram(test, original):\n\toriginal_list = list(original.lower())\n\ttest_list = list(test.lower())\n\toriginal_list.sort()\n\ttest_list.sort()\n\ta = ''.join(test_list)\n\tb = ''.join(original_list)\n\treturn a == b\n", "def is_anagram(test, original):\n\ttest = test.lower().replace(' ', '')\n\toriginal = original.lower().replace(' ', '')\n\tif len(test) != len(original):\n\t\treturn False\n\tfor letter in test:\n\t\tif letter not in original:\n\t\t\treturn False\n\tfor letter in original:\n\t\tif letter not in test:\n\t\t\treturn False\n\treturn True\n"], "public_test_cases": [{"input": ["foefet", "toffee"], "output": [true], "type": "functional"}, {"input": ["Buckethead", "DeathCubeK"], "output": [true], "type": "functional"}], "test_cases": [{"input": ["foefet", "toffee"], "output": [true], "type": "functional"}, {"input": ["Buckethead", "DeathCubeK"], "output": [true], "type": "functional"}, {"input": ["Twoo", "WooT"], "output": [true], "type": "functional"}, {"input": ["dumble", "bumble"], "output": [false], "type": "functional"}, {"input": ["ound", "round"], "output": [false], "type": "functional"}, {"input": ["apple", "pale"], "output": [false], "type": "functional"}], "problem_id": "taco_train_6282", "metadata": {"func_name": "is_anagram", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 6}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nIt started as a discussion with a friend, who didn't fully grasp some way of setting defaults, but I thought the idea was cool enough for a beginner kata: binary `OR` each matching element of two given arrays (or lists, if you do it in Python; vectors in c++) of integers and give the resulting ORed array [starts to sound like a tonguetwister, doesn't it?].\n\nIf one array is shorter than the other, use the optional third parametero (defaulted to `0`) to `OR` the unmatched elements.\n\nFor example:\n\n```python\nor_arrays([1,2,3],[1,2,3]) == [1,2,3]\nor_arrays([1,2,3],[4,5,6]) == [5,7,7]\nor_arrays([1,2,3],[1,2]) == [1,2,3]\nor_arrays([1,2],[1,2,3]) == [1,2,3]\nor_arrays([1,2,3],[1,2,3],3) == [1,2,3]\n```\n\nWrite your solution by modifying this code:\n\n```python\ndef or_arrays(a, b, filler=0):\n\t\n```\n\nYour solution should implemented in the function \"or_arrays\". The inputs will be passed to it and it should return the correct solution.\n\n\nNow solve the problem and return the code.", "solutions": ["```python\nfrom itertools import zip_longest\n\ndef or_arrays(a1, a2, d=0):\n\treturn [x | y for (x, y) in zip_longest(a1, a2, fillvalue=d)]\n\n```"], "public_test_cases": [{"input": [[1, 2, 3], [1, 2, 3]], "output": [1, 2, 3], "type": "functional"}, {"input": [[1, 2, 3], [4, 5, 6]], "output": [5, 7, 7], "type": "functional"}, {"input": [[1, 2, 3], [1, 2]], "output": [1, 2, 3], "type": "functional"}, {"input": [[1, 2], [1, 2, 3]], "output": [1, 2, 3], "type": "functional"}, {"input": [[1, 2, 3], [1, 2, 3], 3], "output": [1, 2, 3], "type": "functional"}], "test_cases": [{"input": [[1, 2, 3], [1, 2, 3]], "output": [[1, 2, 3]], "type": "functional"}, {"input": [[1, 2, 3], [4, 5, 6]], "output": [[5, 7, 7]], "type": "functional"}, {"input": [[1, 2, 3], [1, 2]], "output": [[1, 2, 3]], "type": "functional"}, {"input": [[1, 0], [1, 2, 3]], "output": [[1, 2, 3]], "type": "functional"}, {"input": [[1, 0, 3], [1, 2, 3], 3], "output": [[1, 2, 3]], "type": "functional"}], "problem_id": "primeintellect_train_5440", "metadata": {"func_name": "or_arrays", "config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 5, "num_original_tests": 5}, "generated_solutions": []}
{"problem": "Spoonerize... with numbers... numberize?... numboonerize?... noonerize? ...anyway!  If you don't yet know what a spoonerism is and haven't yet tried my spoonerism kata, please do [check it out](http://www.codewars.com/kata/spoonerize-me) first.\n\nYou will create a function which takes an array of two positive integers, spoonerizes them, and returns the positive difference between them as a single number or ```0``` if the numbers are equal:\n```\n[123, 456] = 423 - 156 = 267\n```\nYour code must test that all array items are numbers and return ```\"invalid array\"``` if it finds that either item is not a number.  The provided array will always contain 2 elements.\n\nWhen the inputs are valid, they will always be integers, no floats will be passed.  However, you must take into account that the numbers will be of varying magnitude, between and within test cases.", "solutions": ["def noonerize(numbers):\n\ttry:\n\t\tnum1 = int(str(numbers[1])[0] + str(numbers[0])[1:])\n\t\tnum2 = int(str(numbers[0])[0] + str(numbers[1])[1:])\n\texcept ValueError:\n\t\treturn 'invalid array'\n\treturn abs(num1 - num2)\n", "def noonerize(numbers):\n\tif not all((isinstance(n, int) for n in numbers)):\n\t\treturn 'invalid array'\n\t(a, b) = map(str, numbers)\n\treturn abs(int(a[0] + b[1:]) - int(b[0] + a[1:]))\n", "def noonerize(numbers):\n\t(a, b) = numbers\n\tif not type(a) == int == type(b):\n\t\treturn 'invalid array'\n\t(a, b) = map(str, numbers)\n\treturn abs(int(a[0] + b[1:]) - int(b[0] + a[1:]))\n", "def noonerize(numbers):\n\tif all((isinstance(x, int) for x in numbers)):\n\t\t(a, b) = (str(x) for x in numbers)\n\t\treturn abs(int(b[0] + a[1:]) - int(a[0] + b[1:]))\n\treturn 'invalid array'\n", "def noonerize(numbers):\n\t(nb1, nb2) = map(str, numbers)\n\ttry:\n\t\treturn abs(int(nb2[0] + nb1[1:]) - int(nb1[0] + nb2[1:]))\n\texcept ValueError:\n\t\treturn 'invalid array'\n", "def noonerize(n):\n\ttry:\n\t\treturn abs(int(str(n[1])[0] + str(n[0])[1:]) - int(str(n[0])[0] + str(n[1])[1:])) if n[0] != n[1] else 0\n\texcept:\n\t\treturn 'invalid array'\n", "def noonerize(numbers):\n\n\tdef spoonerize(numbers):\n\t\t(a, b) = [str(n) for n in numbers]\n\t\treturn '{}{} {}{}'.format(b[0], a[1:], a[0], b[1:])\n\tif all((isinstance(n, int) for n in numbers)):\n\t\t(a, b) = map(int, spoonerize(numbers).split())\n\t\treturn abs(a - b)\n\telse:\n\t\treturn 'invalid array'\n", "def noonerize(numbers):\n\toutput = '{}{}'.format\n\tif any((not isinstance(a, int) for a in numbers)):\n\t\treturn 'invalid array'\n\t(b, c) = (str(d) for d in numbers)\n\treturn abs(int(output(c[0], b[1:])) - int(output(b[0], c[1:])))\n"], "public_test_cases": [{"input": [[123, 456]], "output": [267], "type": "functional"}, {"input": [[12, 34]], "output": [18], "type": "functional"}, {"input": [[55, 63]], "output": [12], "type": "functional"}], "test_cases": [{"input": [[12, 34]], "output": [18], "type": "functional"}, {"input": [[55, 63]], "output": [12], "type": "functional"}, {"input": [[357, 579]], "output": [178], "type": "functional"}, {"input": [[1000000, 9999999]], "output": [7000001], "type": "functional"}, {"input": [[1000000, "hello"]], "output": ["invalid array"], "type": "functional"}, {"input": [["pippi", 9999999]], "output": ["invalid array"], "type": "functional"}, {"input": [["pippi", "hello"]], "output": ["invalid array"], "type": "functional"}, {"input": [[1, 1]], "output": [0], "type": "functional"}, {"input": [[1, 0]], "output": [1], "type": "functional"}, {"input": [[0, 1]], "output": [1], "type": "functional"}], "problem_id": "taco_train_6937", "metadata": {"func_name": "noonerize", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 10}, "generated_solutions": []}
{"problem": "Laura really hates people using acronyms in her office and wants to force her colleagues to remove all acronyms before emailing her. She wants you to build a system that will edit out all known acronyms or else will notify the sender if unknown acronyms are present.\n\nAny combination of three or more letters in upper case will be considered an acronym. Acronyms will not be combined with lowercase letters, such as in the case of 'KPIs'. They will be kept isolated as a word/words within a string.\n\nFor any string: \n\nAll instances of 'KPI' must become \"key performance indicators\" \nAll instances of 'EOD' must become \"the end of the day\" \nAll instances of 'TBD' must become \"to be decided\"\nAll instances of 'WAH' must become \"work at home\"\nAll instances of 'IAM' must become \"in a meeting\"\nAll instances of 'OOO' must become \"out of office\"\nAll instances of 'NRN' must become \"no reply necessary\"\nAll instances of 'CTA' must become \"call to action\"\nAll instances of 'SWOT' must become \"strengths, weaknesses, opportunities and threats\"\nIf there are any unknown acronyms in the string, Laura wants you to return only the message:\n'[acronym] is an acronym. I do not like acronyms. Please remove them from your email.'\nSo if the acronym in question was 'BRB', you would return the string:\n'BRB is an acronym. I do not like acronyms. Please remove them from your email.'\nIf there is more than one unknown acronym in the string, return only the first in your answer.\n\nIf all acronyms can be replaced with full words according to the above, however, return only the altered string.\n\nIf this is the case, ensure that sentences still start with capital letters. '!' or '?' will not be used.", "solutions": ["import re\nfrom functools import reduce\n_ACRONYMS = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'EOP': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\n_ACRONYM_PATTERN = re.compile('\\\\b[A-Z]{3,}\\\\b')\n_CAPITAL_PATTERN = re.compile('(?:\\\\. |^)([a-z])')\n_CAPITAL_FIX = lambda match: '{}'.format(match.group(0).upper())\n\ndef acronym_buster(message):\n\tmessage = reduce(lambda msg, item: msg.replace(*item), _ACRONYMS.items(), message)\n\ttry:\n\t\tacro = next(_ACRONYM_PATTERN.finditer(message)).group(0)\n\t\treturn '{} is an acronym. I do not like acronyms. Please remove them from your email.'.format(acro)\n\texcept StopIteration:\n\t\treturn _CAPITAL_PATTERN.sub(_CAPITAL_FIX, message)\n", "import re\nACRONYMS = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\nACRONYM_PATTERN = re.compile('\\\\b[A-Z]{3,}\\\\b')\n\ndef acronym_buster(message):\n\tnew = ACRONYM_PATTERN.sub(lambda m: ACRONYMS.get(m.group(), m.group()), message)\n\tmatched = ACRONYM_PATTERN.search(new)\n\tif matched:\n\t\treturn f'{matched.group()} is an acronym. I do not like acronyms. Please remove them from your email.'\n\treturn re.sub('[^.\\\\s][^.]*', lambda m: m.group()[0].upper() + m.group()[1:], new)\n", "import re\nD = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\nacronym = re.compile('(?:^|(?<=\\\\W))[A-Z]{3,}(?=\\\\W|$)')\ncapital = re.compile('(?:^|(?<=\\\\.\\\\s))[a-z]')\n\ndef acronym_buster(message):\n\ttry:\n\t\treturn capital.sub(lambda w: w.group().upper(), acronym.sub(lambda w: D[w.group()], message))\n\texcept Exception as e:\n\t\treturn f'{str(e)[1:-1]} is an acronym. I do not like acronyms. Please remove them from your email.'\n", "def acronym_buster(message):\n\tacronyms = {'CTA': 'call to action', 'EOD': 'the end of the day', 'IAM': 'in a meeting', 'KPI': 'key performance indicators', 'NRN': 'no reply necessary', 'OOO': 'out of office', 'SWOT': 'strengths, weaknesses, opportunities and threats', 'TBD': 'to be decided', 'WAH': 'work at home'}\n\tresult = []\n\tfor sentence in message.split('.'):\n\t\ttmp = []\n\t\tfor (i, word) in enumerate(sentence.split()):\n\t\t\tif word.isupper() and len(word) > 2:\n\t\t\t\ttry:\n\t\t\t\t\tword = acronyms[word]\n\t\t\t\texcept KeyError:\n\t\t\t\t\treturn '{} is an acronym. I do not like acronyms. Please remove them from your email.'.format(word)\n\t\t\ttmp.append(word[0].upper() + word[1:] if i == 0 else word)\n\t\tresult.append(' '.join(tmp))\n\treturn '. '.join(result).rstrip()\n", "import re\nknow_acronyms = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\n\ndef acronym_buster(message):\n\tunknow_acronyms = []\n\treplace_or_store = lambda a: a in know_acronyms and know_acronyms[a] or unknow_acronyms.append(a)\n\tcleaned = re.sub('\\\\b[A-Z]{3,}\\\\b', lambda m: replace_or_store(m.group()), message)\n\tif unknow_acronyms:\n\t\treturn '%s is an acronym. I do not like acronyms. Please remove them from your email.' % unknow_acronyms[0]\n\telse:\n\t\treturn re.sub('(^|[.!?]) *\\\\w', lambda m: m.group().upper(), cleaned)\n", "def acronym_buster(message):\n\tacronyms = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'EOP': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\n\tphrases = message.split('.')\n\tword_lists = []\n\tfor phrase in phrases:\n\t\tword_lists.append(phrase.split(' '))\n\tfor word_list in word_lists:\n\t\tfor word in word_list:\n\t\t\tif len(word) >= 3 and word.isupper():\n\t\t\t\tif word in acronyms.keys():\n\t\t\t\t\tword_list[word_list.index(word)] = acronyms[word]\n\t\t\t\telse:\n\t\t\t\t\treturn '{} is an acronym. I do not like acronyms. Please remove them from your email.'.format(word)\n\tphrases = []\n\tfor word_list in word_lists:\n\t\tphrase = ' '.join(word_list)\n\t\tif len(phrase) > 0 and phrase[0].isalpha() and phrase[0].islower():\n\t\t\tphrase = phrase[0].upper() + phrase[1:]\n\t\telif len(phrase) > 0 and phrase[0] == ' ' and phrase[1].islower():\n\t\t\tphrase = phrase[0] + phrase[1].upper() + phrase[2:]\n\t\tphrases.append(phrase)\n\tmessage = '.'.join(phrases)\n\treturn message\n", "import re\n\ndef acronym_buster(s):\n\t(d, temp) = ({'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}, [])\n\twhile re.search('\\\\b[A-Z]{3,}\\\\b', s):\n\t\tr = re.search('\\\\b[A-Z]{3,}\\\\b', s)\n\t\tarn = r.group()\n\t\t(start, end) = r.span()\n\t\tif arn in d:\n\t\t\ts = s[:start] + d[arn] + s[end:]\n\t\telse:\n\t\t\treturn f'{arn} is an acronym. I do not like acronyms. Please remove them from your email.'\n\treturn '. '.join([i[0].upper() + i[1:] for i in s.split('. ')])\n", "import re\nd = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\n\ndef acronym_buster(s):\n\ta = []\n\n\tdef f(x):\n\t\tx = x[0]\n\t\tif x.isupper() and len(x) > 2:\n\t\t\tif x not in d:\n\t\t\t\ta.append(x)\n\t\t\tx = d.get(x, '')\n\t\treturn x\n\ts = re.sub('^.|[!?.] .', lambda x: x[0].upper(), re.sub('\\\\w+', f, s))\n\treturn f'{a[0]} is an acronym. I do not like acronyms. Please remove them from your email.' if a else s\n", "import re\n\ndef acronym_buster(message):\n\tnew_msg = message\n\tsubs = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\n\tfor item in re.findall('(?:\\\\w)*[A-Z]{3,}(?:\\\\w)*', new_msg):\n\t\tif item in subs:\n\t\t\tnew_msg = new_msg.replace(item, subs[item])\n\t\telif item.isupper():\n\t\t\treturn '{} is an acronym. I do not like acronyms. Please remove them from your email.'.format(item)\n\tsentences = new_msg.split('. ')\n\treturn '. '.join((s[:1].upper() + s[1:] for s in sentences))\n"], "public_test_cases": [{"input": ["BRB I need to go into a KPI meeting before EOD"], "output": ["BRB is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["I am IAM so will be OOO until EOD"], "output": ["I am in a meeting so will be out of office until the end of the day"], "type": "functional"}], "test_cases": [{"input": ["BRB I need to go into a KPI meeting before EOD"], "output": ["BRB is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["I am IAM so will be OOO until EOD"], "output": ["I am in a meeting so will be out of office until the end of the day"], "type": "functional"}, {"input": ["Going to WAH today. NRN. OOO"], "output": ["Going to work at home today. No reply necessary. Out of office"], "type": "functional"}, {"input": ["We're looking at SMB on SM DMs today"], "output": ["SMB is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["OOO"], "output": ["Out of office"], "type": "functional"}, {"input": ["KPI"], "output": ["Key performance indicators"], "type": "functional"}, {"input": ["EOD"], "output": ["The end of the day"], "type": "functional"}, {"input": ["TBD"], "output": ["To be decided"], "type": "functional"}, {"input": ["TBD by EOD"], "output": ["To be decided by the end of the day"], "type": "functional"}, {"input": ["BRB I am OOO"], "output": ["BRB is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["WAH"], "output": ["Work at home"], "type": "functional"}, {"input": ["IAM"], "output": ["In a meeting"], "type": "functional"}, {"input": ["NRN"], "output": ["No reply necessary"], "type": "functional"}, {"input": ["CTA"], "output": ["Call to action"], "type": "functional"}, {"input": ["Hi PAB"], "output": ["PAB is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["HATDBEA"], "output": ["HATDBEA is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["LDS"], "output": ["LDS is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["PB"], "output": ["PB"], "type": "functional"}, {"input": ["FA"], "output": ["FA"], "type": "functional"}, {"input": ["CTA and HTTP"], "output": ["HTTP is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["SWOT."], "output": ["Strengths, weaknesses, opportunities and threats."], "type": "functional"}, {"input": ["HTTP"], "output": ["HTTP is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["Please WAH today. KPI on track"], "output": ["Please work at home today. Key performance indicators on track"], "type": "functional"}, {"input": ["The advert needs a CTA. NRN before EOD."], "output": ["The advert needs a call to action. No reply necessary before the end of the day."], "type": "functional"}, {"input": ["I sent you a RFP yesterday."], "output": ["RFP is an acronym. I do not like acronyms. Please remove them from your email."], "type": "functional"}, {"input": ["My SM account needs some work."], "output": ["My SM account needs some work."], "type": "functional"}], "problem_id": "taco_train_6983", "metadata": {"func_name": "acronym_buster", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 26}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nPig Latin is an English language game where the goal is to hide the meaning of a word from people not aware of the rules.\n\nSo, the goal of this kata is to wite a function that encodes a single word string to pig latin.\n\nThe rules themselves are rather easy:\n\n1) The word starts with a vowel(a,e,i,o,u) -> return the original string plus \"way\".\n\n2) The word starts with a consonant -> move consonants from the beginning of the word to the end of the word until the first vowel, then return it plus \"ay\".\n\n3) The result must be lowercase, regardless of the case of the input. If the input string has any non-alpha characters, the function must return None, null, Nothing (depending on the language).\n\n4) The function must also handle simple random strings and not just English words.\n\n5) The input string has no vowels -> return the original string plus \"ay\".\n\nFor example, the word \"spaghetti\" becomes \"aghettispay\" because the first two letters (\"sp\") are consonants, so they are moved to the end of the string and \"ay\" is appended.\n\nWrite your solution by modifying this code:\n\n```python\ndef pig_latin(s):\n\t\n```\n\nYour solution should implemented in the function \"pig_latin\". The inputs will be passed to it and it should return the correct solution.\n\n\nNow solve the problem and return the code.", "solutions": ["```python\nVOWELS = set('aeiou')\n\ndef pig_latin(st):\n\ts = st.lower()\n\tif s.isalpha():\n\t\tif set(s) & VOWELS:\n\t\t\tif s[0] in VOWELS:\n\t\t\t\ts += 'w'\n\t\t\twhile s[0] not in VOWELS:\n\t\t\t\ts = s[1:] + s[:1]\n\t\treturn s + 'ay'\n\n```"], "public_test_cases": [{"input": ["spaghetti"], "output": ["aghettispay"], "type": "functional"}, {"input": ["Hello"], "output": ["ellohay"], "type": "functional"}, {"input": ["CCCC"], "output": ["ccccay"], "type": "functional"}, {"input": ["apple"], "output": ["appleway"], "type": "functional"}, {"input": ["xray"], "output": ["ayxray"], "type": "functional"}], "test_cases": [{"input": ["Hello"], "output": ["ellohay"], "type": "functional"}, {"input": ["CCCC"], "output": ["ccccay"], "type": "functional"}, {"input": ["tes3t5"], "output": [null], "type": "functional"}, {"input": ["ay"], "output": ["ayway"], "type": "functional"}, {"input": [""], "output": [null], "type": "functional"}, {"input": ["YA"], "output": ["ayay"], "type": "functional"}, {"input": ["123"], "output": [null], "type": "functional"}, {"input": ["ya1"], "output": [null], "type": "functional"}, {"input": ["yaYAya"], "output": ["ayayayay"], "type": "functional"}, {"input": ["YayayA"], "output": ["ayayayay"], "type": "functional"}], "problem_id": "primeintellect_train_7378", "metadata": {"func_name": "pig_latin", "config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 5, "num_original_tests": 10}, "generated_solutions": []}
{"problem": "Peter can see a clock in the mirror from the place he sits in the office.\nWhen he saw the clock shows 12:22\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nHe knows that the time is 11:38\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nin the same manner:\n\n05:25 --> 06:35\n\n01:50 --> 10:10\n\n11:58 --> 12:02\n\n12:01 --> 11:59\n\nPlease complete the function `WhatIsTheTime(timeInMirror)`, where `timeInMirror` is the mirrored time (what Peter sees) as string.\n\nReturn the _real_ time as a string.\n\nConsider hours to be between 1 <= hour < 13.\n\nSo there is no 00:20, instead it is 12:20.\n\nThere is no 13:20, instead it is 01:20.", "solutions": ["def what_is_the_time(time_in_mirror):\n\t(h, m) = map(int, time_in_mirror.split(':'))\n\treturn '{:02}:{:02}'.format(-(h + (m != 0)) % 12 or 12, -m % 60)\n", "def what_is_the_time(time_in_mirror):\n\tarray = time_in_mirror.split(':')\n\ta = int(array[0])\n\tb = int(array[1])\n\tif a == 11:\n\t\ta = 12\n\telif a == 12:\n\t\ta = 11\n\telse:\n\t\ta = 11 - a\n\tif b == 0:\n\t\tb = 0\n\t\ta += 1\n\telse:\n\t\tb = 60 - b\n\treturn '{:02}:{:02}'.format(a, b)\n", "def what_is_the_time(time_in_mirror):\n\tCW_HRS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\tMIRROR = [0, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 12, 11]\n\tif time_in_mirror in ['12:00', '12:30', '06:00', '06:30']:\n\t\treturn time_in_mirror\n\t(hours, minutes) = time_in_mirror.split(':')\n\t(hours, minutes) = (int(hours), int(minutes))\n\thrs = abs(12 - hours) if minutes == 0 else MIRROR[hours]\n\tmins = 0 if minutes == 0 else 60 - minutes\n\treturn '{:02}:{:02}'.format(hrs, mins)\n", "def what_is_the_time(time_in_mirror):\n\tl = []\n\thour = []\n\tminute = []\n\tres = []\n\tfor i in time_in_mirror:\n\t\tl.append(i)\n\tl.pop(2)\n\thour.append(l[0])\n\thour.append(l[1])\n\tminute.append(l[2])\n\tminute.append(l[3])\n\thour = ''.join(hour)\n\tminute = ''.join(minute)\n\thour = int(hour)\n\tminute = int(minute)\n\tif hour < 11 and minute != 0:\n\t\thour = 11 - hour\n\telif hour < 11 and minute == 0:\n\t\thour = 12 - hour\n\telif hour == 11 and minute != 0:\n\t\thour = 12\n\telif hour == 11 and minute == 0:\n\t\thour = 1\n\telif hour == 12 and minute != 0:\n\t\thour = 11\n\telif hour == 12 and minute == 0:\n\t\thour = 12\n\tif minute == 0:\n\t\tminute = 0\n\telse:\n\t\tminute = 60 - minute\n\tif hour < 10:\n\t\tres.append(str(0))\n\t\tres.append(str(hour))\n\telse:\n\t\tres.append(str(hour))\n\tres.append(':')\n\tif minute < 10:\n\t\tres.append('0')\n\t\tres.append(str(minute))\n\telse:\n\t\tres.append(str(minute))\n\tres = ''.join(res)\n\treturn res\n", "def what_is_the_time(time_in_mirror):\n\t(hours, minutes) = list(map(int, time_in_mirror.split(':')))\n\tif minutes == 0:\n\t\tmirrored_hours = 12 - hours\n\t\tmirrored_minutes = 0\n\telse:\n\t\tmirrored_hours = (11 - hours) % 12\n\t\tmirrored_minutes = 60 - minutes\n\tif mirrored_hours == 0:\n\t\tmirrored_hours = 12\n\treturn '{:02d}:{:02d}'.format(mirrored_hours, mirrored_minutes)\n", "def what_is_the_time(time):\n\t(h, m) = (int(n) for n in time.split(':'))\n\treturn f'{-(h + (m > 0)) % 12 or 12:02d}:{-m % 60:02d}'\n", "def what_is_the_time(time_in_mirror: str) -> str:\n\t(h, m) = list(map(int, time_in_mirror.split(':')))\n\t(h, m) = divmod(720 - m - h % 12 * 60, 60)\n\treturn f'{h or 12:02d}:{m:02d}'\n", "def what_is_the_time(time):\n\t(a, b) = map(int, time.split(':'))\n\tif 1 <= a <= 10 and 1 <= b <= 59:\n\t\t(a, b) = (11 - a, 60 - b)\n\telif 11 <= a <= 12 and 1 <= b <= 59:\n\t\t(a, b) = (23 - a, 60 - b)\n\telse:\n\t\t(a, b) = (12 - a, b)\n\treturn '{0:>02}:{1:>02}'.format(a or 12, b)\n", "def what_is_the_time(time_in_mirror):\n\tif not time_in_mirror:\n\t\treturn\n\t(x, y) = map(int, time_in_mirror.split(':'))\n\t(q, r) = divmod(720 - 60 * x - y, 60)\n\treturn '{:02d}:{:02d}'.format(q % 12 or 12, r)\n", "def what_is_the_time(time_in_mirror):\n\t(hours, minutes) = map(int, time_in_mirror.split(':'))\n\t(m_hours, m_minutes) = divmod(720 - 60 * hours - minutes, 60)\n\treturn '{:02}:{:02}'.format(m_hours + 12 * (m_hours <= 0), m_minutes)\n"], "public_test_cases": [{"input": ["12:22"], "output": ["11:38"], "type": "functional"}, {"input": ["05:25"], "output": ["06:35"], "type": "functional"}, {"input": ["01:50"], "output": ["10:10"], "type": "functional"}, {"input": ["11:58"], "output": ["12:02"], "type": "functional"}, {"input": ["12:01"], "output": ["11:59"], "type": "functional"}], "test_cases": [{"input": ["06:35"], "output": ["05:25"], "type": "functional"}, {"input": ["11:59"], "output": ["12:01"], "type": "functional"}, {"input": ["12:02"], "output": ["11:58"], "type": "functional"}, {"input": ["04:00"], "output": ["08:00"], "type": "functional"}, {"input": ["06:00"], "output": ["06:00"], "type": "functional"}, {"input": ["12:00"], "output": ["12:00"], "type": "functional"}], "problem_id": "taco_train_289", "metadata": {"func_name": "what_is_the_time", "config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 5, "num_original_tests": 6}, "generated_solutions": []}
{"problem": "Oleg the bank client checks share prices every day. There are n share prices he is interested in. Today he observed that each second exactly one of these prices decreases by k rubles (note that each second exactly one price changes, but at different seconds different prices can change). Prices can become negative. Oleg found this process interesting, and he asked Igor the financial analyst, what is the minimum time needed for all n prices to become equal, or it is impossible at all? Igor is busy right now, so he asked you to help Oleg. Can you answer this question?\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 105, 1 \u2264 k \u2264 109) \u2014 the number of share prices, and the amount of rubles some price decreases each second.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 the initial prices.\n\nOutput\n\nPrint the only line containing the minimum number of seconds needed for prices to become equal, of \u00ab-1\u00bb if it is impossible.\n\nExamples\n\nInput\n\n3 3\n12 9 15\n\n\nOutput\n\n3\n\nInput\n\n2 2\n10 9\n\n\nOutput\n\n-1\n\nInput\n\n4 1\n1 1000000000 1000000000 1000000000\n\n\nOutput\n\n2999999997\n\nNote\n\nConsider the first example. \n\nSuppose the third price decreases in the first second and become equal 12 rubles, then the first price decreases and becomes equal 9 rubles, and in the third second the third price decreases again and becomes equal 9 rubles. In this case all prices become equal 9 rubles in 3 seconds.\n\nThere could be other possibilities, but this minimizes the time needed for all prices to become equal. Thus the answer is 3.\n\nIn the second example we can notice that parity of first and second price is different and never changes within described process. Thus prices never can become equal.\n\nIn the third example following scenario can take place: firstly, the second price drops, then the third price, and then fourth price. It happens 999999999 times, and, since in one second only one price can drop, the whole process takes 999999999 * 3 = 2999999997 seconds. We can note that this is the minimum possible time.", "solutions": ["(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nK = min(l)\nfor i in range(n):\n\tif (l[i] - K) % k != 0:\n\t\tprint(-1)\n\t\texit()\nSum = sum(l)\nK = K * n\nSum = Sum - K\nprint(Sum // k)\n", "(n, k) = map(int, input().split())\na = [int(i) for i in input().split()]\nm = min(a)\nif any(((i - m) % k for i in a)):\n\tprint(-1)\nelse:\n\tprint(sum(((i - m) // k for i in a)))\n", "(N, K) = map(int, input().split())\nA = list(map(int, input().split()))\nminv = int(10000000000.0)\nfor i in range(N):\n\tminv = min(minv, A[i])\nans = 0\nfor i in range(N):\n\tif (A[i] - minv) % K != 0:\n\t\texit(print(-1))\n\tans += (A[i] - minv) // K\nprint(ans)\n", "(n, k) = map(int, input().strip().split())\nl = list(map(int, input().split()))\nk1 = min(l)\ncount = 0\nfor x in l:\n\tp = x - k1\n\tif p % k != 0:\n\t\tprint('-1')\n\t\tbreak\n\tif p % k == 0:\n\t\tcount += p // k\nelse:\n\tprint(count)\n", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmin = min(arr)\nsum = 0\nfor a in arr:\n\tif (a - min) % k != 0:\n\t\tsum = 1\n\t\tk = 2\n\t\tbreak\n\tsum += a - min\nprint(-1) if sum % k != 0 and n > 1 else print(int(sum / k))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\ns = 0\nfor i in a:\n\tif (i - m) % k == 0:\n\t\ts += (i - m) // k\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(s)\n", "(n, k) = [int(el) for el in input().split()]\ncosts = [int(el) for el in input().split()]\nmin_const = min(costs)\nans = 0\nfor cost in costs:\n\tif (cost - min_const) % k == 0:\n\t\tans += (cost - min_const) // k\n\telse:\n\t\tans = -1\n\t\tbreak\nprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nif n == 1:\n\tprint(0)\nelse:\n\ts = 0\n\tx = min(a)\n\tfor i in range(0, n):\n\t\tif (a[i] - x) % k == 0:\n\t\t\ts = s + (a[i] - x) // k\n\t\telse:\n\t\t\tprint(-1)\n\t\t\tn = -40\n\t\t\tbreak\n\tif n != -40:\n\t\tprint(s)\n", "import sys\nimport math\nget_string = lambda : sys.stdin.readline().strip()\nget_int_list = lambda : list(map(int, sys.stdin.readline().strip().split()))\nget_int = lambda : int(sys.stdin.readline())\n(n, k) = get_int_list()\nlst = get_int_list()\nflag = True\ncount = 0\nm = min(lst)\nfor i in range(n):\n\td = lst[i] - m\n\tif d % k != 0:\n\t\tflag = False\n\t\tbreak\n\telse:\n\t\tcount += d // k\nif flag:\n\tprint(count)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\nA = list(map(int, input().split()))\nm = min(A)\nAns = 0\nfor i in A:\n\tif (i - m) % k != 0:\n\t\tAns = -1\n\t\tbreak\n\telse:\n\t\tAns += (i - m) // k\nprint(Ans)\n", "(n, k) = list(map(int, input().split()))\ncount = 0\na = [int(elem) for elem in input().split()]\no = a[0] % k\nfor i in range(len(a)):\n\tif a[i] % k != o:\n\t\tprint('-1')\n\t\texit(0)\nmin_ = 10000000000000\nfor i in range(len(a)):\n\tif a[i] < min_:\n\t\tmin_ = a[i]\nsum_ = 0\nfor i in range(len(a)):\n\tif a[i] != min_:\n\t\tsum_ += a[i]\n\t\tsum_ -= min_\nprint(sum_ // k)\n", "(N, K) = tuple(map(int, input().split()))\nnums = list(map(int, input().split()))\nm = min(nums)\nprint(-1 if [0 for x in nums] != [(x - m) % K for x in nums] else sum([(x - m) // K for x in nums]), end='')\n", "import sys\nread = lambda : sys.stdin.readline().rstrip()\nreadi = lambda : int(sys.stdin.readline())\nwriteln = lambda x: sys.stdout.write(str(x) + '\\n')\nwrite = lambda x: sys.stdout.write(x)\n(N, K) = map(int, read().split())\nps = list(map(int, read().split()))\nps.sort()\nmn = ps[0]\nanswer = 0\nfor i in range(1, N):\n\t(q, r) = divmod(ps[i] - mn, K)\n\tif r:\n\t\tanswer = -1\n\t\tbreak\n\telse:\n\t\tanswer += q\nwriteln(answer)\n", "str = input().split()\n(n, k) = (int(str[0]), int(str[1]))\na = input().split()\nfor i in range(n):\n\ta[i] = int(a[i])\nmymin = 1000000001\nfor elem in a:\n\tif elem < mymin:\n\t\tmymin = elem\nmysum = 0\nok = 1\nfor elem in a:\n\tif (mymin - elem) % k == 0:\n\t\tmysum += (elem - mymin) // k\n\telse:\n\t\tprint(-1)\n\t\tok = 0\n\t\tbreak\nif ok:\n\tprint(mysum)\n", "(n, k) = input().split()\nn = int(n)\nk = int(k)\nl = input().split(' ')\nj = []\nfor i in l:\n\tj.append(int(i))\nm = min(j)\nt = 0\nflag = 1\nfor i in l:\n\ti = int(i)\n\tx = (i - m) / k\n\tx1 = int(x)\n\tif x == x1:\n\t\tt += x\n\telse:\n\t\tprint(-1)\n\t\tflag = 0\n\t\tbreak\nif flag == 1:\n\tprint(int(t))\n", "(n, k) = [int(x) for x in input().split()]\np = [int(x) for x in input().split()]\nm = min(p)\nt = 0\nfor x in p:\n\tif (x - m) % k:\n\t\tprint(-1)\n\t\tbreak\n\telse:\n\t\tt += (x - m) // k\nelse:\n\tprint(t)\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\ntarget = min(l)\nans = 0\nfor i in range(n):\n\tif (target - l[i]) % k == 0:\n\t\tans += abs((target - l[i]) // k)\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(ans)\n", "import sys\nimport math\nimport bisect\nimport itertools\nimport random\nimport re\n\ndef solve(A, m):\n\tn = len(A)\n\tans = 0\n\tfor i in range(n):\n\t\tif A[i] % m:\n\t\t\treturn -1\n\t\tans += A[i] // m\n\treturn ans\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\tmin_val = min(A)\n\tfor i in range(n):\n\t\tA[i] -= min_val\n\tprint(solve(A, m))\nmain()\n", "(n, k) = map(int, input().split(' '))\na = list(map(int, input().split(' ')))\nb = a[0] % k\nbool1 = 0\nfor i in a:\n\tif i % k != b:\n\t\tbool1 = 1\nif bool1 == 1:\n\tprint(-1)\nelse:\n\tans = 0\n\tl = min(a)\n\tfor i in range(n):\n\t\tans += (a[i] - l) // k\n\tprint(ans)\n", "(n, m) = map(int, input().split())\na = sorted(list(map(int, input().split())))\n(z, x) = (0, 0)\nfor i in range(1, len(a)):\n\tif (a[i] - a[0]) % m != 0:\n\t\tz = 1\n\t\tbreak\n\telse:\n\t\tx += (a[i] - a[0]) // m\nif z == 0:\n\tprint(x)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nst = set(l)\ncnt = 0\nif len(st) == 1:\n\tprint(0)\n\texit()\nelse:\n\tx = min(l)\n\tfor i in l:\n\t\tc = i - x\n\t\tif c % k == 0:\n\t\t\tcnt += c // k\n\t\telse:\n\t\t\tprint(-1)\n\t\t\texit()\n\tprint(cnt)\n", "import sys\nfin = sys.stdin\nfout = sys.stdout\n(n, k) = map(int, fin.readline().split())\na = list(map(int, fin.readline().split()))\nif n == 1:\n\tfout.write('0')\n\tsys.exit()\ns1 = set()\nfor cur in a:\n\ts1.add(cur % k)\nif len(s1) > 1:\n\tfout.write('-1')\n\tsys.exit()\ndv = min(a)\nans = 0\nfor cur in a:\n\tans += (cur - dv) // k\nfout.write(str(ans))\n", "def convert(arr):\n\tarr = arr.split(' ')\n\tfor i in range(len(arr)):\n\t\tarr[i] = int(arr[i])\n\treturn arr\nnk = input()\ns = input()\ndecre = convert(nk)\nshares = convert(s)\nshares.sort()\ni = 1\nanswer = 0\nrunLoop = True\nwhile i in range(len(shares)) and runLoop:\n\tdifference = shares[i] - shares[0]\n\tif difference % decre[1] != 0:\n\t\tanswer = -1\n\t\trunLoop = False\n\telse:\n\t\tanswer += int(difference / decre[1])\n\ti += 1\nprint(answer)\n", "def answer(k, nums):\n\tr = nums[0] % k\n\tfor i in range(1, len(nums)):\n\t\tif nums[i] % k != r:\n\t\t\treturn -1\n\tm = min(nums)\n\tsec = 0\n\tfor n in nums:\n\t\tsec += (n - m) // k\n\treturn sec\n(n, k) = map(int, input().split())\nnums = list(map(int, input().split()))\nprint(answer(k, nums))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nif n == 1:\n\tprint(0)\nelse:\n\tmin = min(a)\n\timpossible = False\n\tfor i in range(n):\n\t\tif (a[i] - min) % k != 0:\n\t\t\timpossible = True\n\t\t\tbreak\n\tif impossible:\n\t\tprint(-1)\n\telse:\n\t\tj = 0\n\t\tfor i in range(n):\n\t\t\tj += (a[i] - min) // k\n\t\tprint(j)\n", "(N, K) = tuple(map(int, input().split()))\nnums = list(map(int, input().split()))\nm = min(nums)\ns = 0\ncorr = True\nfor a in nums:\n\tif (a - m) % K == 0:\n\t\ts += (a - m) // K\n\telse:\n\t\tcorr = False\nprint(s if corr else -1, end='')\n", "[n, k] = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = set()\nfor i in range(n):\n\ts.add(a[i] % k)\nif len(s) > 1:\n\tprint('-1')\n\texit(0)\namin = 1000000000.0 + 7\nfor i in range(n):\n\tamin = min(amin, a[i])\nres = 0\nfor i in range(n):\n\tres += (a[i] - amin) // k\nprint(res)\n", "(n, k) = map(int, input().split())\nM = list(map(int, input().split()))\nl = 0\nfor i in range(0, n):\n\tif abs(M[i] - M[i - 1]) % k != 0:\n\t\tl += 1\n\t\tbreak\np = (sum(M) - n * min(M)) // k\nprint(p if l == 0 else '-1')\n", "(n, k) = [int(x) for x in input().split(' ')]\nprecios = [int(x) for x in input().split(' ')]\nresp = 0\nrem = precios[0] % k\nminimo = min(precios)\nfor a in precios:\n\tif a % k != rem:\n\t\tresp = -1\n\t\tbreak\n\telse:\n\t\tresp += (a - minimo) // k\nprint(resp)\n", "(n, k) = tuple(map(int, input().split()))\ns = list(map(int, input().split()))\nmi = min(s)\ns = list(map(lambda x: x - mi, s))\nfor i in s:\n\tif i % k != 0:\n\t\tprint(-1)\n\t\texit()\nprint(sum(s) // k)\n", "def r():\n\td = int(input().split()[1])\n\tacts = sorted((int(s) for s in input().split()))\n\tres = 0\n\tm = acts[0]\n\tfor act in acts:\n\t\tdiff = act - m\n\t\tif diff % d != 0:\n\t\t\treturn -1\n\t\tres += diff // d\n\treturn res\nprint(r())\n", "a = list(map(int, input().split()))\nb = list(map(int, input().split()))\nb.sort()\nh = 1\nu = 0\nfor i in range(1, len(b)):\n\ty = b[i] - b[0]\n\tif y % a[1] != 0:\n\t\th = 0\n\t\tbreak\n\tu += y // a[1]\nif h == 0:\n\tprint('-1')\nelse:\n\tprint(u)\n", "(n, k) = [int(x) for x in input().split(' ')]\nA = [int(x) for x in input().split(' ')]\nx = min(A)\nimpo = 0\nt = 0\nfor a in A:\n\td = a - x\n\tif d % k != 0:\n\t\timpo = 1\n\telse:\n\t\tt += int(d / k)\nif impo:\n\tprint('-1')\nelse:\n\tprint(t)\n", "import math\n(n, k) = input().split()\nn = int(n)\nk = int(k)\na = []\nfor s in input().split():\n\ta.append(int(s))\nmin = math.inf\nfor i in a:\n\tif i < min:\n\t\tmin = i\nsum = 0\nimp = False\nfor i in a:\n\tif (i - min) % k == 0:\n\t\tsum += (i - min) // k\n\telse:\n\t\timp = True\n\t\tbreak\nif imp:\n\tprint(-1)\nelse:\n\tprint(sum)\n", "(n, m) = map(int, input().split())\nl1 = list(map(int, input().split()))\nl1.sort()\ncnt = 0\nflag = True\nfor i in range(1, len(l1)):\n\tdiff = l1[i] - l1[0]\n\tif diff % m == 0:\n\t\tcnt = cnt + diff // m\n\telse:\n\t\tprint(-1)\n\t\tflag = False\n\t\tbreak\nif flag:\n\tprint(cnt)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nminA = a[0]\nfor i in range(len(a)):\n\tif a[i] < minA:\n\t\tminA = a[i]\ncount = 0\nok = True\nfor i in range(len(a)):\n\ta[i] -= minA\n\tif a[i] % k != 0:\n\t\tok = False\n\t\tbreak\n\tcount += int(a[i] / k)\nif ok:\n\tprint(count)\nelse:\n\tprint(-1)\n", "import sys\n\ndef get_single_int():\n\treturn int(sys.stdin.readline().strip())\n\ndef get_string():\n\treturn sys.stdin.readline().strip()\n\ndef get_ints():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n(n, k) = get_ints()\nar = get_list()\ncheck = True\nmi = min(ar)\nif n == 1:\n\tprint(0)\n\tcheck = False\nfor j in range(n):\n\tif check:\n\t\tif (ar[j] - mi) % k == 0:\n\t\t\tpass\n\t\telse:\n\t\t\tprint(-1)\n\t\t\tcheck = False\n\t\t\tbreak\nif check:\n\ttime = 0\n\tfor j in range(n):\n\t\ttime += abs(mi - ar[j]) // k\n\tprint(time)\n", "(n, k) = list(map(int, input().split()))\ns = list(map(int, input().split()))\nans = 0\nr = min(s)\nfor i in s:\n\tif (i - r) % k:\n\t\tprint(-1)\n\t\tbreak\n\telse:\n\t\tans += (i - r) // k\nelse:\n\tprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\na = [x - m for x in a]\nnot_possible = False\nc = 0\nfor x in a:\n\tif x % k != 0:\n\t\tnot_possible = True\n\t\tbreak\n\telse:\n\t\tc += x // k\nif not_possible:\n\tprint(-1)\nelse:\n\tprint(c)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\nans = 0\nf = 0\nfor i in range(n):\n\tdif = a[i] - m\n\tif dif % k != 0:\n\t\tf = 1\n\t\tbreak\n\telse:\n\t\tans += dif\nif f == 0:\n\tprint(ans // k)\nelse:\n\tprint('-1')\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nz = min(a)\nq = []\nfor i in a:\n\tq.append(i - z)\nans = 0\nfor i in q:\n\tif i % k != 0:\n\t\tprint('-1')\n\t\texit(0)\n\telse:\n\t\tans += i // k\nprint(ans)\n", "(n, k) = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = 0\nd = 0\nm = min(a)\nfor x in range(len(a)):\n\tif abs(a[x] - m) % k != 0:\n\t\td = 1\n\t\tbreak\n\telse:\n\t\ts += (a[x] - m) // k\nif d == 1:\n\tprint(-1)\nelse:\n\tprint(s)\n", "(r, k) = map(int, input().split())\nS = [int(x) for x in input().split()]\nt = min(S)\nw = 0\nfor i in range(len(S)):\n\tif (S[i] - t) % k != 0:\n\t\tw = -1\n\t\tbreak\n\telse:\n\t\tw = (S[i] - t) // k + w\nprint(w)\n", "import sys, math\ninput = lambda : sys.stdin.readline().rstrip()\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nans = 0\nc = min(a)\nfor i in a:\n\tif (i - c) % k != 0:\n\t\tprint(-1)\n\t\texit(0)\n\telse:\n\t\tans += (i - c) // k\nprint(ans)\n", "import sys\n\ndef main():\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tm = min(a)\n\tans = 0\n\tfor elem in a:\n\t\tif (elem - m) % k != 0:\n\t\t\tprint('-1\\n')\n\t\t\tsys.exit(0)\n\t\telse:\n\t\t\tans += (elem - m) // k\n\tprint(ans)\nmain()\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nx = min(a)\nansw = 0\ny = 1\nfor i in a:\n\tif i > x:\n\t\tif (i - x) % k == 0:\n\t\t\tansw = answ + (i - x) // k\n\t\telse:\n\t\t\ty = 0\nif y:\n\tprint(answ)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nmn = min(a)\na_ = [el - mn for el in a]\nif any((el % k != 0 for el in a_)):\n\tprint(-1)\n\texit()\nprint(sum([el // k for el in a_]))\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nm = min(l)\nfor i in l:\n\tif (i - m) % k:\n\t\tprint(-1)\n\t\tbreak\nelse:\n\tprint((sum(l) - n * m) // k)\n", "(n, k) = map(int, input().split())\na = [int(i) for i in input().split()]\na.sort()\nans = 0\nfor i in range(1, n):\n\tif (a[i] - a[0]) % k:\n\t\tprint(-1)\n\t\tbreak\n\telse:\n\t\tans += (a[i] - a[0]) // k\nelse:\n\tprint(ans)\n", "import sys\nfrom functools import reduce\n\ndef main():\n\t(num_shares, decrement) = map(int, sys.stdin.readline().split())\n\tinitial_price = [None] * num_shares\n\tinitial_price = list(map(int, sys.stdin.readline().split()))\n\tmin_price = min(initial_price)\n\tcalc = list(map(lambda price: divmod(price - min_price, decrement), initial_price))\n\tresult = reduce(lambda acc, tup: (acc[0] + tup[0], tup[1] == 0 and acc[1]), calc, (0, True))\n\tif not result[1]:\n\t\tsys.stdout.write('-1')\n\telse:\n\t\tsys.stdout.write(str(result[0]))\nmain()\n", "(n, k) = map(int, input().split())\na = input().split()\nl = []\nmi = 10000000000\nzb = 0\np = True\nfor x in a:\n\tb = int(x)\n\tif b < mi:\n\t\tmi = b\n\tl.append(b)\nfor x in l:\n\tif (x - mi) % k != 0:\n\t\tp = False\n\t\tbreak\n\telse:\n\t\tzb += (x - mi) / k\nif p:\n\tprint(round(zb))\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split(' '))\np = list(map(int, input().split(' ')))\no = []\nfor x in p:\n\to.append(x % k)\nruzne = False\nx = o[0]\nfor num in o:\n\tif num != x:\n\t\truzne = True\nif ruzne:\n\tprint('-1')\nelse:\n\tkroky = 0\n\tmn = min(p)\n\tfor i in range(n):\n\t\tkroky += (p[i] - mn) / k\n\tprint(int(kroky))\n", "(n, m) = map(int, input().split())\ns = list(map(int, input().split()))\nl = min(s)\nk = 0\nf = True\nfor i in range(n):\n\tif (s[i] - l) % m == 0:\n\t\tk += (s[i] - l) // m\n\telse:\n\t\tf = False\n\t\tbreak\nif f == False:\n\tprint(-1)\nelse:\n\tprint(k)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nhead = min(a)\n\ndef run():\n\tans = 0\n\tfor i in range(n):\n\t\tif (a[i] - head) % k > 0:\n\t\t\tprint(-1)\n\t\t\treturn\n\t\telse:\n\t\t\tans += (a[i] - head) // k\n\tprint(ans)\nrun()\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nmn = min(a)\nfor i in a:\n\tif (i - mn) % k != 0:\n\t\texit(print('-1'))\nelse:\n\tprint(sum([(i - mn) // k for i in a]))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nmina = min(a)\nfor i in range(n):\n\ta[i] -= mina\nr = 0\nfor i in range(n):\n\tif a[i] % k != 0:\n\t\tprint('-1')\n\t\texit()\n\tr += a[i] // k\nprint(r)\n", "(s, d) = map(int, input().split())\nl = list(map(int, input().split()))\np = min(l)\nt = 0\nr = 0\nfor i in range(s):\n\ty = l[i] - p\n\tr += l[i]\n\tif y % d == 0:\n\t\tif l[i] < p:\n\t\t\tp = l[i]\n\telse:\n\t\tt += 1\nu = r - p * s\nif u % d == 0 and t == 0:\n\tprint(u // d)\nelif s == 1:\n\tprint(0)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\nif any(((p - m) % k != 0 for p in a)):\n\tprint(-1)\nelse:\n\tprint(sum(((p - m) // k for p in a)))\n", "rawa = str(input()).split()\nn = int(rawa[0])\nk = int(rawa[1])\nrawb = str(input()).split()\nnums = [int(x) for x in rawb]\nsmallest = nums[0]\nfor x in nums:\n\tif x < smallest:\n\t\tsmallest = x\nanswer = 0\nfor x in nums:\n\tif (x - smallest) % k != 0:\n\t\tanswer = -1\n\t\tbreak\n\telse:\n\t\tanswer += int((x - smallest) / k)\nprint(answer)\n", "import sys\nimport collections\nimport math\ninput = sys.stdin.readline\n\ndef print(val):\n\tsys.stdout.write(str(val) + '\\n')\n(n, k) = map(int, input().split())\nA = list(map(int, input().split()))\nmn = min(A)\nans = 0\nfor i in range(n):\n\tif (A[i] - mn) % k != 0:\n\t\tprint(-1)\n\t\tsys.exit(0)\n\tans += (A[i] - mn) // k\nprint(ans)\n", "(x, y) = map(int, input().split())\nlist1 = list(map(int, input().split()))\nk = min(list1)\nz = 0\nfor i in list1:\n\tif (i - k) % y == 0:\n\t\tz += (i - k) // y\n\telse:\n\t\tz = -1\n\t\tbreak\nprint(z)\n", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmod = arr[0] % k\nflag = 1\nfor elem in arr:\n\tif elem % k != mod:\n\t\tflag = -1\n\t\tbreak\nif flag == -1:\n\tprint(-1)\nelse:\n\tans = 0\n\tneed = min(arr)\n\tfor elem in arr:\n\t\tans += (elem - need) // k\n\tprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nans1 = min(a)\nans = 0\nfor i in range(n):\n\tif (a[i] - ans1) % k != 0:\n\t\tprint(-1)\n\t\texit()\n\telse:\n\t\tans += (a[i] - ans1) // k\nprint(ans)\n", "x = input().split(' ')\nN = int(x[0])\nK = int(x[1])\nmi = 10 ** 10\nres = 0\ny = [int(a) for a in input().split(' ')]\nfor i in range(len(y)):\n\tif y[i] < mi:\n\t\tmi = y[i]\n\t\ttemp = y[0]\n\t\ty[0] = y[i]\n\t\ty[i] = temp\nfor elem in y:\n\ttemp = (elem - mi) % K\n\tif temp == 0:\n\t\tres += (elem - mi) // K\n\telse:\n\t\tres = -1\n\t\tbreak\nprint(res)\n", "(n, k) = [int(i) for i in input().split()]\nl = [int(i) for i in input().split()]\nc = min(l)\nok = True\nans = 0\nfor i in range(n):\n\tl[i] += c\nc = min(l)\ni = 0\nwhile i < n and ok:\n\tif (l[i] - c) % k == 0:\n\t\tans += (l[i] - c) // k\n\telse:\n\t\tok = False\n\ti += 1\nprint(ans if ok else '-1')\n", "try:\n\t(n, k) = map(int, input().split())\n\tl = list(map(int, input().split()))\n\tx = min(l)\n\tc = 0\n\tflag = False\n\tfor i in l:\n\t\tdif = i - x\n\t\tif dif % k == 0:\n\t\t\tc += dif // k\n\t\t\tflag = True\n\t\telse:\n\t\t\tprint('-1')\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag == True:\n\t\tprint(c)\nexcept EOFError:\n\tpass\n", "(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\n(m, s, f) = (l[0], 0, 0)\nfor x in range(1, a):\n\td = l[x] - m\n\tif d % b == 0:\n\t\ts += d // b\n\telse:\n\t\tf = 1\n\t\tbreak\nif f == 0:\n\tprint(s)\nelse:\n\tprint(-1)\n", "(n, k) = [int(x) for x in input().split(' ')]\nakcii = [int(x) for x in input().split(' ')]\nresp = 0\nrem = akcii[0] % k\nminimo = min(akcii)\nfor i in akcii:\n\tif i % k != rem:\n\t\tresp = -1\n\t\tbreak\n\telse:\n\t\tresp += (i - minimo) // k\nprint(resp)\n", "from sys import maxsize, stdout, stdin, stderr\nimport re\ntup = lambda : map(int, stdin.readline().split())\nI = lambda : int(stdin.readline())\nlint = lambda : [int(x) for x in stdin.readline().split()]\nS = lambda : stdin.readline().replace('\\n', '').strip()\n\ndef grid(r, c):\n\treturn [lint() for i in range(r)]\n\ndef debug(*args, c=6):\n\tprint('\\x1b[3{}m'.format(c), *args, '\\x1b[0m', file=stderr)\nstpr = lambda x: stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nfrom collections import defaultdict\nfrom math import gcd\n(n, k) = tup()\nls = lint()\nm = min(ls)\ncnt = 0\nfor i in range(n):\n\tif ls[i] == m:\n\t\tcontinue\n\telse:\n\t\tp = (ls[i] - m) // k\n\t\tif (ls[i] - m) % k == 0 and p >= 0:\n\t\t\tcnt += p\n\t\telse:\n\t\t\tprint(-1)\n\t\t\texit()\nprint(cnt)\n", "def akcii_oleg(lst, k):\n\t(m, c) = (1 << 30, 0)\n\tfor i in range(len(lst)):\n\t\tm = min(m, lst[i])\n\tfor i in range(len(lst)):\n\t\tif abs(m - lst[i]) % k != 0:\n\t\t\treturn -1\n\t\telse:\n\t\t\tc += (lst[i] - m) // k\n\treturn c\n(N, K) = [int(j) for j in input().split()]\na = [int(x) for x in input().split()]\nprint(akcii_oleg(a, K))\n", "def is_possible(a, k):\n\tb = a[0] % k\n\treturn all((i % k == b for i in a))\nx = input().split()\n(n, k) = (int(x[0]), int(x[1]))\na = input().split()\nb = []\nfor i in a:\n\tb.append(int(i))\nif is_possible(b, k) == False:\n\tprint(-1)\nelse:\n\tlowest = min(b)\n\tans = 0\n\tfor i in b:\n\t\tans += (i - lowest) // k\n\tprint(ans)\n", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmn = min(arr)\ncnt = 0\nfor v in arr:\n\tif (v - mn) % k != 0:\n\t\tprint(-1)\n\t\texit(0)\n\tcnt += (v - mn) // k\nprint(cnt)\n", "(n, k) = map(int, input().split())\nprices = list(map(int, input().split()))\nsmallest = 1000000000\nfor x in prices:\n\tif x < smallest:\n\t\tsmallest = x\nans = 0\nfor y in prices:\n\tif (y - smallest) % k != 0:\n\t\tans = -1\n\t\tbreak\n\telse:\n\t\tans = ans + (y - smallest) // k\nprint(ans)\n", "import math\nnk = input().split()\nn = int(nk[0])\nk = int(nk[1])\nL = list(map(int, input().split()))\nz = min(L)\ns = 0\ncount = 0\nfor i in range(0, len(L)):\n\tif L[i] != z:\n\t\ts += L[i]\n\t\tcount += 1\nx = s - z * count\nr = L[0] % k\nif x % k != 0 or any((e % k != r for e in L)):\n\tprint(-1)\nelse:\n\tprint(x // k)\n", "__author__ = 'Alexander'\n\ndef Task(inp1, inp2):\n\t(n, k) = map(int, inp1.split())\n\telems = [int(elem) for elem in inp2.split()]\n\tminim = min(elems)\n\telems = [x - minim for x in elems]\n\tresid = [x / k for x in elems if x % k == 0]\n\tif len(resid) == len(elems):\n\t\treturn [sum(resid)]\n\telse:\n\t\treturn [-1]\n\ndef Main():\n\tinp1 = input()\n\tinp2 = input()\n\toutp = Task(inp1, inp2)\n\tprint('{}'.format(int(outp[0])))\n\ndef Test():\n\tassert Task('3 3', '12 9 15') == [3]\n\tassert Task('2 2', '10 9') == [-1]\n\tassert Task('4 1', '1 1000000000 1000000000 1000000000') == [2999999997]\nMain()\n", "(n, d) = map(int, input().split())\nl = list(map(int, input().split()))\nc = 0\nf = 0\nl.sort()\nfor i in range(1, n):\n\tz = l[i] - l[0]\n\tif z % d == 0:\n\t\tc = c + z // d\n\telse:\n\t\tf = 1\n\t\tbreak\nif f == 1:\n\tprint(-1)\nelse:\n\tprint(c)\n", "z = input\nmod = 10 ** 9 + 7\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\n\ndef lcd(xnum1, xnum2):\n\treturn xnum1 * xnum2 // gcd(xnum1, xnum2)\n(a, b) = map(int, z().split())\nl = sorted(list(map(int, z().split())))\np = l[0]\nt = 0\ns = 0\nfor i in l:\n\tt = i - p\n\ts += t\n\tif t % b != 0:\n\t\tprint(-1)\n\t\texit(0)\nelse:\n\tprint(s // b)\n", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nvr = -1\nl1 = min(l) // m\nfor x in l:\n\tif vr == -1:\n\t\tvr = x % m\n\telif vr != x % m:\n\t\tprint(-1)\n\t\texit()\nk = 0\nfor x in l:\n\tk += x // m - l1\nprint(k)\n", "L = input()\nL = L.split()\nn = int(L[0])\nk = int(L[1])\nP = input()\nP = P.split()\nfor j in range(len(P)):\n\tP[j] = int(P[j])\nMin = min(P)\nA = [0] * n\nAux = 1\nfor i in range(n):\n\tif (int(P[i]) - Min) % k == 0:\n\t\tA[i] = (int(P[i]) - Min) // k\n\telse:\n\t\tAux = 0\n\t\tbreak\nS = 0\nif Aux == 1:\n\tfor k in range(n):\n\t\tS += A[k]\n\tprint(S)\nelse:\n\tprint('-1')\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\n(s, f) = (0, 0)\nfor i in range(n):\n\tif a[i] == m:\n\t\tpass\n\telif (a[i] - m) % k == 0:\n\t\ts += (a[i] - m) // k\n\telse:\n\t\tf = 1\n\t\tbreak\nif f == 1:\n\tprint(-1)\nelse:\n\tprint(s)\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nminimum = min(l)\nans = 0\nfor i in l:\n\tif (i - minimum) % k != 0:\n\t\tans = -1\n\t\tbreak\n\telse:\n\t\tans = ans + (i - minimum) // k\nprint(ans)\n", "(a, n) = list(map(int, input().split()))\nt = list(map(int, input().split()))\nh = min(t)\n(v, p) = (0, 0)\nfor k in range(a):\n\tif (t[k] - h) % n != 0:\n\t\tprint(-1)\n\t\tv += 1\n\t\tbreak\n\telse:\n\t\tp += (t[k] - h) // n\nif v == 0:\n\tprint(p)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nif len({ai % k for ai in a}) > 1:\n\tprint(-1)\nelse:\n\tm = min(a)\n\tprint(sum(((ai - m) // k for ai in a)))\n", "(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nt = min(l)\nm = 0\nn = 0\nt1 = 0\nfor i in range(a):\n\tk = l[i] - t\n\tif k % b == 0:\n\t\tm = k // b\n\t\tt1 = t1 + m\n\t\tcontinue\n\telse:\n\t\tn = 1\n\t\tprint(-1)\n\t\tbreak\nif n == 0:\n\tprint(t1)\n", "(n, k) = map(int, input().split())\nprices = list(map(int, input().split()))\nost = prices[0] % k\nfor price in prices:\n\tif ost != price % k:\n\t\tprint(-1)\n\t\texit(0)\nprint((sum(prices) - n * min(prices)) // k)\n", "(n, k) = input().split()\nn = int(n)\nk = int(k)\na = list(map(int, input().split()))\na.sort()\nl = []\ni = 0\nwhile i < n:\n\tif (a[0] - a[i]) % k != 0:\n\t\tbreak\n\tl.append(-a[0] + a[i])\n\ti += 1\nif i == n:\n\tprint(sum(l) // k)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\np = min(l)\nsh = 0\nfor i in range(n):\n\tif (l[i] - p) % k != 0:\n\t\tsh = -1\n\t\tbreak\n\tsh += (l[i] - p) // k\nprint(sh)\n", "def f(l, m, n):\n\tc = 0\n\tk = min(l)\n\tfor i in l:\n\t\td = i - k\n\t\tif d % m != 0:\n\t\t\treturn -1\n\t\tc += d // m\n\treturn c\n(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nprint(f(l, m, n))\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\n(z, c) = (min(l), 0)\nfor i in range(n):\n\tif (l[i] - z) % k == 0:\n\t\tc += (l[i] - z) // k\n\telse:\n\t\tprint('-1')\n\t\texit()\nprint(c)\n", "(n, k) = map(int, input().split())\na = sorted(map(int, input().split()))\na = [i - a[0] for i in a]\nprint((sum(a) // k, -1)[any((i % k for i in a))])\n", "(n, k) = map(int, input().split())\nnum = list(map(int, input().split()))\nflag = 1\nm = min(num)\nfor i in range(n):\n\tif (num[i] - m) % k != 0:\n\t\tflag = 0\n\t\tbreak\nans = sum(num) - n * m\nif flag == 0 and ans != 0:\n\tprint('-1')\nelse:\n\tprint(int(ans / k))\n", "import sys\n\ndef main():\n\t(n, k) = list(map(int, sys.stdin.readline().split()))\n\ta = list(map(int, sys.stdin.readline().split()))\n\tamin = min(a)\n\tresult = 0\n\tfor i in range(n):\n\t\tdelta = a[i] - amin\n\t\tif delta % k != 0:\n\t\t\tresult = -1\n\t\t\tbreak\n\t\tresult += delta // k\n\tsys.stdout.write(str(result) + '\\n')\nmain()\n", "s = list(map(int, input().split(' ')))\nn = s[0]\nk = s[1]\np = 0\nm = 10 ** 9 + 1\na = list(map(int, input().split(' ')))\nt = -1\nfor i in a:\n\tif t != -1 and t != i % k:\n\t\tp = -1\n\t\tbreak\n\tt = i % k\n\tm = min(m, i // k)\n\tp += i // k\nif p != -1:\n\tp -= m * n\nprint(p)\n", "def main():\n\t(n, k) = map(int, input().split())\n\taa = list(map(int, input().split()))\n\t(b, t) = (min(aa), 0)\n\tfor a in aa:\n\t\ta -= b\n\t\tif a % k:\n\t\t\tprint(-1)\n\t\t\tbreak\n\t\telse:\n\t\t\tt += a\n\telse:\n\t\tprint(t // k)\nmain()\n", "x = input().split(' ')\na = int(x[0])\nb = int(x[1])\nc = [int(i) for i in input().split(' ')]\nd = min(c)\n(s, ss) = (0, 0)\nfor i in c:\n\tif (i - d) % b != 0:\n\t\tprint('-1')\n\t\tss = 1\n\t\tbreak\n\tif i > d and (i - d) // b != 0:\n\t\ts += (i - d) // b\n\telif i - b < d and i != d:\n\t\tprint('-1')\n\t\tss = 1\n\t\tbreak\nif ss == 0:\n\tprint(s)\n", "from math import floor\n(a, b) = map(int, input().split())\nx = list(map(int, input().split()))\nmini = min(x)\nar = list(map(lambda a: (a - mini) / b, x))\nif len(list(filter(lambda a: floor(a) != a, ar))) > 0:\n\tprint(-1)\nelse:\n\tprint(int(sum(ar)))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nx = min(a)\nflag = 0\nfor i in range(len(a)):\n\tif (a[i] - x) % k != 0:\n\t\tflag = 1\n\t\tbreak\nif flag == 0:\n\tfor i in range(len(a)):\n\t\ta[i] = (a[i] - x) / k\n\tprint(int(sum(a)))\nelif flag == 1:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\na = [int(elem) for elem in input().split()]\nmi = min(a)\ncou = 0\nb = []\nst = 0\nfor i in a:\n\tif st != 0:\n\t\tcontinue\n\tif i != mi:\n\t\tif (i - mi) % k == 0:\n\t\t\tcou += (i - mi) // k\n\t\telse:\n\t\t\tst = 1\n\t\t\tcou = -1\nprint(cou)\n", "(n, k) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nmn = min(a)\nprint(-1 if any([(i - mn) % k for i in a]) else sum([(i - mn) // k for i in a]))\n", "R = lambda : list(map(int, input().split()))\n(n, m) = R()\nl = sorted(R())\nk = list(filter(lambda x: (x - l[0]) % m == 0, l))\nprint(-1) if len(k) != n else print(sum(list(map(lambda x: (x - l[0]) // m, l))))\n", "def main():\n\t[n, k] = [int(_) for _ in input().split()]\n\tprices = [int(_) for _ in input().split()]\n\tprices.sort()\n\ttry:\n\t\tnext((i for i in range(1, n) if (prices[i] - prices[0]) % k != 0))\n\t\tprint(-1)\n\texcept StopIteration:\n\t\tresult = sum(((prices[i] - prices[0]) // k for i in range(1, n)))\n\t\tprint(result)\nmain()\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\nd = min(a)\nr = 0\nfor i in a:\n\tif (i - d) % k == 0:\n\t\tr += (i - d) // k\n\telse:\n\t\tr = -1\n\t\tbreak\nprint(r)\n", "(n, k) = map(int, input().split())\na = [int(i) for i in input().split()]\nb = a[0] % k\nf = 0\np = a[0]\ns = 0\nfor i in range(n):\n\tif a[i] % k != b:\n\t\ts = -1\n\t\tbreak\n\tif a[i] < p:\n\t\ts += (p - a[i]) // k * i\n\t\tp = a[i]\n\tif a[i] > p:\n\t\ts += (a[i] - p) // k\nprint(s)\n", "from sys import stdin\nmax_val = int(10000000000000.0)\nmin_val = int(-10000000000000.0)\n\ndef read_int():\n\treturn int(stdin.readline())\n\ndef read_ints():\n\treturn [int(x) for x in stdin.readline().split()]\n\ndef read_str():\n\treturn input()\n\ndef read_strs():\n\treturn [x for x in stdin.readline().split()]\n(nb_shares, drops) = read_ints()\nprices = read_ints()\nmins = min(prices)\nans = 0\nfor i in prices:\n\tif (i - mins) % drops == 0:\n\t\tans += (i - mins) // drops\n\telse:\n\t\tans = -1\n\t\tbreak\nprint(ans)\n", "(N, S) = map(int, input().split())\nShares = list(map(int, input().split()))\nShares.sort()\nans = 0\nv = True\nfor i in range(N - 1, -1, -1):\n\tif (Shares[i] - Shares[0]) % S != 0:\n\t\tv = False\n\t\tbreak\n\telse:\n\t\tans += (Shares[i] - Shares[0]) // S\nif not v:\n\tprint(-1)\nelse:\n\tprint(ans)\n", "import sys\n(n, k) = [int(i) for i in sys.stdin.readline().strip().split()]\nA = [int(i) for i in sys.stdin.readline().strip().split()]\nr = A[0] % k\nR = [A[i] % k for i in range(n)]\nm = min(A)\nfor i in R:\n\tif i != r:\n\t\tprint('-1')\n\t\tbreak\nelse:\n\ts = 0\n\tfor i in A:\n\t\ts = s + (i - m) / k\n\tprint(int(s))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nif len(set([i % k for i in a])) != 1:\n\tprint(-1)\n\texit()\nans = 0\nfor i in range(1, n):\n\tans += (a[i] - a[0]) // k\nprint(ans)\n", "from os import path\nimport sys\nfrom heapq import heappush, heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\n\ndef ii():\n\treturn int(input())\n\ndef si():\n\treturn input()\n\ndef mi():\n\treturn map(int, input().split())\n\ndef li():\n\treturn list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 998244353\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\n\ndef bo(i):\n\treturn ord(i) - ord('a')\nfile = 1\n\ndef solve():\n\t(n, k) = mi()\n\ta = li()\n\tans = 0\n\tx = min(a)\n\tfor i in a:\n\t\tc = i - x\n\t\tif c % k:\n\t\t\tprint('-1')\n\t\t\texit(0)\n\t\tans += c // k\n\tprint(ans)\nif file:\n\tif path.exists('input1.txt'):\n\t\tsys.stdin = open('input1.txt', 'r')\n\t\tsys.stdout = open('output1.txt', 'w')\n\telse:\n\t\tinput = sys.stdin.readline\nsolve()\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nminn = 10 ** 9 + 1\nfor i in a:\n\tminn = min(minn, i)\nrs = 0\nfor i in a:\n\tif (i - minn) % k != 0:\n\t\tprint(-1)\n\t\texit()\n\trs += int((i - minn) / k)\nprint(rs)\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\na = min(l)\n(j, b) = (0, 0)\nflag = 0\nfor i in range(n - 1):\n\tif abs(l[i + 1] - l[i]) % k != 0:\n\t\tflag = 1\nfor i in range(n):\n\tj = l[i] - a\n\tb += j // k\nif flag == 1:\n\tprint('-1')\nelse:\n\tprint(b)\n", "l1 = [int(x) for x in input().split()]\n(n, k) = (l1[0], l1[1])\nl2 = [int(x) for x in input().split()]\nt = min(l2)\nruined = 0\nans = 0\nfor x in l2:\n\tif (x - t) % k:\n\t\truined = 1\n\t\tbreak\n\telse:\n\t\tans += (x - t) // k\nif not ruined:\n\tprint(ans)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nans = 0\nfor i in range(1, n):\n\tr = A[i] - A[0]\n\tif r % k == 0:\n\t\tans += r // k\n\telse:\n\t\tans = -1\n\t\tbreak\nprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\nc = 0\nfor i in a:\n\tif (i - m) % k != 0:\n\t\tprint(-1)\n\t\tbreak\n\tc += (i - m) // k\nelse:\n\tprint(c)\n", "(n, k) = list(map(int, input().split()))\nal = list(map(int, input().split()))\nrl = [a % k for a in al]\nif max(rl) > min(rl):\n\tprint(-1)\nelse:\n\tma = min(al)\n\tjl = [(a - ma) // k for a in al]\n\tprint(sum(jl))\n", "(n, k) = map(int, input().split())\na = sorted(list(map(int, input().split())))\nans = 0\ncheck = True\nfor i in range(n):\n\tif (a[i] - a[0]) % k != 0:\n\t\tcheck = False\n\telse:\n\t\tans += int((a[i] - a[0]) / k)\nif check:\n\tprint(ans)\nelse:\n\tprint(-1)\n", "(n, m) = map(int, input().split())\na = list(map(int, input().split()))\nmi = min(a)\nans = 0\nfor i in a:\n\tans += (i - mi) // m\n\tif (i - mi) % m:\n\t\tprint(-1)\n\t\tbreak\nelse:\n\tprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nx = min(a)\nm = 0\nc = False\nfor i in range(n):\n\tm = m + (a[i] - x) // k\n\tif (a[i] - x) % k != 0:\n\t\tc = True\nif c == True:\n\tprint('-1')\nelse:\n\tprint(m)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\natest = [(i - a[0]) % k for i in a]\nif any(atest):\n\tprint(-1)\nelse:\n\tamin = min(a)\n\tprint(sum([(i - amin) // k for i in a]))\n", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmn = min(arr)\nans = 0\nfor n in arr:\n\tif (n - mn) % k != 0:\n\t\tprint(-1)\n\t\texit()\n\telse:\n\t\tans += (n - mn) // k\nprint(ans)\n", "import math\n(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nmininl = min(l)\nmin = 0\nfor i in range(n):\n\tcurr = l[i] - mininl\n\tif curr % k != 0:\n\t\tprint('-1')\n\t\tbreak\n\telse:\n\t\tmin += curr // k\nelse:\n\tprint(min)\n", "(n, k) = map(int, input().split())\na = []\na = list(map(int, input().split()))\nmini = min(a)\ncan = True\nans = 0\nfor i in range(n):\n\tif (a[i] - mini) % k != 0:\n\t\tcan = False\n\t\tbreak\n\telse:\n\t\tans += (a[i] - mini) // k\nif can:\n\tprint(ans)\nelse:\n\tprint('-1')\n", "import math\n(n, k) = map(int, input().split())\ndaf = list(map(int, input().split()))\nif k == 1:\n\ttot = sum(daf) - min(daf) * n\n\tprint(tot)\nelse:\n\ttot = 0\n\tmin_daf = min(daf)\n\tfor x in daf:\n\t\tcek = x - min_daf\n\t\tif cek % k != 0:\n\t\t\tprint(-1)\n\t\t\tbreak\n\t\telse:\n\t\t\ttot += cek // k\n\telse:\n\t\tprint(tot)\n", "import sys\n(n, k) = map(int, input().split())\nls = list(map(int, input().split()))\ntotal = 0\nmin_pr = min(ls)\nfor x in range(len(ls)):\n\tls[x] -= min_pr\n\tif ls[x] % k != 0:\n\t\tprint('-1')\n\t\tsys.exit()\n\telse:\n\t\tls[x] /= k\nprint('{:.0f}'.format(sum(ls)))\n", "import sys\nimport math\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nmn = min(a)\nans = 0\nfor i in range(n):\n\tif (a[i] - mn) % k != 0:\n\t\tprint(-1)\n\t\tsys.exit()\n\tans += (a[i] - mn) // k\nprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\n(ans, m) = (0, min(a))\nfor x in a:\n\tif (x - m) % k != 0:\n\t\tprint(-1)\n\t\texit(0)\n\tans += (x - m) // k\nprint(ans)\n", "(n, k) = map(int, input().split())\ndata = list(map(int, input().split()))\nm = min(data)\nif any(map(lambda x: (x - m) % k, data)):\n\tprint(-1)\nelse:\n\tprint(sum(map(lambda x: (x - m) // k, data)))\n", "s = input().split(' ')\nl = input().split(' ')\nn = int(s[0])\nk = int(s[1])\nflag = False\ncounter = 0\nfor t in range(n):\n\tl[t] = int(l[t])\nj = l.index(min(l))\nfor v in l:\n\tif (v - l[j]) % k != 0:\n\t\tflag = True\nif flag == True:\n\tprint(-1)\nelse:\n\tfor g in l:\n\t\tcounter = counter + (g - l[j]) / k\n\tprint(int(counter))\n", "(n, k) = map(int, input().split())\na = tuple(map(int, input().split()))\nm = min(a)\na = [(x - m) // k for x in a if (x - m) % k == 0]\nprint(-1 if len(a) != n else sum(a))\n", "from sys import stdin\nimport math\n(n, k) = map(int, stdin.readline().split(' '))\narr = list(map(int, stdin.readline().split(' ')))\narr = [-1 * i for i in arr]\nmx = max(arr)\nsum = 0\nfor i in arr:\n\tif (mx - i) % k != 0:\n\t\tprint(-1)\n\t\texit(0)\n\tsum += (mx - i) // k\nprint(sum)\n", "(n, k) = input().strip().split(' ')\n(n, k) = (int(n), int(k))\nl = list(map(int, input().strip().split(' ')))\nm = 10 ** 10\nfor i in range(n):\n\tif m > l[i]:\n\t\tm = l[i]\nans = 0\nfor i in range(n):\n\tif (l[i] - m) % k == 0:\n\t\tans += (l[i] - m) // k\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(ans)\n", "(n, k) = map(int, input().split())\nmn = 1000 * 1000 * 1000 + 2\nspl = input().split()\na = [0] * n\nfor i in range(n):\n\ta[i] = int(spl[i])\nfor i in range(n):\n\tmn = min(mn, a[i])\nans = 0\nbad = 0\nfor i in range(n):\n\tc = a[i] - mn\n\tif c % k != 0:\n\t\tbad = 1\n\tans += c // k\nif bad:\n\tprint(-1)\nelse:\n\tprint(ans)\n", "I = lambda : map(int, input().split())\n(n, k) = I()\nA = list(I())\nif any(((A[i + 1] - A[i]) % k for i in range(n - 1))):\n\tprint(-1)\nelse:\n\tx = min(A)\n\tprint(sum((a - x for a in A)) // k)\n", "from sys import stdin, stdout\n(n, k) = map(int, stdin.readline().split())\nvalues = list(map(int, stdin.readline().split()))\nvalue = min(values)\ncnt = 0\nfor i in range(n):\n\tif (values[i] - value) % k:\n\t\tstdout.write('-1')\n\t\tbreak\n\telse:\n\t\tcnt += (values[i] - value) // k\nelse:\n\tstdout.write(str(cnt))\n", "import sys\ninput = sys.stdin.readline\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\nneed = 0\ngood = 1\nfor i in range(len(a)):\n\ta[i] -= m\n\tif a[i] % k:\n\t\tgood = 0\n\tneed += a[i] // k\nif good:\n\tprint(need)\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\ncur = l[0]\ncnt = 0\nfor i in range(1, n):\n\tif cur % k != l[i] % k:\n\t\tprint(-1)\n\t\texit()\n\tif cur < l[i]:\n\t\tcnt += abs(l[i] - cur) // k\n\telse:\n\t\tcnt += abs(l[i] - cur) // k * i\n\t\tcur = l[i]\nprint(cnt)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nflag = 0\nx = min(a)\ns = 0\nfor i in a:\n\tp = i - x\n\tif p % k == 0:\n\t\ts += i - x\n\telse:\n\t\tflag = 1\n\t\tbreak\nif flag == 0:\n\tprint(s // k)\nelse:\n\tprint(-1)\n", "import sys\n(a, k) = [int(i) for i in input().split()]\nin2 = [int(i) for i in input().split()]\nm = min(in2)\nin2.remove(m)\nres = 0\nfor r in in2:\n\tif (r - m) % k == 0:\n\t\tres += (r - m) // k\n\telse:\n\t\tprint(-1)\n\t\tsys.exit(0)\nprint(res)\nsys.exit(0)\n", "(n, k) = list(map(int, input().split(' ')))\nx = list(map(int, input().split(' ')))\na = [i % k for i in x]\nif len(set(a)) != 1:\n\tprint(-1)\n\texit()\nMin = min(x)\nprint(sum(((i - Min) // k for i in x)))\n", "(n, k) = map(int, input().split())\nv = list(map(int, input().split()))\nminimum = min(v)\nsol = 0\nfor x in v:\n\tif (x - minimum) % k != 0:\n\t\tprint('-1')\n\t\texit(0)\n\tsol += int((x - minimum) // k)\nprint(sol)\n", "import sys\ndata = sys.stdin.readlines()\n(n, k) = map(int, data[0].split())\nvalues = list(map(int, data[1].split()))\ntarget = min(values)\nif not all(((target - x) % k == 0 for x in values)):\n\tprint(-1)\nelse:\n\tprint(sum(((x - target) // k for x in values)))\n", "(n, k) = map(int, input().split())\na = input().split()\n(f, j, m) = (0, 0, int(a[0]))\nfor i in range(n):\n\tif abs(int(a[i]) - int(a[i - 1])) % k == 0:\n\t\tf += 1\n\tif int(a[i]) < m:\n\t\tj += (m - int(a[i])) * i // k\n\t\tm = int(a[i])\n\telse:\n\t\tj += (int(a[i]) - m) // k\nif f == n:\n\tprint(int(j))\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nans = 0\namin = min(a)\nfor ai in a:\n\tif 0 < (ai - amin) % k:\n\t\tans = -1\n\t\tbreak\n\telse:\n\t\tans += (ai - amin) // k\nprint(ans)\n", "(n, k) = map(int, input().split())\nc = 0\na = list(map(int, input().split()))\nfor i in range(1, n):\n\tif a[i] % k != a[i - 1] % k:\n\t\tc += 1\nif c != 0:\n\tprint(-1)\nelse:\n\tb = min(a)\n\tfor i in range(0, n):\n\t\tc += a[i] - b\n\tprint(c // k)\n", "import sys\n[_, k, *nums] = (int(x) for x in sys.stdin.read().split())\nsmallest = min(nums)\nsteps = 0\nfor num in nums:\n\tdist = num - smallest\n\tif dist % k != 0:\n\t\tsteps = -1\n\t\tbreak\n\tsteps += int(dist / k)\nprint(str(steps), end='')\n", "str_in = [int(x) for x in input().split()]\nn = str_in[0]\nk = str_in[1]\npr = []\nstr_in = [int(x) for x in input().split()]\nfor i in range(n):\n\tpr.append(str_in[i])\nm = min(pr)\nt = 0\nfor i in range(n):\n\tif (pr[i] - m) % k == 0:\n\t\tt += (pr[i] - m) / k\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(int(t))\n", "(a, b) = map(int, input().split())\narr = list(map(int, input().split()))\narr = sorted(arr)\nmi = arr[0]\nflag = True\narr = arr[::-1]\nc = 0\nfor i in arr:\n\tif (i - mi) % b != 0:\n\t\tflag = False\n\t\tbreak\n\telse:\n\t\tc += (i - mi) // b\nif flag:\n\tprint(c)\nelse:\n\tprint(-1)\n", "(n, k) = (int(i) for i in input().split())\nactions = [int(i) for i in input().split()]\nactions.sort(reverse=True)\nsecs = 0\nposs = True\nfor act in actions:\n\tif (act - actions[-1]) % k != 0:\n\t\tposs = False\n\t\tbreak\n\telse:\n\t\tsecs += (act - actions[-1]) // k\nif poss:\n\tprint(secs)\nelse:\n\tprint(-1)\n", "(N, K) = map(int, input().split())\nL = list(map(int, input().split()))\nL.sort(reverse=True)\ncount = 0\nFLAG = 0\nfor i in range(N - 1):\n\tif (L[i] - L[i + 1]) % K != 0:\n\t\tprint(-1)\n\t\tFLAG = 1\n\t\tbreak\n\telse:\n\t\tcount = count + (i + 1) * ((L[i] - L[i + 1]) // K)\nif FLAG == 0:\n\tprint(count)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nc = 0\nq = min(a)\nfor i in range(n):\n\tif a[i] == q:\n\t\tcontinue\n\tif abs(a[i] - q) % k != 0:\n\t\tprint(-1)\n\t\tbreak\n\telse:\n\t\tc += abs(a[i] - q) // k\nelse:\n\tprint(c)\n", "import sys\n\ndef solve():\n\t(n, k) = map(int, input().split())\n\ta = [int(i) for i in input().split()]\n\tamin = min(a)\n\tans = 0\n\tfor ai in a:\n\t\td = ai - amin\n\t\tif d % k != 0:\n\t\t\tprint(-1)\n\t\t\treturn\n\t\tans += d // k\n\tprint(ans)\nsolve()\n", "def main(a, k):\n\tif len(set((x % k for x in a))) > 1:\n\t\treturn -1\n\tm = min(a)\n\treturn sum(((x - m) // k for x in a))\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nprint(main(a, k))\n", "import sys\n(n, k) = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\ncount = 0\nfor x in range(1, n):\n\tif (a[x] - a[0]) % k == 0:\n\t\tcount += (a[x] - a[0]) // k\n\telse:\n\t\tprint(-1)\n\t\tsys.exit()\nprint(count)\n", "(n, k) = map(int, input().split())\nA = list(map(int, input().split()))\nmods = [A[i] % k for i in range(n)]\nalright = True\nfor i in range(1, n):\n\tif mods[i] != mods[0]:\n\t\talright = False\n\t\tbreak\nif not alright:\n\tprint(-1)\nelse:\n\ts = 0\n\tminA = min(A)\n\tfor i in range(n):\n\t\ts += (A[i] - minA) // k\n\tprint(s)\n", "import math\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nr = a[0] % k\nt = 0\nfor i in range(1, n):\n\tif a[i] % k != r:\n\t\tprint(-1)\n\t\tbreak\n\telse:\n\t\tt += (a[i] - a[0]) // k\nelse:\n\tprint(t)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nminn = min(a)\na_new = list(map(lambda x: x - minn, a))\nif any(map(lambda x: x % k, a_new)):\n\tprint(-1)\nelse:\n\tprint(sum(a_new) // k)\n", "(n, k) = map(int, input().split())\na = sorted(map(int, input().split()))\nif all(((a[i] - a[0]) % k == 0 for i in range(1, n))):\n\tprint(sum([(a[i] - a[0]) // k for i in range(1, n)]))\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nq = a[0] % k\nl = 0\nmin = min(a)\nfor i in range(0, n):\n\tif a[i] % k == q:\n\t\tl += (a[i] - min) // k\n\telse:\n\t\tl = -1\n\t\tbreak\nprint(l)\n", "def solve():\n\t(n, k) = map(int, input().split())\n\ta = sorted(list(map(int, input().split())))\n\tans = 0\n\tfor i in range(1, n):\n\t\tif (a[i] - a[0]) % k != 0:\n\t\t\treturn -1\n\t\telse:\n\t\t\tans += (a[i] - a[0]) // k\n\treturn ans\nprint(solve())\n", "(N, K) = map(int, input().split())\nA = tuple(map(int, input().split()))\nbase = min(A)\nD = map(lambda x: x - base, A)\nres = 0\nfor d in D:\n\t(num, rest) = divmod(d, K)\n\tif rest:\n\t\tres = -1\n\t\tbreak\n\tres += num\nprint(res)\n", "(a, b) = map(int, input().split())\nc = list(map(int, input().split()))\nmi = min(c)\nfor i in c:\n\tif (i - mi) % b:\n\t\tprint(-1)\n\t\texit()\nprint((sum(c) - a * mi) // b)\n", "(n, k) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\n\ndef f(n, k):\n\tz = n[0]\n\tfor i in range(1, len(n)):\n\t\tif (n[i] - n[0]) % k != 0:\n\t\t\treturn 0\n\treturn 1\nif f(a, k) == 0:\n\tprint(-1)\nelse:\n\ta.sort()\n\tt = 0\n\tfor i in range(1, n):\n\t\tt = t + (a[i] - a[0]) // k\n\tprint(t)\n", "class CodeforcesTask793ASolution:\n\n\tdef __init__(self):\n\t\tself.result = ''\n\t\tself.n_k = []\n\t\tself.shares = []\n\n\tdef read_input(self):\n\t\tself.n_k = [int(x) for x in input().split(' ')]\n\t\tself.shares = [int(x) for x in input().split(' ')]\n\n\tdef process_task(self):\n\t\trests = [x % self.n_k[1] for x in self.shares]\n\t\tif len(set(rests)) > 1:\n\t\t\tself.result = '-1'\n\t\telse:\n\t\t\tadj_shares = [(x - rests[0]) // self.n_k[1] for x in self.shares]\n\t\t\tbase_share = min(adj_shares)\n\t\t\ttimes = [x - base_share for x in adj_shares]\n\t\t\tself.result = str(sum(times))\n\n\tdef get_result(self):\n\t\treturn self.result\nSolution = CodeforcesTask793ASolution()\nSolution.read_input()\nSolution.process_task()\nprint(Solution.get_result())\n", "a = int(input().split()[1])\ns = input().split()\nd = []\nfor i in s:\n\td.append(int(i))\nm = min(d)\nt = 0\nfor i in d:\n\tc = i - m\n\tif c % a == 0:\n\t\tt += c // a\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(t)\n", "import sys\n(num_prices, dec_rate) = [int(x) for x in input().split(' ')]\nprices = [int(x) for x in input().split(' ')]\nprices.sort()\nsteps = 0\nfor i in range(1, len(prices)):\n\tif (prices[i] - prices[0]) % dec_rate != 0:\n\t\tprint(-1)\n\t\tsys.exit()\n\tsteps += (prices[i] - prices[0]) / dec_rate\nprint(int(steps))\n", "(n, k) = input().split()\ns = input().split()\ns = list(map(int, s))\ns.sort()\nans = 0\ncount = 0\nfor i in range(1, int(n)):\n\tans += s[i] - s[0]\n\tif (s[i] - s[0]) % int(k) != 0:\n\t\tcount += 1\nif count == 0:\n\tprint(int(ans / int(k)))\nelse:\n\tprint(-1)\n", "import unittest\nimport sys\n\nclass Shares:\n\n\tdef __init__(self, test_inputs=None):\n\t\tit = iter(test_inputs.split('\\n')) if test_inputs else None\n\n\t\tdef uinput():\n\t\t\treturn next(it) if it else sys.stdin.readline().rstrip()\n\t\t[self.n, self.k] = map(int, uinput().split())\n\t\tself.numa = list(map(int, uinput().split()))\n\t\tself.price_min = min(self.numa)\n\t\tself.price_diffs = [price - self.price_min for price in self.numa]\n\n\tdef calculate(self):\n\t\tresult = 0\n\t\tfor diff in self.price_diffs:\n\t\t\tif diff % self.k:\n\t\t\t\tresult = -1\n\t\t\t\tbreak\n\t\t\tresult += diff // self.k\n\t\treturn str(result)\n\nclass unitTests(unittest.TestCase):\n\n\tdef test_single_test(self):\n\t\ttest = '3 3\\n12 9 15'\n\t\td = Shares(test)\n\t\tself.assertEqual(d.n, 3)\n\t\tself.assertEqual(d.k, 3)\n\t\tself.assertEqual(d.numa, [12, 9, 15])\n\t\tself.assertEqual(d.price_min, 9)\n\t\tself.assertEqual(Shares(test).calculate(), '3')\n\t\ttest = '2 2\\n10 9'\n\t\tself.assertEqual(Shares(test).calculate(), '-1')\n\t\ttest = '4 1\\n1 1000000000 1000000000 1000000000'\n\t\tself.assertEqual(Shares(test).calculate(), '2999999997')\n\t\ttest = '2 2\\n-2 -2'\n\t\tself.assertEqual(Shares(test).calculate(), '0')\n\n\tdef time_limit_test(self, nmax):\n\t\timport random\n\t\timport timeit\n\t\ttest = str(nmax) + ' ' + str(nmax) + '\\n'\n\t\tnumnums = [str(i) + ' ' + str(i + 1) for i in range(nmax)]\n\t\ttest += '\\n'.join(numnums) + '\\n'\n\t\tnums = [random.randint(1, 10000) for i in range(nmax)]\n\t\ttest += ' '.join(map(str, nums)) + '\\n'\n\t\tstart = timeit.default_timer()\n\t\td = Shares(test)\n\t\tcalc = timeit.default_timer()\n\t\td.calculate()\n\t\tstop = timeit.default_timer()\n\t\tprint('\\nTimelimit Test: ' + '{0:.3f}s (init {1:.3f}s calc {2:.3f}s)'.format(stop - start, calc - start, stop - calc))\nsys.setrecursionlimit(100000)\nif sys.argv[-1] == '-ut':\n\tunittest.main(argv=[' '])\nsys.stdout.write(Shares().calculate())\n", "(_, k) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nm = min(a)\nif not all([(i - m) % k == 0 for i in a]):\n\tprint(-1)\nelse:\n\tprint(sum([(i - m) // k for i in a]))\n", "num = list(map(int, input().split()))\npri = list(map(int, input().split()))\nless = min(pri)\nres = 0\nfor i in range(num[0]):\n\ta = (pri[i] - less) / num[1]\n\tif a == int(a):\n\t\tres += a\n\telse:\n\t\tres = -1\n\t\tbreak\nprint(int(res))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nm = min(a)\nst = True\nres = 0\nfor i in a:\n\tif (i - m) % k != 0:\n\t\tst = False\n\telse:\n\t\tres += (i - m) // k\nif st:\n\tprint(res)\nelse:\n\tprint(-1)\n", "def check_disible(divisor, array):\n\taux = array[0] % divisor\n\tfor i in range(len(array)):\n\t\tif array[i] % divisor != aux:\n\t\t\treturn True\n\treturn False\n\ndef checks():\n\ttotal = list(map(int, input().split()))\n\tchecks = list(map(int, input().split()))\n\tif check_disible(total[1], checks):\n\t\treturn -1\n\toutput = 0\n\tminimum = min(checks)\n\tfor i in range(len(checks)):\n\t\tif checks[i] != minimum:\n\t\t\toutput += int((checks[i] - minimum) / total[1])\n\treturn output\nA = checks()\nprint(A)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\ncheck = True\nfor i in range(1, n):\n\tcheck = check and a[i] % k == a[0] % k\nif not check:\n\tprint(-1)\nelse:\n\tm = min(a)\n\tans = 0\n\tfor i in range(n):\n\t\tans += a[i] - m\n\tprint(ans // k)\n", "X = list(map(int, input().split()))\nPrices = list(map(int, input().split()))\nif len(set([i % X[1] for i in Prices])) != 1:\n\tprint(-1)\n\texit()\nMIN = min(Prices)\nprint(sum(((i - MIN) // X[1] for i in Prices)))\n", "I = lambda : map(int, input().split())\n(n, k) = I()\na = (*I(),)\nx = min(a)\nprint([sum(((y - x) // k for y in a)), -1][any((y % k != x % k for y in a))])\n", "(inputnum, tk) = list(map(int, input().split()))\nara = list(map(int, input().split()))\nmaxi = ara[0]\nans = 0\nara = sorted(ara)\nmini = ara[0]\nfor i in ara:\n\tif (i - mini) % tk == 0:\n\t\tans += (i - mini) // tk\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(ans)\n", "(n, r) = [int(x) for x in input().split()]\nl = [int(x) for x in input().split()]\nmn = min(l)\nflag = 1\nfor i in range(n):\n\tif (l[i] - mn) % r != 0:\n\t\tflag = 0\n\t\tbreak\nif flag == 1:\n\ttot = (sum(l) - n * mn) // r\n\tprint(tot)\nelse:\n\tprint(-1)\n", "(n, k) = [int(x) for x in input().split(' ')]\na = [int(x) for x in input().split(' ')]\nb = [y % k for y in a]\nif max(b) == min(b):\n\tm = min(a)\n\tans = sum([(z - m) // k for z in a])\nelse:\n\tans = -1\nprint(ans)\n", "(n, k) = map(int, input().split())\nv = list(map(int, input().split()))\nh = 1\nh = 0\nminimum = 0\nfor i in range(n):\n\tif v[minimum] > v[i]:\n\t\tminimum = i\nmiin = v[minimum]\nv.pop(minimum)\nfor i in range(n - 1):\n\tif (v[i] - miin) % k == 0:\n\t\th += (v[i] - miin) // k\n\telse:\n\t\th = -1\n\t\tbreak\nprint(h)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\nm = min(a)\nans = 0\nfor i in a:\n\tif (i - m) % k == 0:\n\t\tans += (i - m) // k\n\telse:\n\t\tans = -1\n\t\tbreak\nprint(ans)\n", "(n, k) = map(int, input().split())\nL = list(map(int, input().split()))\nm = L[0] % k\nans = 0\nfor i in L:\n\tif i % k != m:\n\t\tans = -1\nif ans != -1:\n\tr = min(L)\n\tfor i in L:\n\t\tans += (i - r) // k\nprint(ans)\n", "Input = lambda : map(int, input().split())\n(n, k) = Input()\nl = list(Input())\nm = min(l)\nans = 0\nfor i in range(n):\n\ty = l[i] - m\n\tif y % k == 0:\n\t\tans += y // k\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(ans)\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nq = True\nmi = a[0]\nfor i in a:\n\tif i < mi:\n\t\tmi = i\nfor i in range(n):\n\ta[i] -= mi\n\tif a[i] % k != 0:\n\t\tq = False\n\t\tbreak\nans = 0\nif q:\n\tfor i in a:\n\t\tans += i // k\nelif n == 1:\n\tans = 0\nelse:\n\tans = -1\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef ceil(x):\n\tif x != int(x):\n\t\tx = int(x) + 1\n\treturn x\n\ndef factorial(x, m):\n\tval = 1\n\twhile x > 0:\n\t\tval = val * x % m\n\t\tx -= 1\n\treturn val\n\ndef fact(x):\n\tval = 1\n\twhile x > 0:\n\t\tval *= x\n\t\tx -= 1\n\treturn val\n\ndef swaparr(arr, a, b):\n\ttemp = arr[a]\n\tarr[a] = arr[b]\n\tarr[b] = temp\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef nCr(n, k):\n\tif k > n:\n\t\treturn 0\n\tif k > n - k:\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n\ndef upper_bound(a, x, lo=0, hi=None):\n\tif hi == None:\n\t\thi = len(a)\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif a[mid] < x:\n\t\t\tlo = mid + 1\n\t\telse:\n\t\t\thi = mid\n\treturn lo\n\ndef primefs(n):\n\tprimes = {}\n\twhile n % 2 == 0 and n > 0:\n\t\tprimes[2] = primes.get(2, 0) + 1\n\t\tn = n // 2\n\tfor i in range(3, int(n ** 0.5) + 2, 2):\n\t\twhile n % i == 0 and n > 0:\n\t\t\tprimes[i] = primes.get(i, 0) + 1\n\t\t\tn = n // i\n\tif n > 2:\n\t\tprimes[n] = primes.get(n, 0) + 1\n\treturn primes\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef swap(a, b):\n\ttemp = a\n\ta = b\n\tb = temp\n\treturn (a, b)\n\ndef find(x, link):\n\tp = x\n\twhile p != link[p]:\n\t\tp = link[p]\n\twhile x != p:\n\t\tnex = link[x]\n\t\tlink[x] = p\n\t\tx = nex\n\treturn p\n\ndef union(x, y, link, size):\n\tx = find(x, link)\n\ty = find(y, link)\n\tif size[x] < size[y]:\n\t\t(x, y) = swap(x, y)\n\tif x != y:\n\t\tsize[x] += size[y]\n\t\tlink[y] = x\n\ndef sieve(n):\n\tprime = [True for i in range(n + 1)]\n\t(prime[0], prime[1]) = (False, False)\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p + p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\nMAXN = int(100000.0 + 5)\n\ndef spf_sieve():\n\tspf[1] = 1\n\tfor i in range(2, MAXN):\n\t\tspf[i] = i\n\tfor i in range(4, MAXN, 2):\n\t\tspf[i] = 2\n\tfor i in range(3, ceil(MAXN ** 0.5), 2):\n\t\tif spf[i] == i:\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif spf[j] == j:\n\t\t\t\t\tspf[j] = i\nspf = [0 for i in range(MAXN)]\n\ndef factoriazation(x):\n\tres = []\n\tfor i in range(2, int(x ** 0.5) + 1):\n\t\twhile x % i == 0:\n\t\t\tres.append(i)\n\t\t\tx //= i\n\tif x != 1:\n\t\tres.append(x)\n\treturn res\n\ndef int_array():\n\treturn list(map(int, input().strip().split()))\n\ndef float_array():\n\treturn list(map(float, input().strip().split()))\n\ndef str_array():\n\treturn input().strip().split()\nMOD = int(1000000000.0) + 7\nCMOD = 998244353\nINF = float('inf')\nNINF = -float('inf')\nfrom itertools import permutations\nimport math\nfrom bisect import bisect_left\n\ndef solve():\n\t(n, k) = map(int, input().split())\n\ta = sorted(list(map(int, input().split())))\n\tm = a[0]\n\tans = 0\n\tfor x in a[1:]:\n\t\tif (x - m) % k != 0:\n\t\t\tbreak\n\t\tans += (x - m) // k\n\telse:\n\t\tprint(ans)\n\t\treturn\n\tprint(-1)\nfor _ in range(1):\n\tsolve()\n", "(n, k) = map(int, input().split())\nai = list(map(int, input().split()))\nnum = [ai[i] % k for i in range(n)]\nif max(num) != min(num):\n\tprint(-1)\nelse:\n\tnum = [ai[i] // k for i in range(n)]\n\tminn = min(num)\n\tnum3 = [num[i] - minn for i in range(n)]\n\tprint(sum(num3))\n", "inp1 = [int(x) for x in input().split()]\nn = inp1[0]\nk = inp1[1]\na = [int(x) for x in input().split()]\nr = [x % k for x in a]\nm = [x // k for x in a]\nif any([x != r[0] for x in r]):\n\tprint('-1')\nelse:\n\tmmin = min(m)\n\tprint(sum([x - mmin for x in m]))\n", "def main():\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\ttarget = min(a)\n\tmods = set([x % k for x in a])\n\tif len(mods) != 1:\n\t\tprint(-1)\n\t\treturn\n\tans = sum(((x - target) // k for x in a))\n\tprint(ans)\nmain()\n", "(n, k) = (int(i) for i in input().split())\na = [int(i) for i in input().split()]\nmn = min(a)\ncnt = 0\nbr = 0\nfor i in a:\n\tcc = (i - mn) / k\n\tif cc % 1 != 0:\n\t\tbr = 1\n\t\tbreak\n\tcnt += cc\nif br:\n\tprint(-1)\nelse:\n\tprint(int(cnt))\n", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nm = min(l)\nt = 0\nfor x in l:\n\tif (x - m) / k - int((x - m) / k) == 0:\n\t\tt += (x - m) / k\n\telse:\n\t\tprint(-1)\n\t\texit()\nprint(int(t))\n", "(n, k) = map(int, input().split())\nmn = float('inf')\nl = []\nfor i in input().split():\n\ti = int(i)\n\tmn = min(i, mn)\n\tl.append(i)\no = 0\nfor n in l:\n\tdiff = n - mn\n\tif diff > 0:\n\t\tif diff % k == 0:\n\t\t\to += diff / k\n\t\telse:\n\t\t\to = -1\n\t\t\tbreak\nprint(int(o))\n", "(n, k) = [int(s) for s in input().split()]\nprice = [int(s) for s in input().split()]\nminimum = min((s for s in price))\nres = [s - minimum for s in price]\nr = sum([int(s % k) for s in res])\nif r == 0:\n\tprint(int(sum(res) / k))\nelse:\n\tprint(-1)\n", "(n, k) = map(int, input().split(' '))\nl = list(map(int, input().split(' ')))\nl.sort()\nmin_ = l[0]\nc = 0\nb = True\nfor i in range(1, n):\n\tif (l[i] - min_) % k == 0:\n\t\tc += (l[i] - min_) // k\n\telse:\n\t\tc = -1\n\t\tbreak\nprint(c)\n", "from sys import stdin, stdout\n\ndef ri():\n\treturn map(int, stdin.readline().split())\n(n, k) = ri()\na = list(ri())\na.sort(reverse=True)\nminv = a[-1]\ncount = 0\nfor v in a:\n\tdiff = v - minv\n\tif diff % k:\n\t\tprint(-1)\n\t\texit()\n\tcount += diff // k\nprint(count)\n"], "public_test_cases": [{"input": "3 3\n12 9 15\n", "output": "3\n", "type": "stdin"}, {"input": "2 2\n10 9\n", "output": "-1\n", "type": "stdin"}, {"input": "4 1\n1 1000000000 1000000000 1000000000\n", "output": "2999999997\n", "type": "stdin"}], "test_cases": [{"input": "3 3\n1 3 5\n", "output": "-1\n", "type": "stdin"}, {"input": "10 2\n2 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n", "output": "4499999991\n", "type": "stdin"}, {"input": "2 1\n2 3\n", "output": "1\n", "type": "stdin"}, {"input": "3 5\n2 4 5\n", "output": "-1\n", "type": "stdin"}, {"input": "4 4\n1 5 8 14\n", "output": "-1\n", "type": "stdin"}, {"input": "2 6\n8 16\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n1 3 4\n", "output": "-1\n", "type": "stdin"}, {"input": "4 3\n2 2 5 1\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n7 8 8\n", "output": "-1\n", "type": "stdin"}, {"input": "3 5\n6 11 17\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n7 10\n", "output": "1\n", "type": "stdin"}, {"input": "2 2\n1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "5 1000000000\n1000000000 1000000000 1000000000 1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "3 6\n10 14 12\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n3 5 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 10\n10 13 17\n", "output": "-1\n", "type": "stdin"}, {"input": "2 1\n1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "3 2\n1 2 2\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n88888884 88888886 88888888\n", "output": "3\n", "type": "stdin"}, {"input": "20 6\n38 86 86 50 98 62 32 2 14 62 98 50 2 50 32 38 62 62 8 14\n", "output": "151\n", "type": "stdin"}, {"input": "2 4\n3 7\n", "output": "1\n", "type": "stdin"}, {"input": "3 2\n1 2 4\n", "output": "-1\n", "type": "stdin"}, {"input": "20 1\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "2 3\n2 4\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n100000003 100000005\n", "output": "1\n", "type": "stdin"}, {"input": "1 1\n1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "4 1\n1000000000 1000000000 1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "2 5\n8 17\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n1 6\n", "output": "-1\n", "type": "stdin"}, {"input": "100 18\n489 42 300 366 473 105 220 448 70 488 201 396 168 281 67 235 324 291 313 387 407 223 39 144 224 233 72 318 229 377 62 171 448 119 354 282 147 447 260 384 172 199 67 326 311 431 337 142 281 202 404 468 38 120 90 437 33 420 249 372 367 253 255 411 309 333 103 176 162 120 203 41 352 478 216 498 224 31 261 493 277 99 375 370 394 229 71 488 246 194 233 13 66 111 366 456 277 360 116 354\n", "output": "-1\n", "type": "stdin"}, {"input": "3 5\n1 3 4\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n5 8\n", "output": "1\n", "type": "stdin"}, {"input": "4 2\n1 2 3 4\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n6 9\n", "output": "1\n", "type": "stdin"}, {"input": "2 3\n1 8\n", "output": "-1\n", "type": "stdin"}, {"input": "4 2\n2 3 3 2\n", "output": "-1\n", "type": "stdin"}, {"input": "100 10\n340 70 440 330 130 120 340 210 440 110 410 120 180 40 50 230 70 110 310 360 480 70 230 120 230 310 470 60 210 60 210 480 290 250 450 440 150 40 500 230 280 250 30 50 310 50 230 360 420 260 330 80 50 160 70 470 140 180 380 190 250 30 220 410 80 310 280 50 20 430 440 180 310 190 190 330 90 190 320 390 170 460 230 30 80 500 470 370 80 500 400 120 220 150 70 120 70 320 260 260\n", "output": "2157\n", "type": "stdin"}, {"input": "1 7\n1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "2 3\n2 5\n", "output": "1\n", "type": "stdin"}, {"input": "3 3\n3 2 1\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n3 5\n", "output": "1\n", "type": "stdin"}, {"input": "4 3\n1 6 6 6\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n5 7\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n5 6\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n5 3 4\n", "output": "-1\n", "type": "stdin"}, {"input": "2 1\n1 2\n", "output": "1\n", "type": "stdin"}, {"input": "1 11\n123\n", "output": "0\n", "type": "stdin"}, {"input": "4 2\n1000000000 100000000 100000000 100000000\n", "output": "450000000\n", "type": "stdin"}, {"input": "3 2\n3 4 4\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n1 4 6\n", "output": "-1\n", "type": "stdin"}, {"input": "20 5\n59 54 19 88 55 100 54 3 6 13 99 38 36 71 59 6 64 85 45 54\n", "output": "-1\n", "type": "stdin"}, {"input": "3 137\n1000000000 1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "3 3\n4 7 10\n", "output": "3\n", "type": "stdin"}, {"input": "3 4\n3 5 3\n", "output": "-1\n", "type": "stdin"}, {"input": "5 3\n15 14 9 12 18\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n1 2 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n3 4 5\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n1 4\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n2 3 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n9 10 10\n", "output": "-1\n", "type": "stdin"}, {"input": "4 3\n1 2 2 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n2 3 4\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n1000000000 1000000000 999999997\n", "output": "2\n", "type": "stdin"}, {"input": "3 5\n1 2 5\n", "output": "-1\n", "type": "stdin"}, {"input": "2 5\n5 9\n", "output": "-1\n", "type": "stdin"}, {"input": "4 10\n1 11 100 11\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n6 8\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n9 12\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n1 5 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n1 3 5\n", "output": "-1\n", "type": "stdin"}, {"input": "10 2\n2 1000000000 1000000000 1000000000 1010000000 1000000000 1000000000 1000000000 1000000000 1000000000\n", "output": "4504999991\n", "type": "stdin"}, {"input": "3 1\n1 3 4\n", "output": "5\n", "type": "stdin"}, {"input": "2 3\n1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "3 2\n111405120 88888886 88888888\n", "output": "11258118\n", "type": "stdin"}, {"input": "20 1\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000100000 1000000000 1000000000 1000000000 1000000000\n", "output": "100000\n", "type": "stdin"}, {"input": "2 2\n100000003 58005977\n", "output": "20997013\n", "type": "stdin"}, {"input": "4 1\n1000000000 1000000000 1100000000 1000000000\n", "output": "100000000\n", "type": "stdin"}, {"input": "2 1\n8 17\n", "output": "9\n", "type": "stdin"}, {"input": "4 5\n1 6 6 6\n", "output": "3\n", "type": "stdin"}, {"input": "2 1\n1 0\n", "output": "1\n", "type": "stdin"}, {"input": "4 2\n1000001000 100000000 100000000 100000000\n", "output": "450000500\n", "type": "stdin"}, {"input": "3 1\n1 4 6\n", "output": "8\n", "type": "stdin"}, {"input": "4 1\n1 1001000000 1000000000 1000000000\n", "output": "3000999997\n", "type": "stdin"}, {"input": "10 2\n2 1000000000 1000000000 1000000000 1010000000 1000000000 1000000000 1000000000 1000000010 1000000000\n", "output": "4504999996\n", "type": "stdin"}, {"input": "3 2\n111405120 88888886 43400494\n", "output": "56746509\n", "type": "stdin"}, {"input": "2 3\n1 7\n", "output": "2\n", "type": "stdin"}, {"input": "20 1\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1010000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000100000 1000000000 1000000000 1000000000 1000000000\n", "output": "10100000\n", "type": "stdin"}, {"input": "2 2\n172046127 58005977\n", "output": "57020075\n", "type": "stdin"}, {"input": "2 1\n8 15\n", "output": "7\n", "type": "stdin"}, {"input": "3 5\n2 4 9\n", "output": "-1\n", "type": "stdin"}, {"input": "4 4\n1 9 8 14\n", "output": "-1\n", "type": "stdin"}, {"input": "2 9\n8 16\n", "output": "-1\n", "type": "stdin"}, {"input": "4 3\n2 3 5 1\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n7 10\n", "output": "-1\n", "type": "stdin"}, {"input": "3 6\n3 14 12\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n10 13 17\n", "output": "-1\n", "type": "stdin"}, {"input": "20 11\n38 86 86 50 98 62 32 2 14 62 98 50 2 50 32 38 62 62 8 14\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n3 7\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n1 4 4\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n2 2\n", "output": "0\n", "type": "stdin"}, {"input": "1 2\n1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "2 1\n1 6\n", "output": "5\n", "type": "stdin"}, {"input": "100 18\n489 42 300 366 473 105 220 448 70 488 201 396 168 281 67 235 324 291 313 387 407 223 39 144 224 233 72 318 229 377 62 171 448 119 354 282 147 447 260 384 172 199 67 326 311 431 337 142 281 202 404 468 38 120 90 437 33 420 249 372 367 101 255 411 309 333 103 176 162 120 203 41 352 478 216 498 224 31 261 493 277 99 375 370 394 229 71 488 246 194 233 13 66 111 366 456 277 360 116 354\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n5 12\n", "output": "-1\n", "type": "stdin"}, {"input": "4 2\n1 2 5 4\n", "output": "-1\n", "type": "stdin"}, {"input": "4 3\n2 3 3 2\n", "output": "-1\n", "type": "stdin"}, {"input": "100 10\n340 70 440 330 130 120 340 210 440 110 410 120 180 40 50 230 70 110 310 360 480 70 230 120 230 310 470 60 210 60 210 480 290 250 450 440 150 40 500 230 280 250 30 50 310 50 230 360 420 260 330 80 50 160 70 470 140 180 380 190 344 30 220 410 80 310 280 50 20 430 440 180 310 190 190 330 90 190 320 390 170 460 230 30 80 500 470 370 80 500 400 120 220 150 70 120 70 320 260 260\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n3 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n3 2 0\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n3 3\n", "output": "0\n", "type": "stdin"}, {"input": "2 3\n5 6\n", "output": "-1\n", "type": "stdin"}, {"input": "2 7\n5 6\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n5 5 4\n", "output": "-1\n", "type": "stdin"}, {"input": "20 5\n59 54 19 88 55 100 54 3 6 13 99 38 36 99 59 6 64 85 45 54\n", "output": "-1\n", "type": "stdin"}, {"input": "3 86\n1000000000 1000000000 1000000000\n", "output": "0\n", "type": "stdin"}, {"input": "3 1\n4 7 10\n", "output": "9\n", "type": "stdin"}, {"input": "3 4\n5 5 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n1 3 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n3 4 5\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n1 2\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n3 3 5\n", "output": "1\n", "type": "stdin"}, {"input": "4 3\n1 1 2 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 6\n1000000000 1000000000 999999997\n", "output": "-1\n", "type": "stdin"}, {"input": "3 5\n1 0 5\n", "output": "-1\n", "type": "stdin"}, {"input": "4 10\n1 11 100 17\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n12 8\n", "output": "1\n", "type": "stdin"}, {"input": "2 3\n9 12\n", "output": "1\n", "type": "stdin"}, {"input": "2 2\n11 9\n", "output": "1\n", "type": "stdin"}, {"input": "3 3\n12 9 16\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n1 0 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 5\n2 4 11\n", "output": "-1\n", "type": "stdin"}, {"input": "4 4\n1 9 16 14\n", "output": "-1\n", "type": "stdin"}, {"input": "2 9\n8 27\n", "output": "-1\n", "type": "stdin"}, {"input": "4 3\n2 3 3 1\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n7 16\n", "output": "-1\n", "type": "stdin"}, {"input": "3 5\n3 14 12\n", "output": "-1\n", "type": "stdin"}, {"input": "20 11\n38 86 86 50 38 62 32 2 14 62 98 50 2 50 32 38 62 62 8 14\n", "output": "-1\n", "type": "stdin"}, {"input": "3 2\n2 4 4\n", "output": "2\n", "type": "stdin"}, {"input": "2 3\n2 1\n", "output": "-1\n", "type": "stdin"}, {"input": "2 2\n1 6\n", "output": "-1\n", "type": "stdin"}, {"input": "100 18\n489 42 300 366 473 118 220 448 70 488 201 396 168 281 67 235 324 291 313 387 407 223 39 144 224 233 72 318 229 377 62 171 448 119 354 282 147 447 260 384 172 199 67 326 311 431 337 142 281 202 404 468 38 120 90 437 33 420 249 372 367 101 255 411 309 333 103 176 162 120 203 41 352 478 216 498 224 31 261 493 277 99 375 370 394 229 71 488 246 194 233 13 66 111 366 456 277 360 116 354\n", "output": "-1\n", "type": "stdin"}, {"input": "2 3\n2 12\n", "output": "-1\n", "type": "stdin"}, {"input": "4 2\n1 2 7 4\n", "output": "-1\n", "type": "stdin"}, {"input": "4 2\n2 3 4 2\n", "output": "-1\n", "type": "stdin"}, {"input": "100 10\n340 70 440 330 130 120 340 210 440 110 410 120 180 40 50 230 70 110 310 360 480 70 230 120 230 310 470 60 210 60 210 480 290 250 450 440 150 40 500 230 280 250 30 50 310 50 230 360 420 260 330 80 50 160 70 470 140 180 380 190 344 30 220 410 80 310 280 50 20 430 440 180 310 190 190 330 90 190 320 390 170 460 230 30 80 500 470 370 80 500 400 120 220 150 70 120 63 320 260 260\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n0 2 0\n", "output": "-1\n", "type": "stdin"}, {"input": "4 5\n1 6 1 6\n", "output": "2\n", "type": "stdin"}, {"input": "2 6\n5 6\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n7 6\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n5 5 1\n", "output": "-1\n", "type": "stdin"}, {"input": "4 2\n1000001001 100000000 100000000 100000000\n", "output": "-1\n", "type": "stdin"}, {"input": "3 1\n1 5 6\n", "output": "9\n", "type": "stdin"}, {"input": "20 6\n59 54 19 88 55 100 54 3 6 13 99 38 36 99 59 6 64 85 45 54\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n4 5 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3 4\n3 4 0\n", "output": "-1\n", "type": "stdin"}, {"input": "4 5\n1 1 2 5\n", "output": "-1\n", "type": "stdin"}, {"input": "3 6\n1000000000 1000000000 749672447\n", "output": "-1\n", "type": "stdin"}, {"input": "4 10\n1 11 100 31\n", "output": "-1\n", "type": "stdin"}, {"input": "2 4\n12 4\n", "output": "2\n", "type": "stdin"}, {"input": "2 2\n6 12\n", "output": "3\n", "type": "stdin"}, {"input": "2 2\n10 9\n", "output": "-1\n", "type": "stdin"}, {"input": "3 3\n12 9 15\n", "output": "3\n", "type": "stdin"}, {"input": "4 1\n1 1000000000 1000000000 1000000000\n", "output": "2999999997\n", "type": "stdin"}], "problem_id": "taco_train_6261", "metadata": {"config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 163}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nA has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.\n\nB now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.\n\nYou have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print \"YES\", otherwise print \"NO\" (without the quotes).\n\nInput\n\nThe first and only line consists of a string S ( 1 \u2264 |S| \u2264 5 000 ). It is guaranteed that the string will only consist of the lowercase English letters 'a', 'b', 'c'.\n\nOutput\n\nPrint \"YES\" or \"NO\", according to the condition.\n\nExamples\n\nInput\n\naaabccc\n\n\nOutput\n\nYES\n\n\nInput\n\nbbacc\n\n\nOutput\n\nNO\n\n\nInput\n\naabc\n\n\nOutput\n\nYES\n\nNote\n\nConsider first example: the number of 'c' is equal to the number of 'a'. \n\nConsider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.\n\nConsider third example: the number of 'c' is equal to the number of 'b'.\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\ns = input()+\"d\"\nd = []\nr,l = 0,0\ne = set()\nwhile r!=len(s): \n\tif s[r]!=s[l]:\n\t\td.append(s[l:r])\n\t\tl=r\n\tr+=1\n\nif d[-1][0]!=\"c\" or d[0][0]!=\"a\" or d[1][0]!=\"b\" or len(d)!=3:\n\tprint(\"NO\")\nelif len(d[-1])!=len(d[0]) and len(d[-1])!=len(d[1]):\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")\n```"], "public_test_cases": [{"input": "aaabccc\n", "output": "YES\n", "type": "stdin"}, {"input": "bbacc\n", "output": "NO\n", "type": "stdin"}, {"input": "aabc\n", "output": "YES\n", "type": "stdin"}], "test_cases": [{"input": "aabc\n", "output": "YES\n", "type": "stdin"}, {"input": "aaabccc\n", "output": "YES\n", "type": "stdin"}, {"input": "bbacc\n", "output": "NO\n", "type": "stdin"}, {"input": "aa\n", "output": "NO\n", "type": "stdin"}, {"input": "ccbcc\n", "output": "NO\n", "type": "stdin"}, {"input": "bc\n", "output": "NO\n", "type": "stdin"}, {"input": "c\n", "output": "NO\n", "type": "stdin"}, {"input": "babc\n", "output": "NO\n", "type": "stdin"}, {"input": "aaa\n", "output": "NO\n", "type": "stdin"}, {"input": "aaccaa\n", "output": "NO\n", "type": "stdin"}, {"input": "aabbcc\n", "output": "YES\n", "type": "stdin"}, {"input": "aabbcccc\n", "output": "NO\n", "type": "stdin"}, {"input": "b\n", "output": "NO\n", "type": "stdin"}, {"input": "cc\n", "output": "NO\n", "type": "stdin"}, {"input": "ccbbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "abababccc\n", "output": "NO\n", "type": "stdin"}, {"input": "acbbc\n", "output": "NO\n", "type": "stdin"}, {"input": "aabb\n", "output": "NO\n", "type": "stdin"}, {"input": "aabaccc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbabbc\n", "output": "NO\n", "type": "stdin"}, {"input": "ac\n", "output": "NO\n", "type": "stdin"}, {"input": "acba\n", "output": "NO\n", "type": "stdin"}, {"input": "abcb\n", "output": "NO\n", "type": "stdin"}, {"input": "aacc\n", "output": "NO\n", "type": "stdin"}, {"input": "aabcbcaca\n", "output": "NO\n", "type": "stdin"}, {"input": "bbb\n", "output": "NO\n", "type": "stdin"}, {"input": "aabbaacccc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbc\n", "output": "NO\n", "type": "stdin"}, {"input": "a\n", "output": "NO\n", "type": "stdin"}, {"input": "bbcc\n", "output": "NO\n", "type": "stdin"}, {"input": "abca\n", "output": "NO\n", "type": "stdin"}, {"input": "abacc\n", "output": "NO\n", "type": "stdin"}, {"input": "ababc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbbcc\n", "output": "NO\n", "type": "stdin"}, {"input": "aaaaabbbbbb\n", "output": "NO\n", "type": "stdin"}, {"input": "aaabcbc\n", "output": "NO\n", "type": "stdin"}, {"input": "abc\n", "output": "YES\n", "type": "stdin"}, {"input": "abac\n", "output": "NO\n", "type": "stdin"}, {"input": "abbacc\n", "output": "NO\n", "type": "stdin"}, {"input": "abcc\n", "output": "NO\n", "type": "stdin"}, {"input": "aaacccbb\n", "output": "NO\n", "type": "stdin"}, {"input": "bbbabacca\n", "output": "NO\n", "type": "stdin"}, {"input": "ab\n", "output": "NO\n", "type": "stdin"}, {"input": "aabcc\n", "output": "YES\n", "type": "stdin"}, {"input": "bcbcc\n", "output": "NO\n", "type": "stdin"}, {"input": "cb\n", "output": "NO\n", "type": "stdin"}, {"input": "bacc\n", "output": "NO\n", "type": "stdin"}, {"input": "aab\n", "output": "NO\n", "type": "stdin"}, {"input": "aadcaa\n", "output": "NO\n", "type": "stdin"}, {"input": "aabccc\n", "output": "NO\n", "type": "stdin"}, {"input": "ccccbbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "dc\n", "output": "NO\n", "type": "stdin"}, {"input": "cbcbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "abbbaaccc\n", "output": "NO\n", "type": "stdin"}, {"input": "bcabc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "aacabcc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbcbba\n", "output": "NO\n", "type": "stdin"}, {"input": "ca\n", "output": "NO\n", "type": "stdin"}, {"input": "acaa\n", "output": "NO\n", "type": "stdin"}, {"input": "bcba\n", "output": "NO\n", "type": "stdin"}, {"input": "ccaa\n", "output": "NO\n", "type": "stdin"}, {"input": "babcbcaca\n", "output": "NO\n", "type": "stdin"}, {"input": "bab\n", "output": "NO\n", "type": "stdin"}, {"input": "cabbaaccca\n", "output": "NO\n", "type": "stdin"}, {"input": "cbb\n", "output": "NO\n", "type": "stdin"}, {"input": "bccc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbca\n", "output": "NO\n", "type": "stdin"}, {"input": "abaac\n", "output": "NO\n", "type": "stdin"}, {"input": "bbbbc\n", "output": "NO\n", "type": "stdin"}, {"input": "aaaaabbabbb\n", "output": "NO\n", "type": "stdin"}, {"input": "bcb\n", "output": "NO\n", "type": "stdin"}, {"input": "baac\n", "output": "NO\n", "type": "stdin"}, {"input": "ccabba\n", "output": "NO\n", "type": "stdin"}, {"input": "ccba\n", "output": "NO\n", "type": "stdin"}, {"input": "aabcccab\n", "output": "NO\n", "type": "stdin"}, {"input": "bbbabbcca\n", "output": "NO\n", "type": "stdin"}, {"input": "cccbaaa\n", "output": "NO\n", "type": "stdin"}, {"input": "bbcac\n", "output": "NO\n", "type": "stdin"}, {"input": "bb\n", "output": "NO\n", "type": "stdin"}, {"input": "ccbcb\n", "output": "NO\n", "type": "stdin"}, {"input": "cd\n", "output": "NO\n", "type": "stdin"}, {"input": "caac\n", "output": "NO\n", "type": "stdin"}, {"input": "baa\n", "output": "NO\n", "type": "stdin"}, {"input": "cccbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "babbcccc\n", "output": "NO\n", "type": "stdin"}, {"input": "cccaabbba\n", "output": "NO\n", "type": "stdin"}, {"input": "cbacb\n", "output": "NO\n", "type": "stdin"}, {"input": "aacaacc\n", "output": "NO\n", "type": "stdin"}, {"input": "abcbba\n", "output": "NO\n", "type": "stdin"}, {"input": "ba\n", "output": "NO\n", "type": "stdin"}, {"input": "acab\n", "output": "NO\n", "type": "stdin"}, {"input": "bcaa\n", "output": "NO\n", "type": "stdin"}, {"input": "cdaa\n", "output": "NO\n", "type": "stdin"}, {"input": "acacbcbab\n", "output": "NO\n", "type": "stdin"}, {"input": "abb\n", "output": "NO\n", "type": "stdin"}, {"input": "cabbaaccda\n", "output": "NO\n", "type": "stdin"}, {"input": "ccb\n", "output": "NO\n", "type": "stdin"}, {"input": "bccb\n", "output": "NO\n", "type": "stdin"}, {"input": "bbba\n", "output": "NO\n", "type": "stdin"}, {"input": "ccbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "caaba\n", "output": "NO\n", "type": "stdin"}, {"input": "bbcbc\n", "output": "NO\n", "type": "stdin"}, {"input": "bbbabbaaaaa\n", "output": "NO\n", "type": "stdin"}, {"input": "acb\n", "output": "NO\n", "type": "stdin"}, {"input": "caab\n", "output": "NO\n", "type": "stdin"}, {"input": "dcabba\n", "output": "NO\n", "type": "stdin"}, {"input": "cdba\n", "output": "NO\n", "type": "stdin"}, {"input": "aabdccab\n", "output": "NO\n", "type": "stdin"}, {"input": "abcbc\n", "output": "NO\n", "type": "stdin"}, {"input": "ccbca\n", "output": "NO\n", "type": "stdin"}, {"input": "ce\n", "output": "NO\n", "type": "stdin"}, {"input": "daac\n", "output": "NO\n", "type": "stdin"}, {"input": "aba\n", "output": "NO\n", "type": "stdin"}, {"input": "cccaaa\n", "output": "NO\n", "type": "stdin"}, {"input": "babbcbcc\n", "output": "NO\n", "type": "stdin"}, {"input": "cccaabbaa\n", "output": "NO\n", "type": "stdin"}, {"input": "bbabc\n", "output": "NO\n", "type": "stdin"}, {"input": "ccaacaa\n", "output": "NO\n", "type": "stdin"}, {"input": "abbcba\n", "output": "NO\n", "type": "stdin"}, {"input": "baca\n", "output": "NO\n", "type": "stdin"}, {"input": "dcba\n", "output": "NO\n", "type": "stdin"}, {"input": "bcacbcaab\n", "output": "NO\n", "type": "stdin"}, {"input": "bba\n", "output": "NO\n", "type": "stdin"}, {"input": "cabcaaccda\n", "output": "NO\n", "type": "stdin"}, {"input": "cca\n", "output": "NO\n", "type": "stdin"}, {"input": "bcbc\n", "output": "NO\n", "type": "stdin"}, {"input": "baba\n", "output": "NO\n", "type": "stdin"}, {"input": "cabac\n", "output": "NO\n", "type": "stdin"}, {"input": "caaab\n", "output": "NO\n", "type": "stdin"}, {"input": "bbdbc\n", "output": "NO\n", "type": "stdin"}, {"input": "acc\n", "output": "NO\n", "type": "stdin"}, {"input": "aacb\n", "output": "NO\n", "type": "stdin"}, {"input": "dcabaa\n", "output": "NO\n", "type": "stdin"}], "problem_id": "primeintellect_train_7017", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 134}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nStatistics claims that students sleep no more than three hours a day. But even in the world of their dreams, while they are snoring peacefully, the sense of impending doom is still upon them.\n\nA poor student is dreaming that he is sitting the mathematical analysis exam. And he is examined by the most formidable professor of all times, a three times Soviet Union Hero, a Noble Prize laureate in student expulsion, venerable Petr Palych.\n\nThe poor student couldn't answer a single question. Thus, instead of a large spacious office he is going to apply for a job to thorium mines. But wait a minute! Petr Palych decided to give the student the last chance! Yes, that is possible only in dreams. \n\nSo the professor began: \"Once a Venusian girl and a Marsian boy met on the Earth and decided to take a walk holding hands. But the problem is the girl has al fingers on her left hand and ar fingers on the right one. The boy correspondingly has bl and br fingers. They can only feel comfortable when holding hands, when no pair of the girl's fingers will touch each other. That is, they are comfortable when between any two girl's fingers there is a boy's finger. And in addition, no three fingers of the boy should touch each other. Determine if they can hold hands so that the both were comfortable.\"\n\nThe boy any the girl don't care who goes to the left and who goes to the right. The difference is only that if the boy goes to the left of the girl, he will take her left hand with his right one, and if he goes to the right of the girl, then it is vice versa.\n\nInput\n\nThe first line contains two positive integers not exceeding 100. They are the number of fingers on the Venusian girl's left and right hand correspondingly. The second line contains two integers not exceeding 100. They are the number of fingers on the Marsian boy's left and right hands correspondingly.\n\nOutput\n\nPrint YES or NO, that is, the answer to Petr Palych's question.\n\nExamples\n\nInput\n\n5 1\n10 5\n\n\nOutput\n\nYES\n\nInput\n\n4 5\n3 3\n\n\nOutput\n\nYES\n\nInput\n\n1 2\n11 6\n\n\nOutput\n\nNO\n\nNote\n\nThe boy and the girl don't really care who goes to the left.\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\ng_l,g_r=input().split()\nb_l,b_r=input().split()\ng_l=int(g_l)\ng_r=int(g_r)\nb_l=int(b_l)\nb_r=int(b_r)\nflag=0\nif g_l==b_r:\n    flag=1\nelif g_l>b_r and g_l-1==b_r:\n    flag=1\nelif b_r>g_l and 2*g_l+2>=b_r:\n    flag=1\n\nif flag==0:\n    if g_r == b_l:\n        flag = 1\n    elif g_r > b_l and g_r - 1 == b_l:\n        flag = 1\n    elif b_l > g_r and 2 * g_r + 2 >= b_l:\n        flag = 1\nif flag==0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n```"], "public_test_cases": [{"input": "5 1\n10 5\n", "output": "YES\n", "type": "stdin"}, {"input": "4 5\n3 3\n", "output": "YES\n", "type": "stdin"}, {"input": "1 2\n11 6\n", "output": "NO\n", "type": "stdin"}], "test_cases": [{"input": "4 5\n3 3\n", "output": "YES\n", "type": "stdin"}, {"input": "5 1\n10 5\n", "output": "YES\n", "type": "stdin"}, {"input": "1 2\n11 6\n", "output": "NO\n", "type": "stdin"}, {"input": "100 100\n50 50\n", "output": "NO\n", "type": "stdin"}, {"input": "13 23\n19 63\n", "output": "NO\n", "type": "stdin"}, {"input": "5 23\n12 17\n", "output": "NO\n", "type": "stdin"}, {"input": "65 8\n73 25\n", "output": "NO\n", "type": "stdin"}, {"input": "100 3\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "2 25\n8 24\n", "output": "NO\n", "type": "stdin"}, {"input": "19 17\n5 8\n", "output": "NO\n", "type": "stdin"}, {"input": "24 43\n96 39\n", "output": "YES\n", "type": "stdin"}, {"input": "11 17\n6 4\n", "output": "NO\n", "type": "stdin"}, {"input": "25 9\n16 12\n", "output": "YES\n", "type": "stdin"}, {"input": "58 86\n40 46\n", "output": "NO\n", "type": "stdin"}, {"input": "100 1\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "82 60\n100 38\n", "output": "YES\n", "type": "stdin"}, {"input": "9 21\n13 16\n", "output": "YES\n", "type": "stdin"}, {"input": "6 14\n5 5\n", "output": "YES\n", "type": "stdin"}, {"input": "13 17\n19 1\n", "output": "YES\n", "type": "stdin"}, {"input": "13 2\n13 5\n", "output": "NO\n", "type": "stdin"}, {"input": "1 100\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 2\n12 1\n", "output": "NO\n", "type": "stdin"}, {"input": "9 15\n16 2\n", "output": "YES\n", "type": "stdin"}, {"input": "100 5\n1 1\n", "output": "NO\n", "type": "stdin"}, {"input": "5 12\n13 11\n", "output": "YES\n", "type": "stdin"}, {"input": "36 62\n81 12\n", "output": "YES\n", "type": "stdin"}, {"input": "93 12\n87 54\n", "output": "NO\n", "type": "stdin"}, {"input": "21 1\n5 19\n", "output": "NO\n", "type": "stdin"}, {"input": "6 11\n2 10\n", "output": "YES\n", "type": "stdin"}, {"input": "12 8\n4 12\n", "output": "YES\n", "type": "stdin"}, {"input": "2 6\n12 12\n", "output": "YES\n", "type": "stdin"}, {"input": "15 3\n12 16\n", "output": "YES\n", "type": "stdin"}, {"input": "30 38\n12 100\n", "output": "NO\n", "type": "stdin"}, {"input": "2 2\n1 1\n", "output": "YES\n", "type": "stdin"}, {"input": "1 1\n1 1\n", "output": "YES\n", "type": "stdin"}, {"input": "100 4\n1 1\n", "output": "NO\n", "type": "stdin"}, {"input": "7 12\n10 6\n", "output": "YES\n", "type": "stdin"}, {"input": "18 3\n16 15\n", "output": "NO\n", "type": "stdin"}, {"input": "25 14\n19 91\n", "output": "YES\n", "type": "stdin"}, {"input": "1 100\n1 5\n", "output": "NO\n", "type": "stdin"}, {"input": "15 7\n15 15\n", "output": "YES\n", "type": "stdin"}, {"input": "2 4\n6 6\n", "output": "YES\n", "type": "stdin"}, {"input": "1 100\n5 4\n", "output": "YES\n", "type": "stdin"}, {"input": "3 3\n1 1\n", "output": "NO\n", "type": "stdin"}, {"input": "25 8\n14 24\n", "output": "YES\n", "type": "stdin"}, {"input": "14 7\n2 9\n", "output": "NO\n", "type": "stdin"}, {"input": "19 4\n25 17\n", "output": "NO\n", "type": "stdin"}, {"input": "43 100\n65 24\n", "output": "NO\n", "type": "stdin"}, {"input": "18 22\n22 19\n", "output": "YES\n", "type": "stdin"}, {"input": "1 14\n7 14\n", "output": "NO\n", "type": "stdin"}, {"input": "4 4\n1 1\n", "output": "NO\n", "type": "stdin"}, {"input": "6 11\n13 11\n", "output": "YES\n", "type": "stdin"}, {"input": "15 1\n11 9\n", "output": "NO\n", "type": "stdin"}, {"input": "11 2\n11 22\n", "output": "YES\n", "type": "stdin"}, {"input": "5 15\n13 9\n", "output": "YES\n", "type": "stdin"}, {"input": "8 22\n2 3\n", "output": "NO\n", "type": "stdin"}, {"input": "7 25\n18 15\n", "output": "YES\n", "type": "stdin"}, {"input": "1 5\n14 1\n", "output": "YES\n", "type": "stdin"}, {"input": "94 35\n53 79\n", "output": "YES\n", "type": "stdin"}, {"input": "7 18\n23 19\n", "output": "YES", "type": "stdin"}, {"input": "100 100\n36 50\n", "output": "NO\n", "type": "stdin"}, {"input": "101 3\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "13 23\n19 71\n", "output": "NO\n", "type": "stdin"}, {"input": "65 8\n73 45\n", "output": "NO\n", "type": "stdin"}, {"input": "3 25\n8 24\n", "output": "NO\n", "type": "stdin"}, {"input": "19 17\n2 8\n", "output": "NO\n", "type": "stdin"}, {"input": "24 43\n87 39\n", "output": "YES\n", "type": "stdin"}, {"input": "11 31\n6 4\n", "output": "NO\n", "type": "stdin"}, {"input": "25 7\n16 12\n", "output": "YES\n", "type": "stdin"}, {"input": "58 96\n40 46\n", "output": "NO\n", "type": "stdin"}, {"input": "101 1\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "82 60\n100 64\n", "output": "YES\n", "type": "stdin"}, {"input": "9 42\n13 16\n", "output": "YES\n", "type": "stdin"}, {"input": "6 27\n5 5\n", "output": "YES\n", "type": "stdin"}, {"input": "26 17\n19 1\n", "output": "YES\n", "type": "stdin"}, {"input": "13 2\n21 5\n", "output": "NO\n", "type": "stdin"}, {"input": "1 100\n0 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 2\n12 2\n", "output": "NO\n", "type": "stdin"}, {"input": "9 16\n16 2\n", "output": "YES\n", "type": "stdin"}, {"input": "5 12\n14 11\n", "output": "YES\n", "type": "stdin"}, {"input": "36 62\n81 4\n", "output": "YES\n", "type": "stdin"}, {"input": "166 12\n87 54\n", "output": "NO\n", "type": "stdin"}, {"input": "29 1\n5 19\n", "output": "NO\n", "type": "stdin"}, {"input": "6 5\n2 10\n", "output": "YES\n", "type": "stdin"}, {"input": "12 8\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "4 6\n12 12\n", "output": "YES\n", "type": "stdin"}, {"input": "15 3\n15 16\n", "output": "YES\n", "type": "stdin"}, {"input": "30 34\n12 100\n", "output": "NO\n", "type": "stdin"}, {"input": "2 2\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "0 1\n1 1\n", "output": "YES\n", "type": "stdin"}, {"input": "100 6\n1 1\n", "output": "NO\n", "type": "stdin"}, {"input": "4 12\n10 6\n", "output": "YES\n", "type": "stdin"}, {"input": "18 3\n16 29\n", "output": "YES\n", "type": "stdin"}, {"input": "7 14\n19 91\n", "output": "YES\n", "type": "stdin"}, {"input": "1 101\n1 5\n", "output": "NO\n", "type": "stdin"}, {"input": "15 14\n15 15\n", "output": "YES\n", "type": "stdin"}, {"input": "2 4\n6 8\n", "output": "YES\n", "type": "stdin"}, {"input": "1 100\n5 2\n", "output": "YES\n", "type": "stdin"}, {"input": "3 3\n0 1\n", "output": "NO\n", "type": "stdin"}, {"input": "14 8\n2 9\n", "output": "NO\n", "type": "stdin"}, {"input": "19 4\n25 23\n", "output": "YES\n", "type": "stdin"}, {"input": "43 100\n3 24\n", "output": "NO\n", "type": "stdin"}, {"input": "18 44\n22 19\n", "output": "YES\n", "type": "stdin"}, {"input": "1 4\n1 1\n", "output": "YES\n", "type": "stdin"}, {"input": "6 11\n13 12\n", "output": "YES\n", "type": "stdin"}, {"input": "15 1\n11 0\n", "output": "NO\n", "type": "stdin"}, {"input": "15 2\n11 22\n", "output": "YES\n", "type": "stdin"}, {"input": "5 15\n13 10\n", "output": "YES\n", "type": "stdin"}, {"input": "8 22\n2 0\n", "output": "NO\n", "type": "stdin"}, {"input": "1 5\n6 1\n", "output": "YES\n", "type": "stdin"}, {"input": "150 35\n53 79\n", "output": "YES\n", "type": "stdin"}, {"input": "4 5\n3 1\n", "output": "NO\n", "type": "stdin"}, {"input": "5 1\n4 5\n", "output": "YES\n", "type": "stdin"}, {"input": "1 3\n11 6\n", "output": "NO\n", "type": "stdin"}, {"input": "65 16\n73 45\n", "output": "NO\n", "type": "stdin"}, {"input": "101 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "3 48\n8 24\n", "output": "NO\n", "type": "stdin"}, {"input": "19 10\n2 8\n", "output": "NO\n", "type": "stdin"}, {"input": "44 43\n87 39\n", "output": "YES\n", "type": "stdin"}, {"input": "11 31\n6 8\n", "output": "NO\n", "type": "stdin"}, {"input": "25 7\n0 12\n", "output": "NO\n", "type": "stdin"}, {"input": "58 96\n30 46\n", "output": "NO\n", "type": "stdin"}, {"input": "101 1\n7 1\n", "output": "NO\n", "type": "stdin"}, {"input": "82 60\n100 52\n", "output": "YES\n", "type": "stdin"}, {"input": "9 64\n13 16\n", "output": "YES\n", "type": "stdin"}, {"input": "6 46\n5 5\n", "output": "YES\n", "type": "stdin"}, {"input": "26 17\n19 0\n", "output": "YES\n", "type": "stdin"}, {"input": "11 2\n21 5\n", "output": "NO\n", "type": "stdin"}, {"input": "1 100\n0 3\n", "output": "YES\n", "type": "stdin"}, {"input": "4 2\n12 0\n", "output": "NO\n", "type": "stdin"}, {"input": "0 16\n16 2\n", "output": "YES\n", "type": "stdin"}, {"input": "5 12\n14 12\n", "output": "YES\n", "type": "stdin"}, {"input": "36 62\n85 4\n", "output": "YES\n", "type": "stdin"}, {"input": "166 12\n87 103\n", "output": "NO\n", "type": "stdin"}, {"input": "4 1\n5 19\n", "output": "NO\n", "type": "stdin"}, {"input": "12 8\n4 3\n", "output": "NO\n", "type": "stdin"}], "problem_id": "primeintellect_train_14371", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 136}, "generated_solutions": []}
{"problem": "Toad Ivan has $m$ pairs of integers, each integer is between $1$ and $n$, inclusive. The pairs are $(a_1, b_1), (a_2, b_2), \\ldots, (a_m, b_m)$. \n\nHe asks you to check if there exist two integers $x$ and $y$ ($1 \\leq x < y \\leq n$) such that in each given pair at least one integer is equal to $x$ or $y$.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers $n$ and $m$ ($2 \\leq n \\leq 300\\,000$, $1 \\leq m \\leq 300\\,000$)\u00a0\u2014 the upper bound on the values of integers in the pairs, and the number of given pairs.\n\nThe next $m$ lines contain two integers each, the $i$-th of them contains two space-separated integers $a_i$ and $b_i$ ($1 \\leq a_i, b_i \\leq n, a_i \\neq b_i$)\u00a0\u2014 the integers in the $i$-th pair.\n\n\n-----Output-----\n\nOutput \"YES\" if there exist two integers $x$ and $y$ ($1 \\leq x < y \\leq n$) such that in each given pair at least one integer is equal to $x$ or $y$. Otherwise, print \"NO\". You can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n\nOutput\nNO\n\nInput\n5 4\n1 2\n2 3\n3 4\n4 5\n\nOutput\nYES\n\nInput\n300000 5\n1 2\n1 2\n1 2\n1 2\n1 2\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example, you can't choose any $x$, $y$ because for each such pair you can find a given pair where both numbers are different from chosen integers.\n\nIn the second example, you can choose $x=2$ and $y=4$.\n\nIn the third example, you can choose $x=1$ and $y=2$.", "solutions": ["(m, n) = map(int, input().split())\na = []\nfor i in range(n):\n\t(x, y) = map(int, input().split())\n\ta.append([x, y])\nisk = (a[0][0], a[0][1])\nfor i in range(2):\n\td = isk[i]\n\tans = 0\n\tdd = [0] * (m + 1)\n\tfor j in a:\n\t\tif j[0] != d and j[1] != d:\n\t\t\tdd[j[0]] += 1\n\t\t\tdd[j[1]] += 1\n\t\t\tans += 1\n\tif max(dd) >= ans:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nnumber = [list(map(int, input().split())) for _ in range(m)]\na = number[0][0]\nb = number[0][1]\nif a > n and b > n:\n\tprint('NO')\nelse:\n\tflaga1 = 1\n\tflaga2 = 1\n\tflagb1 = 1\n\tflagb2 = 1\n\tcount = 0\n\tif a <= n:\n\t\tc = a\n\t\td = a\n\t\tfor i in number:\n\t\t\tif a not in i:\n\t\t\t\tc = i[0]\n\t\t\t\td = i[1]\n\t\t\t\tbreak\n\t\tfor i in number:\n\t\t\tif a not in i and d not in i:\n\t\t\t\tflaga1 = 0\n\t\t\t\tbreak\n\t\tfor i in number:\n\t\t\tif a not in i and c not in i:\n\t\t\t\tflaga2 = 0\n\t\t\t\tbreak\n\tif b <= n:\n\t\tc = b\n\t\td = b\n\t\tfor i in number:\n\t\t\tif b not in i:\n\t\t\t\tc = i[0]\n\t\t\t\td = i[1]\n\t\t\t\tbreak\n\t\tfor i in number:\n\t\t\tif b not in i and d not in i:\n\t\t\t\tflagb1 = 0\n\t\t\t\tbreak\n\t\tfor i in number:\n\t\t\tif b not in i and c not in i:\n\t\t\t\tflagb2 = 0\n\t\t\t\tbreak\n\tif flaga1 == 0 and flaga2 == 0 and (flagb1 == 0) and (flagb2 == 0):\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n", "import collections, heapq, sys\n(n, m) = map(int, sys.stdin.readline().rstrip().split(' '))\na = []\nfor _ in range(m):\n\t(x, y) = map(int, sys.stdin.readline().rstrip().split(' '))\n\ta.append([x, y])\n(x, y) = a[0]\n\ndef test(x):\n\tfor i in range(1, m):\n\t\t(q, w) = a[i]\n\t\tif q != x and w != x:\n\t\t\tfst = True\n\t\t\tsnd = True\n\t\t\tfor j in range(i + 1, m):\n\t\t\t\tif x in a[j]:\n\t\t\t\t\tcontinue\n\t\t\t\tif q not in a[j]:\n\t\t\t\t\tfst = False\n\t\t\t\tif w not in a[j]:\n\t\t\t\t\tsnd = False\n\t\t\t\tif not fst and (not snd):\n\t\t\t\t\treturn False\n\t\t\treturn True\n\treturn True\nif test(x) or test(y):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nif m <= 2:\n\tprint('YES')\n\texit(0)\na = list({frozenset(map(int, input().split())) for q in range(m)})\nx = list(a[0])[0]\ny = list(a[0] - {x})[0]\ns = set()\nfor q in a:\n\tif x not in q:\n\t\ts.add(q)\nif len(s) < 2:\n\tprint('YES')\n\texit(0)\ns = iter(s)\nx = set(next(s)) & next(s)\nif len(x) != 0:\n\tx = list(x)[0]\n\tfor q in s:\n\t\tif x not in q:\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit(0)\ns = set()\nfor q in a:\n\tif y not in q:\n\t\ts.add(q)\nif len(s) < 2:\n\tprint('YES')\n\texit(0)\ns = iter(s)\ny = set(next(s)) & next(s)\nif len(y) == 0:\n\tprint('NO')\n\texit(0)\ny = list(y)[0]\nfor q in s:\n\tif y not in q:\n\t\tprint('NO')\n\t\tbreak\nelse:\n\tprint('YES')\n", "def check(x, res, m):\n\tfind_y_from = 0\n\tfor i in range(1, m):\n\t\tif res[i][0] != x:\n\t\t\tif res[i][1] != x:\n\t\t\t\tfind_y_from = i\n\t\t\t\tbreak\n\tif find_y_from == 0:\n\t\tprint('YES')\n\t\treturn 1\n\telse:\n\t\ty_0 = True\n\t\ty_1 = True\n\t\ty = res[find_y_from][0]\n\t\tfor i in range(find_y_from, m):\n\t\t\tif y != res[i][0] and x != res[i][0]:\n\t\t\t\tif y != res[i][1] and x != res[i][1]:\n\t\t\t\t\ty_0 = False\n\t\t\t\t\tbreak\n\t\tif y_0 == False:\n\t\t\ty = res[find_y_from][1]\n\t\t\tfor i in range(find_y_from, m):\n\t\t\t\tif y != res[i][0] and x != res[i][0]:\n\t\t\t\t\tif y != res[i][1] and x != res[i][1]:\n\t\t\t\t\t\ty_1 = False\n\t\t\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\treturn 1\n\t\tif y_1 == True:\n\t\t\tprint('YES')\n\t\t\treturn 1\n\treturn 0\n(n, m) = map(int, input().split())\nres = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tres.append((a, b))\nx = res[0][0]\nif check(x, res, m) != 1:\n\tx = res[0][1]\n\tif check(x, res, m) != 1:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\ns1 = set(list(range(1, n + 1)))\ns2 = set(list(range(1, n + 1)))\nt = []\ncs = 0\nfor _ in range(m):\n\t(u, v) = map(int, input().split())\n\tif not t:\n\t\tt = [u, v]\n\telse:\n\t\tif t[0] in [u, v] and t[1] in [u, v]:\n\t\t\tcs += 1\n\t\tif t[0] not in [u, v]:\n\t\t\ts1 &= set([u, v])\n\t\tif t[1] not in [u, v]:\n\t\t\ts2 &= set([u, v])\nif s1 or s2:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = input().split(sep=' ')\nn = int(n)\nm = int(m)\na = []\nb = []\nfor i in range(m):\n\t(ai, bi) = input().split(sep=' ')\n\ta.append(int(ai))\n\tb.append(int(bi))\nfor x in [a[0], b[0]]:\n\tnot_ok = False\n\tsel_couple = {x}\n\tj = 0\n\tfor i in range(1, m):\n\t\tif not a[i] in sel_couple and (not b[i] in sel_couple):\n\t\t\tj = i\n\t\t\tnot_ok = True\n\t\t\tbreak\n\tif j == 0:\n\t\tbreak\n\tfor y in [a[j], b[j]]:\n\t\tnot_ok = False\n\t\tsel_couple = {x, y}\n\t\tfor i in range(1, m):\n\t\t\tif not a[i] in sel_couple and (not b[i] in sel_couple):\n\t\t\t\tsel_couple = set()\n\t\t\t\tnot_ok = True\n\t\t\t\tbreak\n\t\tif not_ok == False:\n\t\t\tbreak\n\tif not_ok == False:\n\t\tbreak\nif len(sel_couple) == 0:\n\tprint('NO')\nelse:\n\tprint('YES')\n", "(n, m) = input().split(' ')\nn = int(n)\nm = int(m)\nlala = {}\nfirst = []\nsecond = []\n(x, y) = input().split(' ')\n(x, y) = (int(x), int(y))\nlala[0] = set([x, y])\nfirst.append(x not in lala[0])\nsecond.append(y not in lala[0])\nfor i in range(1, m):\n\t(a, b) = input().split(' ')\n\t(a, b) = (int(a), int(b))\n\tlala[i] = set([a, b])\n\tfirst.append(x not in lala[i])\n\tsecond.append(y not in lala[i])\ns = set(list(range(1, n + 1)))\nfor i in range(m):\n\tif first[i]:\n\t\ts &= lala[i]\nif s == set():\n\tk = set(list(range(1, n + 1)))\n\tfor i in range(m):\n\t\tif second[i]:\n\t\t\tk &= lala[i]\n\tif k == set():\n\t\tprint('NO\\n')\n\telse:\n\t\tprint('YES\\n')\nelse:\n\tprint('YES\\n')\n", "(n, m) = list(map(int, input().split()))\n(a, b) = list(map(int, input().split()))\nar1 = [a]\nar2 = [b]\nlst = [[a, b]]\nfor i in range(m - 1):\n\tlst.append(list(map(int, input().split())))\nar3 = [0, 0]\nar4 = [0, 0]\nfor (a, b) in lst:\n\tif len(ar1) == len(ar2) == 2:\n\t\tbreak\n\tif len(ar1) != 2 and a not in ar1 and (b not in ar1):\n\t\tar1.append(a)\n\t\tar3 = [ar1[0], b]\n\tif len(ar2) != 2 and a not in ar2 and (b not in ar2):\n\t\tar2.append(a)\n\t\tar4 = [ar2[0], b]\nans = 'NO'\n(flag1, flag2, flag3, flag4) = (0, 0, 0, 0)\nfor (a, b) in lst:\n\tif a not in ar1 and b not in ar1:\n\t\tflag1 = 1\n\tif a not in ar2 and b not in ar2:\n\t\tflag2 = 1\n\tif a not in ar3 and b not in ar3:\n\t\tflag3 = 1\n\tif a not in ar4 and b not in ar4:\n\t\tflag4 = 1\nif flag1 == 0 or flag2 == 0 or flag3 == 0 or (flag4 == 0):\n\tans = 'YES'\nprint(ans)\n", "(n, m) = map(int, input().split())\nA = []\nfor i in range(m):\n\tA.append(set(map(int, input().split())))\nfor x in A[0]:\n\tunused = set(range(1, n + 1))\n\tfor pair in A[1:]:\n\t\tif x not in pair:\n\t\t\tunused.intersection_update(set(pair))\n\tif len(unused) != 0:\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "(n, m) = input().split()\nm = int(m)\nnum_fre = {}\nnum = []\nnum_set = {}\npair_fre = {}\nif m == 1:\n\tprint('YES')\nelse:\n\tfor _ in range(m):\n\t\t(a, b) = input().split()\n\t\ta = int(a)\n\t\tb = int(b)\n\t\tif a not in num_fre:\n\t\t\tnum_fre[a] = 0\n\t\t\tnum.append(a)\n\t\tif b not in num_fre:\n\t\t\tnum.append(b)\n\t\t\tnum_fre[b] = 0\n\t\tp = tuple(sorted([a, b]))\n\t\tif p not in pair_fre:\n\t\t\tpair_fre[p] = 0\n\t\tpair_fre[p] += 1\n\t\tnum_fre[a] += 1\n\t\tnum_fre[b] += 1\n\tnum.sort(reverse=True, key=lambda x: num_fre[x])\n\tif num_fre[num[0]] < m // 2:\n\t\tvalid = False\n\telse:\n\t\tfor i in range(len(num)):\n\t\t\tcur = num_fre[num[i]]\n\t\t\tvalid = False\n\t\t\tfor j in range(i + 1, len(num)):\n\t\t\t\ttmp = num_fre[num[j]]\n\t\t\t\tif cur + tmp < m:\n\t\t\t\t\tbreak\n\t\t\t\tif cur + tmp >= m:\n\t\t\t\t\tp = tuple(sorted([num[i], num[j]]))\n\t\t\t\t\tcommon = 0\n\t\t\t\t\tif p in pair_fre:\n\t\t\t\t\t\tcommon = pair_fre[p]\n\t\t\t\t\tt = cur + tmp - common\n\t\t\t\t\tif t == m:\n\t\t\t\t\t\tvalid = True\n\t\t\t\tif valid == True:\n\t\t\t\t\tbreak\n\t\t\tif valid == True:\n\t\t\t\tbreak\n\tif valid == True:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = tuple(map(int, input().split()))\nx = []\nfor i in range(m):\n\tpair = tuple(map(int, input().split()))\n\tx.append(pair)\nif m == 1:\n\tprint('YES')\n\texit(0)\ns = None\ntop = x[0][0]\nfor i in range(1, m):\n\tif x[i][0] != top and x[i][1] != top:\n\t\tif s is None:\n\t\t\ts = set(x[i])\n\t\telse:\n\t\t\ts &= set(x[i])\nif s is None or len(s) != 0:\n\tprint('YES')\n\texit(0)\ns = None\ntop = x[0][1]\nfor i in range(1, m):\n\tif x[i][0] != top and x[i][1] != top:\n\t\tif s is None:\n\t\t\ts = set(x[i])\n\t\telse:\n\t\t\ts &= set(x[i])\nif s is None or len(s) != 0:\n\tprint('YES')\n\texit(0)\nprint('NO')\n", "import math, sys, bisect, heapq\nfrom collections import defaultdict, Counter, deque\nfrom itertools import groupby, accumulate\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda : map(int, input().split())\nalele = lambda : list(map(int, input().split()))\nfrom functools import lru_cache\n\ndef list2d(a, b, c):\n\treturn [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d):\n\treturn [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):\n\tprint(['NO', 'YES'][c])\n\ndef y(c):\n\tprint(['no', 'yes'][c])\n\ndef Yy(c):\n\tprint(['No', 'Yes'][c])\n(n, m) = ilele()\nA = []\nfor i in range(m):\n\t(a, b) = ilele()\n\tA.append((a, b))\n\ndef fun(x):\n\t(y1, y2) = (-1, -1)\n\t(f1, f2) = (1, 1)\n\tfor i in range(1, m):\n\t\tx1 = A[i][0]\n\t\tx2 = A[i][1]\n\t\tif x1 != x and x2 != x:\n\t\t\tif y1 == -1:\n\t\t\t\ty1 = x1\n\t\t\t\ty2 = x2\n\t\t\telse:\n\t\t\t\tif x1 != y1 and x2 != y1:\n\t\t\t\t\tf1 = 0\n\t\t\t\tif x1 != y2 and x2 != y2:\n\t\t\t\t\tf2 = 0\n\treturn f1 or f2\nY(fun(A[0][0]) or fun(A[0][1]))\n", "(n, m) = map(int, input().split())\na = []\nb = []\ny = -1\nfor i in range(m):\n\ta.append(list(map(int, input().split())))\n\tb.append(set(a[-1]))\n\tif i >= 1 and y == -1:\n\t\tif not b[0] & b[-1]:\n\t\t\ty = i\nif m <= 2 or y == -1:\n\tprint('YES')\nelse:\n\t(c, d, e, f) = (*a[0], *a[y])\n\tx = [{c, e}, {c, f}, {d, e}, {d, f}]\n\tz = [True, True, True, True]\n\tfor pair in b:\n\t\tfor zp in [0, 1, 2, 3]:\n\t\t\tz[zp] = z[zp] if pair & x[zp] else False\n\tif z[0] or z[1] or z[2] or z[3]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\ndic = {}\npairs = []\noutputy = 0\nfor i in range(m):\n\tlis2 = list(map(int, input().split()))\n\tpairs.append(lis2)\nfor i in range(2):\n\tx = pairs[0][i]\n\tdic[x] = 1\n\tfor j in range(1, m):\n\t\tif x in pairs[j]:\n\t\t\tdic[x] += 1\n\t\telse:\n\t\t\tdic[pairs[j][0]] = dic.get(pairs[j][0], 0) + 1\n\t\t\tdic[pairs[j][1]] = dic.get(pairs[j][1], 0) + 1\n\tif dic[x] == m:\n\t\tprint('YES')\n\t\tbreak\n\tfor (y, value) in dic.items():\n\t\tif value == m - dic[x] and y != x:\n\t\t\toutputy = y\n\t\t\tbreak\n\tif outputy != 0:\n\t\tprint('YES')\n\t\tbreak\n\tdic = {}\nelse:\n\tprint('NO')\n", "def checkCommon(tuple1, tuple2):\n\ttemp = set()\n\ttemp.add(tuple1[0])\n\ttemp.add(tuple1[1])\n\ttemp.add(tuple2[0])\n\ttemp.add(tuple2[1])\n\tif len(temp) == 4:\n\t\treturn False\n\telse:\n\t\treturn True\n\ndef main():\n\t[n, m] = list(map(int, input().split()))\n\tar = list()\n\tfor i in range(m):\n\t\tpair = tuple(map(int, input().split()))\n\t\tar.append(pair)\n\tfirst = ar[0]\n\tflag = 0\n\tfor i in range(1, m):\n\t\tsecond = ar[i]\n\t\tif checkCommon(first, second) == False:\n\t\t\tflag = 1\n\t\t\tx = [first[0], first[1]]\n\t\t\ty = [second[0], second[1]]\n\t\t\tbreak\n\tif flag == 0:\n\t\tprint('YES')\n\telse:\n\t\tfor i in x:\n\t\t\tfor j in y:\n\t\t\t\tflag = 0\n\t\t\t\tfor k in range(m):\n\t\t\t\t\tif i not in ar[k] and j not in ar[k]:\n\t\t\t\t\t\tflag = 1\n\t\t\t\tif flag == 0:\n\t\t\t\t\tprint('YES')\n\t\t\t\t\treturn\n\t\tprint('NO')\nmain()\n", "(n, m) = map(int, input().split())\nd = {}\np = []\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tif x == y:\n\t\td[x] = d.get(x, 0) + 1\n\telse:\n\t\td[x] = d.get(x, 0) + 1\n\t\td[y] = d.get(y, 0) + 1\n\tp.append([x, y])\nxx = []\nx = 0\nfor i in d:\n\tif d[i] >= m / 2:\n\t\txx.append(i)\nif len(xx) == 0:\n\tprint('NO')\n\texit()\ny = 0\nfor x in xx:\n\tp1 = []\n\tfor i in p:\n\t\tif i[0] != x and i[1] != x:\n\t\t\tp1.append(i)\n\td1 = {}\n\tfor i in p1:\n\t\tif i[0] == i[1]:\n\t\t\td1[i[0]] = d1.get(i[0], 0) + 1\n\t\telse:\n\t\t\td1[i[0]] = d1.get(i[0], 0) + 1\n\t\t\td1[i[1]] = d1.get(i[1], 0) + 1\n\tif len(d1) == 0 or max(d1.values()) == len(p1):\n\t\ty += 1\nif y != 0:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from collections import defaultdict\n(n, m) = list(map(int, input().split()))\nfreq = [0 for i in range(n + 1)]\narr = []\nf = 0\nfor i in range(m):\n\t(u, v) = list(map(int, input().split()))\n\tif f == 0:\n\t\ttemp = [u, v]\n\t\tf = 1\n\tp = [u, v]\n\tp = set(p)\n\tarr.append(p)\nfor i in temp:\n\tans = []\n\tfor j in arr:\n\t\tx = list(j)\n\t\tif i in x:\n\t\t\tcontinue\n\t\telse:\n\t\t\tans.append(j)\n\tif ans == []:\n\t\tprint('YES')\n\t\texit()\n\telse:\n\t\tx = ans[0]\n\t\tf = 0\n\t\tfor j in range(1, len(ans)):\n\t\t\ty = ans[j]\n\t\t\tx = x.intersection(y)\n\t\t\tif x == set():\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\tif f == 0:\n\t\t\tprint('YES')\n\t\t\texit()\nprint('NO')\n", "(n, m) = [int(i) for i in input().split()]\nl = []\nfor i in range(m):\n\tl.append([int(i) - 1 for i in input().split()])\nfor i in range(2):\n\tval = [0 for i in range(n)]\n\ta = l[0][i]\n\talx = 0\n\tfor x in range(m):\n\t\tif l[x][0] != a and l[x][1] != a:\n\t\t\tval[l[x][0]] += 1\n\t\t\tval[l[x][1]] += 1\n\t\t\talx += 1\n\tmaxx = -1\n\tfor y in range(n):\n\t\tmaxx = max(maxx, val[y])\n\tif alx == maxx:\n\t\tprint('YES')\n\t\tbreak\n\telif i == 1:\n\t\tprint('NO')\n", "(a, b) = map(int, input().split())\n(q, w) = map(int, input().split())\nx1 = q\nk1 = True\nk2 = True\nx2 = w\nA1 = []\nA2 = []\nfor i in range(b - 1):\n\tB = list(map(int, input().split()))\n\tif x1 not in set(B):\n\t\tif len(A1) != 0 and k1 == True:\n\t\t\tA1 = list(set(A1) & set(B))\n\t\t\tif len(A1) == 0:\n\t\t\t\tk1 = False\n\t\telif k1 == True:\n\t\t\tA1 = B[:]\n\tif x2 not in set(B):\n\t\tif len(A2) != 0 and k2 == True:\n\t\t\tA2 = list(set(A2) & set(B))\n\t\t\tif len(A2) == 0:\n\t\t\t\tk2 = False\n\t\telif k2 == True:\n\t\t\tA2 = B[:]\nif k1 == True or k2 == True:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from sys import stdin, setrecursionlimit\nimport heapq\n\ndef get_count(num, old_flag):\n\tflag = [0] * len(pairs)\n\tcount = 0\n\tfor i in range(len(pairs)):\n\t\tif num in pairs[i] and old_flag[i] == 0:\n\t\t\tflag[i] = 1\n\t\t\tcount += 1\n\treturn (count, flag)\n\ndef no_interest(num, flag):\n\tfor i in range(len(pairs)):\n\t\tif num not in pairs[i] and flag[i] == 0:\n\t\t\treturn i\n\treturn -1\nsetrecursionlimit(15000)\n(n, m) = list(map(int, stdin.readline().split()))\npairs = []\nfor _ in range(m):\n\tpairs.append(list(map(int, stdin.readline().split())))\nflag = [0] * m\n(c1, flag) = get_count(pairs[0][0], flag)\nindex = no_interest(pairs[0][0], flag)\nif index == -1:\n\tprint('YES')\n\texit()\n(c2, flag2) = get_count(pairs[index][0], flag)\n(c3, flag2) = get_count(pairs[index][1], flag)\nif c1 + c2 == m or c1 + c3 >= m:\n\tprint('YES')\nelse:\n\tflag = [0] * m\n\t(c1, flag) = get_count(pairs[0][1], flag)\n\tindex = no_interest(pairs[0][1], flag)\n\tif index == -1:\n\t\tprint('YES')\n\t\texit()\n\t(c2, flag2) = get_count(pairs[index][0], flag)\n\t(c3, flag2) = get_count(pairs[index][1], flag)\n\tif c1 + c2 == m or c1 + c3 == m:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\npair = [-1 for i in range(m)]\ni = 0\nwhile i < m:\n\tpair[i] = list(map(int, input().split()))\n\ti += 1\nx = pair[0]\nfor i in x:\n\tcnt = [0 for i in range(n + 1)]\n\tcnter = 0\n\tfor j in pair:\n\t\tif j[0] != i and j[1] != i:\n\t\t\tcnt[j[0]] += 1\n\t\t\tcnt[j[1]] += 1\n\t\t\tcnter += 1\n\tif max(cnt) == cnter:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\ta.append(list(map(int, input().split())))\nx = a[0][0]\ny = a[0][1]\nd = {}\nf = 0\nc = 0\nfor i in range(1, m):\n\tif a[i][0] != x and a[i][1] != x:\n\t\tif d.get(a[i][0], 0) == c:\n\t\t\td[a[i][0]] = d.get(a[i][0], 0) + 1\n\t\tif d.get(a[i][1], 0) == c:\n\t\t\td[a[i][1]] = d.get(a[i][1], 0) + 1\n\t\tif d.get(a[i][0], 0) != c + 1 and d.get(a[i][1], 0) != c + 1:\n\t\t\tf = 1\n\t\t\tbreak\n\t\tc += 1\nd1 = {}\nc = 0\nif f == 0:\n\texit(print('YES'))\nif f == 1:\n\tfor i in range(1, m):\n\t\tif a[i][0] != y and a[i][1] != y:\n\t\t\tif d1.get(a[i][0], 0) == c:\n\t\t\t\td1[a[i][0]] = d1.get(a[i][0], 0) + 1\n\t\t\tif d1.get(a[i][1], 0) == c:\n\t\t\t\td1[a[i][1]] = d1.get(a[i][1], 0) + 1\n\t\t\tif d1.get(a[i][0], 0) != c + 1 and d1.get(a[i][1], 0) != c + 1:\n\t\t\t\tf = 2\n\t\t\t\tbreak\n\t\t\tc += 1\nif f == 1:\n\texit(print('YES'))\nexit(print('NO'))\nprint(d, d1, f)\nif f == 0:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "def solve(max_number, count):\n\tpairs = [[0, 0] for _ in range(count)]\n\tfor i in range(count):\n\t\t(a, b) = map(int, input().split())\n\t\tpairs[i][0] = a\n\t\tpairs[i][1] = b\n\t(x, y) = pairs[0]\n\tfor v in (x, y):\n\t\tcounts = [0] * (max_number + 1)\n\t\talls = 0\n\t\tfor (p1, p2) in pairs:\n\t\t\tif p1 != v and p2 != v:\n\t\t\t\tcounts[p1] += 1\n\t\t\t\tcounts[p2] += 1\n\t\t\t\talls += 1\n\t\tif max(counts) == alls:\n\t\t\treturn 'YES'\n\treturn 'NO'\n(n, m) = map(int, input().split())\ns = solve(n, m)\nprint(s)\n", "(n, m) = [int(i) for i in input().split()]\nlst = list()\nfor j in range(m):\n\t(x, y) = [int(z) for z in input().split()]\n\tlst.append([x, y])\ncount = 0\npair = lst[0]\nfor v in pair:\n\ta = [0] * (n + 1)\n\tcount = 0\n\tfor elem in lst:\n\t\tif elem[0] != v and elem[1] != v:\n\t\t\ta[elem[0]] = a[elem[0]] + 1\n\t\t\ta[elem[1]] = a[elem[1]] + 1\n\t\t\tcount += 1\n\tif count in a:\n\t\tprint('YES')\n\t\tquit()\nprint('NO')\n", "from copy import copy\nii = lambda : int(input())\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nsi = lambda : input()\n(n, m) = li()\na = []\nfor i in range(m):\n\ta.append(li())\ns = set(range(1, n + 1))\nfor x in (a[0][0], a[0][1]):\n\ts1 = copy(s)\n\tfor i in range(1, m):\n\t\t(p, q) = a[i]\n\t\tif x != p and x != q:\n\t\t\ts1.intersection_update({p, q})\n\tif len(s1):\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "(n, m) = map(int, input().split())\npairs = [tuple((int(x) for x in input().split())) for _ in range(m)]\npossible = {pairs[0], (pairs[0][0], None), (pairs[0][1], None)}\nfor p in pairs[1:]:\n\tadd = set()\n\tremove = set()\n\tfor o in possible:\n\t\tif p[0] in o or p[1] in o:\n\t\t\tcontinue\n\t\tremove.add(o)\n\t\tif o[1] is None:\n\t\t\tadd.add((o[0], p[0]))\n\t\t\tadd.add((o[0], p[1]))\n\tpossible = possible - remove | add\n\tif not possible:\n\t\tbreak\nif not possible:\n\tprint('NO')\nelse:\n\tprint('YES')\n", "(n, m) = list(map(int, input().split()))\np = set()\nfor i in range(m):\n\tp.add(tuple(map(int, input().split())))\nif len(p) == 1:\n\tprint('YES')\n\texit(0)\n(x, y) = p.pop()\nnotx = []\nnoty = []\nfor (a, b) in p:\n\tif x not in (a, b):\n\t\tnotx.append(set([a, b]))\n\tif y not in (a, b):\n\t\tnoty.append(set([a, b]))\n(inotx, inoty) = (False, False)\nif notx:\n\tinotx = set.intersection(*notx)\nif noty:\n\tinoty = set.intersection(*noty)\nif inotx or inoty:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from sys import stdin\ninput = stdin.readline\n(n, m) = map(int, input().split())\nd = []\nfor i in range(m):\n\td.append(list(map(int, input().split())))\nx = d[0][0]\ny = d[0][1]\nc = []\ne = []\ng = []\nfor i in d:\n\tif x in i:\n\t\tc.append(i)\n\tif y in i:\n\t\te.append(i)\n\tif x not in i and y not in i:\n\t\tg.append(i)\nif len(g) == 0:\n\texit(print('YES'))\ns = set(g[0])\nfor i in g:\n\ts = s.intersection(set(i))\nif len(s) == 0:\n\texit(print('NO'))\nk = list(s)\nfor s in k:\n\tfl1 = fl2 = 1\n\tfor i in c:\n\t\tif s not in i and y not in i:\n\t\t\tfl1 = 0\n\t\t\tbreak\n\tfor i in e:\n\t\tif s not in i and x not in i:\n\t\t\tfl2 = 0\n\t\t\tbreak\n\tif fl1 or fl2:\n\t\texit(print('YES'))\nprint('NO')\n", "import sys\n(N, M) = map(int, input().split())\nP = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\nidx = P[0][0]\nS = set()\nfor (i, (a, b)) in enumerate(P):\n\tif a == idx or b == idx:\n\t\tcontinue\n\tbreak\nelse:\n\tprint('YES')\n\treturn\nS = set([P[i][0], P[i][1]])\nfor (a, b) in P[i:]:\n\tif a == idx or b == idx:\n\t\tcontinue\n\tS.intersection_update(set([a, b]))\n\tif not S:\n\t\tbreak\nelse:\n\tprint('YES')\n\treturn\nidx = P[0][1]\nS = set()\nfor (i, (a, b)) in enumerate(P):\n\tif a == idx or b == idx:\n\t\tcontinue\n\tbreak\nelse:\n\tprint('YES')\n\treturn\nS = set([P[i][0], P[i][1]])\nfor (a, b) in P[i:]:\n\tif a == idx or b == idx:\n\t\tcontinue\n\tS.intersection_update(set([a, b]))\n\tif not S:\n\t\tbreak\nelse:\n\tprint('YES')\n\treturn\nprint('NO')\n", "from sys import stdin, stdout\nimport math, bisect\nfrom collections import Counter, deque, defaultdict\nL = lambda : list(map(int, stdin.readline().strip().split()))\nM = lambda : map(int, stdin.readline().strip().split())\nI = lambda : int(stdin.readline().strip())\nS = lambda : stdin.readline().strip()\nC = lambda : stdin.readline().strip().split()\n\ndef pr(a):\n\tprint(' '.join(list(map(str, a))))\n\ndef solve():\n\t(n, m) = M()\n\ta = []\n\tfor i in range(m):\n\t\t(x, y) = M()\n\t\ta += [(x, y)]\n\tfor i in a[0]:\n\t\tc = 0\n\t\tb = [0] * (n + 1)\n\t\tfor j in a:\n\t\t\tif j[0] != i and j[1] != i:\n\t\t\t\tb[j[0]] += 1\n\t\t\t\tb[j[1]] += 1\n\t\t\t\tc += 1\n\t\tif max(b) == c:\n\t\t\tprint('YES')\n\t\t\treturn\n\tprint('NO')\nfor _ in range(1):\n\tsolve()\n", "a = [int(i) for i in input().split()]\nn = a[0]\nm = a[1]\narr = [0 for i in range(n)]\nmaxa1 = 0\nmaxa2 = 0\ninputa = []\nfor i in range(m):\n\tx = [int(i) for i in input().split()]\n\tx[0] -= 1\n\tx[1] -= 1\n\tinputa.append(x)\n\tarr[x[0]] += 1\n\tarr[x[1]] += 1\nans = []\nfor i in range(n):\n\tif arr[i] >= m // 2:\n\t\tans.append(i)\nval1 = -1\nval2 = -1\nflag = 0\nfor i in ans:\n\tcount = 0\n\tfreq = [0 for k in range(n)]\n\tval1 = i\n\tfor j in inputa:\n\t\tif j[0] == i or j[1] == i:\n\t\t\tcount += 1\n\t\telse:\n\t\t\tfreq[j[0]] += 1\n\t\t\tfreq[j[1]] += 1\n\tfor k in range(n):\n\t\tif freq[k] == m - count:\n\t\t\tval2 = k\n\t\t\tflag = 1\n\t\t\tbreak\nif flag == 1:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nnums_list = []\nfor i in range(m):\n\t(n1, n2) = map(int, input().split())\n\tnums_list.append([n1, n2])\nflag = True\nouterloopflag = False\nfor i in nums_list[0]:\n\tj = 1\n\twhile j < m and i in nums_list[j]:\n\t\tj += 1\n\tif j == m:\n\t\tprint('YES')\n\t\tflag = False\n\t\tbreak\n\telse:\n\t\tfor x in nums_list[j]:\n\t\t\tk = j + 1\n\t\t\twhile k < m and (x in nums_list[k] or i in nums_list[k]):\n\t\t\t\tk += 1\n\t\t\tif k == m:\n\t\t\t\tprint('YES')\n\t\t\t\tflag = False\n\t\t\t\touterloopflag = True\n\t\t\t\tbreak\n\t\t\telif k < m and i in nums_list[k]:\n\t\t\t\tk += 1\n\tif outerloopflag:\n\t\tbreak\nif flag:\n\tprint('NO')\n", "s = input()\n(n, m) = map(int, s.split(' '))\nlst = []\nfor i in range(m):\n\ts = input()\n\t(a, b) = map(int, s.split(' '))\n\tlst.append([a, b])\np = 0\nvarx = lst[0]\nfor v in varx:\n\txy_list = [0] * (n + 1)\n\tp = 0\n\tfor item in lst:\n\t\tif item[0] != v and item[1] != v:\n\t\t\txy_list[item[0]] = xy_list[item[0]] + 1\n\t\t\txy_list[item[1]] = xy_list[item[1]] + 1\n\t\t\tp += 1\n\tif p in xy_list:\n\t\tprint('YES')\n\t\tquit()\nprint('NO')\n", "(n, m) = map(int, input().split())\na = [[*map(int, input().split())] for _ in range(m)]\n\ndef g():\n\tfor z in range(2):\n\t\tx = a[0][z]\n\t\tfor i in range(m):\n\t\t\tif x not in a[i]:\n\t\t\t\tbreak\n\t\telse:\n\t\t\treturn 0\n\t\tfor w in range(2):\n\t\t\ty = a[i][w]\n\t\t\tfor j in range(m):\n\t\t\t\tif x not in a[j] and y not in a[j]:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\treturn 0\n\treturn 1\nprint('YNEOS'[g()::2])\n", "from sys import stdin\n(n, m) = map(int, stdin.readline().split())\nedges = []\nfor i in range(m):\n\t(a, b) = map(int, stdin.readline().split())\n\tedges.append((a, b))\npin = edges[0][0]\npinn = edges[0][1]\nfedges = list(filter(lambda x: pin not in x, edges))\nfedgess = list(filter(lambda x: pinn not in x, edges))\nif len(fedges) == 0 or len(fedgess) == 0:\n\tprint('YES')\nelse:\n\tpin1 = fedges[0][0]\n\tpin2 = fedges[0][1]\n\tpin11 = fedgess[0][0]\n\tpin22 = fedgess[0][1]\n\tp1edges = list(filter(lambda x: pin1 not in x, fedges))\n\tp2edges = list(filter(lambda x: pin2 not in x, fedges))\n\txdges = list(filter(lambda x: pin11 not in x, fedgess))\n\txdgess = list(filter(lambda x: pin22 not in x, fedgess))\n\tif len(p1edges) == 0 or len(p2edges) == 0 or len(xdges) == 0 or (len(xdgess) == 0):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "t = 1\nfor test in range(t):\n\tans = 'NO'\n\t(n, m) = list(map(int, input().split()))\n\tarr = []\n\tfor i in range(m):\n\t\t(a, b) = list(map(int, input().split()))\n\t\ttmp = [a, b]\n\t\tarr.append(tmp)\n\tx = arr[0][0]\n\ty = [i for i in range(n + 1)]\n\ty = set(y)\n\tfor pair in arr:\n\t\tif x not in pair:\n\t\t\ty = y.intersection(set(pair))\n\tif len(y) > 0:\n\t\tans = 'YES'\n\tx = arr[0][1]\n\ty = [i for i in range(n + 1)]\n\ty = set(y)\n\tfor pair in arr:\n\t\tif x not in pair:\n\t\t\ty = y.intersection(set(pair))\n\tif len(y) > 0:\n\t\tans = 'YES'\n\tprint(ans)\n", "(n, m) = [int(x) for x in input().split()]\nall_pairs = []\nfor i in range(m):\n\tp = [int(x) for x in input().split()]\n\tall_pairs.append(p)\nok = False\nfor x in p:\n\tcandidate = None\n\tfor e in all_pairs:\n\t\tif e[0] != x and e[1] != x:\n\t\t\tcandidate = e\n\t\t\tbreak\n\tif candidate == None:\n\t\tok = True\n\t\tbreak\n\telse:\n\t\tc1 = True\n\t\tc2 = True\n\t\tfor e in all_pairs:\n\t\t\tif e[0] != x and e[0] != candidate[0] and (e[1] != x) and (e[1] != candidate[0]):\n\t\t\t\tc1 = False\n\t\t\t\tif c2 == False:\n\t\t\t\t\tbreak\n\t\t\tif e[0] != x and e[0] != candidate[1] and (e[1] != x) and (e[1] != candidate[1]):\n\t\t\t\tc2 = False\n\t\t\t\tif c1 == False:\n\t\t\t\t\tbreak\n\t\tif c1 == True or c2 == True:\n\t\t\tok = True\n\t\t\tbreak\nif ok:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nlst = [list(map(int, input().split())) for x in range(m)]\npossible = False\nfirst = set(lst[0])\nfor i in first:\n\t_other = []\n\tfor j in lst[1:]:\n\t\tif i not in j:\n\t\t\t_other += [j]\n\tif _other:\n\t\tk = set(_other[0])\n\t\tfor l in _other[1:]:\n\t\t\tk &= set(l)\n\t\tif k and i != k.pop():\n\t\t\tpossible = True\n\t\t\tbreak\n\telse:\n\t\tpossible = True\n\t\tbreak\nif possible:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "def check(a, b, d, m):\n\tf = a in d[b]\n\tif f:\n\t\treturn len(d[a]) + len(d[b]) - 1 == m\n\treturn len(d[a]) + len(d[b]) == m\nfrom collections import Counter\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\td = {i + 1: [] for i in range(n)}\n\ttots = []\n\trealm = 0\n\tvisited = set()\n\tfor i in range(m):\n\t\t(u, v) = map(int, input().split())\n\t\tif (u, v) in visited or (v, u) in visited:\n\t\t\tcontinue\n\t\td[u].append(v)\n\t\td[v].append(u)\n\t\ttots.append(u)\n\t\ttots.append(v)\n\t\trealm += 1\n\t\tvisited.add((u, v))\n\tm = realm\n\tcnt = Counter(tots)\n\tmlist = [(k, v) for (k, v) in cnt.items()]\n\tmlist.sort(key=lambda x: x[1], reverse=True)\n\tmx = mlist[0][1]\n\tflag = False\n\tl = len(mlist)\n\tfor i in range(l):\n\t\t(k1, v1) = mlist[i]\n\t\tif cnt[k1] + mx < m:\n\t\t\tbreak\n\t\tfor j in range(i + 1, l):\n\t\t\t(k2, v2) = mlist[j]\n\t\t\tif cnt[k2] + cnt[k1] < m:\n\t\t\t\tbreak\n\t\t\telif check(k1, k2, d, m):\n\t\t\t\tflag = True\n\t\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\tdel d\nsolve()\n", "def check_valid(ls, x, y):\n\tfor p in ls:\n\t\tif p[0] != x and p[0] != y and (p[1] != x) and (p[1] != y):\n\t\t\treturn False\n\treturn True\n\ndef find_pair(ls):\n\tfor x in ls[0]:\n\t\tif check_valid(ls, x, -1):\n\t\t\treturn True\n\t\tfor i in range(1, m):\n\t\t\tif ls[i][0] != x and ls[i][1] != x:\n\t\t\t\tif check_valid(ls, x, ls[i][0]) or check_valid(ls, x, ls[i][1]):\n\t\t\t\t\treturn True\n\t\t\t\tbreak\n\treturn False\n(n, m) = map(int, input().split())\nls = []\nfor _ in range(m):\n\t(a, b) = map(int, input().split())\n\tls.append([a, b])\nif find_pair(ls):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from math import *\n\ndef sol():\n\t(n, m) = [int(x) for x in input().split()]\n\tarr = [0] * n\n\trep = dict()\n\tfor i in range(m):\n\t\t(a, b) = [int(x) for x in input().split()]\n\t\tarr[a - 1] += 1\n\t\tarr[b - 1] += 1\n\t\tif (a, b) in rep:\n\t\t\trep[a, b] += 1\n\t\telse:\n\t\t\trep[a, b] = 1\n\tcandidates = []\n\tfor i in range(1, n + 1):\n\t\tif arr[i - 1] >= m / 2:\n\t\t\tcandidates += [i]\n\tfor i in candidates:\n\t\tfor j in range(1, n + 1):\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tx = arr[i - 1]\n\t\t\ty = arr[j - 1]\n\t\t\tintersect = rep.get((i, j), 0) + rep.get((j, i), 0)\n\t\t\tif x + y - intersect >= m:\n\t\t\t\treturn 'YES'\n\treturn 'NO'\nprint(sol())\n", "import sys\ninput = sys.stdin.readline\n\ndef ii():\n\treturn int(input())\n\ndef mi():\n\treturn map(int, input().rstrip().split())\n\ndef lmi():\n\treturn list(map(int, input().rstrip().split()))\n\ndef li():\n\treturn list(input().rstrip())\n(n, m) = mi()\nl = [0] * m\nr = [0] * m\nfor i in range(m):\n\t(l[i], r[i]) = mi()\nlf = l[0]\nrf = r[0]\nflag = True\nfor i in range(m):\n\tif l[i] != lf and r[i] != lf:\n\t\tif l[i] != rf and r[i] != rf:\n\t\t\tlf2 = l[i]\n\t\t\trf2 = r[i]\n\t\t\tflag = False\n\t\t\tbreak\nif flag:\n\tprint('YES')\n\tsys.exit()\nLis = [lf, rf, lf2, rf2]\nfor i in range(3):\n\tfor j in range(i + 1, 4):\n\t\tleft = Lis[i]\n\t\tright = Lis[j]\n\t\tfor cnt in range(m):\n\t\t\tif l[cnt] != left and r[cnt] != left:\n\t\t\t\tif l[cnt] != right and r[cnt] != right:\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\tsys.exit()\nprint('NO')\n", "(n, m) = list(map(int, input().split()))\narr = []\nfor i in range(0, m):\n\t(a, b) = list(map(int, input().split()))\n\tarr.append([a, b])\nx1 = arr[0][0]\nx2 = arr[0][1]\ny1 = 0\ny2 = 0\nfor i in range(0, m):\n\tif x1 in arr[i] or x2 in arr[i]:\n\t\tskb = 1\n\telse:\n\t\ty1 = arr[i][0]\n\t\ty2 = arr[i][1]\n\t\tbreak\n\tif i == m - 1:\n\t\ty1 = arr[i][0]\n\t\ty2 = arr[i][1]\nflag = 0\nfor i in range(0, m):\n\tif x1 not in arr[i] and y1 not in arr[i]:\n\t\tbreak\n\tif i == m - 1:\n\t\tflag = 1\nfor i in range(0, m):\n\tif x1 not in arr[i] and y2 not in arr[i]:\n\t\tbreak\n\tif i == m - 1:\n\t\tflag = 1\nfor i in range(0, m):\n\tif x2 not in arr[i] and y1 not in arr[i]:\n\t\tbreak\n\tif i == m - 1:\n\t\tflag = 1\nfor i in range(0, m):\n\tif x2 not in arr[i] and y2 not in arr[i]:\n\t\tbreak\n\tif i == m - 1:\n\t\tflag = 1\nif flag == 1:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "input = __import__('sys').stdin.readline\nprint = __import__('sys').stdout.write\n(n, m) = map(int, input().split())\ntotal = [False for _ in range(m)]\nfor i in range(m):\n\ttotal[i] = tuple(input().split())\nk = True\nidx = 0\nfor test_case in [[total[i][0]], [total[i][1]]]:\n\ttest_filled = False\n\tidx = 0\n\tsecond = ''\n\tfor i in range(m):\n\t\tfor item in test_case:\n\t\t\tif item in total[i]:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tif not test_filled:\n\t\t\t\ttest_case.append(total[i][0])\n\t\t\t\tsecond = total[i][1]\n\t\t\t\ttest_filled = True\n\t\t\telse:\n\t\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit()\n\ttest_case[1] = second\n\tfor i in range(idx, m):\n\t\tfor item in test_case:\n\t\t\tif item in total[i]:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit()\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\npairs = []\nfor _ in range(m):\n\t(x, y) = map(int, input().split())\n\tpairs.append((x, y))\nfor first in (pairs[0][0], pairs[0][1]):\n\tval = [0] * n\n\tall = 0\n\tfor pair in pairs:\n\t\tif pair[0] != first and pair[1] != first:\n\t\t\tval[pair[0] - 1] += 1\n\t\t\tval[pair[1] - 1] += 1\n\t\t\tall += 1\n\tif max(val) == all:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\nexit()\n", "from sys import stdin\n\ndef input():\n\treturn stdin.readline().strip()\nfrom itertools import permutations, combinations\n(m, n) = map(int, input().split())\npairs = []\nfor i in range(n):\n\t(a, b) = map(int, input().split())\n\tpairs.append((a, b))\nif n == 1:\n\tprint('YES')\nelse:\n\tpossible = set([pairs[0][0], pairs[0][1]])\n\tflag = True\n\tfor i in range(n):\n\t\tif pairs[i][0] in possible or pairs[i][1] in possible:\n\t\t\tcontinue\n\t\telif len(possible) == 4:\n\t\t\tflag = False\n\t\t\tbreak\n\t\telse:\n\t\t\tpossible.add(pairs[i][0])\n\t\t\tpossible.add(pairs[i][1])\n\tif flag:\n\t\tpossible = list(possible)\n\t\tx_y = list(combinations(possible, 2))\n\t\tfor (x, y) in x_y:\n\t\t\tx_y_ = set([x, y])\n\t\t\tflag = True\n\t\t\tfor i in range(n):\n\t\t\t\tif pairs[i][0] in x_y_ or pairs[i][1] in x_y_:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tflag = False\n\t\t\t\t\tbreak\n\t\t\tif flag:\n\t\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "arr = input()\n(N, M) = [int(x) for x in arr.split(' ')]\ndata = [[0] * 2 for _ in range(M)]\nfor i in range(M):\n\tarr = input()\n\t(A, B) = [int(x) for x in arr.split(' ')]\n\tdata[i][0] = A\n\tdata[i][1] = B\npair = [[0, 0], [0, 0], [0, 0], [0, 0]]\nk = 0\nfor x in data[0]:\n\tfor i in range(M):\n\t\tif x not in data[i]:\n\t\t\tpair[k][0] = x\n\t\t\tpair[k][1] = data[i][0]\n\t\t\tk += 1\n\t\t\tpair[k][0] = x\n\t\t\tpair[k][1] = data[i][1]\n\t\t\tk += 1\n\t\t\tbreak\nfor p in pair:\n\tA = p[0]\n\tB = p[1]\n\tflag = 0\n\tif A != 0 and B != 0:\n\t\tfor i in range(M):\n\t\t\tif A not in data[i] and B not in data[i]:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\tif flag == 0:\n\t\tprint('YES')\n\t\tbreak\nif flag == 1:\n\tprint('NO')\n", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\n(a, b) = ([None for _ in range(m)], [None for _ in range(m)])\nfor i in range(m):\n\t(a[i], b[i]) = map(int, input().split())\n(f, c) = ([0 for _ in range(n + 100)], 0)\nfor i in range(m):\n\tif a[i] != a[0] and b[i] != a[0]:\n\t\tc += 1\n\t\tf[a[i]] += 1\n\t\tf[b[i]] += 1\nif max(f) == c:\n\tprint('YES')\nelse:\n\t(f, c) = ([0 for _ in range(n + 100)], 0)\n\tfor i in range(m):\n\t\tif a[i] != b[0] and b[i] != b[0]:\n\t\t\tc += 1\n\t\t\tf[a[i]] += 1\n\t\t\tf[b[i]] += 1\n\tif max(f) == c:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(m, n) = map(int, input().split())\nll = []\nfor i in range(n):\n\t(x, y) = map(int, input().split())\n\tll.append([x, y])\nl = (ll[0][0], ll[0][1])\nfor i in range(2):\n\taa = l[i]\n\tans = 0\n\tbib = [0] * (m + 1)\n\tfor j in ll:\n\t\tif j[0] != aa and j[1] != aa:\n\t\t\tbib[j[0]] += 1\n\t\t\tbib[j[1]] += 1\n\t\t\tans += 1\n\tif max(bib) == ans:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from collections import Counter\nfrom itertools import chain\nab = tuple((tuple(map(int, input().split())) for _ in range(int(input().split()[[2, 1][1]]))))\nfor x_ in Counter(chain(*ab)).most_common(4):\n\tx = x_[0]\n\tab2 = (abi for abi in ab if x not in abi)\n\ttry:\n\t\ttry:\n\t\t\tys = set(next(ab2))\n\t\texcept StopIteration:\n\t\t\tpass\n\t\telse:\n\t\t\tfor abi2 in ab2:\n\t\t\t\tys.intersection_update(abi2)\n\t\t\tassert ys\n\t\tprint('YES')\n\t\tbreak\n\texcept AssertionError:\n\t\tpass\nelse:\n\tprint('NO')\n", "(n, m) = list(map(int, input().split()))\n(a, b) = list(map(int, input().split()))\nar1 = [a]\nar2 = [b]\nlst = [[a, b]]\nfor i in range(m - 1):\n\tlst.append(list(map(int, input().split())))\nar3 = [0, 0]\nar4 = [0, 0]\nfor (a, b) in lst:\n\tif len(ar1) != 2 and a not in ar1 and (b not in ar1):\n\t\tar1.append(a)\n\t\tar3 = [ar1[0], b]\n\tif len(ar2) != 2 and a not in ar2 and (b not in ar2):\n\t\tar2.append(a)\n\t\tar4 = [ar2[0], b]\nans = 'NO'\nflag = 0\nfor (a, b) in lst:\n\tif a not in ar1 and b not in ar1:\n\t\tflag = 1\n\t\tbreak\nif flag == 0:\n\tans = 'YES'\nflag = 0\nfor (a, b) in lst:\n\tif a not in ar2 and b not in ar2:\n\t\tflag = 1\n\t\tbreak\nif flag == 0:\n\tans = 'YES'\nflag = 0\nfor (a, b) in lst:\n\tif a not in ar3 and b not in ar3:\n\t\tflag = 1\n\t\tbreak\nif flag == 0:\n\tans = 'YES'\nflag = 0\nfor (a, b) in lst:\n\tif a not in ar4 and b not in ar4:\n\t\tflag = 1\n\t\tbreak\nif flag == 0:\n\tans = 'YES'\nprint(ans)\n", "(n, m) = map(int, input().split())\nres = [set(map(int, input().split())) for _ in range(m)]\na = res[0]\nhas = False\nfor i in range(m):\n\tif not res[i] & a:\n\t\tb = res[i]\n\t\thas = True\nif not has:\n\tprint('YES')\n\treturn\nfor x in a:\n\tfor y in b:\n\t\tfail = False\n\t\tfor _ in res:\n\t\t\tif x not in _ and y not in _:\n\t\t\t\tfail = True\n\t\tif not fail:\n\t\t\tprint('YES')\n\t\t\treturn\nprint('NO')\n", "(n, k) = map(int, input().split())\nimport sys\ninput = sys.stdin.readline\n\ndef check2(g1):\n\tif len(g1) == 0:\n\t\treturn True\n\tm1 = g1[0][0]\n\tflag = 0\n\tfor i in range(1, len(g1)):\n\t\tif g1[i][0] != m1 and g1[i][1] != m1:\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag == 0:\n\t\treturn True\n\tm1 = g1[0][1]\n\tflag = 0\n\tfor i in range(1, len(g1)):\n\t\tif g1[i][0] != m1 and g1[i][1] != m1:\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag == 0:\n\t\treturn True\n\treturn False\n\ndef check(x, ans):\n\tg1 = []\n\tfor i in range(len(ans)):\n\t\tif ans[i][0] == x or ans[i][1] == x:\n\t\t\tcontinue\n\t\telse:\n\t\t\tg1.append(ans[i])\n\tm = check2(g1)\n\treturn m\nans = []\nfor i in range(k):\n\t(x, y) = map(int, input().split())\n\tans.append([x, y])\nif check(ans[0][0], ans) or check(ans[0][1], ans):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "import sys\n(n, m) = map(int, sys.stdin.readline().split())\nmark = [0 for _ in range(n + 1)]\n(f, s) = map(int, sys.stdin.readline().split())\nscore = [0, 0]\noption1 = [0, 0, 0]\noption2 = [0, 0, 0]\n(c1, c2) = (0, 0)\nboth = 1\nboth2 = 0\nstart = 0\nans = 'YES'\npairs = [[f, s]]\nfor i in range(m - 1):\n\t(a, b) = map(int, sys.stdin.readline().split())\n\tc = [a, b]\n\tpairs.append(c)\n\tif f in c and s in c:\n\t\tboth += 1\n\telif f in c:\n\t\tscore[0] += 1\n\telif s in c:\n\t\tscore[1] += 1\n\telse:\n\t\t(c1, c2) = (a, b)\nif both + score[0] + score[1] == m:\n\tprint('YES')\nelse:\n\tfor pair in pairs:\n\t\tif c1 in pair and c2 in pair:\n\t\t\tboth2 += 1\n\t\telif c1 in pair:\n\t\t\tif f not in pair and s not in pair:\n\t\t\t\toption1[0] += 1\n\t\t\telif f not in pair:\n\t\t\t\toption1[1] += 1\n\t\t\telif s not in pair:\n\t\t\t\toption1[2] += 1\n\t\telif c2 in pair:\n\t\t\tif f not in pair and s not in pair:\n\t\t\t\toption2[0] += 1\n\t\t\telif f not in pair:\n\t\t\t\toption2[1] += 1\n\t\t\telif s not in pair:\n\t\t\t\toption2[2] += 1\n\top1 = both + score[0] + both2 + option1[0] + option1[1]\n\top2 = both + score[1] + both2 + option1[0] + option1[2]\n\top3 = both + score[0] + both2 + option2[0] + option2[1]\n\top4 = both + score[1] + both2 + option2[0] + option2[2]\n\tcheck = [op1, op2, op3, op4]\n\tif m in check:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = list(map(int, input().split()))\nms = []\ncnt = {}\n\ndef cd(x):\n\tif x in cnt:\n\t\tcnt[x] += 1\n\telse:\n\t\tcnt[x] = 1\nfor i in range(m):\n\t(x, y) = list(map(int, input().split()))\n\tms.append((x, y))\n\tcd(x)\n\tcd(y)\nans = []\nfor (k, v) in list(cnt.items()):\n\tif v >= m // 2:\n\t\tans.append(k)\n\ndef check_one(c):\n\tfor i in range(m):\n\t\t(x, y) = ms[i]\n\t\tif x == c or y == c:\n\t\t\tcontinue\n\t\tif check_two(c, x, i):\n\t\t\treturn True\n\t\tif check_two(c, y, i):\n\t\t\treturn True\n\t\treturn False\n\treturn True\n\ndef check_two(c1, c2, s):\n\tfor i in range(s, m):\n\t\t(x, y) = ms[i]\n\t\tif x == c1 or x == c2 or y == c1 or (y == c2):\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True\nfor a in ans:\n\tif check_one(a):\n\t\tprint('YES')\n\t\tquit()\nprint('NO')\n", "def check(x, y):\n\tif y is None:\n\t\tfor i in a:\n\t\t\tif x not in i:\n\t\t\t\treturn False\n\t\treturn True\n\tfor i in a:\n\t\tif x not in i and y not in i:\n\t\t\treturn False\n\treturn True\n(n, m) = map(int, input().split())\na = [list(input().split()) for i in range(m)]\nfor x in a[0]:\n\tif check(x, None):\n\t\tprint('YES')\n\t\texit()\n\tfor i in a:\n\t\tif x not in i:\n\t\t\tif check(x, i[0]) or check(x, i[1]):\n\t\t\t\tprint('YES')\n\t\t\t\texit()\n\t\t\tbreak\nprint('NO')\n", "(n, m) = map(int, input().split())\npairs = [tuple(map(int, input().split())) for i in range(m)]\nfirst = pairs[0]\n(x, y) = ((), ())\nall_differ = lambda x, y: x[0] != y[0] and x[1] != y[0] and (x[0] != y[1]) and (x[1] != y[1])\nfor p in pairs:\n\tif all_differ(first, p):\n\t\t(x, y) = (first, p)\n\t\tbreak\nelse:\n\tprint('YES')\n\texit(0)\nfor (a, b) in [(x[0], y[0]), (x[0], y[1]), (x[1], y[0]), (x[1], y[1])]:\n\tfor p in pairs:\n\t\tif all_differ((a, b), p):\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "p = input().rstrip().split(' ')\nl = []\nq = []\nw = []\nF = 0\nfor i in range(0, int(p[1])):\n\tu = input().rstrip().split(' ')\n\tD = []\n\tD.append(int(u[0]))\n\tD.append(int(u[1]))\n\tl.append(D)\n\tif i == 0:\n\t\ta = int(u[0])\n\t\tb = int(u[1])\n\telse:\n\t\tD = []\n\t\tD.append(int(u[0]))\n\t\tD.append(int(u[1]))\n\t\tif a not in D and b not in D:\n\t\t\tc = int(u[0])\n\t\t\td = int(u[1])\n\t\t\tF = 1\nif F == 0:\n\tprint('YES')\nelse:\n\tA = 0\n\tB = 0\n\tC = 0\n\tD = 0\n\tfor i in range(0, len(l)):\n\t\tif a in l[i] or c in l[i]:\n\t\t\tA += 1\n\t\tif a in l[i] or d in l[i]:\n\t\t\tB += 1\n\t\tif b in l[i] or c in l[i]:\n\t\t\tC += 1\n\t\tif b in l[i] or d in l[i]:\n\t\t\tD += 1\n\tif A == len(l) or B == len(l) or C == len(l) or (D == len(l)):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "import sys\n(n, m) = map(int, input().split())\n(a, b) = map(int, input().split())\npool = [a, b]\npairs = [(a, b)]\nfor _ in range(m - 1):\n\t(a, b) = map(int, input().split())\n\tif a not in pool and b not in pool:\n\t\tpool.append(a)\n\t\tpool.append(b)\n\tpairs.append((a, b))\n\tif len(pool) >= 5:\n\t\tprint('NO')\n\t\tsys.exit()\ncount = 0\nfor i in range(len(pool) - 1):\n\tfor j in range(i + 1, len(pool)):\n\t\tx = [pool[i], pool[j]]\n\t\tfor k in pairs:\n\t\t\tif k[0] != x[0] and k[0] != x[1] and (k[1] != x[0]) and (k[1] != x[1]):\n\t\t\t\tcount += 1\n\t\t\t\tbreak\nif count != len(pool) * (len(pool) - 1) // 2:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "inp = input().split()\nn = int(inp[0])\nm = int(inp[1])\npairs = []\nflag = True\nx = x1 = x2 = y = y1 = y2 = 0\nfor i in range(m):\n\tinp = input().split()\n\tpairs.append(inp)\nfor i in range(m):\n\tif i == 0:\n\t\tx = pairs[i][0]\n\t\tcontinue\n\tif x not in pairs[i] and y not in pairs[i]:\n\t\tif y1 == 0:\n\t\t\ty1 = pairs[i][0]\n\t\t\ty2 = pairs[i][1]\n\t\t\tcontinue\n\t\telif y == 0:\n\t\t\tif y1 in pairs[i] and y2 in pairs[i]:\n\t\t\t\tpass\n\t\t\telif y1 in pairs[i]:\n\t\t\t\ty = y1\n\t\t\telif y2 in pairs[i]:\n\t\t\t\ty = y2\n\t\t\telse:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\telif y not in pairs[i]:\n\t\t\tflag = False\n\t\t\tbreak\nflag2 = True\ny1 = y2 = x = y = 0\nif flag == False:\n\tfor i in range(m):\n\t\tif i == 0:\n\t\t\tx = pairs[i][1]\n\t\t\tcontinue\n\t\tif x not in pairs[i] and y not in pairs[i]:\n\t\t\tif y1 == 0:\n\t\t\t\ty1 = pairs[i][0]\n\t\t\t\ty2 = pairs[i][1]\n\t\t\t\tcontinue\n\t\t\telif y == 0:\n\t\t\t\tif y1 in pairs[i] and y2 in pairs[i]:\n\t\t\t\t\tpass\n\t\t\t\telif y1 in pairs[i]:\n\t\t\t\t\ty = y1\n\t\t\t\telif y2 in pairs[i]:\n\t\t\t\t\ty = y2\n\t\t\t\telse:\n\t\t\t\t\tflag2 = False\n\t\t\t\t\tbreak\n\t\t\telif y not in pairs[i]:\n\t\t\t\tflag2 = False\n\t\t\t\tbreak\nif flag or flag2:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left, bisect_right\nfrom types import GeneratorType\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\timport os\n\t\tself.os = os\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tself.os.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nimport collections as col\nimport math, string\n\ndef getInts():\n\treturn [int(s) for s in input().split()]\n\ndef getInt():\n\treturn int(input())\n\ndef getStrs():\n\treturn [s for s in input().split()]\n\ndef getStr():\n\treturn input()\n\ndef listStr():\n\treturn list(input())\nMOD = 10 ** 9 + 7\n\ndef solve():\n\t(N, M) = getInts()\n\tvals = []\n\tfor m in range(M):\n\t\tvals.append(tuple(sorted(getInts())))\n\tif M <= 2:\n\t\treturn 'YES'\n\tvals.sort()\n\t(a, b) = vals.pop(0)\n\t(c, d) = vals.pop()\n\tif a == c and b == d:\n\t\treturn 'YES'\n\tif a == c:\n\t\tcandidates = [(b, d), (a, a)]\n\telif b == c:\n\t\tcandidates = [(a, d), (b, b)]\n\telif b == d:\n\t\tcandidates = [(a, c), (b, b)]\n\telse:\n\t\tcandidates = [(a, c), (a, d), (b, c), (b, d)]\n\n\tdef works(x, y):\n\t\tif x == y:\n\t\t\tops = []\n\t\t\tfor (a, b) in vals:\n\t\t\t\tif a == x or b == x:\n\t\t\t\t\tcontinue\n\t\t\t\tif not ops:\n\t\t\t\t\tops = [a, b]\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tfor j in range(len(ops) - 1, -1, -1):\n\t\t\t\t\t\tif ops[j] not in [a, b]:\n\t\t\t\t\t\t\tops.pop(j)\n\t\t\t\tif not ops:\n\t\t\t\t\treturn False\n\t\t\treturn True\n\t\telse:\n\t\t\tfor (a, b) in vals:\n\t\t\t\tif a not in [x, y] and b not in [x, y]:\n\t\t\t\t\treturn False\n\t\t\treturn True\n\tfor (x, y) in candidates:\n\t\tif works(x, y):\n\t\t\treturn 'YES'\n\treturn 'NO'\nprint(solve())\n", "(n, m) = list(map(int, input().split()))\na = []\nfor i in range(m):\n\ta.append(list(map(int, input().split())))\nx = a[0][0]\nfor i in range(1, m):\n\tif not x in a[i]:\n\t\ty = a[i][0]\n\t\tfor j in range(i + 1, m):\n\t\t\tif not x in a[j] and (not y in a[j]):\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\texit()\n\t\ty = a[i][1]\n\t\tfor j in range(i + 1, m):\n\t\t\tif not x in a[j] and (not y in a[j]):\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\texit()\n\t\tbreak\nelse:\n\tprint('YES')\n\texit()\nx = a[0][1]\nfor i in range(1, m):\n\tif not x in a[i]:\n\t\ty = a[i][0]\n\t\tfor j in range(i + 1, m):\n\t\t\tif not x in a[j] and (not y in a[j]):\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\texit()\n\t\ty = a[i][1]\n\t\tfor j in range(i + 1, m):\n\t\t\tif not x in a[j] and (not y in a[j]):\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\texit()\n\t\tbreak\nelse:\n\tprint('YES')\n\texit()\nprint('NO')\n", "(n, m) = map(int, input().split())\narr = []\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tarr.append((x, y))\nx1 = -1\nx2 = -1\ny1 = -1\ny2 = -1\n(x, y) = (arr[0][0], arr[0][1])\nfor i in arr:\n\tif i[0] != x and i[1] != x and (i[0] != y) and (i[1] != y):\n\t\tx1 = x\n\t\ty1 = y\n\t\tx2 = i[0]\n\t\ty2 = i[1]\n\t\tbreak\nif x1 == -1:\n\tprint('YES')\n\texit()\nfor (x, y) in ((x1, y1), (x1, x2), (x1, y2), (x2, y1), (x2, y2), (y1, y2)):\n\tfor itr in arr:\n\t\tif itr[0] != x and itr[1] != x and (itr[0] != y) and (itr[1] != y):\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\nclass Problem:\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef solve(self):\n\t\tprint(self._solve())\n\n\tdef _solve(self):\n\t\t(n, m) = [int(item) for item in input().split()]\n\t\tpairs = []\n\t\tcnt = {}\n\t\tmp = defaultdict(int)\n\t\tfor i in range(m):\n\t\t\tpair = sorted([int(item) for item in input().split()])\n\t\t\tpairs.append(pair)\n\t\t\tmp[pair[0]] += 1\n\t\t\tmp[pair[1]] += 1\n\t\t\tpair = tuple(pair)\n\t\t\tif pair in cnt:\n\t\t\t\tcnt[pair] += 1\n\t\t\telse:\n\t\t\t\tcnt[pair] = 1\n\t\tres = []\n\t\tfor x in mp:\n\t\t\tres.append([mp[x], x])\n\t\tres.sort()\n\t\tfor i in range(len(res) - 1, -1, -1):\n\t\t\tfor j in range(len(res) - 1, i, -1):\n\t\t\t\tif res[i][0] + res[j][0] < m:\n\t\t\t\t\tbreak\n\t\t\t\tpair = tuple(sorted([res[i][1], res[j][1]]))\n\t\t\t\tif pair[0] == pair[1]:\n\t\t\t\t\tcontinue\n\t\t\t\tif not pair in cnt:\n\t\t\t\t\toccs = 0\n\t\t\t\telse:\n\t\t\t\t\toccs = cnt[pair]\n\t\t\t\tif res[i][0] + res[j][0] - occs == m:\n\t\t\t\t\treturn 'YES'\n\t\treturn 'NO'\n\ndef main():\n\tproblem = Problem()\n\tproblem.solve()\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "(n, m) = map(int, input().split())\na = [tuple(map(int, input().split())) for _ in range(m)]\np = a[0]\nfirst = p[0]\nsecond = -1\na = set(a)\nfor el in a:\n\tif first != el[0] and first != el[1]:\n\t\tif second == -1:\n\t\t\tsecond = el[0]\n\t\telif second != el[0] and second != el[1]:\n\t\t\tbreak\nelse:\n\tprint('YES')\n\texit()\nsecond = -1\nfor el in a:\n\tif first != el[0] and first != el[1]:\n\t\tif second == -1:\n\t\t\tsecond = el[1]\n\t\telif second != el[0] and second != el[1]:\n\t\t\tbreak\nelse:\n\tprint('YES')\n\texit()\nfirst = p[1]\nsecond = -1\nfor el in a:\n\tif first != el[0] and first != el[1]:\n\t\tif second == -1:\n\t\t\tsecond = el[0]\n\t\telif second != el[0] and second != el[1]:\n\t\t\tbreak\nelse:\n\tprint('YES')\n\texit()\nsecond = -1\nfor el in a:\n\tif first != el[0] and first != el[1]:\n\t\tif second == -1:\n\t\t\tsecond = el[1]\n\t\telif second != el[0] and second != el[1]:\n\t\t\tbreak\nelse:\n\tprint('YES')\n\texit()\nprint('NO')\n", "(n, m) = [int(t) for t in input().split(' ')]\npair = [int(t) for t in input().split(' ')]\ncandidates = [(pair[0], None), (pair[1], None), (pair[0], pair[1])]\nfor i in range(m - 1):\n\tif not candidates:\n\t\tbreak\n\tpair = [int(t) for t in input().split(' ')]\n\tnew = []\n\tfor c in candidates:\n\t\tif any((p in c for p in pair)):\n\t\t\tnew.append(c)\n\t\telif None in c:\n\t\t\tnew.append((c[0], pair[0]))\n\t\t\tnew.append((c[0], pair[1]))\n\tcandidates = new\nprint('YES' if candidates else 'NO')\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\ta.append(tuple(map(int, input().split())))\nfor i in a[0]:\n\tkol = 0\n\tb = [0] * (n + 1)\n\tfor c in a:\n\t\tif c[0] != i and c[1] != i:\n\t\t\tb[c[0]] += 1\n\t\t\tb[c[1]] += 1\n\t\t\tkol += 1\n\tif kol == max(b):\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "def f(c):\n\tif c:\n\t\tprint('YES')\n\t\texit()\n(n, m) = map(int, input().split())\ncnt = [0] * n\nl = [[*map(int, input().split())] for _ in range(m)]\nf(m == 1)\nfor x in l[0]:\n\ti = 1\n\twhile i < m and x in l[i]:\n\t\ti += 1\n\tf(i == m)\n\tfor y in l[i]:\n\t\tj = i + 1\n\t\twhile j < m and (x in l[j] or y in l[j]):\n\t\t\tj += 1\n\t\tf(j == m)\nprint('NO')\n", "(n, m) = [int(i) for i in input().split(' ')]\na = []\nfor i in range(m):\n\ta.append([int(i) for i in input().split(' ')])\nfor i in (a[0][0], a[0][1]):\n\tmyset = set((i for i in range(1, n + 1)))\n\tfor x in a[1:]:\n\t\tif i not in x:\n\t\t\tmyset.intersection_update(set(x))\n\tif len(myset):\n\t\texit(print('YES'))\nprint('NO')\n", "import sys\n\ndef ch1(arr, x, y):\n\tfor i in arr:\n\t\tif not (i[0] == x or i[0] == y or i[1] == x or (i[1] == y)):\n\t\t\treturn False\n\treturn True\n\ndef ch(arr, x):\n\tfor i in arr:\n\t\tif i[0] != x and i[1] != x:\n\t\t\tif ch1(arr, x, i[0]):\n\t\t\t\treturn i[0]\n\t\t\tif ch1(arr, x, i[1]):\n\t\t\t\treturn i[1]\n\t\t\treturn -1\n\tif x != 1:\n\t\treturn 1\n\treturn 2\n(m, n) = input().split()\nn = int(n)\nm = int(m)\narr = []\nfor i in range(n):\n\tarr.append(input().split())\nt = ch(arr, arr[0][0])\nif t != -1:\n\tprint('YES')\n\tsys.exit()\nt = ch(arr, arr[0][1])\nif t != -1:\n\tprint('YES')\n\tsys.exit()\nprint('NO')\n", "(bound, m) = [int(x) for x in input().split()]\nif m == 1:\n\tprint('YES')\n\texit(0)\npairs_uniq = set()\nfor _ in range(m):\n\tx = [int(x) for x in input().split()]\n\tx.sort()\n\tpairs_uniq.add((x[0], x[1]))\nif len(pairs_uniq) == 1:\n\tprint('YES')\n\texit(0)\npairs = [x for x in pairs_uniq]\nfor x in pairs[0]:\n\tno_x_pairs = [n for n in pairs if n[0] != x and n[1] != x]\n\tx_pairs_count = 0\n\td = {}\n\tfor (i, j) in pairs:\n\t\tif i != x and j != x:\n\t\t\tif i not in d:\n\t\t\t\td[i] = 0\n\t\t\td[i] += 1\n\t\t\tif j not in d:\n\t\t\t\td[j] = 0\n\t\t\td[j] += 1\n\t\telse:\n\t\t\tx_pairs_count += 1\n\tmax_ = 0 if len(d.values()) == 0 else sorted(d.values())[-1]\n\tif max_ + x_pairs_count == len(pairs):\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "from copy import copy\n(n, m) = map(int, input().split())\nP = []\nz = set()\nfor i in range(1, n + 1):\n\tz.add(i)\nfor i in range(m):\n\tP.append(list(map(int, input().split())))\nfor x in (P[0][0], P[0][1]):\n\ts = copy(z)\n\tfor i in range(1, m):\n\t\t(a, b) = P[i]\n\t\tif a != x and b != x:\n\t\t\ts.intersection_update({a, b})\n\tif len(s):\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "(n, p) = map(int, input().split())\nd = {}\nc = []\nm = {}\nfor _ in range(p):\n\t(a, b) = map(int, input().split())\n\tif a > b:\n\t\t(a, b) = (b, a)\n\tif a not in d:\n\t\td[a] = 1\n\telse:\n\t\td[a] += 1\n\tif b not in d:\n\t\td[b] = 1\n\telse:\n\t\td[b] += 1\n\tif (a, b) not in m:\n\t\tm[a, b] = 1\n\telse:\n\t\tm[a, b] += 1\nl = []\nflag = 0\nfor (k1, v1) in d.items():\n\tif flag:\n\t\tbreak\n\tif v1 == p - 1:\n\t\tflag = 1\n\t\tbreak\n\tif v1 < p // 2:\n\t\tcontinue\n\tfor (k2, v2) in d.items():\n\t\tif v1 + v2 < p:\n\t\t\tcontinue\n\t\tif k1 != k2:\n\t\t\t(d1, d2) = (k1, k2)\n\t\t\tif k1 > k2:\n\t\t\t\td1 = k2\n\t\t\t\td2 = k1\n\t\t\tif (d1, d2) not in m and v1 + v2 == p:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\telif (d1, d2) in m and v1 + v2 - m[d1, d2] == p:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\nif flag:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "def solution(pairs):\n\t((a, b), *rest) = pairs\n\twithout_a = [(x, y) for (x, y) in pairs if x != a and y != a]\n\tif len(without_a) == 0:\n\t\treturn True\n\t((c, d), *rest2) = without_a\n\twithout_a_c = [(x, y) for (x, y) in without_a if x != c and y != c]\n\tif len(without_a_c) == 0:\n\t\treturn True\n\twithout_a_d = [(x, y) for (x, y) in without_a if x != d and y != d]\n\tif len(without_a_d) == 0:\n\t\treturn True\n\twithout_b = [(x, y) for (x, y) in pairs if x != b and y != b]\n\tif len(without_b) == 0:\n\t\treturn True\n\t((c, d), *rest2) = without_b\n\twithout_b_c = [(x, y) for (x, y) in without_b if x != c and y != c]\n\tif len(without_b_c) == 0:\n\t\treturn True\n\twithout_b_d = [(x, y) for (x, y) in without_b if x != d and y != d]\n\tif len(without_b_d) == 0:\n\t\treturn True\n\treturn False\n(n, m) = [int(x) for x in input().split()]\npairs = []\nfor _ in range(m):\n\t(a, b) = [int(x) for x in input().split()]\n\tpairs.append((a, b))\nif solution(pairs):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "pa = []\n(n, m) = list(map(int, input().split()))\n\ndef check(tup):\n\tglobal pa, n, m\n\tfor (f, s) in pa:\n\t\tif f not in tup and s not in tup:\n\t\t\treturn False\n\treturn True\n\ndef forward(first):\n\tglobal pa, n, m\n\tfor j in pa:\n\t\tif first not in j:\n\t\t\tif check((first, j[0])) or check((first, j[1])):\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\treturn True\nfor i in range(m):\n\tpa.append(tuple(map(int, input().split())))\nif forward(pa[0][0]) or forward(pa[0][1]):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\n(a, b) = map(int, input().split())\ns = set()\ns1 = set()\ns.add(a)\ns.add(b)\nl = [[a, b]]\ntag = True\nfor i in range(m - 1):\n\tl.append(list(map(int, input().split())))\nfor i in range(len(l)):\n\tif a not in l[i] and b not in l[i]:\n\t\ts1.add(l[i][0])\n\t\ts1.add(l[i][1])\n\t\ttag = False\n\t\tbreak\nif tag:\n\tprint('YES')\nelse:\n\ttag = True\n\tt = 0\n\tfor i in s:\n\t\tfor j in s1:\n\t\t\tfor k in l:\n\t\t\t\tif i not in k and j not in k:\n\t\t\t\t\tt = -1\n\t\t\t\t\tbreak\n\t\t\tif t == 0:\n\t\t\t\tprint('YES')\n\t\t\t\texit()\n\t\t\tt = 0\n\tprint('NO')\n", "def ok(pairs, x):\n\ty = -1\n\tind = 0\n\tfor i in range(len(pairs)):\n\t\t(a, b) = pairs[i]\n\t\tif a != x and b != x:\n\t\t\tbreak\n\t\tind += 1\n\tif ind == len(pairs):\n\t\treturn True\n\ty = pairs[ind][0]\n\ttmp = True\n\tfor i in range(ind + 1, len(pairs)):\n\t\t(a, b) = pairs[i]\n\t\tif a != x and a != y and (b != x) and (b != y):\n\t\t\ttmp = False\n\t\t\tbreak\n\tif tmp:\n\t\treturn True\n\ty = pairs[ind][1]\n\tfor i in range(ind + 1, len(pairs)):\n\t\t(a, b) = pairs[i]\n\t\tif a != x and a != y and (b != x) and (b != y):\n\t\t\treturn False\n\treturn True\n\ndef B():\n\t(n, m) = [int(x) for x in input().split()]\n\torig_pairs = []\n\tfor i in range(m):\n\t\t(a, b) = [int(x) for x in input().split()]\n\t\torig_pairs.append((a, b))\n\tif ok(orig_pairs, orig_pairs[0][0]) or ok(orig_pairs, orig_pairs[0][1]):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nB()\n", "def solve(n, pairs):\n\tX = pairs.pop()\n\tfor x in X:\n\t\ty_candidates = {}\n\t\ttotal = 0\n\t\tfor p in pairs:\n\t\t\tif x not in p:\n\t\t\t\ty_candidates[p[0]] = y_candidates.get(p[0], 0) + 1\n\t\t\t\ty_candidates[p[1]] = y_candidates.get(p[1], 0) + 1\n\t\t\t\ttotal += 1\n\t\tif total == 0 and y_candidates == {} or max(y_candidates.values()) == total:\n\t\t\tprint('YES')\n\t\t\treturn\n\tprint('NO')\n(n, m) = map(int, input().split(' '))\npairs = set()\nunique_values = set()\nfor i in range(m):\n\t(a, b) = map(int, input().split(' '))\n\tpairs.add((a, b))\nsolve(n, pairs)\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\ta.append(list(map(int, input().split())))\nfor i in a[0]:\n\tcnt = 0\n\tnl = [0] * (n + 1)\n\tfor j in a:\n\t\tif j[0] != i and j[1] != i:\n\t\t\tnl[j[0]] += 1\n\t\t\tnl[j[1]] += 1\n\t\t\tcnt += 1\n\tif cnt == max(nl):\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import *\nfrom copy import *\nfrom collections import deque\nfrom collections import Counter as counter\nfrom itertools import combinations as comb\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\ndef print(*args, **kwargs):\n\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop('end', '\\n'))\n\tif kwargs.pop('flush', False):\n\t\tfile.flush()\nif sys.version_info[0] < 3:\n\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\nelse:\n\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\nmod = 1000000007\n\ndef inp():\n\treturn sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n\tsys.stdout.write(str(var))\n\ndef lis():\n\treturn list(map(int, inp().split()))\n\ndef stringlis():\n\treturn list(map(str, inp().split()))\n\ndef sep():\n\treturn map(int, inp().split())\n\ndef strsep():\n\treturn map(str, inp().split())\n\ndef zerolist(n):\n\treturn [0] * n\n\ndef nextline():\n\tout('\\n')\n\ndef testcase(t):\n\tfor p in range(t):\n\t\tsolve()\n\ndef printlist(a):\n\tfor p in range(0, len(a)):\n\t\tout(str(a[p]) + ' ')\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef power(a, b):\n\tans = 1\n\twhile b > 0:\n\t\tif b % 2 == 1:\n\t\t\tans *= a\n\t\ta *= a\n\t\tb //= 2\n\treturn ans\n\ndef ncr(n, r):\n\treturn factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tif n <= 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\ti = 5\n\twhile i * i <= n:\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\n\ndef solve():\n\t(n, m) = sep()\n\tstorage = []\n\tfor i in range(m):\n\t\t(a, b) = sep()\n\t\tstorage.append([a, b])\n\tff = storage[0]\n\tss = -1\n\tfor i in range(m):\n\t\tif ff[0] in storage[i] or ff[1] in storage[i]:\n\t\t\tcontinue\n\t\telse:\n\t\t\tss = storage[i]\n\t\t\tbreak\n\tif ss == -1:\n\t\tprint('YES')\n\t\treturn\n\tfor i in range(2):\n\t\tfor j in range(2):\n\t\t\ta = ff[i]\n\t\t\tb = ss[j]\n\t\t\tf = True\n\t\t\tfor ii in range(m):\n\t\t\t\tif a in storage[ii] or b in storage[ii]:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tf = False\n\t\t\t\t\tbreak\n\t\t\tif f:\n\t\t\t\tprint('YES')\n\t\t\t\treturn\n\tprint('NO')\ntestcase(1)\n", "(n, m) = map(int, input().split())\narr = [list(map(int, input().split())) for i in range(m)]\na = arr[0][0]\nb = arr[0][1]\narr1 = []\narr2 = []\nfor i in range(m):\n\tif a not in arr[i]:\n\t\tarr1.append(arr[i])\n\tif b not in arr[i]:\n\t\tarr2.append(arr[i])\ntry:\n\ts1 = set(arr1[0])\n\tfor i in arr1:\n\t\ts1 = s1.intersection(set(i))\n\ts2 = set(arr2[0])\n\tfor i in arr2:\n\t\ts2 = s2.intersection(set(i))\n\ts1 = list(s1)\n\ts2 = list(s2)\n\tif len(s1) >= 1 or len(s2) >= 1 or arr1 == [] or (arr2 == []):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nexcept:\n\tprint('YES')\n", "import sys\ninput = sys.stdin.readline\n\ndef ceil(x):\n\tif x != int(x):\n\t\tx = int(x) + 1\n\treturn x\n\ndef factorial(x, m):\n\tval = 1\n\twhile x > 0:\n\t\tval = val * x % m\n\t\tx -= 1\n\treturn val\n\ndef swaparr(arr, a, b):\n\ttemp = arr[a]\n\tarr[a] = arr[b]\n\tarr[b] = temp\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef nCr(n, k):\n\tif k > n - k:\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n\ndef upper_bound(a, x, lo=0, hi=None):\n\tif hi == None:\n\t\thi = len(a)\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif a[mid] < x:\n\t\t\tlo = mid + 1\n\t\telse:\n\t\t\thi = mid\n\treturn lo\n\ndef primefs(n):\n\tprimes = {}\n\twhile n % 2 == 0 and n > 0:\n\t\tprimes[2] = primes.get(2, 0) + 1\n\t\tn = n // 2\n\tfor i in range(3, int(n ** 0.5) + 2, 2):\n\t\twhile n % i == 0 and n > 0:\n\t\t\tprimes[i] = primes.get(i, 0) + 1\n\t\t\tn = n // i\n\tif n > 2:\n\t\tprimes[n] = primes.get(n, 0) + 1\n\treturn primes\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef swap(a, b):\n\ttemp = a\n\ta = b\n\tb = temp\n\treturn (a, b)\n\ndef find(x, link):\n\tp = x\n\twhile p != link[p]:\n\t\tp = link[p]\n\twhile x != p:\n\t\tnex = link[x]\n\t\tlink[x] = p\n\t\tx = nex\n\treturn p\n\ndef union(x, y, link, size):\n\tx = find(x, link)\n\ty = find(y, link)\n\tif size[x] < size[y]:\n\t\t(x, y) = swap(x, y)\n\tif x != y:\n\t\tsize[x] += size[y]\n\t\tlink[y] = x\n\ndef sieve(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\nMAXN = int(100000.0 + 5)\n\ndef spf_sieve():\n\tspf[1] = 1\n\tfor i in range(2, MAXN):\n\t\tspf[i] = i\n\tfor i in range(4, MAXN, 2):\n\t\tspf[i] = 2\n\tfor i in range(3, ceil(MAXN ** 0.5), 2):\n\t\tif spf[i] == i:\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif spf[j] == j:\n\t\t\t\t\tspf[j] = i\n\ndef factoriazation(x):\n\tret = {}\n\twhile x != 1:\n\t\tret[spf[x]] = ret.get(spf[x], 0) + 1\n\t\tx = x // spf[x]\n\treturn ret\n\ndef int_array():\n\treturn list(map(int, input().strip().split()))\n\ndef float_array():\n\treturn list(map(float, input().strip().split()))\n\ndef str_array():\n\treturn input().strip().split()\nMOD = int(1000000000.0) + 7\nCMOD = 998244353\nINF = float('inf')\nNINF = -float('inf')\npairs = []\n\ndef check(x, y):\n\tfor p in pairs:\n\t\tif p[0] != x and p[1] != x and (p[0] != y) and (p[1] != y):\n\t\t\treturn False\n\treturn True\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\tfor q in range(m):\n\t\t(a, b) = map(int, input().split())\n\t\tpairs.append((a, b))\n\tfor x in pairs[0]:\n\t\tif check(x, -1):\n\t\t\tprint('YES')\n\t\t\texit()\n\t\tfor p in pairs:\n\t\t\tif p[0] != x and p[1] != x:\n\t\t\t\tif check(x, p[0]) or check(x, p[1]):\n\t\t\t\t\tprint('YES')\n\t\t\t\t\texit()\n\t\t\t\tbreak\n\tprint('NO')\nfor _ in range(1):\n\tsolve()\n", "import sys\n(n, m) = map(int, input().split(' '))\nA = set()\nL = [sys.stdin.readline() for _ in range(m)]\nC = [0] * n\nfor l in L:\n\t(a, b) = map(int, l.split(' '))\n\tif a > b:\n\t\t(a, b) = (b, a)\n\tA.add((a, b))\nfor a in A:\n\tC[a[0] - 1] += 1\n\tC[a[1] - 1] += 1\nmax_idx = -1\nmax_v = 0\nfor i in range(n):\n\tif max_v < C[i]:\n\t\tmax_idx = i\n\t\tmax_v = C[i]\nmax_n = max_idx + 1\nB = set()\nfor a in A:\n\tif max_n not in a:\n\t\tB.add(a)\nD = [0] * n\nfor b in B:\n\tD[b[0] - 1] += 1\n\tD[b[1] - 1] += 1\nmax_idx = -1\nmax_v = 0\nfor i in range(n):\n\tif max_v < D[i]:\n\t\tmax_idx = i\n\t\tmax_v = D[i]\nmax_n = max_idx + 1\nfor b in B:\n\tif max_n not in b:\n\t\tprint('NO')\n\t\tbreak\nelse:\n\tprint('YES')\n", "def test(c1, c2):\n\tflag = True\n\tfor pair in pairs:\n\t\tif c1 not in pair and c2 not in pair:\n\t\t\tflag = False\n\treturn flag\n(n, m) = map(int, input().split())\npairs = []\nfor i in range(0, m):\n\t(x, y) = map(int, input().split())\n\tpairs.append((x, y))\nw = pairs[0][0]\ny = pairs[0][1]\ne = ' '\nr = ' '\nfor pair in pairs:\n\tif w not in pair and y not in pair:\n\t\te = pair[0]\n\t\tr = pair[1]\n\t\tbreak\nif test(w, e) or test(w, r) or test(y, e) or test(y, r) or test(w, y):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "def process(A):\n\t(x, y) = A[0]\n\tstart = set([(x, y)])\n\ta1 = None\n\tb1 = None\n\tfor (a, b) in A[1:]:\n\t\tif x != a and x != b and (y != a) and (y != b):\n\t\t\ta1 = a\n\t\t\tb1 = b\n\t\t\tstart.add((x, a1))\n\t\t\tstart.add((x, b1))\n\t\t\tstart.add((y, a1))\n\t\t\tstart.add((y, b1))\n\t\t\tbreak\n\tif b1 is None or a1 is None:\n\t\treturn 'YES'\n\tfor (x, y) in start:\n\t\tworking = True\n\t\tfor (a, b) in A:\n\t\t\tif x != a and x != b and (y != a) and (y != b):\n\t\t\t\tworking = False\n\t\t\t\tbreak\n\t\tif working:\n\t\t\treturn 'YES'\n\treturn 'NO'\n(n, m) = [int(x) for x in input().split()]\nA = []\nfor i in range(m):\n\t(x, y) = [int(c) for c in input().split()]\n\tA.append([x, y])\nprint(process(A))\n", "input = __import__('sys').stdin.readline\n(n, m) = map(int, input().split())\naa = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\taa.append([a, b])\nfor i in range(2):\n\tindx = aa[0][i]\n\tdd = [0] * (n + 1)\n\tans = 0\n\tfor j in aa:\n\t\tif j[0] != indx and j[1] != indx:\n\t\t\tdd[j[0]] += 1\n\t\t\tdd[j[1]] += 1\n\t\t\tans += 1\n\tif max(dd) == ans:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "ls = input().split()\nls[0] = int(ls[0])\nls[1] = int(ls[1])\na = input().split()\nr = []\nz = 1\nfor i in range(ls[1] - 1):\n\tr.append(input().split())\nfor j in range(2):\n\tx = a[j]\n\ts = []\n\tfor i in r:\n\t\tif x not in i:\n\t\t\ts.append(i)\n\tif len(s) == 0 and z:\n\t\tprint('YES')\n\t\tz = 0\n\t\tbreak\n\telif len(s):\n\t\tfor k in range(2):\n\t\t\tq = s[0][k]\n\t\t\tk = 0\n\t\t\tfor i in range(1, len(s)):\n\t\t\t\tif q in s[i]:\n\t\t\t\t\tk = k + 1\n\t\t\tif k == len(s) - 1 and z:\n\t\t\t\tprint('YES')\n\t\t\t\tz = 0\n\t\t\t\tbreak\nif z:\n\tprint('NO')\n", "class Pair:\n\n\tdef __init__(self, x, y):\n\t\tself._data = _data = [x, y]\n\n\tdef __setitem__(self, key, value):\n\t\tself._data[key] = value\n\n\tdef __getitem__(self, key):\n\t\treturn self._data[key]\n\n\tdef __len__(self):\n\t\treturn len(_data)\n\n\tdef __repr__(self):\n\t\treturn '{' + str(self._data[0]) + ',' + str(self._data[1]) + '}'\n(n, m) = map(int, input().split())\nv = []\nd = dict()\nfor i in range(m):\n\t(f, s) = map(int, input().split())\n\tv.append(Pair(f, s))\nvalue = [v[0][0], v[0][1]]\nflag = False\nfor x in value:\n\tval = [0] * (n + 1)\n\ta = 0\n\tfor y in v:\n\t\tif y[0] != x and y[1] != x:\n\t\t\ta += 1\n\t\t\tval[y[0]] += 1\n\t\t\tval[y[1]] += 1\n\tif max(val) == a:\n\t\tprint('YES')\n\t\tflag = True\n\t\tbreak\nif not flag:\n\tprint('NO')\n", "nums = [int(x) for x in input().split()]\nm = nums[0]\nn = nums[1]\npos = False\nnumbers = [int(x) for x in input().split()]\nr = numbers[:]\nr.sort()\nf = []\ng = []\nhasntbeenNumZero = False\nhasntbeenNumOne = False\n\ndef find_letter(letter, lst):\n\tfor i in range(len(lst)):\n\t\tif lst[i] == letter:\n\t\t\treturn True\n\treturn False\nfor i in range(n - 1):\n\tnumbers = [int(x) for x in input().split()]\n\tif find_letter(r[0], numbers) == False:\n\t\tif hasntbeenNumZero == False:\n\t\t\thasntbeenNumZero = True\n\t\t\tf = numbers[:]\n\t\telse:\n\t\t\tfor l in range(len(f)):\n\t\t\t\tif find_letter(f[len(f) - 1 - l], numbers) == False:\n\t\t\t\t\tf.pop(len(f) - 1 - l)\n\tif find_letter(r[1], numbers) == False:\n\t\tif hasntbeenNumOne == False:\n\t\t\thasntbeenNumOne = True\n\t\t\tg = numbers[:]\n\t\telse:\n\t\t\tfor l in range(len(g)):\n\t\t\t\tif find_letter(g[len(g) - 1 - l], numbers) == False:\n\t\t\t\t\tg.pop(len(g) - 1 - l)\nif hasntbeenNumZero == False or hasntbeenNumOne == False or len(f) != 0 or (len(g) != 0):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\na = [[*map(int, input().split())] for _ in range(m)]\ntry:\n\tfor x in a[0]:\n\t\tp = next((p for p in a if x not in p))\n\t\tfor y in p:\n\t\t\tnext((0 for p in a if x not in p and y not in p))\n\ta = 1\nexcept:\n\ta = 0\nprint('YNEOS'[a::2])\n", "from __future__ import division, print_function\n\ndef get_ints():\n\treturn map(int, input().strip().split())\n\ndef get_array():\n\treturn list(map(int, input().strip().split()))\nmod = 1000000007\nimport collections, math, sys, bisect\nINF = sys.maxsize\nMOD = 998244353\n\ndef main():\n\n\tdef check(a, b, arr):\n\t\tfor i in arr:\n\t\t\tif i[0] != a and i[1] != b and (i[0] != b) and (i[1] != a):\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef solve():\n\t\t(n, m) = get_ints()\n\t\tarr = []\n\t\tfor i in range(m):\n\t\t\t(a, b) = get_ints()\n\t\t\tarr.append((a, b))\n\t\tfor x in arr[0]:\n\t\t\tif check(x, -1, arr):\n\t\t\t\tprint('YES')\n\t\t\t\treturn\n\t\t\tfor i in range(1, len(arr)):\n\t\t\t\tif arr[i][0] != x and arr[i][1] != x:\n\t\t\t\t\tif check(x, arr[i][0], arr) or check(x, arr[i][1], arr):\n\t\t\t\t\t\tprint('YES')\n\t\t\t\t\t\treturn\n\t\t\t\t\tbreak\n\t\tprint('NO')\n\tsolve()\npy2 = round(0.5)\nif py2:\n\tfrom future_builtins import ascii, filter, hex, map, oct, zip\n\trange = xrange\nimport os, sys\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._file = file\n\t\tself._fd = file.fileno()\n\t\tself.writable = 'x' in file.mode or 'w' in file.mode\n\t\tself.write = super(FastIO, self).write if self.writable else None\n\n\tdef _fill(self):\n\t\ts = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\tself.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n\t\treturn s\n\n\tdef read(self):\n\t\twhile self._fill():\n\t\t\tpass\n\t\treturn super(FastIO, self).read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\ts = self._fill()\n\t\t\tself.newlines = s.count(b'\\n') + (not s)\n\t\tself.newlines -= 1\n\t\treturn super(FastIO, self).readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.getvalue())\n\t\t\t(self.truncate(0), self.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tif py2:\n\t\t\tself.write = self.buffer.write\n\t\t\tself.read = self.buffer.read\n\t\t\tself.readline = self.buffer.readline\n\t\telse:\n\t\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n", "import sys\n(n, m) = map(int, input().split())\na = [tuple(map(int, input().split())) for _ in range(m)]\nx = (a[0][0], a[0][1])\ny = []\nfor i in a:\n\tif x[0] not in i:\n\t\ty.append(i)\n\t\tbreak\nif len(y) == 0:\n\ty = [[-1, -1]]\nfor i in a:\n\tif x[1] not in i:\n\t\ty.append(i)\nif len(y) == 1:\n\ty.append([-1, -1])\nfor j in range(2):\n\tfor k in range(2):\n\t\tfor i in a:\n\t\t\tif x[j] not in i and y[j][k] not in i:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('YES')\n\t\t\tsys.exit()\nprint('NO')\n", "(n, m) = map(int, input().split())\npairs = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tpairs.append((a, b))\n\ndef iterate(pairs, x, m):\n\tct_rem = [0] * (n + 1)\n\tctx = 1\n\tfor i in range(1, m):\n\t\t(a, b) = pairs[i]\n\t\tif a != x and b != x:\n\t\t\tct_rem[a] += 1\n\t\t\tct_rem[b] += 1\n\t\telse:\n\t\t\tctx += 1\n\tremaining = m - ctx\n\tfor v in ct_rem:\n\t\tif v == remaining:\n\t\t\treturn True\n\treturn False\nif iterate(pairs, pairs[0][0], m):\n\tprint('YES')\nelif iterate(pairs, pairs[0][1], m):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nl = {}\nk = []\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tk.append([x, y])\nt = True\ni = 1\np1 = k[0][0]\np2 = k[0][1]\nwhile i < m and t:\n\tif k[i][0] not in [p1, p2] and k[i][1] not in [p1, p2]:\n\t\tp3 = k[i][0]\n\t\tp4 = k[i][1]\n\t\tj = i\n\t\tt = False\n\ti += 1\nif t:\n\tprint('YES')\nelse:\n\tb = 0\n\tp = [p1, p3]\n\tfor i in range(m):\n\t\tif k[i][0] not in p and k[i][1] not in p:\n\t\t\tb += 1\n\t\t\tbreak\n\tp = [p2, p3]\n\tfor i in range(m):\n\t\tif k[i][0] not in p and k[i][1] not in p:\n\t\t\tb += 1\n\t\t\tbreak\n\tp = [p1, p4]\n\tfor i in range(m):\n\t\tif k[i][0] not in p and k[i][1] not in p:\n\t\t\tb += 1\n\t\t\tbreak\n\tp = [p2, p4]\n\tfor i in range(m):\n\t\tif k[i][0] not in p and k[i][1] not in p:\n\t\t\tb += 1\n\t\t\tbreak\n\tif b < 4:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "def acha(ar, x, y, b):\n\tfor i in range(b):\n\t\tif (ar[i][0] != x and ar[i][0] != y) and (ar[i][1] != x and ar[i][1] != y):\n\t\t\treturn False\n\treturn True\n(a, b) = map(int, input().split())\nar = []\nfor i in range(b):\n\tl = list(map(int, input().split()))\n\tar.append(l)\nx1 = ar[0][0]\nx2 = ar[0][1]\ny1 = [0, 0]\ny2 = [0, 0]\nfor i in range(b):\n\tif ar[i][0] != x1 and ar[i][1] != x1:\n\t\ty1[0] = ar[i][0]\n\t\ty1[1] = ar[i][1]\n\t\tbreak\nfor i in range(b):\n\tif ar[i][0] != x2 and ar[i][1] != x2:\n\t\ty2[0] = ar[i][0]\n\t\ty2[1] = ar[i][1]\n\t\tbreak\nans1 = acha(ar, x1, y1[0], b)\nans2 = acha(ar, x1, y1[1], b)\nans3 = acha(ar, x2, y2[0], b)\nans4 = acha(ar, x2, y2[1], b)\nif ans1 == False and ans2 == False and (ans3 == False) and (ans4 == False):\n\tprint('NO')\nelse:\n\tprint('YES')\n", "from sys import stdin, stdout\nfrom itertools import combinations\nfrom collections import defaultdict, OrderedDict\nimport math\nimport heapq\n\ndef listIn():\n\treturn list(map(int, stdin.readline().strip().split()))\n\ndef stringListIn():\n\treturn [x for x in stdin.readline().split()]\n\ndef intIn():\n\treturn int(stdin.readline())\n\ndef stringIn():\n\treturn stdin.readline().strip()\n(n, m) = listIn()\ndi = defaultdict(int)\nli = []\nArr = defaultdict(list)\nfor i in range(m):\n\t(a, b) = listIn()\n\tli.append((a, b))\n\tArr[a].append(i + 1)\n\tArr[b].append(i + 1)\n\tdi[a] += 1\n\tdi[b] += 1\n(a, b) = (li[0][0], li[0][1])\nli2 = []\nli2.append(a)\nli2.append(b)\nf = 1\nfor i in range(1, m):\n\tif a not in li[i] and b not in li[i]:\n\t\tf = 0\n\t\tli2.append(li[i][0])\n\t\tli2.append(li[i][1])\n\t\tbreak\nif f:\n\tprint('YES')\nelse:\n\tf = 0\n\tfor i in [0, 1]:\n\t\ts = set(Arr[li2[i]])\n\t\tfor j in [2, 3]:\n\t\t\ts1 = s | set(Arr[li2[j]])\n\t\t\tif len(s1) == m:\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\tif f:\n\t\t\tbreak\n\tif f:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\nl = [set() for i in range(n)]\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tl[a - 1].add(b - 1)\n\tl[b - 1].add(a - 1)\nmax1 = 0\nmax2 = 0\nk1 = 0\nk2 = 0\ns = 0\nfor i in range(n):\n\tif len(l[i]) > max1:\n\t\tmax1 = len(l[i])\n\t\tk1 = i\n\ts += len(l[i])\ns = s // 2\nfor i in range(n):\n\tt = len(l[i])\n\tif i in l[k1]:\n\t\tif t - 1 > max2:\n\t\t\tmax2 = t - 1\n\telif i != k1:\n\t\tif t > max2:\n\t\t\tmax2 = t\nif max1 + max2 == s:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().strip().split())\ncan = False\npairs = []\nfor i in range(m):\n\t(a, b) = map(int, input().strip().split())\n\tpairs.append([a, b])\nfirst = pairs[0][0]\nmissed = []\nfor i in range(m):\n\tif pairs[i][0] != first and pairs[i][1] != first:\n\t\tmissed.append(i)\nif missed != []:\n\tind = missed[0]\n\tsecond = pairs[ind][0]\n\ttest = True\n\tfor i in range(len(missed)):\n\t\tif second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n\t\t\ttest = False\n\t\t\tbreak\n\tif test == True:\n\t\tcan = True\n\tsecond = pairs[ind][1]\n\ttest = True\n\tfor i in range(len(missed)):\n\t\tif second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n\t\t\ttest = False\n\t\t\tbreak\n\tif test == True:\n\t\tcan = True\nelse:\n\tcan = True\nfirst = pairs[0][1]\nmissed = []\nfor i in range(m):\n\tif pairs[i][0] != first and pairs[i][1] != first:\n\t\tmissed.append(i)\nif missed != []:\n\tind = missed[0]\n\tsecond = pairs[ind][0]\n\ttest = True\n\tfor i in range(len(missed)):\n\t\tif second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n\t\t\ttest = False\n\t\t\tbreak\n\tif test == True:\n\t\tcan = True\n\tsecond = pairs[ind][1]\n\ttest = True\n\tfor i in range(len(missed)):\n\t\tif second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n\t\t\ttest = False\n\t\t\tbreak\n\tif test == True:\n\t\tcan = True\nelse:\n\tcan = True\nif can == True:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\n\ndef go():\n\tfor x in a[0]:\n\t\tfor i in range(1, m):\n\t\t\tif x not in a[i]:\n\t\t\t\tfor y in a[i]:\n\t\t\t\t\tfor j in range(i + 1, m):\n\t\t\t\t\t\tif x not in a[j] and y not in a[j]:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn sorted([x, y])\n\t\t\t\tbreak\n\t\telse:\n\t\t\treturn [x, x + 1]\n\treturn []\nprint('YES' if go() else 'NO')\n", "(ure, nre) = list(map(int, input().split()))\nlolly = [list(map(int, input().split())) for i in range(nre)]\nimport sys\nxre = lolly[0][0]\nfor i in range(nre):\n\tif xre not in lolly[i]:\n\t\tyre = lolly[i][0]\n\t\tzre = lolly[i][1]\n\t\tj = i\n\t\tbreak\n\tif i == nre - 1:\n\t\tprint('YES')\n\t\treturn\nkre1 = 1\nkre2 = 1\nfor i in range(j, nre):\n\tif xre not in lolly[i] and yre not in lolly[i]:\n\t\tkre1 = 0\n\t\tbreak\nfor i in range(j, nre):\n\tif xre not in lolly[i] and zre not in lolly[i]:\n\t\tkre2 = 0\n\t\tbreak\nimport sys\nif kre1 == 1 or kre2 == 1:\n\tprint('YES')\n\treturn\nxre = lolly[0][1]\nfor i in range(nre):\n\tif xre not in lolly[i]:\n\t\tyre = lolly[i][0]\n\t\tzre = lolly[i][1]\n\t\tj = i\n\t\tbreak\nkre1 = 1\nkre2 = 1\nfor i in range(j, nre):\n\tif xre not in lolly[i] and yre not in lolly[i]:\n\t\tkre1 = 0\n\t\tbreak\nfor i in range(j, nre):\n\tif xre not in lolly[i] and zre not in lolly[i]:\n\t\tkre2 = 0\n\t\tbreak\nimport sys\nif kre1 == 1 or kre2 == 1:\n\tprint('YES')\n\treturn\nprint('NO')\n", "(n, m) = map(int, input().split())\na = list()\nb = list()\nfor _ in range(m):\n\t(c, d) = map(int, input().split())\n\ta.append(c)\n\tb.append(d)\nx1 = a[0]\nx2 = b[0]\nk = list()\nk.append(x1)\nk.append(x2)\nans = 'NO'\nfor num in k:\n\tcount = 0\n\tf = {}\n\tfor bc in range(1, m):\n\t\tif num != a[bc] and num != b[bc]:\n\t\t\tcount += 1\n\t\t\tp1 = a[bc]\n\t\t\tp2 = b[bc]\n\t\t\tif p1 in f:\n\t\t\t\tf[p1] += 1\n\t\t\tif p1 not in f:\n\t\t\t\tf[p1] = 1\n\t\t\tif p2 in f:\n\t\t\t\tf[p2] += 1\n\t\t\tif p2 not in f:\n\t\t\t\tf[p2] = 1\n\tif count == 0:\n\t\tprint('YES')\n\t\texit()\n\tif count == max(f.values()):\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from itertools import combinations\n(n, m) = list(map(int, input().split()))\nc = [[] for i in range(n + 1)]\np = []\nfor i in range(m):\n\t(x, y) = list(map(int, input().split()))\n\tp.append([x, y])\nx = p[0]\narr = [x[0], x[1]]\nfor i in p:\n\tif len(set(x).intersection(set(i))) == 0:\n\t\tarr.append(i[0])\n\t\tarr.append(i[1])\n\t\tbreak\nfor i in range(m):\n\tfor j in arr:\n\t\tif j in p[i]:\n\t\t\tc[j].append(i)\nx = list(combinations(arr, 2))\nreq = [i for i in range(m)]\nfor i in x:\n\tn1 = i[0]\n\tn2 = i[1]\n\tif list(set(c[n1] + c[n2])) == req:\n\t\tprint('YES')\n\t\treturn\nprint('NO')\n", "(n, m) = map(int, input().split())\na = []\nfor _ in range(m):\n\t(x, y) = map(int, input().split())\n\ta.append((x, y))\nfor i in a[0]:\n\tk = 0\n\tval = [0 for _ in range(n + 1)]\n\tfor p in a:\n\t\tif p[0] != i and p[1] != i:\n\t\t\tval[p[0]] += 1\n\t\t\tval[p[1]] += 1\n\t\t\tk += 1\n\tif max(val) == k:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from collections import Counter\nd = []\n(n, m) = map(int, input().split())\n(x1, x2) = map(int, input().split())\nnx1 = []\nnx2 = []\n(nx1c, nx2c) = (0, 0)\nfor i in range(m - 1):\n\tlol = list(map(int, input().split()))\n\tif x1 not in lol:\n\t\tnx1.extend(list(set(lol)))\n\t\tnx1c += 1\n\tif x2 not in lol:\n\t\tnx2.extend(list(set(lol)))\n\t\tnx2c += 1\nif len(nx1) == 0 or len(nx2) == 0:\n\tprint('YES')\nelse:\n\tflag = 0\n\tcx1 = dict(Counter(nx1))\n\tcx2 = dict(Counter(nx2))\n\tfor u in cx1.values():\n\t\tif u == nx1c:\n\t\t\tflag = 1\n\tfor u in cx2.values():\n\t\tif u == nx2c:\n\t\t\tflag = 1\n\tprint('YES' if flag == 1 else 'NO')\n", "(n, m) = map(int, input().split())\narr = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tarr.append([a, b])\nif m <= 1:\n\tprint('YES')\n\texit()\nx = arr[0][0]\ny = arr[0][1]\nans = {}\nansy = {}\nind2 = 0\nind3 = 0\nfor a in arr:\n\tif x not in a:\n\t\tif a[0] not in ans:\n\t\t\tans[a[0]] = 1\n\t\telse:\n\t\t\tans[a[0]] += 1\n\t\tif a[1] not in ans:\n\t\t\tans[a[1]] = 1\n\t\telse:\n\t\t\tans[a[1]] += 1\n\telse:\n\t\tind2 += 1\n\tif y not in a:\n\t\tif a[0] not in ansy:\n\t\t\tansy[a[0]] = 1\n\t\telse:\n\t\t\tansy[a[0]] += 1\n\t\tif a[1] not in ansy:\n\t\t\tansy[a[1]] = 1\n\t\telse:\n\t\t\tansy[a[1]] += 1\n\telse:\n\t\tind3 += 1\nif ans:\n\tind2 += max(ans.values())\nif ansy:\n\tind3 += max(ansy.values())\nif ind2 >= m or ind3 >= m:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from sys import stdin, stdout\n\ndef find_union_universal_vertex(edges) -> str:\n\n\tdef edge_to_x_or_y(x: int, y: int) -> bool:\n\t\tfor edge in edges:\n\t\t\tif edge[0] != x and edge[0] != y and (edge[1] != x) and (edge[1] != y):\n\t\t\t\treturn False\n\t\treturn True\n\tfor x in edges[0]:\n\t\tif edge_to_x_or_y(x, 0):\n\t\t\treturn 'YES'\n\t\tfor edge in edges:\n\t\t\tif edge[0] != x and edge[1] != x:\n\t\t\t\tif edge_to_x_or_y(x, edge[0]) or edge_to_x_or_y(x, edge[1]):\n\t\t\t\t\treturn 'YES'\n\t\t\t\tbreak\n\treturn 'NO'\n\ndef dp_probability_rule_of_sum(value_upperbound: int, edges) -> str:\n\tdp = [[0 for _ in range(value_upperbound + 1)] for _ in range(value_upperbound + 1)]\n\tfor pair in edges:\n\t\tif pair[0] == pair[1]:\n\t\t\tdp[pair[0]][pair[0]] += 1\n\t\telse:\n\t\t\tdp[pair[0]][pair[0]] += 1\n\t\t\tdp[pair[1]][pair[1]] += 1\n\t\t\tdp[pair[0]][pair[1]] += 1\n\t\t\tdp[pair[1]][pair[0]] += 1\n\tfor i in range(value_upperbound):\n\t\tfor j in range(i + 1, value_upperbound):\n\t\t\tif dp[i][i] + dp[j][j] - dp[i][j] == len(edges):\n\t\t\t\treturn 'YES'\n\treturn 'NO'\n(value_upperbound, n) = map(int, stdin.readline().rstrip().split(' '))\npairs = []\nfor _ in range(n):\n\tline = stdin.readline().rstrip().split(' ')\n\tpairs.append([int(line[0]), int(line[1])])\nstdout.write(find_union_universal_vertex(pairs) + '\\n')\n", "inp = [int(e) for e in input().split(' ')]\np1 = True\np2 = True\nans = 'YES'\na = [int(e) for e in input().split(' ')]\nv1 = a[0]\nv2 = a[1]\ns1 = -1\ns2 = -1\nfor i in range(1, inp[1]):\n\ta = [int(e) for e in input().split(' ')]\n\tif p1:\n\t\tif v1 not in a:\n\t\t\tif s1 == -1:\n\t\t\t\ts1 = set(a)\n\t\t\telif s1 & set(a) == set():\n\t\t\t\tp1 = False\n\t\t\telse:\n\t\t\t\ts1 = s1 & set(a)\n\tif p2:\n\t\tif v2 not in a:\n\t\t\tif s2 == -1:\n\t\t\t\ts2 = set(a)\n\t\t\telif s2 & set(a) == set():\n\t\t\t\tp2 = False\n\t\t\telse:\n\t\t\t\ts2 = s2 & set(a)\n\tif not p1 and (not p2):\n\t\tbreak\nif p1 or p2:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nc = []\nfor ai in range(m):\n\tc.append(input().split())\n(a, b) = c[0]\nka = 0\nkb = 0\ndb = {'a': 0}\nda = {'a': 0}\nfor ai in c:\n\tif a not in ai:\n\t\tka += 1\n\t\tda[ai[0]] = da.get(ai[0], 0) + 1\n\t\tda[ai[1]] = da.get(ai[1], 0) + 1\n\tif b not in ai:\n\t\tkb += 1\n\t\tdb[ai[0]] = db.get(ai[0], 0) + 1\n\t\tdb[ai[1]] = db.get(ai[1], 0) + 1\nif ka == max(da.values()):\n\tprint('YES')\nelif kb == max(db.values()):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = list(map(int, input().split()))\na = []\nfor i in range(m):\n\ta.append(list(map(int, input().split())))\nb = [0] * m\nfor i in range(m):\n\tif a[0][0] in a[i] or a[0][1] in a[i]:\n\t\tb[i] = 1\nif list(set(b)) == [1]:\n\tprint('YES')\nelse:\n\te = 0\n\tfor i in range(2):\n\t\tb = [0] * m\n\t\tfor j in range(m):\n\t\t\tif a[0][i] in a[j]:\n\t\t\t\tb[j] = 1\n\t\tfor j in range(m):\n\t\t\tif b[j] == 0:\n\t\t\t\tk = j\n\t\t\t\tbreak\n\t\tfor j in range(2):\n\t\t\tc = b.copy()\n\t\t\tfor l in range(m):\n\t\t\t\tif a[k][j] in a[l]:\n\t\t\t\t\tc[l] = 1\n\t\t\tif list(set(c)) == [1]:\n\t\t\t\te = 1\n\tif e == 1:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\npairs = []\nd = set()\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tpairs.append([a, b])\n\tif a not in d and b not in d:\n\t\tif len(d) >= 4:\n\t\t\tprint('NO')\n\t\t\texit()\n\t\telse:\n\t\t\td.add(a)\n\t\t\td.add(b)\nd = list(d)\nfor i in range(len(d)):\n\tfor j in range(i + 1, len(d)):\n\t\ts = set()\n\t\ts.add(d[i])\n\t\ts.add(d[j])\n\t\tf = True\n\t\tfor p in pairs:\n\t\t\tif p[0] not in s and p[1] not in s:\n\t\t\t\tf = False\n\t\t\t\tbreak\n\t\tif f:\n\t\t\tprint('YES')\n\t\t\texit()\nprint('NO')\n", "(n, m) = tuple(map(int, input().split()))\npairs = []\nfor i in range(m):\n\tpairs.append(tuple(map(int, input().split())))\nd1 = pairs[0][0]\nd2 = pairs[0][1]\nk1 = -1\nk2 = -1\n(T1, T2) = (True, True)\nfor i in range(1, m):\n\tif pairs[i][0] == d1 or pairs[i][1] == d1:\n\t\tcontinue\n\telif k1 == -1 and k2 == -1:\n\t\tk1 = pairs[i][0]\n\t\tk2 = pairs[i][1]\n\telif k2 == -1 and (k1 == pairs[i][0] or k1 == pairs[i][1]):\n\t\tcontinue\n\telif k1 == pairs[i][0] and k2 == pairs[i][1] or (k1 == pairs[i][1] and k2 == pairs[i][0]):\n\t\tcontinue\n\telif k1 == pairs[i][0] or k1 == pairs[i][1]:\n\t\tk2 = -1\n\telif k2 == pairs[i][0] or k2 == pairs[i][1]:\n\t\tk1 = k2\n\t\tk2 = -1\n\telse:\n\t\tT1 = False\nk1 = -1\nk2 = -1\nfor i in range(1, m):\n\tif pairs[i][0] == d2 or pairs[i][1] == d2:\n\t\tcontinue\n\telif k1 == -1 and k2 == -1:\n\t\tk1 = pairs[i][0]\n\t\tk2 = pairs[i][1]\n\telif k2 == -1 and (k1 == pairs[i][0] or k1 == pairs[i][1]):\n\t\tcontinue\n\telif k1 == pairs[i][0] and k2 == pairs[i][1] or (k1 == pairs[i][1] and k2 == pairs[i][0]):\n\t\tcontinue\n\telif k1 == pairs[i][0] or k1 == pairs[i][1]:\n\t\tk2 = -1\n\telif k2 == pairs[i][0] or k2 == pairs[i][1]:\n\t\tk1 = k2\n\t\tk2 = -1\n\telse:\n\t\tT2 = False\nif T1 or T2:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from sys import stdin, stdout\n(a, b) = ([], [])\n\ndef test(index, first, second):\n\toutcome = False\n\twhile True:\n\t\tif index >= 0:\n\t\t\toutcome = True\n\t\t\tbreak\n\t\telif first == -1:\n\t\t\toutcome = test(index + 1, a[index], second) or test(index + 1, b[index], second)\n\t\t\tbreak\n\t\telif a[index] == first or b[index] == first:\n\t\t\tindex += 1\n\t\telif second == -1:\n\t\t\toutcome = test(index + 1, first, a[index]) or test(index + 1, first, b[index])\n\t\t\tbreak\n\t\telif a[index] == second or b[index] == second:\n\t\t\tindex += 1\n\t\telse:\n\t\t\tbreak\n\treturn outcome\n\ndef main():\n\t(n, m) = [int(i) for i in stdin.readline().split()]\n\tfor i in range(m):\n\t\t(x, y) = [int(j) for j in stdin.readline().split()]\n\t\ta.append(x)\n\t\tb.append(y)\n\toutcome = test(-m, -1, -1)\n\tif outcome:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nmain()\n", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nl = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tl.append((a, b))\ne1 = l[0][0]\ne2 = l[0][1]\nf = 0\ng = 0\nfor x in l:\n\ta = x[0]\n\tb = x[1]\n\tif a == e1 or b == e1:\n\t\tcontinue\n\telif f == 0:\n\t\ts = set()\n\t\ts.add(a)\n\t\ts.add(b)\n\t\tf = 1\n\telse:\n\t\ts = s & {a, b}\n\t\tif len(s) == 0:\n\t\t\tg = 1\n\t\t\tbreak\nif g == 0:\n\tprint('YES')\n\texit()\ng = 0\nf = 0\nfor x in l:\n\ta = x[0]\n\tb = x[1]\n\tif a == e2 or b == e2:\n\t\tcontinue\n\telif f == 0:\n\t\ts = set()\n\t\ts.add(a)\n\t\ts.add(b)\n\t\tf = 1\n\telse:\n\t\ts = s & {a, b}\n\t\tif len(s) == 0:\n\t\t\tg = 1\n\t\t\tbreak\nif g == 0:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\n(a, b) = map(int, input().split())\nans = 1\nl1 = []\nl2 = []\nfor i in range(m - 1):\n\t(x, y) = map(int, input().split())\n\tif x != a and y != a:\n\t\tl1.append(x)\n\t\tl1.append(y)\n\tif x != b and y != b:\n\t\tl2.append(x)\n\t\tl2.append(y)\nl3 = [0] * 300003\nfor i in range(len(l1)):\n\tl3[l1[i]] += 1\nl4 = [0] * 300003\nfor i in range(len(l2)):\n\tl4[l2[i]] += 1\nif max(l3) == len(l1) // 2 or len(l2) // 2 == max(l4):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "def main():\n\t(n, m) = input().split(' ')\n\tn = int(n)\n\tm = int(m)\n\tpairs = set()\n\t(x, y) = (None, None)\n\tfor i in range(m):\n\t\tpair = input().split(' ')\n\t\tx = int(pair[0])\n\t\ty = int(pair[1])\n\t\tpairs.add((x, y))\n\tfor x in [x, y]:\n\t\tif checkx(pairs, x, 0):\n\t\t\tprint('YES')\n\t\t\tquit()\n\tprint('NO')\n\ndef checkx(pairs: set, target, level):\n\td = set((pair for pair in pairs if target in pair))\n\trest = pairs - d\n\tif level == 1:\n\t\treturn not rest\n\tif not rest:\n\t\treturn True\n\tsample = rest.pop()\n\trest.add(sample)\n\treturn checkx(rest, sample[0], 1) or checkx(rest, sample[1], 1)\nmain()\n", "from collections import Counter\n\ndef common(mat):\n\tp = Counter(mat)\n\tfor j in p:\n\t\tif p[j] == len(mat) // 2:\n\t\t\treturn j\n\treturn False\n\ndef solve(n, m, mat, s):\n\tc = mat[0][0]\n\tpoc = []\n\tk = 0\n\tfor j in range(1, m):\n\t\tif c not in mat[j]:\n\t\t\tpoc.append(mat[j][0])\n\t\t\tpoc.append(mat[j][1])\n\t\t\tk = 1\n\tif k == 0 and c != n:\n\t\treturn 'YES'\n\tp = common(poc)\n\tif p != False and (p > c or c > p):\n\t\treturn 'YES'\n\tc = mat[0][1]\n\tpoc = []\n\tk = 0\n\tfor j in range(1, m):\n\t\tif c not in mat[j]:\n\t\t\tpoc.append(mat[j][0])\n\t\t\tpoc.append(mat[j][1])\n\t\t\tk = 1\n\tif k == 0 and c != n:\n\t\treturn 'YES'\n\tp = common(poc)\n\tif p != False and (p > c or c > p):\n\t\treturn 'YES'\n\treturn 'NO'\n(n, m) = map(int, input().split())\nmat = []\ns = set()\nfor i in range(m):\n\t(c, d) = sorted(map(int, input().split()))\n\ts.add(c)\n\ts.add(d)\n\tmat.append([c, d])\nprint(solve(n, m, mat, s))\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nl = [[] for i in range(n)]\nvals = [[] for i in range(m)]\nfor i in range(m):\n\t(temp1, temp2) = input().split()\n\ttemp1 = int(temp1)\n\ttemp2 = int(temp2)\n\tl[temp1 - 1].append(i)\n\tl[temp2 - 1].append(i)\n\tvals[i] = [temp1 - 1, temp2 - 1]\nx = list(range(m))\nflag = False\none = vals[0][0]\nl[one].sort()\nokay = False\nl[one] = list(set(l[one]))\nfor i in range(len(l[one])):\n\tif l[one][i] != x[i]:\n\t\tokay = True\n\t\tthen = x[i]\n\t\tbreak\nif len(l[one]) < m:\n\tif okay == False:\n\t\tokay = True\n\t\tthen = len(l[one])\nif okay:\n\tone1 = vals[then][0]\n\tone2 = vals[then][1]\n\ttemp = l[one] + l[one1]\n\ttemp.sort()\n\ttemp = list(set(temp))\n\tif temp == x:\n\t\tflag = True\n\telse:\n\t\ttemp = l[one] + l[one2]\n\t\ttemp.sort()\n\t\ttemp = list(set(temp))\n\t\tif temp == x:\n\t\t\tflag = True\nif l[one] == x:\n\tflag = True\nif flag == False:\n\tone = vals[0][1]\n\tl[one].sort()\n\tokay = False\n\tl[one] = list(set(l[one]))\n\tfor i in range(len(l[one])):\n\t\tif l[one][i] != x[i]:\n\t\t\tokay = True\n\t\t\tthen = x[i]\n\t\t\tbreak\n\tif len(l[one]) < m:\n\t\tif okay == False:\n\t\t\tokay = True\n\t\t\tthen = len(l[one])\n\tif okay:\n\t\tone1 = vals[then][0]\n\t\tone2 = vals[then][1]\n\t\ttemp = l[one] + l[one1]\n\t\ttemp.sort()\n\t\ttemp = list(set(temp))\n\t\tif temp == x:\n\t\t\tflag = True\n\t\telse:\n\t\t\ttemp = l[one] + l[one2]\n\t\t\ttemp.sort()\n\t\t\ttemp = list(set(temp))\n\t\t\tif temp == x:\n\t\t\t\tflag = True\n\tif l[one] == x:\n\t\tflag = True\nif flag:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nab = [0] * m\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tab[i] = (a, b)\nfor x in ab[0]:\n\td = [0] * n\n\tall = 0\n\tfor i in range(m):\n\t\t(a, b) = (ab[i][0], ab[i][1])\n\t\tif a != x and b != x:\n\t\t\td[a - 1] += 1\n\t\t\td[b - 1] += 1\n\t\t\tall += 1\n\tif max(d) == all:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from math import *\n\ndef solve():\n\t(n, m) = [int(x) for x in input().split()]\n\tk = [0] * n\n\tpairs = dict()\n\tfor i in range(m):\n\t\t(a, b) = [int(x) for x in input().split()]\n\t\tk[a - 1] += 1\n\t\tk[b - 1] += 1\n\t\tif (a, b) in pairs:\n\t\t\tpairs[a, b] += 1\n\t\telse:\n\t\t\tpairs[a, b] = 1\n\tcandidates = []\n\tfor i in range(1, n + 1):\n\t\tif k[i - 1] >= m / 2:\n\t\t\tcandidates += [i]\n\tfor i in candidates:\n\t\tfor j in range(1, n + 1):\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tx = k[i - 1]\n\t\t\ty = k[j - 1]\n\t\t\tintersect = pairs.get((i, j), 0) + pairs.get((j, i), 0)\n\t\t\tif x + y - intersect >= m:\n\t\t\t\treturn 'YES'\n\treturn 'NO'\nprint(solve())\n", "(n, m) = [int(i) for i in input().split()]\nl = []\nfor i in range(m):\n\tl.append([int(i) for i in input().split()])\ndone = 0\nfor x in range(2):\n\tif done == 0:\n\t\ta = l[0][x]\n\t\tvisited = [0 for i in range(m)]\n\t\tvisited[0] = 1\n\t\tfound = 1\n\t\tnext_round = 0\n\t\tfor i in range(1, m):\n\t\t\tif l[i][0] == a or l[i][1] == a:\n\t\t\t\tvisited[i] = 1\n\t\t\t\tfound += 1\n\t\t\t\tcontinue\n\t\t\tif visited[i] == 0 and next_round == 0:\n\t\t\t\tnext_round = i\n\t\tif found >= m:\n\t\t\tprint('YES')\n\t\t\tdone = 1\n\t\telse:\n\t\t\tfor tmp in range(2):\n\t\t\t\tn1 = l[next_round][tmp]\n\t\t\t\tfound1 = 0\n\t\t\t\tfor i in range(m):\n\t\t\t\t\tif (l[i][0] == n1 or l[i][1] == n1) and visited[i] == 0:\n\t\t\t\t\t\tfound1 += 1\n\t\t\t\t\t\tcontinue\n\t\t\t\tif found1 + found >= m:\n\t\t\t\t\tprint('YES')\n\t\t\t\t\tdone = 1\n\t\t\t\t\tbreak\nif done == 0:\n\tprint('NO')\n", "import collections\n(n, m) = map(int, input().split())\na = [list(map(int, input().split())) for i in range(m)]\n(x, y) = a.pop()\nans = 'NO'\nfor v in (x, y):\n\tval = [0] * (n + 1)\n\tcnt = 0\n\tfor (v1, v2) in a:\n\t\tif v1 != v and v2 != v:\n\t\t\t(val[v1], val[v2], cnt) = (val[v1] + 1, val[v2] + 1, cnt + 1)\n\tif max(val) == cnt:\n\t\tans = 'YES'\n\t\tbreak\nprint(ans)\n", "from sys import stdin, stdout\n\ndef IsPos(x, y):\n\tfor (xx, yy) in l:\n\t\tif xx not in [x, y] and yy not in [x, y]:\n\t\t\treturn False\n\treturn True\nfor _ in range(1):\n\t(m, n) = list(map(int, stdin.readline().split()))\n\tl = []\n\tf = 0\n\tfor i in range(n):\n\t\t(A, B) = list(map(int, stdin.readline().split()))\n\t\tl += [[A, B]]\n\tif IsPos(l[0][0], l[0][1]):\n\t\tprint('YES')\n\t\tcontinue\n\tx = l[0][0]\n\tfor i in range(1, n):\n\t\tif x not in l[i]:\n\t\t\tif IsPos(x, l[i][0]) or IsPos(x, l[i][1]):\n\t\t\t\tf = 1\n\t\t\tbreak\n\tif f:\n\t\tprint('YES')\n\t\tcontinue\n\ty = l[0][1]\n\tfor i in range(1, n):\n\t\tif y not in l[i]:\n\t\t\tif IsPos(y, l[i][0]) or IsPos(y, l[i][1]):\n\t\t\t\tf = 1\n\t\t\tbreak\n\tprint('YES' if f else 'NO')\n", "from collections import Counter\n(n, m) = map(int, input().split())\ncp = []\nfor i in range(m):\n\tcp.append(list(map(int, input().split())))\n(v1, v2) = (cp[0][0], cp[0][1])\n(m1, m2) = ([], [])\nfor i in range(1, m):\n\tif v1 not in cp[i]:\n\t\tm1.append(cp[i])\n\tif v2 not in cp[i]:\n\t\tm2.append(cp[i])\nused = [[], [], [], []]\nif (len(m1) < 2) | (len(m2) < 2):\n\tprint('YES')\nelse:\n\t(v1, v2) = (m1[0][0], m1[0][1])\n\tfor i in range(1, len(m1)):\n\t\tif v1 not in m1[i]:\n\t\t\tused[0].append(0)\n\t\telse:\n\t\t\tused[0].append(1)\n\t\tif v2 not in m1[i]:\n\t\t\tused[1].append(0)\n\t\telse:\n\t\t\tused[1].append(1)\n\t(v1, v2) = (m2[0][0], m2[0][1])\n\tfor i in range(1, len(m2)):\n\t\tif v1 not in m2[i]:\n\t\t\tused[2].append(0)\n\t\telse:\n\t\t\tused[2].append(1)\n\t\tif v2 not in m2[i]:\n\t\t\tused[3].append(0)\n\t\telse:\n\t\t\tused[3].append(1)\n\tb = False\n\tfor i in range(4):\n\t\tif Counter(used[i])[0] == 0:\n\t\t\tb = True\n\t\t\tbreak\n\tif b:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "from collections import defaultdict, Counter, deque\nfrom math import sqrt, log10, log, floor, factorial, gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, combinations\nimport sys, io, os\ninput = sys.stdin.readline\ninf = float('inf')\nmod = 10 ** 9 + 7\n\ndef get_list():\n\treturn [int(i) for i in input().split()]\n\ndef yn(a):\n\tprint('YES' if a else 'NO')\nceil = lambda a, b: (a + b - 1) // b\n\ndef check(m):\n\tif len(m) <= 1:\n\t\treturn 1\n\ts = set(tuple(m[0]))\n\tfor i in m:\n\t\ts = s.intersection(tuple(i))\n\treturn len(s) == 1\nt = 1\nfor i in range(t):\n\t(n, k) = [int(i) for i in input().split()]\n\tl = []\n\tfor i in range(k):\n\t\tl.append([int(i) for i in input().split()])\n\ta = l[0][0]\n\tif check([i for i in l if a not in i]):\n\t\tyn(1)\n\t\tcontinue\n\ta = l[0][1]\n\tif check([i for i in l if a not in i]):\n\t\tyn(1)\n\t\tcontinue\n\tyn(0)\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(aa, bb) = list(map(int, input().split()))\n\ta.append(aa)\n\tb.append(bb)\ncand = [a[0], b[0]]\ngood = 0\nfor c in cand:\n\trest = 0\n\td = {}\n\tfor i in range(m):\n\t\tif a[i] == c or b[i] == c:\n\t\t\tcontinue\n\t\telse:\n\t\t\td[a[i]] = d.get(a[i], 0) + 1\n\t\t\td[b[i]] = d.get(b[i], 0) + 1\n\t\t\trest += 1\n\tif rest == 0:\n\t\tgood = 1\n\tfor k in d.keys():\n\t\tif d[k] == rest:\n\t\t\tgood = 1\nif good == 1:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().strip().split())\na = input().strip().split()\na = [int(i) for i in a]\nb = [a[:]]\nflag = 0\nfor i in range(m - 1):\n\t(a1, a2) = map(int, input().strip().split())\n\tb.append([a1, a2])\n\tif (a1 in a) == False and len(a) < 3 and ((a2 in a) == False):\n\t\ta.append(a1)\n\t\ta.append(a2)\n\tif len(a) == 4 and (a1 in a) == False and ((a2 in a) == False):\n\t\tflag = 1\nif len(a) <= 4 and flag == 0:\n\tif len(a) == 2:\n\t\tprint('YES')\n\tif len(a) == 4:\n\t\ts1 = 0\n\t\ts2 = 0\n\t\ts3 = 0\n\t\ts4 = 0\n\t\ts5 = 0\n\t\ts6 = 0\n\t\tfor (x, y) in b:\n\t\t\tif x in [a[0], a[1]] or y in [a[0], a[1]]:\n\t\t\t\ts1 = s1 + 1\n\t\t\tif x in [a[1], a[2]] or y in [a[1], a[2]]:\n\t\t\t\ts2 = s2 + 1\n\t\t\tif x in [a[2], a[3]] or y in [a[2], a[3]]:\n\t\t\t\ts3 = s3 + 1\n\t\t\tif x in [a[0], a[2]] or y in [a[0], a[2]]:\n\t\t\t\ts4 = s4 + 1\n\t\t\tif x in [a[0], a[3]] or y in [a[0], a[3]]:\n\t\t\t\ts5 = s5 + 1\n\t\t\tif x in [a[1], a[3]] or y in [a[1], a[3]]:\n\t\t\t\ts6 = s6 + 1\n\t\tif s1 == m or s2 == m or s3 == m or (s4 == m) or (s5 == m) or (s6 == m):\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nelse:\n\tprint('NO')\n", "(n, m) = [int(i) for i in input().split()]\nx = []\nflag = True\nflaga = False\nfor _ in range(m):\n\t(a, b) = [int(i) for i in input().split()]\n\tx.append([a, b])\ni = x[0]\nfor l in range(m):\n\tif not (x[l][0] in i or x[l][1] in i):\n\t\tj = x[l]\n\t\tflag = False\n\t\tbreak\nif flag:\n\tflaga = True\nelse:\n\tpa = []\n\tfor s in i:\n\t\tfor d in j:\n\t\t\tpa.append([s, d])\n\tfor s in pa:\n\t\tflag = True\n\t\tfor l in range(m):\n\t\t\tif not (x[l][0] in s or x[l][1] in s):\n\t\t\t\tj = x[l]\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\tif flag:\n\t\t\tflaga = True\n\t\t\tbreak\nif flaga:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nfl1 = 0\nA = []\nB = []\nfor i in range(m):\n\tif i != 0:\n\t\t(x1, y1) = map(int, input().split())\n\t\tif x1 != x and y1 != x:\n\t\t\tA.append([x1, y1])\n\t\tif x1 != y and y1 != y:\n\t\t\tB.append([x1, y1])\n\telse:\n\t\t(x, y) = map(int, input().split())\nif len(A) != 0:\n\tx = A[0][0]\n\ty = A[0][1]\n\tflx = fly = 0\n\tfor i in range(1, len(A)):\n\t\tif A[i][1] != x and A[i][0] != x:\n\t\t\tflx = 1\n\t\tif A[i][1] != y and A[i][0] != y:\n\t\t\tfly = 1\n\tif flx == 0 or fly == 0:\n\t\tprint('YES')\n\telif len(B) != 0:\n\t\tx = B[0][0]\n\t\ty = B[0][1]\n\t\tflx = fly = 0\n\t\tfor i in range(1, len(B)):\n\t\t\tif B[i][1] != x and B[i][0] != x:\n\t\t\t\tflx = 1\n\t\t\tif B[i][1] != y and B[i][0] != y:\n\t\t\t\tfly = 1\n\t\tif flx == 0 or fly == 0:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tprint('YES')\nelse:\n\tprint('YES')\n", "def is_contain(pair, num):\n\treturn pair[0] == num or pair[1] == num\n(n, m) = map(int, input().split())\nx = [list(map(int, input().split())) for i in range(m)]\nans = False\nfor i in x[0]:\n\tcnt = [0] * 300010\n\tmiss = 0\n\tfor pair in x:\n\t\tif not is_contain(pair, i):\n\t\t\tcnt[pair[0]] += 1\n\t\t\tcnt[pair[1]] += 1\n\t\t\tmiss += 1\n\tif max(cnt) == miss:\n\t\tans = True\nif ans:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nli1 = []\nli2 = []\n(xx, yy) = map(int, input().split())\nfor i in range(m - 1):\n\tse = set(map(int, input().split()))\n\tf1 = xx in se\n\tf2 = yy in se\n\tif f1 and (not f2):\n\t\tli2.append(se.copy())\n\telif f2 and (not f1):\n\t\tli1.append(se.copy())\n\telif f1 and f2:\n\t\tcontinue\n\telse:\n\t\tli1.append(se.copy())\n\t\tli2.append(se.copy())\nf1 = True\nf2 = True\nif li1:\n\tans = li1[0].copy()\n\tfor i in li1:\n\t\tans = ans.intersection(i)\n\tif len(ans) == 0:\n\t\tf1 = False\nif li2:\n\tans = li2[0].copy()\n\tfor i in li2:\n\t\tans = ans.intersection(i)\n\tif len(ans) == 0:\n\t\tf2 = False\nif f1 or f2:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from sys import stdin\n(n, m) = list(map(int, stdin.readline().strip().split()))\ns = [list(map(int, stdin.readline().strip().split())) for i in range(m)]\n(a, b) = (s[0][0], s[0][1])\ns1 = []\nflag = False\nfor i in range(len(s)):\n\tif s[i][0] != a and s[i][1] != a:\n\t\ts1.append(s[i])\na1 = 0\nb1 = 0\nfor i in range(len(s1)):\n\tif i == 0:\n\t\t(a1, b1) = (s1[0][0], s1[0][1])\n\t\tcontinue\n\tif a1 != s1[i][1] and a1 != s1[i][0]:\n\t\ta1 = -1\n\tif b1 != s1[i][1] and b1 != s1[i][0]:\n\t\tb1 = -1\nif b1 != -1 or a1 != -1:\n\tflag = True\ns1 = []\nfor i in range(len(s)):\n\tif s[i][0] != b and s[i][1] != b:\n\t\ts1.append(s[i])\na1 = 0\nb1 = 0\nfor i in range(len(s1)):\n\tif i == 0:\n\t\t(a1, b1) = (s1[0][0], s1[0][1])\n\t\tcontinue\n\tif a1 != s1[i][1] and a1 != s1[i][0]:\n\t\ta1 = -1\n\tif b1 != s1[i][1] and b1 != s1[i][0]:\n\t\tb1 = -1\nif b1 != -1 or a1 != -1:\n\tflag = True\nif flag:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = list(map(int, input().split()))\npairs = []\nfor _ in range(m):\n\t(a, b) = tuple(map(int, input().split()))\n\tpairs.append((a, b))\n\ndef find_other(x):\n\tfor p in pairs:\n\t\tif p[0] != x and p[1] != x:\n\t\t\treturn p\n\treturn (-1, -1)\n\ndef check(x, y):\n\tfor p in pairs:\n\t\tif x not in p and y not in p:\n\t\t\treturn False\n\treturn True\np1 = find_other(pairs[0][0])\np2 = find_other(pairs[0][1])\nif p1 == (-1, -1) or p2 == (-1, -1):\n\tprint('YES')\n\texit()\nelif check(pairs[0][0], p1[0]) or check(pairs[0][0], p1[1]) or check(pairs[0][1], p2[0]) or check(pairs[0][1], p2[1]):\n\tprint('YES')\n\texit()\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split(' '))\na = []\nb = []\nfor _ in range(m):\n\t(p, q) = map(int, input().split(' '))\n\ta.append(p)\n\tb.append(q)\nflag = 0\nl1 = []\nl2 = []\nx = a[0]\nfor i in range(1, m):\n\tif a[i] != x and b[i] != x:\n\t\tl1.append(a[i])\n\t\tl2.append(b[i])\nif len(l1) == 0:\n\tprint('YES')\nelse:\n\ty = l1[0]\n\tf1 = 1\n\tf2 = 1\n\tfor i in range(1, len(l1)):\n\t\tif l1[i] != y and l2[i] != y:\n\t\t\tf1 = 0\n\t\t\tbreak\n\ty = l2[0]\n\tfor i in range(1, len(l1)):\n\t\tif l1[i] != y and l2[i] != y:\n\t\t\tf2 = 0\n\t\t\tbreak\n\tif f1 == 1 or f2 == 1:\n\t\tflag = 1\n\tif flag == 1:\n\t\tprint('YES')\n\telse:\n\t\tx = b[0]\n\t\tl1 = []\n\t\tl2 = []\n\t\tfor i in range(1, m):\n\t\t\tif a[i] != x and b[i] != x:\n\t\t\t\tl1.append(a[i])\n\t\t\t\tl2.append(b[i])\n\t\ty = l1[0]\n\t\tf1 = 1\n\t\tf2 = 1\n\t\tfor i in range(1, len(l1)):\n\t\t\tif l1[i] != y and l2[i] != y:\n\t\t\t\tf1 = 0\n\t\t\t\tbreak\n\t\ty = l2[0]\n\t\tfor i in range(1, len(l1)):\n\t\t\tif l1[i] != y and l2[i] != y:\n\t\t\t\tf2 = 0\n\t\t\t\tbreak\n\t\tif f1 == 1 or f2 == 1:\n\t\t\tflag = 1\n\t\tif flag == 1:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\na = []\nfor i in range(0, m):\n\tb = input().split()\n\tb[0] = int(b[0])\n\tb[1] = int(b[1])\n\ta.append(b[0])\n\ta.append(b[1])\nd = [0] * (n + 1)\ncnt = 0\nfor i in range(0, m):\n\tif a[i * 2] != a[0] and a[i * 2 + 1] != a[0]:\n\t\td[a[i * 2 + 1]] += 1\n\t\td[a[i * 2]] += 1\n\t\tcnt += 1\nif cnt == 0:\n\tprint('YES')\n\texit(0)\nif max(d) == cnt:\n\tprint('YES')\n\texit(0)\nd = [0] * (n + 1)\ncnt = 0\nfor i in range(0, m):\n\tif a[i * 2] != a[1] and a[i * 2 + 1] != a[1]:\n\t\td[a[i * 2 + 1]] += 1\n\t\td[a[i * 2]] += 1\n\t\tcnt += 1\nif cnt == 0:\n\tprint('YES')\n\texit(0)\nif max(d) == cnt:\n\tprint('YES')\n\texit(0)\nprint('NO')\n", "import sys\n\ndef check(ans, ind, M):\n\tfor i in range(ind, m):\n\t\tif ans in M[i]:\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn i\n\treturn i + 1\n(n, m) = map(int, input().split())\nM = []\nif m <= 2:\n\tprint('YES')\n\tsys.exit(0)\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tM.append([x, y])\nfor j in M[0]:\n\tn_ind = check(j, 1, M)\n\tif n_ind == m:\n\t\tprint('YES')\n\t\tsys.exit(0)\n\telse:\n\t\tfor k in M[n_ind]:\n\t\t\tfor l in range(n_ind, m):\n\t\t\t\tif j in M[l] or k in M[l]:\n\t\t\t\t\tif l == m - 1:\n\t\t\t\t\t\tprint('YES')\n\t\t\t\t\t\tsys.exit(0)\n\t\t\t\telse:\n\t\t\t\t\tbreak\nprint('NO')\n", "def get(list):\n\tfor z in range(2):\n\t\tx = list[0][z]\n\t\tfor i in range(m):\n\t\t\tif x not in list[i]:\n\t\t\t\tbreak\n\t\telse:\n\t\t\treturn 0\n\t\tfor w in range(2):\n\t\t\ty = list[i][w]\n\t\t\tfor j in range(m):\n\t\t\t\tif x not in list[j] and y not in list[j]:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\treturn 0\n\treturn 1\n(n, m) = map(int, input().split())\nl = []\nfor i in range(m):\n\tl.append(list(map(int, input().strip().split())))\nif get(l) == 0:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\t(u, v) = map(int, input().split())\n\td = [u, v]\n\ta.append(d)\nfor i in a[0]:\n\td = [0] * (n + 1)\n\tc = 0\n\tfor j in range(1, m):\n\t\tif i not in a[j]:\n\t\t\td[a[j][1]] += 1\n\t\t\td[a[j][0]] += 1\n\t\t\tc += 1\n\tif c == max(d):\n\t\texit(print('YES'))\nprint('NO')\n", "from collections import Counter, OrderedDict\nfrom itertools import permutations as perm\nfrom fractions import Fraction\nfrom collections import deque\nfrom sys import stdin\nfrom bisect import *\nfrom heapq import *\nfrom math import *\ng = lambda : stdin.readline().strip()\ngl = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1000000000.0) + 7\ninf = float('inf')\n(m, n) = gil()\np = []\nfor _ in range(n):\n\tp.append(gil())\n\ndef getLeft(x, it):\n\tleft = []\n\tfor i in it:\n\t\tif x not in p[i]:\n\t\t\tleft.append(i)\n\treturn left\nleft1 = getLeft(p[0][0], range(n))\nif len(left1) > 1:\n\t(x, y) = p[left1[0]]\n\tif getLeft(x, left1) == [] or getLeft(y, left1) == []:\n\t\tprint('YES')\n\t\texit()\nelse:\n\tprint('YES')\n\texit()\nleft2 = getLeft(p[0][1], range(n))\nif len(left2) > 1:\n\t(x, y) = p[left2[0]]\n\tif getLeft(x, left2) == [] or getLeft(y, left2) == []:\n\t\tprint('YES')\n\t\texit()\nelse:\n\tprint('YES')\n\texit()\nprint('NO')\n", "[N, M] = list(map(int, input().split()))\nlisti = []\nfor i in range(M):\n\tlisti.append([int(i) for i in input().split()])\nfor x in listi[0]:\n\tarray = N * [0]\n\tAlPr = 0\n\tfor y in range(1, M):\n\t\tif listi[y][0] != x and listi[y][1] != x and (listi[y][0] == listi[y][1]):\n\t\t\tarray[listi[y][0] - 1] += 1\n\t\t\tAlPr += 1\n\t\telif listi[y][0] != x and listi[y][1] != x and (listi[y][0] != listi[y][1]):\n\t\t\tarray[listi[y][0] - 1] += 1\n\t\t\tarray[listi[y][1] - 1] += 1\n\t\t\tAlPr += 1\n\tif max(array) == AlPr:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from sys import stdin\nfrom sys import stdout\n(n, m) = map(int, stdin.readline().split())\npairs = []\nflag = 0\nfor i in range(m):\n\t(u, v) = map(int, stdin.readline().split())\n\tpairs.append((u, v))\nfor i in pairs[0]:\n\tcnt = 0\n\tval = [0] * (n + 1)\n\tfor p in pairs:\n\t\tif p[0] != i and p[1] != i:\n\t\t\tval[p[0]] += 1\n\t\t\tval[p[1]] += 1\n\t\t\tcnt += 1\n\tif cnt in val:\n\t\tflag = 1\n\t\tbreak\nif flag == 1:\n\tstdout.write('YES')\nelse:\n\tstdout.write('NO')\n", "nm = list(map(int, input().split()))\nl = []\nflag = 0\nfor i in range(0, nm[1]):\n\tk = list(map(int, input().split()))\n\tl.append(k)\nfor j in range(2):\n\tx = l[0][j]\n\td = [0] * 300001\n\tc = 0\n\tfor i in l:\n\t\tif i[0] != x and i[1] != x:\n\t\t\td[i[0]] += 1\n\t\t\td[i[1]] += 1\n\t\telse:\n\t\t\tc += 1\n\tif max(d) == nm[1] - c:\n\t\tflag = 1\n\t\tbreak\nif flag:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "test = list(map(int, input().split(' ')))\nn = test[0]\nm = test[1]\nx1 = 0\nx2 = 0\ny1 = 0\ny2 = 0\nt = list(map(int, input().split(' ')))\nx1 = t[0]\ny1 = t[1]\nq1 = []\na = []\na.append(t)\nfor i in range(m - 1):\n\tt = list(map(int, input().split(' ')))\n\ta.append(t)\n\tif x1 not in t:\n\t\tq1.append(t)\nk = 1\nif len(q1) > 0:\n\tx2 = q1[0][0]\n\ty2 = q1[0][1]\n\tfor i in range(1, len(q1)):\n\t\tif x2 not in q1[i]:\n\t\t\tk = 0\n\t\t\tbreak\n\tif k == 1:\n\t\tprint('YES')\n\t\texit()\n\tk = 1\n\tfor i in range(1, len(q1)):\n\t\tif y2 not in q1[i]:\n\t\t\tk = 0\n\t\t\tbreak\n\tif k == 1:\n\t\tprint('YES')\n\t\texit()\n\tk = 1\nq1 = []\nfor i in range(1, m):\n\tif y1 not in a[i]:\n\t\tq1.append(a[i])\nif len(q1) > 0:\n\tx2 = q1[0][0]\n\ty2 = q1[0][1]\n\tfor i in range(1, len(q1)):\n\t\tif x2 not in q1[i]:\n\t\t\tk = 0\n\t\t\tbreak\n\tif k == 1:\n\t\tprint('YES')\n\t\texit()\n\tk = 1\n\tfor i in range(1, len(q1)):\n\t\tif y2 not in q1[i]:\n\t\t\tk = 0\n\t\t\tbreak\nif k == 1:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = [int(x) for x in input().split()]\npairs = []\nfor i in range(m):\n\ta = [int(x) for x in input().split()]\n\tpairs.append(a)\n(x, y) = (pairs[0][0], pairs[0][1])\nfor item in pairs:\n\tif item[0] != x and item[0] != y and (item[1] != x) and (item[1] != y):\n\t\t(a, b, c, d) = (x, y, item[0], item[1])\n\t\tbreak\nelse:\n\t(a, b, c, d) = (x, y, x, y)\nfor (x, y) in ((a, b), (a, c), (b, d), (c, d), (a, d), (b, c)):\n\tfor item in pairs:\n\t\tif item[0] != x and item[1] != x and (item[0] != y) and (item[1] != y):\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\tbreak\nelse:\n\tprint('NO')\n", "import sys\n\ndef get_array():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef get_ints():\n\treturn map(int, sys.stdin.readline().split())\n\ndef input():\n\treturn sys.stdin.readline().strip()\n\ndef main():\n\t(n, m) = get_ints()\n\tarr = [0] * m\n\tfor i in range(m):\n\t\t(a, b) = get_ints()\n\t\tarr[i] = (a, b)\n\tx = arr[0][0]\n\tflag = True\n\tind = 0\n\tfor i in range(m):\n\t\tif x not in arr[i]:\n\t\t\tflag = False\n\t\t\tind = i\n\t\t\ty = arr[i][0]\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\t\treturn\n\tflag = True\n\tfor i in range(ind, m):\n\t\tif y not in arr[i] and x not in arr[i]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\t\treturn\n\ty = arr[ind][1]\n\tflag = True\n\tfor i in range(ind, m):\n\t\tif y not in arr[i] and x not in arr[i]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\t\treturn\n\tx = arr[0][1]\n\tflag = True\n\tind = 0\n\tfor i in range(m):\n\t\tif x not in arr[i]:\n\t\t\tflag = False\n\t\t\tind = i\n\t\t\ty = arr[i][0]\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\t\treturn\n\tflag = True\n\tfor i in range(ind, m):\n\t\tif y not in arr[i] and x not in arr[i]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\t\treturn\n\ty = arr[ind][1]\n\tflag = True\n\tfor i in range(ind, m):\n\t\tif y not in arr[i] and x not in arr[i]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\t\treturn\n\tprint('NO')\nmain()\n", "def check(ch1, ch2):\n\tflag = True\n\tfor pair in pairs:\n\t\tif ch1 not in pair and ch2 not in pair:\n\t\t\tflag = False\n\treturn flag\n(n, m) = map(int, input().strip().split())\na = []\npairs = []\nfor j in range(n + 1):\n\ta.append([])\nfor i in range(m):\n\t(x, y) = map(int, input().strip().split())\n\tpairs.append((x, y))\nw = pairs[0][0]\ny = pairs[0][1]\ne = ' '\nr = ' '\nfor pair in pairs:\n\tif w not in pair and y not in pair:\n\t\te = pair[0]\n\t\tr = pair[1]\n\t\tbreak\nif check(w, e) or check(w, r) or check(y, e) or check(y, r) or check(w, y):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "def check(ls, cand):\n\tfor i in ls:\n\t\tif not i[0] in cand and (not i[1] in cand):\n\t\t\treturn False\n\treturn True\n(n, m) = map(int, input().split())\nls = []\nfor i in range(m):\n\tls.append(tuple(map(int, input().split())))\ninter = set(range(1, n + 1))\nfor i in ls:\n\tinter = inter.intersection(i)\nif len(inter) >= 1:\n\tprint('YES')\nelse:\n\tfirst = ls[0]\n\tfor i in ls:\n\t\tif len(set(first).intersection(set(i))) == 0:\n\t\t\tsecond = i\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit()\n\tcand = [(first[0], second[0]), (first[0], second[1]), (first[1], second[0]), (first[1], second[1])]\n\tfor i in cand:\n\t\tif check(ls, i):\n\t\t\tprint('YES')\n\t\t\tbreak\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\nalt_c1 = 0\nalt_c2 = 0\nvals_1 = [0] * (n + 1)\nvals_2 = [0] * (n + 1)\n(a, b) = map(int, input().split())\nfor i in range(m - 1):\n\t(ai, bi) = map(int, input().split())\n\tif ai != a and bi != a:\n\t\tvals_1[ai] += 1\n\t\tvals_1[bi] += 1\n\t\talt_c1 += 1\n\tif ai != b and bi != b:\n\t\tvals_2[ai] += 1\n\t\tvals_2[bi] += 1\n\t\talt_c2 += 1\nif max(vals_1) == alt_c1 or max(vals_2) == alt_c2:\n\tprint('YES')\n\texit()\nprint('NO')\n", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\n(n, m) = I()\ng = [I() for i in range(m)]\n(x, y) = g[0]\ntf = 0\nfor i in [x, y]:\n\ttemp = 0\n\tf = [0] * (n + 1)\n\tfor j in g:\n\t\tif i not in j:\n\t\t\ttemp += 1\n\t\t\tf[j[0]] += 1\n\t\t\tf[j[1]] += 1\n\tif temp == max(f):\n\t\ttf = 1\n\t\tbreak\nprint('YES' if tf else 'NO')\n", "import sys\nimport math\nfrom itertools import permutations\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\narr = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tif a > b:\n\t\tarr.append((b, a))\n\telse:\n\t\tarr.append((a, b))\nflag1 = False\nflag2 = False\nflag3 = False\nflag4 = False\nflag5 = False\nflag6 = False\ncur = 0\nfor i in range(1, m):\n\tif arr[0][0] not in arr[i]:\n\t\tcur = i\n\t\tflag1 = True\n\t\tbreak\nif flag1:\n\tfor i in range(cur + 1, m):\n\t\tif arr[cur][0] not in arr[i] and arr[0][0] not in arr[i]:\n\t\t\tflag2 = True\n\t\t\tbreak\n\tif flag2:\n\t\tfor i in range(cur + 1, m):\n\t\t\tif arr[cur][1] not in arr[i] and arr[0][0] not in arr[i]:\n\t\t\t\tflag3 = True\n\t\t\t\tbreak\n\t\tif flag3:\n\t\t\tfor i in range(1, m):\n\t\t\t\tif arr[0][1] not in arr[i]:\n\t\t\t\t\tcur = i\n\t\t\t\t\tflag4 = True\n\t\t\t\t\tbreak\n\t\t\tif flag4:\n\t\t\t\tfor i in range(cur + 1, m):\n\t\t\t\t\tif arr[cur][0] not in arr[i] and arr[0][1] not in arr[i]:\n\t\t\t\t\t\tflag5 = True\n\t\t\t\t\t\tbreak\n\t\t\t\tif flag5:\n\t\t\t\t\tfor i in range(cur + 1, m):\n\t\t\t\t\t\tif arr[cur][1] not in arr[i] and arr[0][1] not in arr[i]:\n\t\t\t\t\t\t\tflag6 = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif flag6:\n\t\t\t\t\t\tprint('NO')\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint('YES')\n\t\t\t\telse:\n\t\t\t\t\tprint('YES')\n\t\t\telse:\n\t\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('YES')\n\telse:\n\t\tprint('YES')\nelse:\n\tprint('YES')\n", "def covers_all(a1, b1):\n\tfor i in d:\n\t\tif a1 not in i and b1 not in i:\n\t\t\treturn False\n\treturn True\n(n, m) = map(int, input().strip().split())\nd = {}\npair_found = False\npairs = []\nfor i in range(m):\n\t(a, b) = map(int, input().strip().split())\n\tif (a, b) not in d:\n\t\td[a, b] = 1\n\t\tpairs.append((a, b))\n\tif i == 0:\n\t\tn1 = a\n\t\tn2 = b\n\telif pair_found == False and n1 not in [a, b] and (n2 not in [a, b]):\n\t\tn3 = a\n\t\tn4 = b\n\t\tpair_found = True\nif pair_found == False or covers_all(n1, n3) or covers_all(n1, n4) or covers_all(n2, n3) or covers_all(n2, n4):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nbigList = []\nfor i in range(m):\n\tsubList = []\n\t(a, b) = map(int, input().split())\n\tsubList.append(a)\n\tsubList.append(b)\n\tbigList.append(subList)\nretList = []\nx = bigList[0][0]\nfor i in range(1, m):\n\tif x not in bigList[i]:\n\t\ty = bigList[i][0]\n\t\tbreak\nfor j in range(1, m):\n\tif x not in bigList[j] and y not in bigList[j]:\n\t\tretList.append(0)\n\t\tbreak\nfor i in range(1, m):\n\tif x not in bigList[i]:\n\t\ty = bigList[i][1]\n\t\tbreak\nfor j in range(1, m):\n\tif x not in bigList[j] and y not in bigList[j]:\n\t\tretList.append(0)\n\t\tbreak\nx = bigList[0][1]\nfor i in range(1, m):\n\tif x not in bigList[i]:\n\t\ty = bigList[i][0]\n\t\tbreak\nfor j in range(1, m):\n\tif x not in bigList[j] and y not in bigList[j]:\n\t\tretList.append(0)\n\t\tbreak\nfor i in range(1, m):\n\tif x not in bigList[i]:\n\t\ty = bigList[i][1]\n\t\tbreak\nfor j in range(1, m):\n\tif x not in bigList[j] and y not in bigList[j]:\n\t\tretList.append(0)\n\t\tbreak\nif len(retList) < 4:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = tuple([int(i) for i in input().split()])\nlist_couple = []\nfor i in range(m):\n\tlist_couple.append(tuple([int(i) for i in input().split()]))\nflg = 0\nfor x in list_couple[0]:\n\tlist_y = list(filter(lambda x1: x1[0] != x and x1[1] != x, list_couple))\n\tif list_y == []:\n\t\tflg = 1\n\t\tbreak\n\tfor y in list_y[0]:\n\t\tlist_ = list(filter(lambda x1: x1[0] != y and x1[1] != y, list_y))\n\t\tif list_ == []:\n\t\t\tflg = 1\nif flg:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "import sys\n(n, m) = map(int, input().split())\npairs = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tpairs.append([a, b])\nd = {}\npx = pairs[0][0]\npx2 = pairs[0][1]\nfor x in [px, px2]:\n\tremain = []\n\tcount = 0\n\tfor j in pairs:\n\t\tif j[0] == x or j[1] == x:\n\t\t\tcontinue\n\t\telse:\n\t\t\tremain.append(j)\n\t\t\tcount += 1\n\td = {}\n\tif count == 0:\n\t\tprint('YES')\n\t\tsys.exit()\n\tfor j in remain:\n\t\td[j[0]] = d.get(j[0], 0) + 1\n\t\td[j[1]] = d.get(j[1], 0) + 1\n\tfor i in d.values():\n\t\tif i == count:\n\t\t\tprint('YES')\n\t\t\tsys.exit()\nprint('NO')\n", "iarr = list(map(int, input().split()))\nn = iarr[0]\nm = iarr[1]\narr = [0 for i in range(n + 1)]\nxar = [0 for i in range(m)]\nyar = [0 for i in range(m)]\nfor i in range(m):\n\tiarr = list(map(int, input().split()))\n\tx = iarr[0]\n\ty = iarr[1]\n\txar[i] = x\n\tyar[i] = y\n\tarr[x] += 1\n\tarr[y] += 1\nflag = 0\nfor x in range(1, n + 1):\n\tfx = arr[x]\n\tif fx >= m // 2:\n\t\tsfarr = [0 for i in range(n + 1)]\n\t\tfor j in range(m):\n\t\t\tif xar[j] != x and yar[j] != x:\n\t\t\t\tsfarr[xar[j]] += 1\n\t\t\t\tsfarr[yar[j]] += 1\n\t\tfor j in range(1, n + 1):\n\t\t\tif sfarr[j] == m - fx:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\nif flag == 1:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "from sys import stdin, stdout\nfrom math import *\n\ndef tryxy(x, y):\n\tglobal n, m, a, b\n\tfor i in range(m):\n\t\tif not (a[i] == x or b[i] == x or a[i] == y or (b[i] == y)):\n\t\t\treturn False\n\treturn True\n\ndef tryx(x):\n\tglobal n, m, a, b\n\ty = None\n\tfor i in range(m):\n\t\tif a[i] == x or b[i] == x:\n\t\t\tcontinue\n\t\telif tryxy(x, a[i]) == True or tryxy(x, b[i]) == True:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\treturn True\n\ndef main():\n\tglobal n, m, a, b\n\t(n, m) = [int(x) for x in stdin.readline().split()]\n\ta = [0] * m\n\tb = [0] * m\n\tfor i in range(m):\n\t\t(a[i], b[i]) = [int(x) for x in stdin.readline().split()]\n\tif tryx(a[0]) or tryx(b[0]):\n\t\tstdout.write('YES')\n\telse:\n\t\tstdout.write('NO')\n\treturn 0\nmain()\n", "def main():\n\n\tdef check(x, y):\n\t\tfor (a, b) in mas:\n\t\t\tif not ((a == x or a == y) or (b == x or b == y)):\n\t\t\t\treturn [a, b]\n\t\treturn [-1, -1]\n\n\tdef check1(x, y):\n\t\tfor (a, b) in mas:\n\t\t\tif not ((a == x or a == y) or (b == x or b == y)):\n\t\t\t\treturn False\n\t\treturn True\n\t(n, m) = list(map(int, input().split()))\n\tmas = []\n\tans = False\n\tfor i in range(m):\n\t\tmas.append(sorted(list(map(int, input().split()))))\n\tk = check(*mas[0])\n\tif k == [-1, -1]:\n\t\tprint('YES')\n\telse:\n\t\tans = check1(mas[0][0], k[0]) or check1(mas[0][0], k[1]) or check1(mas[0][1], k[0]) or check1(mas[0][1], k[1])\n\t\tif ans:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nmain()\n", "nm = input().split(' ')\nn = int(nm[0])\nm = int(nm[1])\npairs = []\nfor i in range(m):\n\tab = input().split(' ')\n\ta = int(ab[0])\n\tb = int(ab[1])\n\tpairs.append((a, b))\nx1 = pairs[0][0]\nothers = []\nfor i in range(1, m):\n\tif pairs[i][0] == x1 or pairs[i][1] == x1:\n\t\tcontinue\n\telse:\n\t\tothers.append(pairs[i])\ncarr = [0 for i in range(n)]\nfor i in range(len(others)):\n\tcarr[others[i][0] - 1] += 1\n\tcarr[others[i][1] - 1] += 1\nif max(carr) == len(others):\n\tprint('YES')\n\texit()\nx2 = pairs[0][1]\nothers = []\nfor i in range(1, m):\n\tif pairs[i][0] == x2 or pairs[i][1] == x2:\n\t\tcontinue\n\telse:\n\t\tothers.append(pairs[i])\ncarr = [0 for i in range(n)]\nfor i in range(len(others)):\n\tcarr[others[i][0] - 1] += 1\n\tcarr[others[i][1] - 1] += 1\nif max(carr) == len(others):\n\tprint('YES')\n\texit()\nprint('NO')\n", "(n, m) = map(int, input().split())\ns = {}\nst = False\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tif i == 0:\n\t\txx = x\n\t\tyy = y\n\telif st == False:\n\t\tif yy not in [x, y] and xx not in [x, y]:\n\t\t\txx2 = x\n\t\t\tyy2 = y\n\t\t\tst = True\n\ttry:\n\t\ts[x].add(i)\n\texcept:\n\t\ts[x] = set([i])\n\ttry:\n\t\ts[y].add(i)\n\texcept:\n\t\ts[y] = set([i])\nstt = 'NO'\nk = set(list(range(0, m)))\narr = [xx, yy]\nif st:\n\tarr.extend([xx2, yy2])\nfor i in arr:\n\tif len(s[i]) >= m / 2:\n\t\tfor ii in arr:\n\t\t\tif i == ii:\n\t\t\t\tcontinue\n\t\t\tif len(s[ii]) >= m - len(s[i]):\n\t\t\t\tif s[ii].union(s[i]) == k:\n\t\t\t\t\tstt = 'YES'\n\t\t\t\t\tbreak\nprint(stt)\n", "from collections import defaultdict\n(n, m) = map(int, input().split(' '))\na = [None for i in range(m)]\nfor i in range(m):\n\t(x, y) = map(int, input().split(' '))\n\ta[i] = [x, y]\n\ndef check(x):\n\tcounter = defaultdict(int)\n\tlast_pair = None\n\tunbound_count = 0\n\tfor i in range(m):\n\t\tif a[i][0] != x and a[i][1] != x:\n\t\t\tunbound_count += 1\n\t\t\tcounter[a[i][0]] += 1\n\t\t\tcounter[a[i][1]] += 1\n\t\t\tlast_pair = a[i]\n\tif unbound_count == 0:\n\t\treturn True\n\treturn counter[last_pair[0]] == unbound_count or counter[last_pair[1]] == unbound_count\nfor x in a[0]:\n\tif check(x):\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "(n, m) = map(int, input().split())\naa = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\taa.append((a, b))\nfor i in aa[0]:\n\td = {0: 0}\n\ty = 0\n\tfor j in aa:\n\t\tif i not in j:\n\t\t\ty += 1\n\t\t\tif j[0] not in d:\n\t\t\t\td[j[0]] = 1\n\t\t\telse:\n\t\t\t\td[j[0]] += 1\n\t\t\tif j[1] not in d:\n\t\t\t\td[j[1]] = 1\n\t\t\telse:\n\t\t\t\td[j[1]] += 1\n\tif y == max(d.values()):\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "from sys import stdin, stdout\nimport math, queue, heapq\nfastinput = stdin.readline\nfastout = stdout.write\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tif n <= 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\ti = 5\n\twhile i * i <= n:\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\n\ndef computeLPSArray(pat, M, lps):\n\tlen = 0\n\tlps[0]\n\ti = 1\n\twhile i < M:\n\t\tif pat[i] == pat[len]:\n\t\t\tlen += 1\n\t\t\tlps[i] = len\n\t\t\ti += 1\n\t\telif len != 0:\n\t\t\tlen = lps[len - 1]\n\t\telse:\n\t\t\tlps[i] = 0\n\t\t\ti += 1\nt = 1\nwhile t:\n\tt -= 1\n\t(n, m) = map(int, fastinput().split())\n\ta = []\n\tfor _ in range(m):\n\t\ta.append(list(map(int, fastinput().split())))\n\tx1 = a[0][0]\n\ty1 = a[0][1]\n\ty2 = a[0][1]\n\tfor i in a:\n\t\tif i[0] == x1 or i[1] == x1:\n\t\t\tcontinue\n\t\telse:\n\t\t\ty1 = i[0]\n\t\t\ty2 = i[1]\n\t\t\tbreak\n\tx2 = a[0][1]\n\ty3 = a[0][0]\n\ty4 = a[0][0]\n\tfor i in a:\n\t\tif i[0] == x2 or i[1] == x2:\n\t\t\tcontinue\n\t\telse:\n\t\t\ty3 = i[0]\n\t\t\ty4 = i[1]\n\t\t\tbreak\n\n\tdef istrue(x, y):\n\t\tfor i in a:\n\t\t\tif i[0] == x or i[0] == y or i[1] == x or (i[1] == y):\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\treturn False\n\t\treturn True\n\tif istrue(x1, y1) or istrue(x1, y2) or istrue(x2, y3) or istrue(x2, y4):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\nli = []\nfor _ in range(m):\n\t(a, b) = map(int, input().split())\n\tli.append([a, b])\nfor x in li[0]:\n\tdic = {-1: 0}\n\tall = 0\n\tfor c in li:\n\t\tif c[0] != x and c[1] != x:\n\t\t\tdic[c[0]] = dic[c[0]] + 1 if dic.get(c[0]) else 1\n\t\t\tdic[c[1]] = dic[c[1]] + 1 if dic.get(c[1]) else 1\n\t\t\tall += 1\n\tif dic[max(dic, key=dic.__getitem__)] == all:\n\t\tprint('YES')\n\t\texit(0)\nprint('NO')\n", "import itertools\n(n, m) = map(int, input().split())\nD = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tD.append((a, b))\nd = []\nfor i in range(m):\n\t(a, b) = D[i]\n\tif len(d) == 0:\n\t\td.append(a)\n\t\td.append(b)\n\telif a not in d and b not in d:\n\t\td.append(a)\n\t\td.append(b)\n\t\tbreak\nR = [i for i in range(len(d))]\nfor (i, j) in itertools.combinations(R, 2):\n\t(a, b) = (d[i], d[j])\n\tfor k in range(m):\n\t\t(a1, b1) = D[k]\n\t\tif a1 != a and a1 != b and (b1 != a) and (b1 != b):\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "def isY(x):\n\tpossible_ys = []\n\txc = 0\n\tfor p in ab:\n\t\tif x in p:\n\t\t\txc += 1\n\t\telif len(possible_ys) == 0:\n\t\t\tpossible_ys = p\n\tif len(possible_ys) == 0:\n\t\treturn True\n\tfor py in possible_ys:\n\t\tyc = 0\n\t\tfor p in ab:\n\t\t\tif x not in p and py in p:\n\t\t\t\tyc += 1\n\t\tif xc + yc == len(ab):\n\t\t\treturn True\n\treturn False\n(n, m) = list(map(int, input().split()))\nab = []\nfor i in range(m):\n\tinp = input()\n\tab.append(list(map(int, inp.split())))\nvalid = False\nfirst = ab[0]\nprint('YES' if isY(first[0]) or isY(first[1]) else 'NO')\n", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nAB = [list(map(int, input().split())) for i in range(m)]\nCANDI = [[0, 0] for i in range(4)]\nx = AB[0][0]\ny = AB[0][1]\nfor (a, b) in AB:\n\tif a == x or b == x:\n\t\tcontinue\n\telse:\n\t\tx1 = a\n\t\tx2 = b\n\t\tbreak\nelse:\n\tprint('YES')\n\tsys.exit()\nfor (a, b) in AB:\n\tif a == y or b == y:\n\t\tcontinue\n\telse:\n\t\ty1 = a\n\t\ty2 = b\n\t\tbreak\nelse:\n\tprint('YES')\n\tsys.exit()\nfor (z, w) in [[x, x1], [x, x2], [y, y1], [y, y2]]:\n\tfor (a, b) in AB:\n\t\tif a == z or b == z or a == w or (b == w):\n\t\t\tcontinue\n\t\telse:\n\t\t\tbreak\n\telse:\n\t\tprint('YES')\n\t\tsys.exit()\nprint('NO')\n", "class Node:\n\n\tdef __init__(self, data):\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.data = data\n\n\tdef add_left(self, data):\n\t\tself.left = data\n\n\tdef add_right(self, data):\n\t\tself.right = data\n(n, m) = [int(x) for x in input().strip().split()]\n(u, v) = [int(x) for x in input().strip().split()]\ntree1 = Node(u)\ntree2 = Node(v)\ndic1 = {}\ndic1[u] = 1\ndic2 = {}\ndic3 = {}\ndic3[u] = 1\ndic4 = {}\ndic4[v] = 1\ndic2[v] = 1\ncount1 = 0\ncount2 = 0\ncount3 = 0\ncount4 = 0\nfor _ in range(m - 1):\n\t(u, v) = [int(x) for x in input().strip().split()]\n\tif u not in dic1 and v not in dic1:\n\t\ttree1.add_left(u)\n\t\tdic1[u] = 1\n\t\tcount1 += 1\n\tif u not in dic3 and v not in dic3:\n\t\ttree1.add_right(v)\n\t\tdic3[v] = 1\n\t\tcount2 += 1\n\tif u not in dic2 and v not in dic2:\n\t\ttree2.add_left(u)\n\t\tdic2[u] = 1\n\t\tcount3 += 1\n\tif u not in dic4 and v not in dic4:\n\t\ttree2.add_right(v)\n\t\tdic4[v] = 1\n\t\tcount4 += 1\nres = min(count1, count2, count3, count4)\nif res > 1:\n\tprint('NO')\nelse:\n\tprint('YES')\n", "(n, m) = list(map(int, input().split()))\nif m < 3:\n\tprint('YES')\nelse:\n\tarr = []\n\tfor i in range(m):\n\t\tarr2 = list(map(int, input().split()))\n\t\tarr.append(arr2)\n\tf1 = arr[0][0]\n\tf2 = arr[0][1]\n\tans = True\n\tnum = f1\n\taaa = []\n\tfor pair in arr:\n\t\tif not num in pair and len(aaa) == 0:\n\t\t\taaa.append(pair[0])\n\t\t\taaa.append(pair[1])\n\t\telif len(aaa) == 1 and (not num in pair):\n\t\t\tif not aaa[0] in pair:\n\t\t\t\tans = False\n\t\telif len(aaa) == 2 and (not num in pair):\n\t\t\tif aaa[0] in pair and aaa[1] not in pair:\n\t\t\t\tdel aaa[1]\n\t\t\tif len(aaa) == 2:\n\t\t\t\tif aaa[1] in pair and aaa[0] not in pair:\n\t\t\t\t\tdel aaa[0]\n\t\t\tif len(aaa) == 1:\n\t\t\t\tif not aaa[0] in pair:\n\t\t\t\t\tans = False\n\t\t\tif len(aaa) == 2:\n\t\t\t\tif not (aaa[0] in pair or aaa[1] in pair):\n\t\t\t\t\tans = False\n\tans2 = True\n\tnum = f2\n\taaa = []\n\tfor pair in arr:\n\t\tif not num in pair and len(aaa) == 0:\n\t\t\taaa.append(pair[0])\n\t\t\taaa.append(pair[1])\n\t\telif len(aaa) == 1 and (not num in pair):\n\t\t\tif not aaa[0] in pair:\n\t\t\t\tans2 = False\n\t\telif len(aaa) == 2 and (not num in pair):\n\t\t\tif aaa[0] in pair and aaa[1] not in pair:\n\t\t\t\tdel aaa[1]\n\t\t\tif len(aaa) == 2:\n\t\t\t\tif aaa[1] in pair and aaa[0] not in pair:\n\t\t\t\t\tdel aaa[0]\n\t\t\tif len(aaa) == 1:\n\t\t\t\tif not aaa[0] in pair:\n\t\t\t\t\tans2 = False\n\t\t\tif len(aaa) == 2:\n\t\t\t\tif not (aaa[0] in pair or aaa[1] in pair):\n\t\t\t\t\tans2 = False\n\tif ans or ans2:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\ta.append(x)\n\tb.append(y)\ng = {}\nai = a[0]\nbi = b[0]\ncounter = 0\nfor i in range(m):\n\tif ai != a[i] and ai != b[i]:\n\t\tif a[i] in g:\n\t\t\tg[a[i]] += 1\n\t\telse:\n\t\t\tg[a[i]] = 1\n\t\tif b[i] in g:\n\t\t\tg[b[i]] += 1\n\t\telse:\n\t\t\tg[b[i]] = 1\n\telse:\n\t\tcounter += 1\nflag = False\nif counter == m:\n\tflag = True\nfor i in g:\n\tif g[i] == m - counter:\n\t\tflag = True\n\t\tbreak\nif flag != True:\n\tg = {}\n\tcounter = 0\n\tfor i in range(m):\n\t\tif bi != a[i] and bi != b[i]:\n\t\t\tif a[i] in g:\n\t\t\t\tg[a[i]] += 1\n\t\t\telse:\n\t\t\t\tg[a[i]] = 1\n\t\t\tif b[i] in g:\n\t\t\t\tg[b[i]] += 1\n\t\t\telse:\n\t\t\t\tg[b[i]] = 1\n\t\telse:\n\t\t\tcounter += 1\n\tfor i in g:\n\t\tif g[i] == m - counter:\n\t\t\tflag = True\n\t\t\tbreak\nif flag == True:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "(n, m) = map(int, input().split())\nif m <= 2:\n\tprint('YES')\n\texit()\na = []\nfor i in range(m):\n\ta.append(sorted(tuple(map(int, input().split()))))\nx1 = a[0][0]\nx2 = a[0][1]\nx3 = -1\nx4 = -1\nfor i in a:\n\tif i[0] == x1 or i[0] == x2:\n\t\tcontinue\n\tif i[1] == x1 or i[1] == x2:\n\t\tcontinue\n\tx3 = i[0]\n\tx4 = i[1]\n\tbreak\nif x4 == -1:\n\tprint('YES')\n\texit()\nc = []\nc.append({x1, x2})\nc.append({x1, x3})\nc.append({x1, x4})\nc.append({x2, x3})\nc.append({x2, x4})\nc.append({x3, x4})\nf = []\nf.append(True)\nf.append(True)\nf.append(True)\nf.append(True)\nf.append(True)\nf.append(True)\nfor i in a:\n\t(x, y) = i\n\tfor j in range(6):\n\t\tif x not in c[j] and y not in c[j]:\n\t\t\tf[j] = False\nans = False\nfor i in f:\n\tans |= i\nif ans:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\n(N, M) = map(int, input().split())\nA = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(M)]\nB = [[] for _ in range(N)]\nfor (i, (a1, a2)) in enumerate(A):\n\tB[a1].append(i)\n\tB[a2].append(i)\n\ndef check(x1, x2):\n\tfor a in A:\n\t\tif not x1 in a and (not x2 in a):\n\t\t\treturn False\n\treturn True\nC = []\nfor i in range(N):\n\tC.append((i, len(B[i])))\nC.sort(reverse=True, key=itemgetter(1))\nn1 = C[0][0]\nans = 'NO'\nif len(B[n1]) == M:\n\tans = 'YES'\nelse:\n\tto_check = [True] * M\n\tfor i in B[n1]:\n\t\tto_check[i] = False\n\tfor m in range(M):\n\t\tif to_check[m]:\n\t\t\t(a1, a2) = A[m]\n\t\t\tbreak\n\tif check(n1, a1):\n\t\tans = 'YES'\n\tif check(n1, a2):\n\t\tans = 'YES'\n\ti = B[n1][0]\n\tfor k in A[i]:\n\t\tif k != n1:\n\t\t\tn2 = k\n\tto_check = [True] * M\n\tfor i in B[n2]:\n\t\tto_check[i] = False\n\tfor m in range(M):\n\t\tif to_check[m]:\n\t\t\t(a1, a2) = A[m]\n\t\t\tbreak\n\tif check(n2, a1):\n\t\tans = 'YES'\n\tif check(n2, a2):\n\t\tans = 'YES'\nprint(ans)\n", "from sys import stdin, stdout\n\ndef find_union_universal_vertex(edges) -> str:\n\n\tdef edge_to_x_or_y(x: int, y: int) -> bool:\n\t\tfor edge in edges:\n\t\t\tif edge[0] != x and edge[0] != y and (edge[1] != x) and (edge[1] != y):\n\t\t\t\treturn False\n\t\treturn True\n\tfor x in edges[0]:\n\t\tif edge_to_x_or_y(x, 0):\n\t\t\treturn 'YES'\n\t\tfor edge in edges:\n\t\t\tif edge[0] != x and edge[1] != x:\n\t\t\t\tif edge_to_x_or_y(x, edge[0]) or edge_to_x_or_y(x, edge[1]):\n\t\t\t\t\treturn 'YES'\n\t\t\t\tbreak\n\treturn 'NO'\n(value_upperbound, n) = map(int, stdin.readline().rstrip().split(' '))\npairs = []\nfor _ in range(n):\n\tpairs.append(stdin.readline().rstrip().split(' '))\nstdout.write(find_union_universal_vertex(pairs) + '\\n')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nx = 0\ny = 0\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\ta.append(x)\n\tb.append(y)\nx = a[0]\ny = 0\nans = 1\nfa = 1\nfb = 1\nfc = 1\nfd = 1\nif m == 1:\n\tprint('YES')\n\tquit()\nfor i in range(1, m):\n\tif a[i] != x and a[i] != y and (b[i] != x) and (b[i] != y):\n\t\ty = a[i]\n\t\tfor j in range(i + 1, m):\n\t\t\tif a[j] != x and a[j] != y and (b[j] != x) and (b[j] != y):\n\t\t\t\tfa = 0\n\t\tif fa == 1:\n\t\t\tprint('YES')\n\t\t\tquit()\n\t\ty = b[i]\n\t\tfor j in range(0, m):\n\t\t\tif a[j] != x and a[j] != y and (b[j] != x) and (b[j] != y):\n\t\t\t\tfb = 0\n\t\tif fb == 1:\n\t\t\tprint('YES')\n\t\t\tquit()\n\t\tbreak\n\tif i + 1 == m:\n\t\tprint('YES')\n\t\tquit()\nx = b[0]\nfor i in range(1, m):\n\tif a[i] != x and a[i] != y and (b[i] != x) and (b[i] != y):\n\t\ty = a[i]\n\t\tfor j in range(0, m):\n\t\t\tif a[j] != x and a[j] != y and (b[j] != x) and (b[j] != y):\n\t\t\t\tfc = 0\n\t\tif fc == 1:\n\t\t\tprint('YES')\n\t\t\tquit()\n\t\ty = b[i]\n\t\tfor j in range(0, m):\n\t\t\tif a[j] != x and a[j] != y and (b[j] != x) and (b[j] != y):\n\t\t\t\tfd = 0\n\t\tif fd == 1:\n\t\t\tprint('YES')\n\t\t\tquit()\n\t\tbreak\n\tif i + 1 == m:\n\t\tprint('YES')\n\t\tquit()\nprint('NO')\n", "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom collections import *\nfrom collections import deque\nfrom operator import itemgetter, attrgetter\nfrom decimal import *\nimport bisect\nimport math\nimport heapq as hq\nMOD = 10 ** 9 + 7\n\ndef is_prime(n):\n\tif n == 2 or n == 3:\n\t\treturn True\n\tif n < 2 or n % 2 == 0:\n\t\treturn False\n\tif n < 9:\n\t\treturn True\n\tif n % 3 == 0:\n\t\treturn False\n\tr = int(n ** 0.5)\n\tf = 5\n\twhile f <= r:\n\t\tif n % f == 0:\n\t\t\treturn False\n\t\tif n % (f + 2) == 0:\n\t\t\treturn False\n\t\tf += 6\n\treturn True\n\ndef pow(a, b, m):\n\tans = 1\n\twhile b:\n\t\tif b & 1:\n\t\t\tans = ans * a % m\n\t\tb //= 2\n\t\ta = a * a % m\n\treturn ans\nvis = []\ngraph = []\n\ndef dfs(v):\n\tif vis[v]:\n\t\treturn 0\n\tvis[v] = True\n\ttemp = 0\n\tfor vv in graph[v]:\n\t\ttemp += dfs(vv)\n\treturn 1 + temp\n\ndef ispalindrome(s):\n\tif s[:] == s[::-1]:\n\t\treturn 1\n\treturn 0\n(n, m) = map(int, input().split())\nmat = []\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tmat.append([x - 1, y - 1])\ntemp = [mat[0][0], mat[0][1]]\nfor i in temp:\n\tl = [0 for j in range(n)]\n\tno = 0\n\tfor j in range(m):\n\t\tif mat[j][0] != i and mat[j][1] != i:\n\t\t\tno += 1\n\t\t\tl[mat[j][0]] += 1\n\t\t\tl[mat[j][1]] += 1\n\tif no <= max(l):\n\t\tprint('YES')\n\t\tbreak\nelse:\n\tprint('NO')\n", "from collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\n\nclass RestAPI(object):\n\n\tdef __init__(self, n, m, pairs):\n\t\tself.pairs = pairs[:]\n\t\tself.n = n\n\t\tself.m = m\n\t\tself.xy_cnt_dt = defaultdict(int)\n\t\tself.xy_dt = defaultdict(list)\n\t\tfor (i, (a, b)) in enumerate(self.pairs):\n\t\t\tself.xy_cnt_dt[a] += 1\n\t\t\tself.xy_cnt_dt[b] += 1\n\t\t\tself.xy_dt[a] += [i]\n\t\t\tself.xy_dt[b] += [i]\n\t\tself.xy_cnt_dt = sorted(self.xy_cnt_dt.items(), key=lambda x: x[1])\n\n\tdef function(self):\n\t\tfor (i, (x, cnt_x)) in reversed(list(enumerate(self.xy_cnt_dt))):\n\t\t\tif cnt_x >= (self.m + 1) // 2:\n\t\t\t\tif cnt_x >= self.m - 1:\n\t\t\t\t\treturn 'YES'\n\t\t\t\tscnd = set()\n\t\t\t\tfor j in set(range(self.m)) - set(self.xy_dt[x]):\n\t\t\t\t\t(lf, rt) = self.pairs[j]\n\t\t\t\t\tif not scnd:\n\t\t\t\t\t\tscnd = set([lf, rt])\n\t\t\t\t\telse:\n\t\t\t\t\t\tscnd &= set([lf, rt])\n\t\t\t\t\t\tif not scnd:\n\t\t\t\t\t\t\tbreak\n\t\t\t\tif scnd:\n\t\t\t\t\treturn 'YES'\n\t\t\telse:\n\t\t\t\treturn 'NO'\n\t\treturn 'NO'\n(n, m) = map(int, input().split())\npairs = [tuple(map(int, input().split())) for _ in range(m)]\napi = RestAPI(n, m, pairs)\nresponse = api.function()\nprint(response)\n", "(n, m) = list(map(int, input().split()))\narr = []\nfor q in range(m):\n\tarr.append(list(map(int, input().split())))\n(a, b) = arr[0]\nc = -1\nd = -1\nflag1 = 1\nflag2 = 1\nflag3 = 1\nflag4 = 1\nflag5 = 1\nfor w in range(m):\n\tif a not in arr[w] and b not in arr[w]:\n\t\tc = arr[w][0]\n\t\td = arr[w][1]\n\t\tflag1 = 0\n\t\tbreak\nif c != -1:\n\tfor e in range(m):\n\t\tif a not in arr[e] and c not in arr[e]:\n\t\t\tflag2 = 0\n\t\tif a not in arr[e] and d not in arr[e]:\n\t\t\tflag3 = 0\n\t\tif b not in arr[e] and c not in arr[e]:\n\t\t\tflag4 = 0\n\t\tif b not in arr[e] and d not in arr[e]:\n\t\t\tflag5 = 0\nif flag1 == 1 or (c != -1 and flag2 == 1) or (c != -1 and flag3 == 1) or (c != -1 and flag4 == 1) or (c != -1 and flag5 == 1):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "dic = {}\n(n, m) = [int(i) for i in input().split()]\ndata = []\nfor i in range(m):\n\t(a, b) = [int(i) for i in input().split()]\n\tdata.append((a, b))\n\tif a not in dic:\n\t\tdic[a] = set()\n\tdic[a].add(i)\n\tif b not in dic:\n\t\tdic[b] = set()\n\tdic[b].add(i)\nlis = list(dic.keys())\nlis.sort(key=lambda elem: len(dic[elem]))\n\ndef good(a, s):\n\tif s.issubset(dic[a]):\n\t\treturn True\n\treturn False\nflag = False\nfor i in range(-1, -1 * min(m + 1, 5), -1):\n\tneed = set(range(m)) - dic[lis[i]]\n\tif len(need) == 0:\n\t\tflag = True\n\t\tbreak\n\tf = need.pop()\n\tneed.add(f)\n\tif good(data[f][0], need) or good(data[f][1], need):\n\t\tflag = True\n\t\tbreak\nif flag:\n\tprint('YES')\nelse:\n\tprint('NO')\n", "import math\nimport heapq, bisect\nimport sys\nfrom collections import deque\nfrom fractions import Fraction\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] <= key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] > k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\n(n, m) = map(int, input().split())\na1 = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\ta1.append((a, b))\n\ndef check(i1, j):\n\tfor i in range(m):\n\t\tif a1[i][0] == i1 or a1[i][1] == i1:\n\t\t\tcontinue\n\t\telif a1[i][0] == j or a1[i][1] == j:\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True\nf = a1[0][0]\nfl = 1\nfor i in range(m):\n\tif a1[i][0] != f and a1[i][1] != f:\n\t\tfl = 0\n\t\tif check(a1[i][0], f) or check(a1[i][1], f):\n\t\t\tfl = 1\n\t\t\tprint('YES')\n\t\t\tsys.exit()\n\t\telse:\n\t\t\tbreak\nf = a1[0][1]\nfl = 1\nfor i in range(m):\n\tif a1[i][0] != f and a1[i][1] != f:\n\t\tfl = 0\n\t\tif check(a1[i][0], f) or check(a1[i][1], f):\n\t\t\tfl = 1\n\t\t\tprint('YES')\n\t\t\tsys.exit()\n\t\telse:\n\t\t\tbreak\nif fl == 0:\n\tprint('NO')\nelse:\n\tprint('YES')\n", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nl = []\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tl.append((a, b))\nfor i in range(2):\n\tindx = l[0][i]\n\tt = [0] * (n + 1)\n\tans = 0\n\tfor j in l:\n\t\tif j[0] != indx and j[1] != indx:\n\t\t\tt[j[0]] += 1\n\t\t\tt[j[1]] += 1\n\t\t\tans += 1\n\tif max(t) == ans:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\n(n, m) = mapin()\ns = set([])\nfor i in range(m):\n\tp = listin()\n\tp.sort()\n\tp = tuple(p)\n\ts.add(p)\nz = list(s)\nn = len(s)\ndegree = defaultdict(int)\nfor i in z:\n\tdegree[i[0]] += 1\n\tdegree[i[1]] += 1\np = list(degree.keys())\nq = list(degree.values())\ndeg = []\nfor i in range(len(q)):\n\tdeg.append((q[i], p[i]))\ndeg.sort(reverse=True)\nif deg[0][0] + deg[1][0] > n:\n\tprint('YES')\nelif deg[0][0] + deg[1][0] < n:\n\tprint('NO')\nelse:\n\tk = defaultdict(list)\n\tfor i in deg:\n\t\tk[i[0]].append(i[1])\n\tfor i in k.keys():\n\t\tif n - i in k:\n\t\t\tfor a in k[i]:\n\t\t\t\tfor b in k[n - i]:\n\t\t\t\t\tif (min(a, b), max(a, b)) not in s and a != b:\n\t\t\t\t\t\tprint('YES')\n\t\t\t\t\t\texit()\n\tprint('NO')\n"], "public_test_cases": [{"input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "output": "NO\n", "type": "stdin"}, {"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": "YES\n", "type": "stdin"}, {"input": "300000 5\n1 2\n1 2\n1 2\n1 2\n1 2\n", "output": "YES\n", "type": "stdin"}], "test_cases": [{"input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "output": "NO\n", "type": "stdin"}, {"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": "YES\n", "type": "stdin"}, {"input": "300000 5\n1 2\n1 2\n1 2\n1 2\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "2 1\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "6 9\n6 2\n4 2\n3 6\n4 6\n2 6\n1 4\n2 6\n4 5\n4 2\n", "output": "YES\n", "type": "stdin"}, {"input": "4 6\n3 4\n4 2\n3 2\n2 1\n1 2\n3 1\n", "output": "YES\n", "type": "stdin"}, {"input": "5 8\n3 2\n5 3\n1 4\n4 5\n3 1\n4 2\n3 5\n2 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 8\n1 4\n1 3\n3 2\n4 3\n2 3\n1 3\n2 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "9 10\n6 5\n9 8\n7 8\n4 5\n5 8\n3 5\n7 8\n9 8\n8 5\n1 5\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 5\n1 4\n6 5\n4 5\n7 4\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 4\n1 4\n6 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 1\n1 3\n2 1\n7 3\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n7 1\n5 1\n2 7\n1 3\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n1 6\n1 3\n7 3\n7 1\n2 1\n", "output": "YES\n", "type": "stdin"}, {"input": "4 1\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "4 2\n1 2\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 4\n1 2\n3 4\n1 4\n2 3\n", "output": "YES\n", "type": "stdin"}, {"input": "4 5\n1 2\n1 3\n1 4\n2 3\n2 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 3\n1 2\n1 3\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 3\n1 2\n2 3\n3 1\n", "output": "YES\n", "type": "stdin"}, {"input": "4 2\n1 2\n2 3\n", "output": "YES\n", "type": "stdin"}, {"input": "4 4\n1 2\n2 3\n3 1\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 3\n1 2\n2 3\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "5 9\n1 2\n1 3\n1 4\n1 5\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "5 8\n1 2\n1 3\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "10 10\n1 3\n1 3\n1 3\n1 3\n1 3\n2 3\n1 5\n2 6\n2 7\n2 9\n", "output": "YES\n", "type": "stdin"}, {"input": "5 7\n1 5\n1 5\n5 2\n5 2\n5 2\n3 2\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "100 2\n1 2\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "6 9\n6 2\n4 2\n3 6\n4 6\n2 6\n1 4\n2 6\n4 5\n4 2\n", "output": "YES", "type": "stdin"}, {"input": "5 8\n1 2\n1 3\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO", "type": "stdin"}, {"input": "4 4\n1 2\n2 3\n3 1\n1 4\n", "output": "YES", "type": "stdin"}, {"input": "4 3\n1 2\n2 3\n3 4\n", "output": "YES", "type": "stdin"}, {"input": "4 3\n1 2\n1 3\n1 4\n", "output": "YES", "type": "stdin"}, {"input": "7 5\n6 4\n1 4\n6 4\n2 4\n6 4\n", "output": "YES", "type": "stdin"}, {"input": "4 2\n1 2\n2 3\n", "output": "YES", "type": "stdin"}, {"input": "7 5\n6 1\n1 3\n2 1\n7 3\n7 1\n", "output": "YES", "type": "stdin"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO", "type": "stdin"}, {"input": "7 5\n7 1\n5 1\n2 7\n1 3\n6 7\n", "output": "YES", "type": "stdin"}, {"input": "4 2\n1 2\n3 4\n", "output": "YES", "type": "stdin"}, {"input": "4 5\n1 2\n1 3\n1 4\n2 3\n2 4\n", "output": "YES", "type": "stdin"}, {"input": "5 8\n3 2\n5 3\n1 4\n4 5\n3 1\n4 2\n3 5\n2 4\n", "output": "YES", "type": "stdin"}, {"input": "5 9\n1 2\n1 3\n1 4\n1 5\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO", "type": "stdin"}, {"input": "4 3\n1 2\n2 3\n3 1\n", "output": "YES", "type": "stdin"}, {"input": "4 6\n3 4\n4 2\n3 2\n2 1\n1 2\n3 1\n", "output": "YES", "type": "stdin"}, {"input": "4 1\n1 2\n", "output": "YES", "type": "stdin"}, {"input": "100 2\n1 2\n1 2\n", "output": "YES", "type": "stdin"}, {"input": "10 10\n1 3\n1 3\n1 3\n1 3\n1 3\n2 3\n1 5\n2 6\n2 7\n2 9\n", "output": "YES", "type": "stdin"}, {"input": "2 1\n1 2\n", "output": "YES", "type": "stdin"}, {"input": "7 5\n6 5\n1 4\n6 5\n4 5\n7 4\n", "output": "YES", "type": "stdin"}, {"input": "4 4\n1 2\n3 4\n1 4\n2 3\n", "output": "YES", "type": "stdin"}, {"input": "5 7\n1 5\n1 5\n5 2\n5 2\n5 2\n3 2\n1 4\n", "output": "YES", "type": "stdin"}, {"input": "4 8\n1 4\n1 3\n3 2\n4 3\n2 3\n1 3\n2 4\n4 1\n", "output": "YES", "type": "stdin"}, {"input": "9 10\n6 5\n9 8\n7 8\n4 5\n5 8\n3 5\n7 8\n9 8\n8 5\n1 5\n", "output": "YES", "type": "stdin"}, {"input": "7 5\n1 6\n1 3\n7 3\n7 1\n2 1\n", "output": "YES", "type": "stdin"}, {"input": "4 3\n1 2\n2 4\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "10 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "7 5\n6 4\n1 5\n6 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "5 8\n3 2\n5 3\n1 4\n4 5\n3 1\n4 2\n3 5\n2 3\n", "output": "YES\n", "type": "stdin"}, {"input": "100 1\n1 2\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "10 10\n1 3\n1 3\n1 3\n1 3\n1 3\n2 3\n1 5\n2 7\n2 7\n2 9\n", "output": "YES\n", "type": "stdin"}, {"input": "5 7\n1 5\n1 5\n5 2\n5 2\n5 2\n4 2\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 8\n1 4\n1 3\n3 2\n4 3\n2 3\n1 3\n1 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 1\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 4\n1 5\n6 4\n3 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "101 1\n1 2\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "5 7\n1 5\n2 5\n5 2\n5 2\n5 2\n4 2\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 8\n1 4\n1 3\n3 2\n4 2\n2 3\n1 3\n1 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 4\n2 5\n6 4\n3 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "101 1\n1 2\n0 2\n", "output": "YES\n", "type": "stdin"}, {"input": "4 8\n1 4\n1 3\n3 2\n4 2\n2 1\n1 3\n1 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 4\n2 5\n6 4\n3 5\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 4\n1 2\n2 4\n3 1\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n5 4\n1 4\n6 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "13 5\n6 1\n1 3\n2 1\n7 3\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 2\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "7 5\n2 1\n5 1\n2 7\n1 3\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "8 2\n1 2\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 5\n1 2\n2 3\n1 4\n2 3\n2 4\n", "output": "YES\n", "type": "stdin"}, {"input": "5 9\n1 2\n1 3\n1 4\n1 5\n2 4\n2 5\n3 2\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "8 1\n1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "10 10\n1 3\n1 3\n1 3\n1 3\n1 3\n2 3\n1 5\n2 3\n2 7\n2 9\n", "output": "YES\n", "type": "stdin"}, {"input": "4 8\n1 4\n1 3\n3 2\n4 3\n2 3\n1 3\n2 4\n4 2\n", "output": "YES\n", "type": "stdin"}, {"input": "12 5\n1 6\n1 3\n7 3\n7 1\n2 1\n", "output": "YES\n", "type": "stdin"}, {"input": "5 4\n1 2\n1 3\n3 4\n4 5\n", "output": "YES\n", "type": "stdin"}, {"input": "6 3\n1 2\n2 4\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "10 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 2\n", "output": "NO\n", "type": "stdin"}, {"input": "5 8\n3 2\n5 3\n1 4\n4 5\n4 1\n4 2\n3 5\n2 3\n", "output": "YES\n", "type": "stdin"}, {"input": "100 1\n1 2\n0 2\n", "output": "YES\n", "type": "stdin"}, {"input": "10 10\n1 3\n1 3\n1 3\n1 4\n1 3\n2 3\n1 5\n2 7\n2 7\n2 9\n", "output": "YES\n", "type": "stdin"}, {"input": "6 7\n1 5\n2 5\n5 2\n5 2\n5 2\n4 2\n1 4\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 4\n1 5\n3 4\n3 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "4 4\n1 4\n1 3\n3 2\n4 2\n2 3\n1 3\n1 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 5\n2 5\n6 4\n3 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "101 1\n1 2\n-1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "7 3\n5 4\n1 4\n6 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "26 5\n6 1\n1 3\n2 1\n7 3\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 4\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "7 5\n2 1\n5 1\n2 7\n1 6\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "4 2\n1 2\n2 3\n1 4\n2 3\n2 4\n", "output": "YES\n", "type": "stdin"}, {"input": "5 9\n1 2\n1 3\n2 4\n1 5\n2 4\n2 5\n3 2\n3 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "6 3\n1 2\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "10 10\n1 3\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 2\n", "output": "NO\n", "type": "stdin"}, {"input": "5 8\n3 2\n5 1\n1 4\n4 5\n4 1\n4 2\n3 5\n2 3\n", "output": "NO\n", "type": "stdin"}, {"input": "100 1\n1 2\n-1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "10 6\n1 3\n1 3\n1 3\n1 4\n1 3\n2 3\n1 5\n2 7\n2 7\n2 9\n", "output": "YES\n", "type": "stdin"}, {"input": "4 1\n1 4\n1 3\n3 2\n4 2\n2 3\n1 3\n1 4\n4 1\n", "output": "YES\n", "type": "stdin"}, {"input": "111 1\n1 2\n-1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "7 3\n5 2\n1 4\n6 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "26 1\n6 1\n1 3\n2 1\n7 3\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "5 9\n1 2\n2 3\n2 4\n1 5\n2 4\n2 5\n3 2\n3 5\n4 5\n", "output": "YES\n", "type": "stdin"}, {"input": "5 8\n3 2\n5 1\n1 4\n4 5\n4 1\n4 3\n3 5\n2 3\n", "output": "NO\n", "type": "stdin"}, {"input": "101 1\n1 2\n-2 2\n", "output": "YES\n", "type": "stdin"}, {"input": "110 1\n1 2\n-1 2\n", "output": "YES\n", "type": "stdin"}, {"input": "7 1\n5 2\n1 4\n6 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "26 1\n6 1\n1 3\n2 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "101 1\n1 2\n-2 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 1\n5 2\n1 4\n9 4\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "26 1\n6 1\n1 3\n3 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 1\n5 2\n1 4\n9 4\n2 4\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "26 1\n2 1\n1 3\n3 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 1\n5 2\n1 4\n9 4\n2 0\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "26 1\n2 1\n1 2\n3 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 1\n5 2\n1 5\n9 4\n2 0\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "29 1\n2 1\n1 2\n3 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "7 1\n5 2\n2 5\n9 4\n2 0\n6 7\n", "output": "YES\n", "type": "stdin"}, {"input": "29 1\n2 1\n2 2\n3 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "29 1\n3 1\n2 2\n3 1\n7 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "29 1\n3 1\n2 2\n3 1\n8 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "29 1\n3 1\n2 4\n3 1\n8 2\n7 1\n", "output": "YES\n", "type": "stdin"}, {"input": "6 9\n6 2\n4 2\n3 6\n4 6\n2 6\n1 4\n1 6\n4 5\n4 2\n", "output": "YES\n", "type": "stdin"}, {"input": "7 5\n6 4\n1 4\n6 5\n2 4\n6 4\n", "output": "YES\n", "type": "stdin"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n4 5\n4 5\n", "output": "NO\n", "type": "stdin"}, {"input": "7 5\n7 1\n5 1\n2 7\n1 3\n4 7\n", "output": "YES\n", "type": "stdin"}, {"input": "4 5\n1 2\n1 3\n1 4\n2 3\n3 4\n", "output": "YES\n", "type": "stdin"}, {"input": "300000 5\n1 2\n1 2\n1 2\n1 2\n1 2\n", "output": "YES", "type": "stdin"}, {"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": "YES", "type": "stdin"}, {"input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "output": "NO", "type": "stdin"}], "problem_id": "taco_train_119", "metadata": {"config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 138}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nThe main street of Berland is a straight line with n houses built along it (n is an even number). The houses are located at both sides of the street. The houses with odd numbers are at one side of the street and are numbered from 1 to n - 1 in the order from the beginning of the street to the end (in the picture: from left to right). The houses with even numbers are at the other side of the street and are numbered from 2 to n in the order from the end of the street to its beginning (in the picture: from right to left). The corresponding houses with even and odd numbers are strictly opposite each other, that is, house 1 is opposite house n, house 3 is opposite house n - 2, house 5 is opposite house n - 4 and so on. [Image] \n\nVasya needs to get to house number a as quickly as possible. He starts driving from the beginning of the street and drives his car to house a. To get from the beginning of the street to houses number 1 and n, he spends exactly 1 second. He also spends exactly one second to drive the distance between two neighbouring houses. Vasya can park at any side of the road, so the distance between the beginning of the street at the houses that stand opposite one another should be considered the same.\n\nYour task is: find the minimum time Vasya needs to reach house a.\n\n\n-----Input-----\n\nThe first line of the input contains two integers, n and a (1 \u2264 a \u2264 n \u2264 100 000)\u00a0\u2014 the number of houses on the street and the number of the house that Vasya needs to reach, correspondingly. It is guaranteed that number n is even.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimum time Vasya needs to get from the beginning of the street to house a.\n\n\n-----Examples-----\nInput\n4 2\n\nOutput\n2\n\nInput\n8 5\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample there are only four houses on the street, two houses at each side. House 2 will be the last at Vasya's right.\n\nThe second sample corresponds to picture with n = 8. House 5 is the one before last at Vasya's left.\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\n(n, a) = map(int, input().split())\nif a % 2 == 1:\n\tprint(a // 2 + 1)\nelse:\n\tprint((n - a + 1) // 2 + 1)\n\n```"], "public_test_cases": [{"input": "4 2\n", "output": "2\n", "type": "stdin"}, {"input": "8 5\n", "output": "3\n", "type": "stdin"}], "test_cases": [{"input": "4 2\n", "output": "2\n", "type": "stdin"}, {"input": "8 5\n", "output": "3\n", "type": "stdin"}, {"input": "2 1\n", "output": "1\n", "type": "stdin"}, {"input": "2 2\n", "output": "1\n", "type": "stdin"}, {"input": "10 1\n", "output": "1\n", "type": "stdin"}, {"input": "10 10\n", "output": "1\n", "type": "stdin"}, {"input": "100000 100000\n", "output": "1\n", "type": "stdin"}, {"input": "100000 2\n", "output": "50000\n", "type": "stdin"}, {"input": "100000 3\n", "output": "2\n", "type": "stdin"}, {"input": "100000 99999\n", "output": "50000\n", "type": "stdin"}, {"input": "100 100\n", "output": "1\n", "type": "stdin"}, {"input": "3000 34\n", "output": "1484\n", "type": "stdin"}, {"input": "2000 1\n", "output": "1\n", "type": "stdin"}, {"input": "100000 1\n", "output": "1\n", "type": "stdin"}, {"input": "24842 1038\n", "output": "11903\n", "type": "stdin"}, {"input": "1628 274\n", "output": "678\n", "type": "stdin"}, {"input": "16186 337\n", "output": "169\n", "type": "stdin"}, {"input": "24562 2009\n", "output": "1005\n", "type": "stdin"}, {"input": "9456 3443\n", "output": "1722\n", "type": "stdin"}, {"input": "5610 332\n", "output": "2640\n", "type": "stdin"}, {"input": "1764 1288\n", "output": "239\n", "type": "stdin"}, {"input": "28588 13902\n", "output": "7344\n", "type": "stdin"}, {"input": "92480 43074\n", "output": "24704\n", "type": "stdin"}, {"input": "40022 26492\n", "output": "6766\n", "type": "stdin"}, {"input": "85766 64050\n", "output": "10859\n", "type": "stdin"}, {"input": "67808 61809\n", "output": "30905\n", "type": "stdin"}, {"input": "80124 68695\n", "output": "34348\n", "type": "stdin"}, {"input": "95522 91716\n", "output": "1904\n", "type": "stdin"}, {"input": "7752 2915\n", "output": "1458\n", "type": "stdin"}, {"input": "5094 5058\n", "output": "19\n", "type": "stdin"}, {"input": "6144 4792\n", "output": "677\n", "type": "stdin"}, {"input": "34334 20793\n", "output": "10397\n", "type": "stdin"}, {"input": "23538 10243\n", "output": "5122\n", "type": "stdin"}, {"input": "9328 7933\n", "output": "3967\n", "type": "stdin"}, {"input": "11110 9885\n", "output": "4943\n", "type": "stdin"}, {"input": "26096 2778\n", "output": "11660\n", "type": "stdin"}, {"input": "75062 5323\n", "output": "2662\n", "type": "stdin"}, {"input": "94790 7722\n", "output": "43535\n", "type": "stdin"}, {"input": "90616 32240\n", "output": "29189\n", "type": "stdin"}, {"input": "96998 8992\n", "output": "44004\n", "type": "stdin"}, {"input": "95130 19219\n", "output": "9610\n", "type": "stdin"}, {"input": "92586 8812\n", "output": "41888\n", "type": "stdin"}, {"input": "3266 3044\n", "output": "112\n", "type": "stdin"}, {"input": "5026 4697\n", "output": "2349\n", "type": "stdin"}, {"input": "3044 2904\n", "output": "71\n", "type": "stdin"}, {"input": "6022 5396\n", "output": "314\n", "type": "stdin"}, {"input": "31270 25522\n", "output": "2875\n", "type": "stdin"}, {"input": "82156 75519\n", "output": "37760\n", "type": "stdin"}, {"input": "34614 27913\n", "output": "13957\n", "type": "stdin"}, {"input": "88024 61143\n", "output": "30572\n", "type": "stdin"}, {"input": "91870 55672\n", "output": "18100\n", "type": "stdin"}, {"input": "95718 4868\n", "output": "45426\n", "type": "stdin"}, {"input": "99564 358\n", "output": "49604\n", "type": "stdin"}, {"input": "89266 13047\n", "output": "6524\n", "type": "stdin"}, {"input": "90904 16455\n", "output": "8228\n", "type": "stdin"}, {"input": "94750 13761\n", "output": "6881\n", "type": "stdin"}, {"input": "100000 23458\n", "output": "38272\n", "type": "stdin"}, {"input": "100000 23457\n", "output": "11729\n", "type": "stdin"}, {"input": "59140 24272\n", "output": "17435\n", "type": "stdin"}, {"input": "9860 8516\n", "output": "673\n", "type": "stdin"}, {"input": "25988 2733\n", "output": "1367\n", "type": "stdin"}, {"input": "9412 5309\n", "output": "2655\n", "type": "stdin"}, {"input": "25540 23601\n", "output": "11801\n", "type": "stdin"}, {"input": "76260 6050\n", "output": "35106\n", "type": "stdin"}, {"input": "92388 39118\n", "output": "26636\n", "type": "stdin"}, {"input": "8516 5495\n", "output": "2748\n", "type": "stdin"}, {"input": "91940 37847\n", "output": "18924\n", "type": "stdin"}, {"input": "30518 286\n", "output": "15117\n", "type": "stdin"}, {"input": "46646 19345\n", "output": "9673\n", "type": "stdin"}, {"input": "5026 4697\n", "output": "2349", "type": "stdin"}, {"input": "1628 274\n", "output": "678", "type": "stdin"}, {"input": "34614 27913\n", "output": "13957", "type": "stdin"}, {"input": "92388 39118\n", "output": "26636", "type": "stdin"}, {"input": "85766 64050\n", "output": "10859", "type": "stdin"}, {"input": "100000 2\n", "output": "50000", "type": "stdin"}, {"input": "59140 24272\n", "output": "17435", "type": "stdin"}, {"input": "90616 32240\n", "output": "29189", "type": "stdin"}, {"input": "2 1\n", "output": "1", "type": "stdin"}, {"input": "67808 61809\n", "output": "30905", "type": "stdin"}, {"input": "10 10\n", "output": "1", "type": "stdin"}, {"input": "9456 3443\n", "output": "1722", "type": "stdin"}, {"input": "100000 100000\n", "output": "1", "type": "stdin"}, {"input": "95522 91716\n", "output": "1904", "type": "stdin"}, {"input": "28588 13902\n", "output": "7344", "type": "stdin"}, {"input": "40022 26492\n", "output": "6766", "type": "stdin"}, {"input": "5094 5058\n", "output": "19", "type": "stdin"}, {"input": "11110 9885\n", "output": "4943", "type": "stdin"}, {"input": "3266 3044\n", "output": "112", "type": "stdin"}, {"input": "96998 8992\n", "output": "44004", "type": "stdin"}, {"input": "25988 2733\n", "output": "1367", "type": "stdin"}, {"input": "90904 16455\n", "output": "8228", "type": "stdin"}, {"input": "100000 99999\n", "output": "50000", "type": "stdin"}, {"input": "31270 25522\n", "output": "2875", "type": "stdin"}, {"input": "6144 4792\n", "output": "677", "type": "stdin"}, {"input": "76260 6050\n", "output": "35106", "type": "stdin"}, {"input": "9328 7933\n", "output": "3967", "type": "stdin"}, {"input": "75062 5323\n", "output": "2662", "type": "stdin"}, {"input": "91940 37847\n", "output": "18924", "type": "stdin"}, {"input": "6022 5396\n", "output": "314", "type": "stdin"}, {"input": "24842 1038\n", "output": "11903", "type": "stdin"}, {"input": "1764 1288\n", "output": "239", "type": "stdin"}, {"input": "91870 55672\n", "output": "18100", "type": "stdin"}, {"input": "89266 13047\n", "output": "6524", "type": "stdin"}, {"input": "46646 19345\n", "output": "9673", "type": "stdin"}, {"input": "3044 2904\n", "output": "71", "type": "stdin"}, {"input": "92480 43074\n", "output": "24704", "type": "stdin"}, {"input": "5610 332\n", "output": "2640", "type": "stdin"}, {"input": "9412 5309\n", "output": "2655", "type": "stdin"}, {"input": "100000 23457\n", "output": "11729", "type": "stdin"}, {"input": "95130 19219\n", "output": "9610", "type": "stdin"}, {"input": "24562 2009\n", "output": "1005", "type": "stdin"}, {"input": "100 100\n", "output": "1", "type": "stdin"}, {"input": "10 1\n", "output": "1", "type": "stdin"}, {"input": "8516 5495\n", "output": "2748", "type": "stdin"}, {"input": "92586 8812\n", "output": "41888", "type": "stdin"}, {"input": "2000 1\n", "output": "1", "type": "stdin"}, {"input": "88024 61143\n", "output": "30572", "type": "stdin"}, {"input": "7752 2915\n", "output": "1458", "type": "stdin"}, {"input": "34334 20793\n", "output": "10397", "type": "stdin"}, {"input": "23538 10243\n", "output": "5122", "type": "stdin"}, {"input": "94790 7722\n", "output": "43535", "type": "stdin"}, {"input": "100000 1\n", "output": "1", "type": "stdin"}, {"input": "2 2\n", "output": "1", "type": "stdin"}, {"input": "95718 4868\n", "output": "45426", "type": "stdin"}, {"input": "26096 2778\n", "output": "11660", "type": "stdin"}, {"input": "100000 23458\n", "output": "38272", "type": "stdin"}, {"input": "99564 358\n", "output": "49604", "type": "stdin"}, {"input": "100000 3\n", "output": "2", "type": "stdin"}, {"input": "25540 23601\n", "output": "11801", "type": "stdin"}, {"input": "30518 286\n", "output": "15117", "type": "stdin"}, {"input": "82156 75519\n", "output": "37760", "type": "stdin"}, {"input": "94750 13761\n", "output": "6881", "type": "stdin"}, {"input": "16186 337\n", "output": "169", "type": "stdin"}, {"input": "80124 68695\n", "output": "34348", "type": "stdin"}, {"input": "9860 8516\n", "output": "673", "type": "stdin"}, {"input": "3000 34\n", "output": "1484", "type": "stdin"}, {"input": "5026 2900\n", "output": "1064\n", "type": "stdin"}, {"input": "1628 155\n", "output": "78\n", "type": "stdin"}, {"input": "92388 40801\n", "output": "20401\n", "type": "stdin"}, {"input": "59140 26336\n", "output": "16403\n", "type": "stdin"}, {"input": "9456 6396\n", "output": "1531\n", "type": "stdin"}, {"input": "95522 17107\n", "output": "8554\n", "type": "stdin"}, {"input": "30662 26492\n", "output": "2086\n", "type": "stdin"}, {"input": "5094 4955\n", "output": "2478\n", "type": "stdin"}, {"input": "11100 9885\n", "output": "4943\n", "type": "stdin"}, {"input": "25988 4210\n", "output": "10890\n", "type": "stdin"}, {"input": "90904 27462\n", "output": "31722\n", "type": "stdin"}, {"input": "44450 25522\n", "output": "9465\n", "type": "stdin"}, {"input": "76260 3749\n", "output": "1875\n", "type": "stdin"}, {"input": "62680 5323\n", "output": "2662\n", "type": "stdin"}, {"input": "24842 1669\n", "output": "835\n", "type": "stdin"}, {"input": "89266 14660\n", "output": "37304\n", "type": "stdin"}, {"input": "3044 1505\n", "output": "753\n", "type": "stdin"}, {"input": "92480 79119\n", "output": "39560\n", "type": "stdin"}, {"input": "5610 543\n", "output": "272\n", "type": "stdin"}, {"input": "9412 2775\n", "output": "1388\n", "type": "stdin"}, {"input": "100000 5356\n", "output": "47323\n", "type": "stdin"}, {"input": "95130 1001\n", "output": "501\n", "type": "stdin"}, {"input": "26562 2009\n", "output": "1005\n", "type": "stdin"}, {"input": "110 100\n", "output": "6\n", "type": "stdin"}, {"input": "10 2\n", "output": "5\n", "type": "stdin"}, {"input": "2508 1\n", "output": "1\n", "type": "stdin"}, {"input": "88024 5990\n", "output": "41018\n", "type": "stdin"}, {"input": "19020 10243\n", "output": "5122\n", "type": "stdin"}, {"input": "94790 11093\n", "output": "5547\n", "type": "stdin"}, {"input": "21354 2778\n", "output": "9289\n", "type": "stdin"}, {"input": "100000 5142\n", "output": "47430\n", "type": "stdin"}, {"input": "100000 5\n", "output": "3\n", "type": "stdin"}, {"input": "47264 23601\n", "output": "11801\n", "type": "stdin"}, {"input": "19690 286\n", "output": "9703\n", "type": "stdin"}, {"input": "17480 337\n", "output": "169\n", "type": "stdin"}, {"input": "64604 26336\n", "output": "19135\n", "type": "stdin"}, {"input": "30662 4789\n", "output": "2395\n", "type": "stdin"}, {"input": "44450 40278\n", "output": "2087\n", "type": "stdin"}, {"input": "76260 1594\n", "output": "37334\n", "type": "stdin"}, {"input": "62680 2755\n", "output": "1378\n", "type": "stdin"}, {"input": "24842 1381\n", "output": "691\n", "type": "stdin"}, {"input": "89266 25528\n", "output": "31870\n", "type": "stdin"}, {"input": "3044 2563\n", "output": "1282\n", "type": "stdin"}, {"input": "92480 87713\n", "output": "43857\n", "type": "stdin"}, {"input": "5610 113\n", "output": "57\n", "type": "stdin"}, {"input": "9412 1871\n", "output": "936\n", "type": "stdin"}, {"input": "100000 10711\n", "output": "5356\n", "type": "stdin"}, {"input": "95130 1000\n", "output": "47066\n", "type": "stdin"}, {"input": "26562 3031\n", "output": "1516\n", "type": "stdin"}, {"input": "110 101\n", "output": "51\n", "type": "stdin"}, {"input": "16 2\n", "output": "8\n", "type": "stdin"}, {"input": "2508 2\n", "output": "1254\n", "type": "stdin"}, {"input": "88024 8443\n", "output": "4222\n", "type": "stdin"}, {"input": "19020 6214\n", "output": "6404\n", "type": "stdin"}, {"input": "94790 17460\n", "output": "38666\n", "type": "stdin"}, {"input": "7222 2778\n", "output": "2223\n", "type": "stdin"}, {"input": "100000 10\n", "output": "49996\n", "type": "stdin"}, {"input": "47264 16323\n", "output": "8162\n", "type": "stdin"}, {"input": "24540 286\n", "output": "12128\n", "type": "stdin"}, {"input": "17480 315\n", "output": "158\n", "type": "stdin"}, {"input": "64604 45055\n", "output": "22528\n", "type": "stdin"}, {"input": "30662 5067\n", "output": "2534\n", "type": "stdin"}, {"input": "76260 1793\n", "output": "897\n", "type": "stdin"}, {"input": "89266 41040\n", "output": "24114\n", "type": "stdin"}, {"input": "95130 1100\n", "output": "47016\n", "type": "stdin"}, {"input": "18 2\n", "output": "9\n", "type": "stdin"}, {"input": "2508 4\n", "output": "1253\n", "type": "stdin"}, {"input": "88024 3516\n", "output": "42255\n", "type": "stdin"}, {"input": "19020 5280\n", "output": "6871\n", "type": "stdin"}, {"input": "94790 1306\n", "output": "46743\n", "type": "stdin"}, {"input": "24540 160\n", "output": "12191\n", "type": "stdin"}, {"input": "17480 589\n", "output": "295\n", "type": "stdin"}, {"input": "64604 11687\n", "output": "5844\n", "type": "stdin"}, {"input": "99684 41040\n", "output": "29323\n", "type": "stdin"}, {"input": "95130 0100\n", "output": "47516\n", "type": "stdin"}, {"input": "19006 1513\n", "output": "757\n", "type": "stdin"}, {"input": "216 4\n", "output": "107\n", "type": "stdin"}, {"input": "88024 452\n", "output": "43787\n", "type": "stdin"}, {"input": "19020 10108\n", "output": "4457\n", "type": "stdin"}, {"input": "15698 160\n", "output": "7770\n", "type": "stdin"}, {"input": "17480 818\n", "output": "8332\n", "type": "stdin"}, {"input": "60622 2667\n", "output": "1334\n", "type": "stdin"}, {"input": "8 8\n", "output": "1\n", "type": "stdin"}, {"input": "1152 155\n", "output": "78\n", "type": "stdin"}, {"input": "83992 2755\n", "output": "1378\n", "type": "stdin"}, {"input": "27596 1381\n", "output": "691\n", "type": "stdin"}, {"input": "19006 3031\n", "output": "1516\n", "type": "stdin"}, {"input": "63342 16323\n", "output": "8162\n", "type": "stdin"}, {"input": "60622 5067\n", "output": "2534\n", "type": "stdin"}, {"input": "90110 2755\n", "output": "1378\n", "type": "stdin"}, {"input": "13812 1381\n", "output": "691\n", "type": "stdin"}, {"input": "4 2\n", "output": "2", "type": "stdin"}, {"input": "8 5\n", "output": "3", "type": "stdin"}], "problem_id": "primeintellect_train_7422", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 229}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nYou are given an array $a_1, a_2, \\dots, a_n$ of integer numbers.\n\nYour task is to divide the array into the maximum number of segments in such a way that:\n\n  each element is contained in exactly one segment;  each segment contains at least one element;  there doesn't exist a non-empty subset of segments such that bitwise XOR of the numbers from them is equal to $0$. \n\nPrint the maximum number of segments the array can be divided into. Print -1 if no suitable division exists.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the array.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nPrint the maximum number of segments the array can be divided into while following the given constraints. Print -1 if no suitable division exists.\n\n\n-----Examples-----\nInput\n4\n5 5 7 2\n\nOutput\n2\n\nInput\n3\n1 2 3\n\nOutput\n-1\n\nInput\n3\n3 1 10\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example $2$ is the maximum number. If you divide the array into $\\{[5], [5, 7, 2]\\}$, the XOR value of the subset of only the second segment is $5 \\oplus 7 \\oplus 2 = 0$. $\\{[5, 5], [7, 2]\\}$ has the value of the subset of only the first segment being $5 \\oplus 5 = 0$. However, $\\{[5, 5, 7], [2]\\}$ will lead to subsets $\\{[5, 5, 7]\\}$ of XOR $7$, $\\{[2]\\}$ of XOR $2$ and $\\{[5, 5, 7], [2]\\}$ of XOR $5 \\oplus 5 \\oplus 7 \\oplus 2 = 5$.\n\nLet's take a look at some division on $3$ segments \u2014 $\\{[5], [5, 7], [2]\\}$. It will produce subsets:\n\n  $\\{[5]\\}$, XOR $5$;  $\\{[5, 7]\\}$, XOR $2$;  $\\{[5], [5, 7]\\}$, XOR $7$;  $\\{[2]\\}$, XOR $2$;  $\\{[5], [2]\\}$, XOR $7$;  $\\{[5, 7], [2]\\}$, XOR $0$;  $\\{[5], [5, 7], [2]\\}$, XOR $5$; \n\nAs you can see, subset $\\{[5, 7], [2]\\}$ has its XOR equal to $0$, which is unacceptable. You can check that for other divisions of size $3$ or $4$, non-empty subset with $0$ XOR always exists.\n\nThe second example has no suitable divisions.\n\nThe third example array can be divided into $\\{[3], [1], [10]\\}$. No subset of these segments has its XOR equal to $0$.\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\nimport sys\nfrom math import *\nfrom fractions import gcd\nreadints = lambda : map(int, input().strip('\\n').split())\nn = int(input())\narr = list(readints())\npref = 0\nbasis = []\nfor v in arr:\n\tpref = pref ^ v\n\tfor b in basis:\n\t\tv = min(v, v ^ b)\n\tif v > 0:\n\t\tbasis.append(v)\nif pref == 0:\n\tprint(-1)\nelse:\n\tprint(len(basis))\n\n```"], "public_test_cases": [{"input": "4\n5 5 7 2\n", "output": "2\n", "type": "stdin"}, {"input": "3\n1 2 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3\n3 1 10\n", "output": "3\n", "type": "stdin"}], "test_cases": [{"input": "4\n5 5 7 2\n", "output": "2\n", "type": "stdin"}, {"input": "3\n1 2 3\n", "output": "-1\n", "type": "stdin"}, {"input": "3\n3 1 10\n", "output": "3\n", "type": "stdin"}, {"input": "1\n0\n", "output": "-1\n", "type": "stdin"}, {"input": "1\n7\n", "output": "1\n", "type": "stdin"}, {"input": "2\n3 4\n", "output": "2\n", "type": "stdin"}, {"input": "10\n2 1 0 0 0 2 2 1 1 0\n", "output": "2\n", "type": "stdin"}, {"input": "10\n5 3 2 0 6 5 4 1 6 2\n", "output": "3\n", "type": "stdin"}, {"input": "10\n63366411 57391809 217887804 43036621 397716019 878676084 451005539 537039674 935482853 474757099\n", "output": "10\n", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 1 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 2 1 0 0 1 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 3 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "2\n", "type": "stdin"}, {"input": "100\n7 4 5 5 3 0 1 3 4 2 5 0 1 5 5 7 2 4 4 6 7 7 3 6 6 2 0 0 2 7 7 2 6 1 5 7 4 1 0 7 0 7 1 5 7 5 3 4 2 2 0 0 6 3 6 3 7 7 2 5 3 7 3 0 0 1 6 1 5 3 7 6 3 7 4 3 5 7 7 4 7 4 7 2 2 5 5 4 4 4 3 3 0 3 4 3 1 7 1 6\n", "output": "3\n", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 102 103 78 4 55 79 17 114 45 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 66 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "7\n", "type": "stdin"}, {"input": "100\n1065 362 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 1624 1183 572 1496 1014 2007 139 1820 1662 1546 1695 1215 40 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 1128 644 1280\n", "output": "11\n", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 397 259 176 318 310 362 185 211 413 231 254 97 35 284 67 146 350 351 156 288 380 57 306 341 375 309 30 239 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 371 363 234 233 160 9 387 177 302 4 330 266\n", "output": "9\n", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 7486060 68191796 72498272 70428676 73572450 71318068 71469694 5386788 74459206 4234844 68299902 70263402 69240440 70434322 68299868 70391846\n", "output": "16\n", "type": "stdin"}, {"input": "20\n1081344 1081344 0 32768 0 1081344 1048576 0 0 32768 1048576 32768 1048576 1081344 1081344 1048576 0 1048576 1048576 1081344\n", "output": "2\n", "type": "stdin"}, {"input": "1\n23424\n", "output": "1\n", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 1 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 2 1 0 0 1 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 3 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "2", "type": "stdin"}, {"input": "1\n23424\n", "output": "1", "type": "stdin"}, {"input": "10\n5 3 2 0 6 5 4 1 6 2\n", "output": "3", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 7486060 68191796 72498272 70428676 73572450 71318068 71469694 5386788 74459206 4234844 68299902 70263402 69240440 70434322 68299868 70391846\n", "output": "16", "type": "stdin"}, {"input": "10\n2 1 0 0 0 2 2 1 1 0\n", "output": "2", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 102 103 78 4 55 79 17 114 45 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 66 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "7", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 397 259 176 318 310 362 185 211 413 231 254 97 35 284 67 146 350 351 156 288 380 57 306 341 375 309 30 239 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 371 363 234 233 160 9 387 177 302 4 330 266\n", "output": "9", "type": "stdin"}, {"input": "1\n0\n", "output": "-1", "type": "stdin"}, {"input": "10\n63366411 57391809 217887804 43036621 397716019 878676084 451005539 537039674 935482853 474757099\n", "output": "10", "type": "stdin"}, {"input": "20\n1081344 1081344 0 32768 0 1081344 1048576 0 0 32768 1048576 32768 1048576 1081344 1081344 1048576 0 1048576 1048576 1081344\n", "output": "2", "type": "stdin"}, {"input": "100\n7 4 5 5 3 0 1 3 4 2 5 0 1 5 5 7 2 4 4 6 7 7 3 6 6 2 0 0 2 7 7 2 6 1 5 7 4 1 0 7 0 7 1 5 7 5 3 4 2 2 0 0 6 3 6 3 7 7 2 5 3 7 3 0 0 1 6 1 5 3 7 6 3 7 4 3 5 7 7 4 7 4 7 2 2 5 5 4 4 4 3 3 0 3 4 3 1 7 1 6\n", "output": "3", "type": "stdin"}, {"input": "100\n1065 362 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 1624 1183 572 1496 1014 2007 139 1820 1662 1546 1695 1215 40 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 1128 644 1280\n", "output": "11", "type": "stdin"}, {"input": "1\n7\n", "output": "1", "type": "stdin"}, {"input": "2\n3 4\n", "output": "2", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 1 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 0 1 0 0 1 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 3 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "2\n", "type": "stdin"}, {"input": "1\n15588\n", "output": "1\n", "type": "stdin"}, {"input": "10\n5 3 2 0 6 5 7 1 6 2\n", "output": "3\n", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 7486060 68191796 72498272 70428676 73572450 71318068 71469694 5386788 74459206 4234844 68299902 70263402 69240440 70434322 68299868 79637823\n", "output": "17\n", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 102 103 78 4 55 79 17 51 45 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 66 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "7\n", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 429 259 176 318 310 362 185 211 413 231 254 97 35 284 67 146 350 351 156 288 380 57 306 341 375 309 30 239 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 371 363 234 233 160 9 387 177 302 4 330 266\n", "output": "9\n", "type": "stdin"}, {"input": "10\n97285659 57391809 217887804 43036621 397716019 878676084 451005539 537039674 935482853 474757099\n", "output": "10\n", "type": "stdin"}, {"input": "100\n7 4 5 5 3 0 1 3 4 2 5 0 1 5 5 7 2 4 4 6 7 7 3 6 6 2 0 0 2 7 2 2 6 1 5 7 4 1 0 7 0 7 1 5 7 5 3 4 2 2 0 0 6 3 6 3 7 7 2 5 3 7 3 0 0 1 6 1 5 3 7 6 3 7 4 3 5 7 7 4 7 4 7 2 2 5 5 4 4 4 3 3 0 3 4 3 1 7 1 6\n", "output": "-1\n", "type": "stdin"}, {"input": "100\n1065 362 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 1624 826 572 1496 1014 2007 139 1820 1662 1546 1695 1215 40 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 1128 644 1280\n", "output": "11\n", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 7486060 68191796 72498272 70428676 73572450 71318068 71469694 5386788 16294399 4234844 68299902 70263402 69240440 70434322 68299868 79637823\n", "output": "18\n", "type": "stdin"}, {"input": "100\n1065 362 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 3109 826 572 1496 1014 2007 139 1820 1662 1546 1695 1215 40 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 1128 644 1280\n", "output": "12\n", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 3265468 68191796 72498272 70428676 73572450 71318068 71469694 5386788 16294399 4234844 125696297 70263402 69240440 70434322 68299868 42504967\n", "output": "19\n", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 130 103 78 3 55 79 17 51 0 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 19 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "8\n", "type": "stdin"}, {"input": "10\n2 1 0 0 0 0 2 1 1 0\n", "output": "2\n", "type": "stdin"}, {"input": "1\n1\n", "output": "1\n", "type": "stdin"}, {"input": "20\n1081344 135354 0 32768 0 1081344 1048576 0 0 32768 1048576 32768 1048576 1081344 1081344 1048576 0 1048576 1048576 1081344\n", "output": "3\n", "type": "stdin"}, {"input": "1\n5\n", "output": "1\n", "type": "stdin"}, {"input": "2\n2 4\n", "output": "2\n", "type": "stdin"}, {"input": "3\n0 2 3\n", "output": "2\n", "type": "stdin"}, {"input": "3\n3 2 10\n", "output": "3\n", "type": "stdin"}, {"input": "4\n0 5 7 2\n", "output": "-1\n", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 2 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 0 1 0 0 1 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 3 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "-1\n", "type": "stdin"}, {"input": "1\n11861\n", "output": "1\n", "type": "stdin"}, {"input": "10\n5 3 1 0 6 5 7 1 6 2\n", "output": "3\n", "type": "stdin"}, {"input": "10\n2 2 0 0 0 0 2 1 1 0\n", "output": "2\n", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 102 103 78 4 55 79 17 51 45 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 19 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "7\n", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 429 259 176 318 310 362 185 211 413 231 254 97 35 284 67 146 350 351 156 288 380 57 306 341 375 309 30 414 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 371 363 234 233 160 9 387 177 302 4 330 266\n", "output": "9\n", "type": "stdin"}, {"input": "10\n97285659 57391809 217887804 43036621 397716019 878676084 451005539 559027088 935482853 474757099\n", "output": "10\n", "type": "stdin"}, {"input": "100\n7 4 5 5 3 0 1 3 4 2 5 0 1 4 5 7 2 4 4 6 7 7 3 6 6 2 0 0 2 7 2 2 6 1 5 7 4 1 0 7 0 7 1 5 7 5 3 4 2 2 0 0 6 3 6 3 7 7 2 5 3 7 3 0 0 1 6 1 5 3 7 6 3 7 4 3 5 7 7 4 7 4 7 2 2 5 5 4 4 4 3 3 0 3 4 3 1 7 1 6\n", "output": "3\n", "type": "stdin"}, {"input": "1\n6\n", "output": "1\n", "type": "stdin"}, {"input": "2\n0 4\n", "output": "1\n", "type": "stdin"}, {"input": "3\n1 1 10\n", "output": "2\n", "type": "stdin"}, {"input": "4\n0 10 7 2\n", "output": "3\n", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 2 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 1 1 0 0 1 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 3 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "2\n", "type": "stdin"}, {"input": "1\n11963\n", "output": "1\n", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 7486060 68191796 72498272 70428676 73572450 71318068 71469694 5386788 16294399 4234844 68299902 70263402 69240440 70434322 68299868 42504967\n", "output": "18\n", "type": "stdin"}, {"input": "10\n2 2 0 0 0 0 2 0 1 0\n", "output": "2\n", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 102 103 78 3 55 79 17 51 45 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 19 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "7\n", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 429 259 176 318 310 362 185 211 413 231 254 97 40 284 67 146 350 351 156 288 380 57 306 341 375 309 30 414 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 371 363 234 233 160 9 387 177 302 4 330 266\n", "output": "9\n", "type": "stdin"}, {"input": "10\n97285659 31435629 217887804 43036621 397716019 878676084 451005539 559027088 935482853 474757099\n", "output": "10\n", "type": "stdin"}, {"input": "100\n1065 332 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 3109 826 572 1496 1014 2007 139 1820 1662 1546 1695 1215 40 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 1128 644 1280\n", "output": "12\n", "type": "stdin"}, {"input": "1\n11\n", "output": "1\n", "type": "stdin"}, {"input": "2\n0 2\n", "output": "1\n", "type": "stdin"}, {"input": "3\n1 1 12\n", "output": "2\n", "type": "stdin"}, {"input": "4\n0 10 7 4\n", "output": "3\n", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 2 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 1 1 0 0 1 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 1 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "2\n", "type": "stdin"}, {"input": "1\n13124\n", "output": "1\n", "type": "stdin"}, {"input": "20\n6336516 45164 67114498 71304212 3265468 68191796 72498272 70428676 73572450 71318068 71469694 5386788 16294399 4234844 68299902 70263402 69240440 70434322 68299868 42504967\n", "output": "18\n", "type": "stdin"}, {"input": "100\n116 15 100 97 10 72 118 57 127 14 8 99 78 74 3 22 21 34 36 64 125 102 103 78 3 55 79 17 51 0 34 103 90 7 2 124 107 58 122 69 91 4 110 14 87 19 3 8 123 88 91 73 47 40 115 46 2 55 86 124 26 5 104 107 91 88 108 107 86 14 48 68 26 86 126 92 33 77 53 88 80 114 14 66 19 17 60 62 17 28 41 62 109 15 85 94 31 95 89 117\n", "output": "7\n", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 429 259 176 318 310 362 185 211 413 231 254 97 40 284 67 146 350 351 156 288 380 57 306 341 375 309 30 414 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 371 363 234 233 160 9 448 177 302 4 330 266\n", "output": "9\n", "type": "stdin"}, {"input": "10\n97285659 31435629 217887804 43036621 397716019 878676084 451005539 559027088 181736667 474757099\n", "output": "10\n", "type": "stdin"}, {"input": "100\n1065 332 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 3109 826 572 1496 1014 2007 139 1820 1662 1546 1695 1215 40 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 830 644 1280\n", "output": "12\n", "type": "stdin"}, {"input": "1\n12\n", "output": "1\n", "type": "stdin"}, {"input": "2\n0 0\n", "output": "-1\n", "type": "stdin"}, {"input": "3\n2 1 12\n", "output": "3\n", "type": "stdin"}, {"input": "4\n0 12 7 4\n", "output": "3\n", "type": "stdin"}, {"input": "100\n3 2 1 3 2 3 1 2 0 0 1 2 2 3 2 0 2 0 2 3 1 1 1 0 1 0 3 2 2 0 0 1 0 1 3 3 1 2 2 2 3 0 2 1 3 0 1 1 0 0 2 2 2 3 1 3 2 2 2 0 0 1 0 1 0 2 3 2 2 1 0 2 0 2 0 1 3 3 1 1 3 1 1 1 1 0 0 1 0 0 2 3 1 2 1 3 0 3 0 0\n", "output": "-1\n", "type": "stdin"}, {"input": "1\n21380\n", "output": "1\n", "type": "stdin"}, {"input": "69\n380 150 5 157 175 306 237 3 232 356 148 429 259 176 318 310 362 185 211 413 231 254 97 40 284 67 146 350 351 156 288 380 57 306 341 375 309 30 414 261 168 45 180 78 268 324 342 85 66 77 318 130 83 360 409 122 79 82 363 234 233 160 9 448 177 302 4 330 266\n", "output": "9\n", "type": "stdin"}, {"input": "10\n97285659 31435629 217887804 43036621 397716019 254887457 451005539 559027088 181736667 474757099\n", "output": "10\n", "type": "stdin"}, {"input": "100\n1065 332 1002 1071 502 252 1401 1824 887 1803 1572 1571 502 1408 1699 1750 1785 1507 1616 1458 372 323 939 1208 1639 1517 1145 319 935 1507 1094 156 1062 39 1884 1470 646 917 1699 631 39 789 1030 1589 1700 17 495 32 506 574 1458 206 1091 211 279 1617 3109 826 572 1496 1014 2007 139 1820 1662 1546 1695 1215 49 1555 686 193 1346 385 919 1812 685 291 151 277 1612 1783 1028 447 1782 549 60 704 2032 1427 1498 271 1530 625 1446 867 1826 830 644 1280\n", "output": "12\n", "type": "stdin"}, {"input": "1\n22\n", "output": "1\n", "type": "stdin"}, {"input": "3\n2 1 21\n", "output": "3\n", "type": "stdin"}, {"input": "3\n1 2 3\n", "output": "-1", "type": "stdin"}, {"input": "3\n3 1 10\n", "output": "3", "type": "stdin"}, {"input": "4\n5 5 7 2\n", "output": "2", "type": "stdin"}], "problem_id": "primeintellect_train_7644", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 97}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\n[Image] \n\nIt's the end of July\u00a0\u2013 the time when a festive evening is held at Jelly Castle! Guests from all over the kingdom gather here to discuss new trends in the world of confectionery. Yet some of the things discussed here are not supposed to be disclosed to the general public: the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands. So it's a necessity to not let any uninvited guests in.\n\nThere are 26 entrances in Jelly Castle, enumerated with uppercase English letters from A to Z. Because of security measures, each guest is known to be assigned an entrance he should enter the castle through. The door of each entrance is opened right before the first guest's arrival and closed right after the arrival of the last guest that should enter the castle through this entrance. No two guests can enter the castle simultaneously.\n\nFor an entrance to be protected from possible intrusion, a candy guard should be assigned to it. There are k such guards in the castle, so if there are more than k opened doors, one of them is going to be left unguarded! Notice that a guard can't leave his post until the door he is assigned to is closed.\n\nSlastyona had a suspicion that there could be uninvited guests at the evening. She knows the order in which the invited guests entered the castle, and wants you to help her check whether there was a moment when more than k doors were opened.\n\n\n-----Input-----\n\nTwo integers are given in the first string: the number of guests n and the number of guards k (1 \u2264 n \u2264 10^6, 1 \u2264 k \u2264 26).\n\nIn the second string, n uppercase English letters s_1s_2... s_{n} are given, where s_{i} is the entrance used by the i-th guest.\n\n\n-----Output-----\n\nOutput \u00abYES\u00bb if at least one door was unguarded during some time, and \u00abNO\u00bb otherwise.\n\nYou can output each letter in arbitrary case (upper or lower).\n\n\n-----Examples-----\nInput\n5 1\nAABBB\n\nOutput\nNO\n\nInput\n5 1\nABABB\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first sample case, the door A is opened right before the first guest's arrival and closed when the second guest enters the castle. The door B is opened right before the arrival of the third guest, and closed after the fifth one arrives. One guard can handle both doors, as the first one is closed before the second one is opened.\n\nIn the second sample case, the door B is opened before the second guest's arrival, but the only guard can't leave the door A unattended, as there is still one more guest that should enter the castle through this door.\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\nn, k = map(int, input().split())\ns = input()\nour = set()\nopened = set()\nfor i in range(ord('A'), ord('Z') + 1):\n    sym = chr(i)\n    if sym in s:\n        our.add(s.rfind(sym))\nfor i in range(len(s)):\n    if s[i] not in opened:\n        opened.add(s[i])\n        k -= 1\n        if k < 0:\n            print('YES')\n            return\n    if i in our:\n        k += 1\nprint('NO')\n```"], "public_test_cases": [{"input": "5 1\nAABBB\n", "output": "NO\n", "type": "stdin"}, {"input": "5 1\nABABB\n", "output": "YES\n", "type": "stdin"}], "test_cases": [{"input": "5 1\nAABBB\n", "output": "NO\n", "type": "stdin"}, {"input": "5 1\nABABB\n", "output": "YES\n", "type": "stdin"}, {"input": "26 1\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n", "output": "NO\n", "type": "stdin"}, {"input": "27 1\nABCDEFGHIJKLMNOPQRSTUVWXYZA\n", "output": "YES\n", "type": "stdin"}, {"input": "5 2\nABACA\n", "output": "NO\n", "type": "stdin"}, {"input": "6 2\nABCABC\n", "output": "YES\n", "type": "stdin"}, {"input": "8 3\nABCBCDCA\n", "output": "NO\n", "type": "stdin"}, {"input": "73 2\nDEBECECBBADAADEAABEAEEEAEBEAEBCDDBABBAEBACCBEEBBAEADEECACEDEEDABACDCDBBBD\n", "output": "YES\n", "type": "stdin"}, {"input": "44 15\nHGJIFCGGCDGIJDHBIBGAEABCIABIGBDEADBBBAGDFDHA\n", "output": "NO\n", "type": "stdin"}, {"input": "41 19\nTMEYYIIELFDCMBDKWWKYNRNDUPRONYROXQCLVQALP\n", "output": "NO\n", "type": "stdin"}, {"input": "377 3\nEADADBBBBDEAABBAEBABACDBDBBCACAADBEAEACDEAABACADEEDEACACDADABBBBDDEECBDABACACBAECBADAEBDEEBDBCDAEADBCDDACACDCCEEDBCCBBCEDBECBABCDDBBDEADEDAEACDECECBEBACBCCDCDBDAECDECADBCBEDBBDAAEBCAAECCDCCDBDDEBADEEBDCAEABBDEDBBDDEAECCBDDCDEACDAECCBDDABABEAEDCDEDBAECBDEACEBCECEACDCBABCBAAEAADACADBBBBABEADBCADEBCBECCABBDDDEEBCDEBADEBDAAABBEABADEDEAEABCEEBEEDEAEBEABCEDDBACBCCADEBAAAAAEABABBCE\n", "output": "YES\n", "type": "stdin"}, {"input": "433 3\nFZDDHMJGBZCHFUXBBPIEBBEFDWOMXXEPOMDGSMPIUZOMRZQNSJAVNATGIWPDFISKFQXJNVFXPHOZDAEZFDAHDXXQKZMGNSGKQNWGNGJGJZVVITKNFLVCPMZSDMCHBTVAWYVZLIXXIADXNYILEYNIQHKMOGMVOCWGHCWIYMPEPADSJAAKEGTUSEDWAHMNYJDIHBKHVUHLYGNGZDBULRXLSAJHPCMNWCEAAPYMHDTYWPADOTJTXTXUKLCHWKUSZRHEKQEFPVJEJJHRWCKYOIWALRTIBUMNOCRXLSIKQCJVQXEPGOHRUDJDKMUUUDORURWXJNVRVMNOUNRFKSVMTMZGOIJLXEPAMVGESOADYIGZXRBJDIWKNOWTCSROAQTBECHTOZVSQUOOJRZIBAUHMKAXDCIMDZJFMABGRNTGPUJAUNFPFWCJG\n", "output": "YES\n", "type": "stdin"}, {"input": "5 2\nABCAB\n", "output": "YES\n", "type": "stdin"}, {"input": "5 1\nAZAZA\n", "output": "YES\n", "type": "stdin"}, {"input": "7 2\nABCDBCD\n", "output": "YES\n", "type": "stdin"}, {"input": "3 26\nAAB\n", "output": "NO\n", "type": "stdin"}], "problem_id": "primeintellect_train_6974", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 16}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nThere exists an island called Arpa\u2019s land, some beautiful girls live there, as ugly ones do.\n\nMehrdad wants to become minister of Arpa\u2019s land. Arpa has prepared an exam. Exam has only one question, given n, print the last digit of 1378n. \n\n<image>\n\nMehrdad has become quite confused and wants you to help him. Please help, although it's a naive cheat.\n\nInput\n\nThe single line of input contains one integer n (0 \u2264 n \u2264 109).\n\nOutput\n\nPrint single integer \u2014 the last digit of 1378n.\n\nExamples\n\nInput\n\n1\n\n\nOutput\n\n8\n\nInput\n\n2\n\n\nOutput\n\n4\n\nNote\n\nIn the first example, last digit of 13781 = 1378 is 8.\n\nIn the second example, last digit of 13782 = 1378\u00b71378 = 1898884 is 4.\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\nn = int(input())\nif n == 0:\n    print(1)\nif n % 4 == 0 and n!= 0 :\n    print(6)\nif n % 4 == 1:\n    print(8)\nif n % 4 == 2:\n    print(4)\nif n % 4 == 3:\n    print(2)\n\n```"], "public_test_cases": [{"input": "1\n", "output": "8\n", "type": "stdin"}, {"input": "2\n", "output": "4\n", "type": "stdin"}], "test_cases": [{"input": "2\n", "output": "4\n", "type": "stdin"}, {"input": "1\n", "output": "8\n", "type": "stdin"}, {"input": "12\n", "output": "6\n", "type": "stdin"}, {"input": "1378\n", "output": "4\n", "type": "stdin"}, {"input": "51202278\n", "output": "4\n", "type": "stdin"}, {"input": "989898989\n", "output": "8\n", "type": "stdin"}, {"input": "4\n", "output": "6\n", "type": "stdin"}, {"input": "7\n", "output": "2\n", "type": "stdin"}, {"input": "9\n", "output": "8\n", "type": "stdin"}, {"input": "6\n", "output": "4\n", "type": "stdin"}, {"input": "8\n", "output": "6\n", "type": "stdin"}, {"input": "12193721\n", "output": "8\n", "type": "stdin"}, {"input": "999999995\n", "output": "2\n", "type": "stdin"}, {"input": "999999999\n", "output": "2\n", "type": "stdin"}, {"input": "11\n", "output": "2\n", "type": "stdin"}, {"input": "999999996\n", "output": "6\n", "type": "stdin"}, {"input": "999999998\n", "output": "4\n", "type": "stdin"}, {"input": "3\n", "output": "2\n", "type": "stdin"}, {"input": "14\n", "output": "4\n", "type": "stdin"}, {"input": "15\n", "output": "2\n", "type": "stdin"}, {"input": "10\n", "output": "4\n", "type": "stdin"}, {"input": "999999994\n", "output": "4\n", "type": "stdin"}, {"input": "1000\n", "output": "6\n", "type": "stdin"}, {"input": "13781378\n", "output": "4\n", "type": "stdin"}, {"input": "5\n", "output": "8\n", "type": "stdin"}, {"input": "999999997\n", "output": "8\n", "type": "stdin"}, {"input": "1000000000\n", "output": "6\n", "type": "stdin"}, {"input": "13\n", "output": "8\n", "type": "stdin"}, {"input": "16\n", "output": "6\n", "type": "stdin"}, {"input": "0\n", "output": "1\n", "type": "stdin"}, {"input": "24\n", "output": "6\n", "type": "stdin"}, {"input": "1983990\n", "output": "4\n", "type": "stdin"}, {"input": "937715\n", "output": "2\n", "type": "stdin"}, {"input": "1902349577\n", "output": "8\n", "type": "stdin"}, {"input": "0000000000\n", "output": "1\n", "type": "stdin"}, {"input": "2584\n", "output": "6\n", "type": "stdin"}, {"input": "394254778\n", "output": "4\n", "type": "stdin"}, {"input": "341779918\n", "output": "4\n", "type": "stdin"}, {"input": "21\n", "output": "8\n", "type": "stdin"}, {"input": "215963833\n", "output": "8\n", "type": "stdin"}, {"input": "1065810635\n", "output": "2\n", "type": "stdin"}, {"input": "28\n", "output": "6\n", "type": "stdin"}, {"input": "17\n", "output": "8\n", "type": "stdin"}, {"input": "1760197508\n", "output": "6\n", "type": "stdin"}, {"input": "1001\n", "output": "8\n", "type": "stdin"}, {"input": "5602440\n", "output": "6\n", "type": "stdin"}, {"input": "17877370\n", "output": "4\n", "type": "stdin"}, {"input": "22\n", "output": "4\n", "type": "stdin"}, {"input": "19\n", "output": "2\n", "type": "stdin"}, {"input": "44\n", "output": "6\n", "type": "stdin"}, {"input": "49\n", "output": "8\n", "type": "stdin"}, {"input": "3952697\n", "output": "8\n", "type": "stdin"}, {"input": "74399095\n", "output": "2\n", "type": "stdin"}, {"input": "185380\n", "output": "6\n", "type": "stdin"}, {"input": "212134273\n", "output": "8\n", "type": "stdin"}, {"input": "45271055\n", "output": "2\n", "type": "stdin"}, {"input": "1603265602\n", "output": "4\n", "type": "stdin"}, {"input": "50\n", "output": "4\n", "type": "stdin"}, {"input": "403279506\n", "output": "4\n", "type": "stdin"}, {"input": "1011\n", "output": "2\n", "type": "stdin"}, {"input": "212217\n", "output": "8\n", "type": "stdin"}, {"input": "6373463\n", "output": "2\n", "type": "stdin"}, {"input": "0001000000\n", "output": "6\n", "type": "stdin"}, {"input": "26\n", "output": "4\n", "type": "stdin"}, {"input": "23\n", "output": "2\n", "type": "stdin"}, {"input": "43\n", "output": "2\n", "type": "stdin"}, {"input": "53\n", "output": "8\n", "type": "stdin"}, {"input": "252331\n", "output": "2\n", "type": "stdin"}, {"input": "59773239\n", "output": "2\n", "type": "stdin"}, {"input": "348367\n", "output": "2\n", "type": "stdin"}, {"input": "274204102\n", "output": "4\n", "type": "stdin"}, {"input": "88997880\n", "output": "6\n", "type": "stdin"}, {"input": "37\n", "output": "8\n", "type": "stdin"}, {"input": "333212833\n", "output": "8\n", "type": "stdin"}, {"input": "1111\n", "output": "2\n", "type": "stdin"}, {"input": "117086\n", "output": "4\n", "type": "stdin"}, {"input": "3544279\n", "output": "2\n", "type": "stdin"}, {"input": "0001000010\n", "output": "4\n", "type": "stdin"}, {"input": "30\n", "output": "4\n", "type": "stdin"}, {"input": "74\n", "output": "4\n", "type": "stdin"}, {"input": "32\n", "output": "6\n", "type": "stdin"}, {"input": "87\n", "output": "2\n", "type": "stdin"}, {"input": "425517\n", "output": "8\n", "type": "stdin"}, {"input": "39722903\n", "output": "2\n", "type": "stdin"}, {"input": "129454\n", "output": "4\n", "type": "stdin"}, {"input": "502575216\n", "output": "6\n", "type": "stdin"}, {"input": "151917914\n", "output": "4\n", "type": "stdin"}, {"input": "39\n", "output": "2\n", "type": "stdin"}, {"input": "284885416\n", "output": "6\n", "type": "stdin"}, {"input": "1010\n", "output": "4\n", "type": "stdin"}, {"input": "184257\n", "output": "8\n", "type": "stdin"}, {"input": "5976311\n", "output": "2\n", "type": "stdin"}, {"input": "0101000010\n", "output": "4\n", "type": "stdin"}, {"input": "48\n", "output": "6\n", "type": "stdin"}, {"input": "18\n", "output": "4\n", "type": "stdin"}, {"input": "38\n", "output": "4\n", "type": "stdin"}, {"input": "160\n", "output": "6\n", "type": "stdin"}, {"input": "769275\n", "output": "2\n", "type": "stdin"}, {"input": "60872248\n", "output": "6\n", "type": "stdin"}, {"input": "54684\n", "output": "6\n", "type": "stdin"}, {"input": "787055094\n", "output": "4\n", "type": "stdin"}, {"input": "251769870\n", "output": "4\n", "type": "stdin"}, {"input": "31\n", "output": "2\n", "type": "stdin"}, {"input": "1395680\n", "output": "6\n", "type": "stdin"}, {"input": "0010\n", "output": "4\n", "type": "stdin"}, {"input": "334614\n", "output": "4\n", "type": "stdin"}, {"input": "2269906\n", "output": "4\n", "type": "stdin"}, {"input": "0101000011\n", "output": "2\n", "type": "stdin"}, {"input": "65\n", "output": "8\n", "type": "stdin"}, {"input": "33\n", "output": "8\n", "type": "stdin"}, {"input": "34\n", "output": "4\n", "type": "stdin"}, {"input": "262\n", "output": "4\n", "type": "stdin"}, {"input": "1263861\n", "output": "8\n", "type": "stdin"}, {"input": "85907381\n", "output": "8\n", "type": "stdin"}, {"input": "59967\n", "output": "2\n", "type": "stdin"}, {"input": "646944545\n", "output": "8\n", "type": "stdin"}, {"input": "213990998\n", "output": "4\n", "type": "stdin"}, {"input": "72\n", "output": "6\n", "type": "stdin"}, {"input": "787056\n", "output": "6\n", "type": "stdin"}, {"input": "0011\n", "output": "2\n", "type": "stdin"}, {"input": "245481\n", "output": "8\n", "type": "stdin"}, {"input": "1079259\n", "output": "2\n", "type": "stdin"}, {"input": "0101000111\n", "output": "2\n", "type": "stdin"}, {"input": "27\n", "output": "2\n", "type": "stdin"}, {"input": "42\n", "output": "4\n", "type": "stdin"}, {"input": "25\n", "output": "8\n", "type": "stdin"}, {"input": "400\n", "output": "6\n", "type": "stdin"}, {"input": "1699298\n", "output": "4\n", "type": "stdin"}, {"input": "127860079\n", "output": "2\n", "type": "stdin"}, {"input": "34050\n", "output": "4\n", "type": "stdin"}], "problem_id": "primeintellect_train_6391", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 130}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nVladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.\n\nVladik knows n airports. All the airports are located on a straight line. Each airport has unique id from 1 to n, Vladik's house is situated next to the airport with id a, and the place of the olympiad is situated next to the airport with id b. It is possible that Vladik's house and the place of the olympiad are located near the same airport. \n\nTo get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport a and finish it at the airport b.\n\nEach airport belongs to one of two companies. The cost of flight from the airport i to the airport j is zero if both airports belong to the same company, and |i - j| if they belong to different companies.\n\nPrint the minimum cost Vladik has to pay to get to the olympiad.\n\n\n-----Input-----\n\nThe first line contains three integers n, a, and b (1 \u2264 n \u2264 10^5, 1 \u2264 a, b \u2264 n)\u00a0\u2014 the number of airports, the id of the airport from which Vladik starts his route and the id of the airport which he has to reach. \n\nThe second line contains a string with length n, which consists only of characters 0 and 1. If the i-th character in this string is 0, then i-th airport belongs to first company, otherwise it belongs to the second.\n\n\n-----Output-----\n\nPrint single integer\u00a0\u2014 the minimum cost Vladik has to pay to get to the olympiad.\n\n\n-----Examples-----\nInput\n4 1 4\n1010\n\nOutput\n1\nInput\n5 5 2\n10110\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. \n\nIn the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company.\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\nn, a, b = list(map(int, input().split()))\nm = input()\nif m[a - 1] == m[b - 1]:\n    print(0)\nelse:\n    print(1)\n```"], "public_test_cases": [{"input": "4 1 4\n1010\n", "output": "1", "type": "stdin"}, {"input": "5 5 2\n10110\n", "output": "0", "type": "stdin"}], "test_cases": [{"input": "4 1 4\n1010\n", "output": "1", "type": "stdin"}, {"input": "5 5 2\n10110\n", "output": "0", "type": "stdin"}, {"input": "10 9 5\n1011111001\n", "output": "1", "type": "stdin"}, {"input": "7 3 7\n1110111\n", "output": "0", "type": "stdin"}, {"input": "1 1 1\n1\n", "output": "0", "type": "stdin"}, {"input": "10 3 3\n1001011011\n", "output": "0", "type": "stdin"}, {"input": "1 1 1\n0\n", "output": "0", "type": "stdin"}, {"input": "10 5 8\n1000001110\n", "output": "1", "type": "stdin"}, {"input": "10 1 10\n0000011111\n", "output": "1", "type": "stdin"}, {"input": "4 1 4\n0011\n", "output": "1", "type": "stdin"}, {"input": "10 3 7\n0000011111\n", "output": "1", "type": "stdin"}, {"input": "5 1 5\n11010\n", "output": "1", "type": "stdin"}, {"input": "6 1 6\n111000\n", "output": "1", "type": "stdin"}, {"input": "2 1 2\n01\n", "output": "1", "type": "stdin"}, {"input": "10 10 1\n0000011111\n", "output": "1", "type": "stdin"}, {"input": "6 1 6\n000111\n", "output": "1", "type": "stdin"}, {"input": "10 2 10\n0000011111\n", "output": "1", "type": "stdin"}, {"input": "8 1 8\n11110000\n", "output": "1", "type": "stdin"}, {"input": "6 1 5\n100000\n", "output": "1", "type": "stdin"}, {"input": "16 4 12\n0000000011111111\n", "output": "1", "type": "stdin"}, {"input": "6 1 5\n111000\n", "output": "1", "type": "stdin"}, {"input": "8 2 7\n11110000\n", "output": "1", "type": "stdin"}, {"input": "6 2 5\n111000\n", "output": "1", "type": "stdin"}, {"input": "9 9 1\n111000000\n", "output": "1", "type": "stdin"}, {"input": "2 2 1\n01\n", "output": "1", "type": "stdin"}, {"input": "5 2 5\n00001\n", "output": "1", "type": "stdin"}, {"input": "5 1 5\n10000\n", "output": "1", "type": "stdin"}, {"input": "6 1 6\n011111\n", "output": "1", "type": "stdin"}, {"input": "5 5 1\n11110\n", "output": "1", "type": "stdin"}, {"input": "2 1 2\n10\n", "output": "1", "type": "stdin"}, {"input": "4 2 4\n0001\n", "output": "1", "type": "stdin"}, {"input": "10 1 10\n1111100000\n", "output": "1", "type": "stdin"}, {"input": "8 4 5\n00001111\n", "output": "1", "type": "stdin"}, {"input": "4 4 1\n0111\n", "output": "1", "type": "stdin"}, {"input": "8 1 8\n00101001\n", "output": "1", "type": "stdin"}], "problem_id": "primeintellect_train_5795", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 35}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nThere are N points on a number line, i-th of which is placed on coordinate X_i. These points are numbered in the increasing order of coordinates. In other words, for all i (1 \\leq i \\leq N-1), X_i < X_{i+1} holds. In addition to that, an integer K is given.\n\nProcess Q queries.\n\nIn the i-th query, two integers L_i and R_i are given. Here, a set s of points is said to be a good set if it satisfies all of the following conditions. Note that the definition of good sets varies over queries.\n\n* Each point in s is one of X_{L_i},X_{L_i+1},\\ldots,X_{R_i}.\n* For any two distinct points in s, the distance between them is greater than or equal to K.\n* The size of s is maximum among all sets that satisfy the aforementioned conditions.\n\n\n\nFor each query, find the size of the union of all good sets.\n\nConstraints\n\n* 1 \\leq N \\leq 2 \\times 10^5\n* 1 \\leq K \\leq 10^9\n* 0 \\leq X_1 < X_2 < \\cdots < X_N \\leq 10^9\n* 1 \\leq Q \\leq 2 \\times 10^5\n* 1 \\leq L_i \\leq R_i \\leq N\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\nX_1 X_2 \\cdots X_N\nQ\nL_1 R_1\nL_2 R_2\n\\vdots\nL_Q R_Q\n\n\nOutput\n\nFor each query, print the size of the union of all good sets in a line.\n\nExamples\n\nInput\n\n5 3\n1 2 4 7 8\n2\n1 5\n1 2\n\n\nOutput\n\n4\n2\n\n\nInput\n\n15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n6 14\n1 8\n1 13\n7 12\n4 12\n\n\nOutput\n\n4\n6\n11\n2\n3\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\nimport sys\nreadline = sys.stdin.buffer.readline\n\nn,k = map(int,readline().split())\nvs = list(map(int,readline().split()))\n\nL=18\nxid=[0]*(n*L)\nxsum=[0]*(n*L)\nyid=[0]*(n*L)\nysum=[0]*(n*L)\n\nj=n\nfor i in reversed(range(n)):\n\twhile i<j and vs[i]+k<=vs[j-1]:\n\t\tj-=1\n\txid[i*L+0]=j\n\txsum[i*L+0]=j\n\tfor lv in range(1,L):\n\t\ta=xid[i*L+lv-1]\n\t\tif a==n:\n\t\t\txid[i*L+lv]=n\n\t\telse:\n\t\t\txid[i*L+lv]=xid[a*L+lv-1]\n\t\t\txsum[i*L+lv]=xsum[i*L+lv-1]+xsum[a*L+lv-1]\n\nj=-1\nfor i in range(n):\n\twhile j<i and vs[j+1]+k<=vs[i]:\n\t\tj+=1\n\tyid[i*L+0]=j\n\tysum[i*L+0]=j\n\tfor lv in range(1,L):\n\t\ta=yid[i*L+lv-1]\n\t\tif a==-1:\n\t\t\tyid[i*L+lv]=-1\n\t\telse:\n\t\t\tyid[i*L+lv]=yid[a*L+lv-1]\n\t\t\tysum[i*L+lv]=ysum[i*L+lv-1]+ysum[a*L+lv-1]\n\nq=int(readline())\nfor tmp in range(q):\n\tl,r=map(int,readline().split())\n\tl-=1\n\tr-=1\n\tans=0\n\t\n\ti=l\n\tans-=i\n\tfor lv in reversed(range(L)):\n\t\tif xid[i*L+lv]<=r:\n\t\t\tans-=xsum[i*L+lv]\n\t\t\ti=xid[i*L+lv]\n\t\n\ti=r\n\tans+=i+1\n\tfor lv in reversed(range(L)):\n\t\tif yid[i*L+lv]>=l:\n\t\t\tans+=ysum[i*L+lv]+(1<<lv)\n\t\t\ti=yid[i*L+lv]\n\t\n\tprint(ans)\n\t\n\n```"], "public_test_cases": [{"input": "5 3\n1 2 4 7 8\n2\n1 5\n1 2", "output": "4\n2", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n6 14\n1 8\n1 13\n7 12\n4 12", "output": "4\n6\n11\n2\n3", "type": "stdin"}], "test_cases": [{"input": "5 3\n1 2 4 7 8\n2\n1 5\n1 2", "output": "4\n2", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n6 14\n1 8\n1 13\n7 12\n4 12", "output": "4\n6\n11\n2\n3", "type": "stdin"}, {"input": "5 3\n1 2 4 4 8\n2\n1 5\n1 2", "output": "4\n2\n", "type": "stdin"}, {"input": "5 3\n1 4 4 4 8\n2\n1 5\n1 2", "output": "5\n2\n", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n7 12\n4 12", "output": "3\n6\n11\n2\n3\n", "type": "stdin"}, {"input": "15 220492538\n3365326 12864090 23146757 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n4 12", "output": "3\n12\n11\n2\n3\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n4 12", "output": "6\n13\n12\n5\n7\n", "type": "stdin"}, {"input": "5 3\n1 2 4 7 8\n2\n1 5\n1 4", "output": "4\n3\n", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 13\n1 13\n7 12\n4 12", "output": "3\n11\n11\n2\n3\n", "type": "stdin"}, {"input": "5 3\n1 2 4 5 6\n2\n1 3\n1 2", "output": "2\n2\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n4 12", "output": "6\n12\n11\n5\n8\n", "type": "stdin"}, {"input": "5 3\n2 2 4 7 8\n2\n1 5\n1 4", "output": "5\n4\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 60508580 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n4 12", "output": "6\n13\n12\n5\n8\n", "type": "stdin"}, {"input": "5 3\n2 2 4 7 8\n2\n1 5\n1 1", "output": "5\n1\n", "type": "stdin"}, {"input": "5 3\n-1 2 4 5 6\n2\n1 3\n1 2", "output": "3\n2\n", "type": "stdin"}, {"input": "5 3\n2 2 4 7 8\n2\n1 5\n2 1", "output": "5\n0\n", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n12 12\n4 12", "output": "3\n6\n11\n1\n3\n", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n7 12\n4 14", "output": "3\n6\n11\n2\n9\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 6\n7 12\n4 12", "output": "6\n13\n6\n5\n7\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n5 12", "output": "6\n12\n11\n5\n7\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 60508580 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n2 14\n1 13\n7 12\n4 12", "output": "6\n12\n12\n5\n8\n", "type": "stdin"}, {"input": "5 3\n2 2 4 7 8\n2\n2 5\n1 1", "output": "4\n1\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n12 12\n4 12", "output": "6\n3\n13\n1\n7\n", "type": "stdin"}, {"input": "5 3\n0 2 4 5 8\n2\n1 3\n2 2", "output": "2\n1\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n4\n9 14\n1 8\n1 13\n12 12\n4 12", "output": "6\n3\n13\n1\n", "type": "stdin"}, {"input": "5 3\n0 2 1 7 8\n2\n1 5\n2 4", "output": "5\n3\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 36967106 60508580 87064208 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 12\n1 14\n1 13\n7 12\n4 12", "output": "4\n13\n12\n5\n8\n", "type": "stdin"}, {"input": "5 2\n1 2 4 6 8\n2\n3 5\n1 3", "output": "3\n3\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 57619799 60508580 87064208 511725318 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 12\n1 14\n1 13\n7 12\n4 12", "output": "4\n14\n13\n6\n9\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 13573921 42574196 60508580 44514885 263239555 350278176 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 5\n4 12", "output": "6\n13\n12\n-1\n8\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 13573921 42574196 60508580 44514885 263239555 147051407 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 5\n4 12", "output": "6\n14\n13\n-1\n9\n", "type": "stdin"}, {"input": "15 220492538\n3365326 12864090 23146757 36967106 133073771 141315707 263239555 350278176 401243954 394106614 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n7 12\n4 12", "output": "4\n6\n12\n2\n3\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 14\n1 14\n2 13\n7 12\n4 12", "output": "6\n13\n11\n5\n8\n", "type": "stdin"}, {"input": "5 3\n2 2 4 5 8\n2\n1 5\n2 1", "output": "4\n0\n", "type": "stdin"}, {"input": "15 220492538\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 3\n1 13\n12 12\n4 12", "output": "3\n3\n11\n1\n3\n", "type": "stdin"}, {"input": "5 3\n1 2 2 4 6\n2\n1 1\n1 2", "output": "1\n2\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n2 12\n5 12", "output": "6\n12\n11\n9\n7\n", "type": "stdin"}, {"input": "5 4\n0 2 4 7 8\n2\n1 5\n1 4", "output": "3\n4\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n9 12\n4 12", "output": "6\n3\n13\n4\n7\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 36967106 60508580 87064208 263239555 375407502 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n4 12", "output": "6\n14\n13\n6\n9\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n4\n9 14\n1 8\n1 1\n12 12\n4 12", "output": "6\n3\n1\n1\n", "type": "stdin"}, {"input": "15 102222527\n3365326 23626786 13573921 42574196 60508580 44514885 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n10 14\n1 14\n1 13\n7 12\n4 12", "output": "5\n13\n12\n5\n8\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 201568249 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 14\n1 8\n1 13\n12 12\n4 12", "output": "6\n8\n13\n1\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 13573921 42574196 60508580 44514885 263239555 350278176 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n3\n9 14\n1 14\n1 13\n7 12\n4 12", "output": "6\n13\n12\n", "type": "stdin"}, {"input": "5 3\n1 2 7 7 8\n1\n1 5\n1 2", "output": "5\n", "type": "stdin"}, {"input": "15 220492538\n5303327 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 1\n1 13\n7 12\n4 12", "output": "3\n1\n11\n2\n3\n", "type": "stdin"}, {"input": "15 102222527\n3365326 22617180 13573921 9187992 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n1 14\n1 14\n1 13\n7 12\n4 12", "output": "13\n13\n12\n5\n8\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 201568249 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 14\n1 8\n1 8\n12 12\n4 12", "output": "6\n8\n8\n1\n", "type": "stdin"}, {"input": "15 57873268\n781207 12864090 23146757 57619799 60508580 87064208 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 12\n1 14\n1 13\n7 12\n4 12", "output": "4\n12\n11\n5\n8\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 13573921 42574196 60508580 44514885 263239555 350278176 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n3\n9 14\n1 14\n1 3\n7 12\n4 12", "output": "6\n13\n3\n", "type": "stdin"}, {"input": "5 6\n1 2 4 5 8\n2\n1 5\n2 1", "output": "3\n0\n", "type": "stdin"}, {"input": "15 102222527\n3365326 22617180 13573921 9187992 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n1 8\n1 14\n1 13\n7 12\n4 12", "output": "8\n13\n12\n5\n8\n", "type": "stdin"}, {"input": "15 220492538\n4452279 9350033 36346652 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n7 10\n4 14", "output": "3\n6\n11\n4\n9\n", "type": "stdin"}, {"input": "5 1\n1 2 4 4 8\n2\n2 5\n1 4", "output": "4\n4\n", "type": "stdin"}, {"input": "5 6\n0 2 4 5 8\n2\n1 5\n3 1", "output": "3\n-1\n", "type": "stdin"}, {"input": "15 327168494\n264496 12864090 681716 31318558 133073771 141315707 263239555 201568249 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 14\n1 8\n1 8\n14 12\n4 12", "output": "6\n8\n8\n-1\n", "type": "stdin"}, {"input": "15 327168494\n264496 12864090 681716 31318558 133073771 141315707 263239555 201568249 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 8\n1 8\n1 8\n14 12\n4 12", "output": "0\n8\n8\n-1\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 14\n2 13\n7 12\n4 12", "output": "6\n12\n10\n5\n8\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 13573921 9187992 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 1\n1 14\n1 13\n7 12\n4 12", "output": "-7\n13\n12\n5\n8\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 60508580 252521403 331355180 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n2 14\n1 13\n7 12\n4 12", "output": "6\n12\n12\n3\n8\n", "type": "stdin"}, {"input": "5 3\n2 2 0 6 12\n2\n1 5\n2 0", "output": "5\n-1\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 36967106 60508580 87064208 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n4 10", "output": "6\n13\n12\n5\n6\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n4\n9 14\n1 12\n1 13\n12 12\n4 12", "output": "6\n11\n13\n1\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 36967106 60508580 87064208 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 12\n1 14\n1 13\n3 12\n4 12", "output": "4\n13\n12\n9\n8\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 14\n1 8\n1 13\n12 4\n4 12", "output": "6\n3\n13\n-7\n", "type": "stdin"}, {"input": "5 2\n1 2 4 6 8\n2\n3 1\n1 3", "output": "-1\n3\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 57619799 60508580 6121126 511725318 350278176 401243954 418305779 450172439 890547505 625900495 626194585 1673546355\n5\n9 12\n1 14\n1 13\n7 12\n4 4", "output": "4\n14\n13\n6\n1\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 13573921 42574196 60508580 44514885 263239555 147051407 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 6\n4 12", "output": "6\n14\n13\n0\n9\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 13573921 42574196 35282797 44514885 263239555 147051407 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n5\n9 14\n1 14\n2 13\n7 5\n4 12", "output": "6\n14\n12\n-1\n9\n", "type": "stdin"}, {"input": "15 220492538\n3365326 12864090 23146757 36967106 133073771 141315707 263239555 350278176 401243954 394106614 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 9\n7 12\n4 12", "output": "4\n6\n9\n2\n3\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n12 14\n1 14\n1 13\n2 12\n5 12", "output": "3\n12\n11\n9\n7\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 1296810 36967106 60508580 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n2\n9 14\n2 14\n1 13\n7 12\n4 12", "output": "6\n12\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 819032353 891960194\n5\n9 14\n1 8\n1 13\n9 12\n4 12", "output": "4\n3\n13\n4\n7\n", "type": "stdin"}, {"input": "5 3\n0 2 4 5 8\n2\n2 3\n2 1", "output": "2\n0\n", "type": "stdin"}, {"input": "15 102222527\n3365326 23626786 13573921 42574196 60508580 44514885 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n10 14\n1 14\n1 13\n11 12\n4 12", "output": "5\n13\n12\n2\n8\n", "type": "stdin"}, {"input": "15 102222527\n781207 12864090 23146757 57619799 60508580 87064208 263239555 350278176 357884719 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 12\n1 14\n1 13\n7 12\n4 12", "output": "4\n12\n11\n4\n7\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 57619799 60508580 6121126 511725318 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n7 12\n1 14\n1 13\n11 12\n4 12", "output": "6\n14\n13\n2\n9\n", "type": "stdin"}, {"input": "15 102222527\n2568807 23626786 1332608 42574196 60508580 44514885 263239555 147051407 401243954 418305779 450172439 846763323 625900495 626194585 891960194\n5\n11 14\n1 14\n1 13\n7 5\n4 12", "output": "4\n14\n13\n-1\n9\n", "type": "stdin"}, {"input": "15 269362976\n4452279 9350033 36346652 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n7 12\n4 14", "output": "6\n5\n6\n2\n4\n", "type": "stdin"}, {"input": "6 4\n0 2 7 7 8\n2\n1 5\n1 4", "output": "-3\n", "type": "stdin"}, {"input": "15 102222527\n786368 23626786 13573921 36967106 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 14\n2 14\n1 13\n4 12\n4 12", "output": "6\n12\n12\n8\n8\n", "type": "stdin"}, {"input": "15 220492538\n4452279 9350033 36346652 36967106 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 8\n1 13\n7 11\n4 14", "output": "3\n6\n11\n5\n9\n", "type": "stdin"}, {"input": "5 1\n1 2 7 4 8\n1\n2 5\n1 2", "output": "4\n", "type": "stdin"}, {"input": "15 75278082\n3365326 22617180 13573921 9187992 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 651610188 891960194\n5\n1 8\n1 14\n1 13\n7 12\n4 12", "output": "8\n12\n11\n4\n7\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 681716 31318558 133073771 141315707 263239555 201568249 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 14\n1 11\n1 8\n12 12\n4 12", "output": "6\n7\n8\n1\n", "type": "stdin"}, {"input": "5 6\n0 2 4 5 8\n2\n1 1\n3 1", "output": "1\n-1\n", "type": "stdin"}, {"input": "15 220492538\n3365326 12864090 23146757 36967106 133073771 233375184 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n9 14\n1 5\n1 13\n7 12\n4 12", "output": "3\n5\n11\n2\n3\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 133073771 252521403 263239555 350278176 401243954 418305779 450172439 480433293 625900495 626194585 891960194\n5\n9 14\n1 14\n2 13\n7 12\n4 12", "output": "6\n13\n11\n6\n9\n", "type": "stdin"}, {"input": "5 3\n0 2 4 7 8\n2\n1 1\n1 1", "output": "1\n1\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 13573921 36967106 60508580 252521403 263239555 211111683 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 14\n1 14\n1 13\n7 12\n7 12", "output": "6\n14\n13\n6\n6\n", "type": "stdin"}, {"input": "15 102222527\n2699151 12864090 23146757 57619799 60508580 6121126 511725318 350278176 401243954 418305779 450172439 890547505 625900495 626194585 1673546355\n5\n9 12\n1 14\n1 13\n1 12\n4 4", "output": "4\n14\n13\n12\n1\n", "type": "stdin"}, {"input": "15 220492538\n5303327 12864090 23146757 31318558 133073771 238119693 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n4\n9 14\n1 13\n1 13\n7 12\n4 12", "output": "3\n11\n11\n2\n", "type": "stdin"}, {"input": "15 102222527\n3365326 12864090 23146757 36967106 188518495 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n5\n12 14\n1 14\n1 13\n2 12\n5 12", "output": "3\n14\n13\n11\n8\n", "type": "stdin"}, {"input": "5 4\n0 3 4 7 8\n1\n1 5\n1 4", "output": "3\n", "type": "stdin"}, {"input": "15 177073037\n3365326 12864090 1296810 36967106 60508580 252521403 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n2\n9 14\n2 14\n1 13\n7 12\n4 12", "output": "4\n13\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 819032353 891960194\n5\n9 14\n1 8\n1 13\n9 12\n1 12", "output": "4\n3\n13\n4\n11\n", "type": "stdin"}, {"input": "15 102222527\n781207 12864090 23146757 57619799 60508580 87064208 263239555 350278176 357884719 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 1\n1 14\n1 13\n7 12\n4 12", "output": "-7\n12\n11\n4\n7\n", "type": "stdin"}, {"input": "15 57873268\n781207 12864090 36279670 44605331 60508580 87064208 263239555 350278176 401243954 418305779 450172439 890547505 625900495 626194585 891960194\n5\n9 12\n1 14\n1 13\n7 12\n4 12", "output": "4\n11\n10\n5\n8\n", "type": "stdin"}, {"input": "15 327168494\n4452279 12864090 477673 31318558 133073771 141315707 263239555 201568249 401243954 418305779 450172439 560311491 679375917 626194585 1332571214\n4\n9 14\n1 8\n2 8\n12 12\n4 12", "output": "6\n8\n7\n1\n", "type": "stdin"}, {"input": "15 75278082\n3365326 22617180 13573921 9187992 60508580 252521403 263239555 350278176 401243954 418305779 450172439 890547505 625900495 651610188 891960194\n5\n2 8\n1 14\n1 13\n7 12\n4 12", "output": "7\n12\n11\n4\n7\n", "type": "stdin"}, {"input": "5 6\n0 2 4 5 8\n2\n1 2\n3 1", "output": "2\n-1\n", "type": "stdin"}, {"input": "15 327168494\n264496 12864090 681716 31318558 133073771 11602338 263239555 201568249 401243954 418305779 450172439 560311491 625900495 626194585 1332571214\n4\n9 8\n1 7\n1 8\n14 12\n4 12", "output": "0\n7\n8\n-1\n", "type": "stdin"}], "problem_id": "primeintellect_train_6524", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 102}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nNikolay lives in a two-storied house. There are n rooms on each floor, arranged in a row and numbered from one from left to right. So each room can be represented by the number of the floor and the number of the room on this floor (room number is an integer between 1 and n). \n\nIf Nikolay is currently in some room, he can move to any of the neighbouring rooms (if they exist). Rooms with numbers i and i+1 on each floor are neighbouring, for all 1 \u2264 i \u2264 n - 1. There may also be staircases that connect two rooms from different floors having the same numbers. If there is a staircase connecting the room x on the first floor and the room x on the second floor, then Nikolay can use it to move from one room to another.\n\n<image> The picture illustrates a house with n = 4. There is a staircase between the room 2 on the first floor and the room 2 on the second floor, and another staircase between the room 4 on the first floor and the room 4 on the second floor. The arrows denote possible directions in which Nikolay can move. The picture corresponds to the string \"0101\" in the input. \n\nNikolay wants to move through some rooms in his house. To do this, he firstly chooses any room where he starts. Then Nikolay moves between rooms according to the aforementioned rules. Nikolay never visits the same room twice (he won't enter a room where he has already been). \n\nCalculate the maximum number of rooms Nikolay can visit during his tour, if:\n\n  * he can start in any room on any floor of his choice, \n  * and he won't visit the same room twice. \n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases in the input. Then test cases follow. Each test case consists of two lines.\n\nThe first line contains one integer n (1 \u2264 n \u2264 1 000) \u2014 the number of rooms on each floor.\n\nThe second line contains one string consisting of n characters, each character is either a '0' or a '1'. If the i-th character is a '1', then there is a staircase between the room i on the first floor and the room i on the second floor. If the i-th character is a '0', then there is no staircase between the room i on the first floor and the room i on the second floor.\n\nIn hacks it is allowed to use only one test case in the input, so t = 1 should be satisfied.\n\nOutput\n\nFor each test case print one integer \u2014 the maximum number of rooms Nikolay can visit during his tour, if he can start in any room on any floor, and he won't visit the same room twice.\n\nExample\n\nInput\n\n\n4\n5\n00100\n8\n00000000\n5\n11111\n3\n110\n\n\nOutput\n\n\n6\n8\n10\n6\n\nNote\n\nIn the first test case Nikolay may start in the first room of the first floor. Then he moves to the second room on the first floor, and then \u2014 to the third room on the first floor. Then he uses a staircase to get to the third room on the second floor. Then he goes to the fourth room on the second floor, and then \u2014 to the fifth room on the second floor. So, Nikolay visits 6 rooms.\n\nThere are no staircases in the second test case, so Nikolay can only visit all rooms on the same floor (if he starts in the leftmost or in the rightmost room).\n\nIn the third test case it is possible to visit all rooms: first floor, first room \u2192 second floor, first room \u2192 second floor, second room \u2192 first floor, second room \u2192 first floor, third room \u2192 second floor, third room \u2192 second floor, fourth room \u2192 first floor, fourth room \u2192 first floor, fifth room \u2192 second floor, fifth room.\n\nIn the fourth test case it is also possible to visit all rooms: second floor, third room \u2192 second floor, second room \u2192 second floor, first room \u2192 first floor, first room \u2192 first floor, second room \u2192 first floor, third room.\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\ndef solve(n, s):\n\tis_stairs = [s[x] == '1' for x in range(n)]\n\tif not any(is_stairs):\n\t\treturn n\n\tif is_stairs[0] or is_stairs[-1]:\n\t\treturn n * 2\n\telse:\n\t\tmin_idx = max_idx = None\n\t\tfor i in range(n):\n\t\t\tif not is_stairs[i]:\n\t\t\t\tcontinue\n\t\t\tif not min_idx:\n\t\t\t\tmin_idx = i\n\t\t\tmax_idx = i\n\n\t\treturn max(max_idx + 1, n - min_idx) * 2\n\n\nfor _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\tr = solve(n, s)\n\tprint(r)\n\n```"], "public_test_cases": [{"input": "4\n5\n00100\n8\n00000000\n5\n11111\n3\n110\n", "output": "6\n8\n10\n6\n", "type": "stdin"}], "test_cases": [{"input": "4\n5\n00100\n8\n00000000\n5\n11111\n3\n110\n", "output": "6\n8\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n", "output": "100\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n010\n3\n011\n3\n100\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n4\n6\n6\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000\n", "output": "124\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n010\n3\n011\n3\n000\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n4\n6\n3\n6\n6\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n11111\n3\n110\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n010\n3\n011\n3\n001\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n4\n6\n6\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000\n", "output": "116\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001001\n5\n10111\n3\n110\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000\n", "output": "170\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000\n", "output": "130\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n110\n3\n011\n3\n001\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n6\n6\n6\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000100000000000000000000000101000000000000000000000000000000000000000000\n", "output": "138\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n001\n3\n001\n3\n110\n3\n011\n3\n001\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n6\n6\n6\n6\n6\n6\n6\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00000000\n5\n11011\n3\n110\n", "output": "6\n8\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000100000000000000000000000000000000000000\n", "output": "136\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n000\n3\n011\n3\n000\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n3\n6\n3\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000010000000000000000000000000000000000000000000001000000000000000000000000000000000000000000\n", "output": "178\n", "type": "stdin"}, {"input": "4\n5\n00101\n8\n00001001\n5\n00111\n3\n110\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00000010\n5\n11011\n3\n110\n", "output": "6\n14\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00101\n8\n00001001\n5\n10111\n3\n010\n", "output": "10\n16\n10\n4\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000010000000000000000000000000000000000000001000000000000000000000000000000000000000000\n", "output": "166\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000100000000000000100000000000000000000000101000000000000000000000000000000000000000000\n", "output": "168\n", "type": "stdin"}, {"input": "4\n5\n00000\n8\n00011000\n5\n11111\n3\n111\n", "output": "5\n10\n10\n6\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n000\n3\n000\n3\n011\n3\n000\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n3\n3\n6\n3\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0100000100000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000\n", "output": "198\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000001\n", "output": "200\n", "type": "stdin"}, {"input": "4\n5\n00110\n8\n00001000\n5\n10110\n3\n110\n", "output": "8\n10\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n10100\n8\n00001000\n5\n10111\n3\n100\n", "output": "10\n10\n10\n6\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n000\n3\n000\n3\n111\n3\n000\n3\n101\n3\n010\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n3\n3\n6\n3\n6\n4\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000010000000000000000000000000000000000100000000000000000000000000000000000000\n", "output": "148\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n11111\n3\n010\n", "output": "6\n10\n10\n4\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000001000000000000000000000000000001000000000000000000000000000000000000000000\n", "output": "146\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000100000000010000000000000000000000000000\n", "output": "144\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n000\n3\n100\n3\n111\n3\n000\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n3\n6\n6\n3\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000001000000000000000000000000000001000000000000000000000100000000000000000000\n", "output": "160\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000000000000000000000100000000001000000000100000\n", "output": "190\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n101\n3\n010\n3\n011\n3\n100\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n4\n6\n6\n6\n6\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n10111\n3\n110\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000\n", "output": "116\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n11111\n3\n111\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n101\n3\n010\n3\n011\n3\n100\n3\n100\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n4\n6\n6\n6\n6\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001001\n5\n00111\n3\n110\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00011000\n5\n11111\n3\n111\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000100000000000000000000000000000000000000000000000000000001000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n10001000\n5\n10111\n3\n110\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n01001001\n5\n10111\n3\n110\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000100000010000000000000000101000000000000000000000000000000000000000000\n", "output": "138\n", "type": "stdin"}, {"input": "1\n100\n0000000101000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000100000000000000000000000010000000000000000000000000000001000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000\n", "output": "136\n", "type": "stdin"}, {"input": "4\n5\n10100\n8\n01001001\n5\n10111\n3\n110\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000110000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n00101\n8\n00001001\n5\n10111\n3\n110\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n10100\n8\n00001001\n5\n10111\n3\n110\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00000010\n5\n11111\n3\n110\n", "output": "6\n14\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n10110\n3\n110\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000100000000000000000000000000000000000000000000000000000000001000000000000000\n", "output": "170\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n11101\n3\n111\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000000000000000000000000000000000000000000000000000100000001000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000100000000000000000000000000000010000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n10001000\n5\n10101\n3\n110\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000101000000000000000000000000000000000000000000000000000000000000000000000000101000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n00101\n8\n00001001\n5\n10111\n3\n011\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n10100\n8\n00001001\n5\n10111\n3\n100\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00101\n8\n00001001\n5\n10101\n3\n010\n", "output": "10\n16\n10\n4\n", "type": "stdin"}, {"input": "1\n100\n1000000000000000010000000000000000000000000000000000000001000000000000000000000000000000000000000000\n", "output": "200\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001000\n5\n11101\n3\n110\n", "output": "6\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000000000000000000000000000000000000000000000000000100000001000010000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000100000000000000000000000010000010000000\n", "output": "186\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n000\n3\n000\n3\n111\n3\n000\n3\n101\n3\n110\n3\n111\n", "output": "1\n2\n2\n4\n4\n4\n3\n3\n3\n6\n3\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0100000100000000000000000000000000000000100000000000000000000100100000000000000000000000000000000000\n", "output": "198\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001001\n5\n10111\n3\n011\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0100000100001000000000000000000000000000100000000000000000000100100000000000000000000000000000000000\n", "output": "198\n", "type": "stdin"}, {"input": "4\n5\n11100\n8\n00001000\n5\n10111\n3\n100\n", "output": "10\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0100000100001100000000000000000000000000100000000000000000000100100000000000000000000000000000000000\n", "output": "198\n", "type": "stdin"}, {"input": "4\n5\n11100\n8\n00001000\n5\n10111\n3\n110\n", "output": "10\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0100000100001100000000000000000000000000100000000000010000000100100000000000000000000000000000000000\n", "output": "198\n", "type": "stdin"}, {"input": "14\n1\n0\n1\n1\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n010\n3\n011\n3\n000\n3\n101\n3\n110\n3\n101\n", "output": "1\n2\n2\n4\n4\n4\n3\n6\n4\n6\n3\n6\n6\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000000000000000000000000000000100000000001000000000000000\n", "output": "170\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000000000100000000000000100100000000000000000000000000000000000\n", "output": "130\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000100001000000000000000000101000000000000000000000000000000000000000000\n", "output": "138\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00001001\n5\n01111\n3\n110\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000100000000000000000000000000100000000000000000000000000001000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00000000\n5\n10011\n3\n110\n", "output": "6\n8\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000010000000000000000000000000000000000000000000001000000000010000000000000000000000000000000\n", "output": "178\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n10001000\n5\n10111\n3\n111\n", "output": "6\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000000100000010000000000000000101000000000000000000000000000000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000110000000000000000000000000000000000000000000000000000100100000000000000000000001000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n00001\n8\n00001001\n5\n10111\n3\n110\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00100\n8\n00010010\n5\n11111\n3\n110\n", "output": "6\n14\n10\n6\n", "type": "stdin"}, {"input": "4\n5\n00000\n8\n00001000\n5\n11101\n3\n111\n", "output": "5\n10\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000100000000000000100000000000000000001000101000000000000000000000000000000000000000000\n", "output": "168\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000010000000000000000000000000000100000000000000000000000001000010000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0100000100000000000000000000000100000000000000000000000000000100100000000000000000000000000000000000\n", "output": "198\n", "type": "stdin"}, {"input": "1\n100\n0000000101000000000000000000000000000000000000000000000000000000000000000000000001101000000000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000100000000000000000000000000000000000000000000000000000000000000000000100000011000010000000000\n", "output": "186\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000001000010000000000000000000000000000100000000000000000000000010000010000000\n", "output": "186\n", "type": "stdin"}, {"input": "4\n5\n11100\n8\n00001001\n5\n10111\n3\n100\n", "output": "10\n16\n10\n6\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000010000000000000000000010000000000000100000000000000000000000000000000000000\n", "output": "148\n", "type": "stdin"}, {"input": "1\n100\n0000000000000000000000000000000000000000001000100000000000000100100000000000000000000000000000000000\n", "output": "130\n", "type": "stdin"}], "problem_id": "primeintellect_train_15802", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 103}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nThe Saratov State University Olympiad Programmers Training Center (SSU OPTC) has n students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.\n\nThe head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least k times?\n\nInput\n\nThe first line contains two integers, n and k (1 \u2264 n \u2264 2000; 1 \u2264 k \u2264 5). The next line contains n integers: y1, y2, ..., yn (0 \u2264 yi \u2264 5), where yi shows the number of times the i-th person participated in the ACM ICPC world championship.\n\nOutput\n\nPrint a single number \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n5 2\n0 4 5 1 0\n\n\nOutput\n\n1\n\n\nInput\n\n6 4\n0 1 2 3 4 5\n\n\nOutput\n\n0\n\n\nInput\n\n6 5\n0 0 0 0 0 0\n\n\nOutput\n\n2\n\nNote\n\nIn the first sample only one team could be made: the first, the fourth and the fifth participants.\n\nIn the second sample no teams could be created.\n\nIn the third sample two teams could be created. Any partition into two teams fits.\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\nn, k = [int(x) for x in input().split()]\npros = [int(x) for x in input().split()]\nteams=0\nfor i in range(n):\n    z = pros[i]+k\n    if z <= 5:\n        teams+=1\n\nprint(int(teams/3))\n```"], "public_test_cases": [{"input": "5 2\n0 4 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "6 4\n0 1 2 3 4 5\n", "output": "0\n", "type": "stdin"}, {"input": "6 5\n0 0 0 0 0 0\n", "output": "2\n", "type": "stdin"}], "test_cases": [{"input": "6 4\n0 1 2 3 4 5\n", "output": "0\n", "type": "stdin"}, {"input": "6 5\n0 0 0 0 0 0\n", "output": "2\n", "type": "stdin"}, {"input": "5 2\n0 4 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "12 2\n0 1 2 3 4 0 1 2 3 4 0 1\n", "output": "3\n", "type": "stdin"}, {"input": "3 4\n0 2 0\n", "output": "0\n", "type": "stdin"}, {"input": "3 4\n0 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "20 1\n5 0 4 2 2 3 2 1 2 4 1 3 5 5 5 4 4 1 3 0\n", "output": "5\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 1 5 0 4 1 1 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "1 4\n1\n", "output": "0\n", "type": "stdin"}, {"input": "6 3\n4 4 4 4 4 4\n", "output": "0\n", "type": "stdin"}, {"input": "2 3\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 5 0 3 3 0 4 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "15 2\n0 1 2 3 4 0 1 2 3 4 0 1 2 3 4\n", "output": "4\n", "type": "stdin"}, {"input": "1 1\n0\n", "output": "0\n", "type": "stdin"}, {"input": "12 2\n0 1 2 3 2 0 1 2 3 4 0 1\n", "output": "3\n", "type": "stdin"}, {"input": "3 4\n0 2 1\n", "output": "0\n", "type": "stdin"}, {"input": "20 1\n5 0 8 2 2 3 2 1 2 4 1 3 5 5 5 4 4 1 3 0\n", "output": "5\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 5 0 3 3 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "6 4\n0 1 2 3 0 5\n", "output": "1\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 2 5 0 4 1 1 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "6 3\n4 5 4 4 4 4\n", "output": "0\n", "type": "stdin"}, {"input": "2 1\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "15 2\n0 1 2 3 4 0 1 2 3 4 0 1 2 3 5\n", "output": "4\n", "type": "stdin"}, {"input": "1 0\n0\n", "output": "0\n", "type": "stdin"}, {"input": "6 5\n0 0 1 0 0 0\n", "output": "1\n", "type": "stdin"}, {"input": "5 4\n0 4 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "12 2\n0 0 2 3 2 0 1 2 3 4 0 1\n", "output": "3\n", "type": "stdin"}, {"input": "3 2\n0 2 0\n", "output": "1\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 4 5 0 4 1 1 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "6 1\n4 5 4 4 4 4\n", "output": "1\n", "type": "stdin"}, {"input": "2 2\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 5 0 3 3 1 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "1 0\n1\n", "output": "0\n", "type": "stdin"}, {"input": "6 4\n0 1 2 3 1 5\n", "output": "1\n", "type": "stdin"}, {"input": "6 5\n0 0 1 0 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "5 4\n0 6 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "12 2\n0 0 2 3 2 1 1 2 3 4 0 1\n", "output": "3\n", "type": "stdin"}, {"input": "3 1\n0 2 0\n", "output": "1\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 4 5 0 8 1 1 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "1 2\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 0 0 3 3 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "0 0\n0\n", "output": "0\n", "type": "stdin"}, {"input": "6 4\n0 1 2 3 1 6\n", "output": "1\n", "type": "stdin"}, {"input": "6 5\n0 1 1 0 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "5 3\n0 6 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "3 1\n0 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "0 2\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 0 0 3 2 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "6 5\n0 1 2 3 1 6\n", "output": "0\n", "type": "stdin"}, {"input": "5 3\n0 6 5 1 1\n", "output": "1\n", "type": "stdin"}, {"input": "2 0\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n0 4 5 1 3 4 0 0 0 3 2 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "6 5\n0 1 2 3 1 10\n", "output": "0\n", "type": "stdin"}, {"input": "5 2\n0 6 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "20 2\n0 4 5 1 3 4 0 0 0 6 2 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "6 5\n1 1 2 3 1 10\n", "output": "0\n", "type": "stdin"}, {"input": "5 2\n0 6 5 0 0\n", "output": "1\n", "type": "stdin"}, {"input": "20 2\n0 4 5 1 3 4 0 0 0 6 2 0 5 0 0 1 4 4 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 1 3 4 0 0 0 6 2 0 5 0 0 1 4 4 0 6\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 0 3 4 0 0 0 6 2 0 5 0 0 1 4 4 0 6\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 0 3 8 0 0 0 6 2 0 5 0 0 1 4 4 0 6\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 0 5 8 0 0 0 6 2 0 5 0 0 1 4 4 0 6\n", "output": "3\n", "type": "stdin"}, {"input": "20 2\n0 4 5 0 5 8 0 0 0 6 2 0 5 0 0 0 4 4 0 6\n", "output": "3\n", "type": "stdin"}, {"input": "12 2\n0 1 2 3 4 0 1 2 3 4 0 2\n", "output": "3\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 1 5 0 4 1 1 0 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "0 4\n1\n", "output": "0\n", "type": "stdin"}, {"input": "6 3\n5 4 4 4 4 4\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n2 4 5 1 3 4 0 5 0 3 3 0 4 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "1 1\n1\n", "output": "0\n", "type": "stdin"}, {"input": "6 4\n0 1 2 0 4 5\n", "output": "1\n", "type": "stdin"}, {"input": "5 2\n0 1 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "12 2\n0 1 2 3 2 0 1 2 3 0 0 1\n", "output": "4\n", "type": "stdin"}, {"input": "3 4\n0 4 1\n", "output": "0\n", "type": "stdin"}, {"input": "20 1\n5 0 8 1 2 3 2 1 2 4 1 3 5 5 5 4 4 1 3 0\n", "output": "5\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 2 5 0 4 1 2 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "6 3\n4 5 4 1 4 4\n", "output": "0\n", "type": "stdin"}, {"input": "15 2\n0 1 2 5 4 0 1 2 3 4 0 1 2 3 5\n", "output": "3\n", "type": "stdin"}, {"input": "6 5\n1 0 1 0 0 0\n", "output": "1\n", "type": "stdin"}, {"input": "5 4\n1 4 5 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "12 2\n0 0 2 0 2 0 1 2 3 4 0 1\n", "output": "3\n", "type": "stdin"}, {"input": "3 2\n0 4 0\n", "output": "0\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 4 5 0 4 1 2 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "6 1\n4 5 4 1 4 4\n", "output": "1\n", "type": "stdin"}, {"input": "2 2\n1 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 5 0 2 3 1 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "12 2\n0 0 2 3 2 1 1 1 3 4 0 1\n", "output": "3\n", "type": "stdin"}, {"input": "13 1\n5 0 5 0 4 5 0 8 1 2 1 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "1 2\n0 1\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 0 0 3 5 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "0 0\n1\n", "output": "0\n", "type": "stdin"}, {"input": "6 4\n0 1 2 3 2 6\n", "output": "0\n", "type": "stdin"}, {"input": "6 5\n0 1 0 0 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "5 3\n0 6 6 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "3 1\n1 1 0\n", "output": "1\n", "type": "stdin"}, {"input": "0 2\n1 0\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n1 4 5 1 3 4 0 0 0 3 2 0 5 0 1 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 1 3 4 0 0 0 3 0 0 5 0 0 1 4 2 0 4\n", "output": "4\n", "type": "stdin"}, {"input": "6 5\n0 0 2 3 1 10\n", "output": "0\n", "type": "stdin"}, {"input": "6 5\n1 1 2 3 0 10\n", "output": "0\n", "type": "stdin"}, {"input": "20 2\n0 4 5 1 3 4 0 0 0 6 2 0 2 0 0 1 4 4 0 6\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 0 3 8 0 0 0 2 2 0 5 0 0 1 4 4 0 6\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 4 5 0 3 8 0 0 0 6 2 0 5 0 0 1 4 4 0 1\n", "output": "4\n", "type": "stdin"}, {"input": "20 2\n0 3 5 0 5 8 0 0 0 6 2 0 5 0 0 0 4 4 0 6\n", "output": "4\n", "type": "stdin"}, {"input": "12 2\n0 1 2 3 4 0 1 2 1 4 0 2\n", "output": "3\n", "type": "stdin"}], "problem_id": "primeintellect_train_5957", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 104}, "generated_solutions": []}
{"problem": "This is a story in a depopulated area. In this area, houses are sparsely built along a straight road called Country Road. Until now, there was no electricity in this area, but this time the government will give us some generators. You can install the generators wherever you like, but in order for electricity to be supplied to your home, you must be connected to one of the generators via an electric wire, which incurs a cost proportional to its length. As the only technical civil servant in the area, your job is to seek generator and wire placement that minimizes the total length of wires, provided that electricity is supplied to all homes. Is. Since the capacity of the generator is large enough, it is assumed that electricity can be supplied to as many houses as possible.\n\nFigure 2 shows the first data set of the sample input. To give the optimum placement for this problem, place the generators at the positions x = 20 and x = 80 as shown in the figure, and draw the wires at the positions shown in gray in the figure, respectively.\n\nExample of generator and wire placement (first dataset in input example).\n---\nFigure 2: Example of generator and wire placement (first dataset in input example).\n\n\n\nInput\n\nThe number of datasets t (0 <t \u2264 50) is given on the first line of the input.\n\nSubsequently, t datasets are given. Each dataset is given in two lines in the following format.\n\n\nn k\nx1 x2 ... xn\n\n\nn is the number of houses and k is the number of generators. x1, x2, ..., xn are one-dimensional coordinates that represent the position of the house, respectively. All of these values \u200b\u200bare integers and satisfy 0 <n \u2264 100000, 0 <k \u2264 100000, 0 \u2264 x1 <x2 <... <xn \u2264 1000000.\n\nIn addition, 90% of the dataset satisfies 0 <n \u2264 100, 0 <k \u2264 100.\n\nOutput\n\nFor each dataset, output the minimum total required wire length in one line.\n\nExample\n\nInput\n\n6\n5 2\n10 30 40 70 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50\n\n\nOutput\n\n60\n13\n0\n1000000\n0\n20", "solutions": ["def cr():\n\tNK = input().split()\n\tn = int(NK[0])\n\tk = int(NK[1])\n\tx = list(map(int, input().split()))\n\tdistance = []\n\tfor i in range(len(x) - 1):\n\t\tdistance.append(x[i + 1] - x[i])\n\tdistance.sort()\n\tif n > k:\n\t\tfor i in range(k - 1):\n\t\t\tdistance.pop()\n\t\tsum = 0\n\t\tfor i in range(n - k):\n\t\t\tsum += distance[i]\n\t\tprint(sum)\n\telse:\n\t\tprint(0)\nS = int(input())\nfor i in range(S):\n\tcr()\n", "t = int(input())\nfor _ in range(0, t):\n\t(n, k) = map(int, input().strip().split())\n\tx = list(map(int, input().split()))\n\ty = []\n\tfor i in range(1, n):\n\t\ty.append(x[i] - x[i - 1])\n\ty.sort()\n\tcount = 0\n\tif k < n:\n\t\tfor i in range(0, n - k):\n\t\t\tcount += y[i]\n\telse:\n\t\tcount = 0\n\tprint(count)\n", "N = int(input())\nfor i in range(N):\n\t(n, k) = map(int, input().split())\n\tL = list(map(int, input().split()))\n\tif n <= k:\n\t\tprint(0)\n\telse:\n\t\tA = []\n\t\tfor j in range(1, n):\n\t\t\tA.append(L[j] - L[j - 1])\n\t\tA.sort()\n\t\tA.reverse()\n\t\tS = L[n - 1] - L[0]\n\t\tfor l in range(k - 1):\n\t\t\tS -= A[l]\n\t\tprint(S)\n", "t = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\tX = list(map(int, input().split()))\n\tli = []\n\tfor j in range(n - 1):\n\t\tli.append(X[j + 1] - X[j])\n\tli.sort(reverse=True)\n\tprint(sum(li[k - 1:]))\n", "for t in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tX = list(map(int, input().split()))\n\tmid = [X[i] - X[i - 1] for i in range(1, n)]\n\tmid.sort()\n\tans = [0, sum(mid[:n - k])][k < n]\n\tprint(ans)\n", "t = int(input())\nfor count in range(t):\n\t(n, k) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\tdiff = []\n\tif n <= k:\n\t\tprint(0)\n\t\tcontinue\n\tfor i in range(n - 1):\n\t\tdiff.append(x[i + 1] - x[i])\n\tdiff.sort()\n\tans = 0\n\tfor i in range(max(0, n - k)):\n\t\tans += diff[i]\n\tprint(ans)\n", "t = int(input())\nfor i in range(t):\n\t(n, k) = [int(j) for j in input().split(' ')]\n\tx = [int(j) for j in input().split(' ')]\n\tif n <= k:\n\t\tprint(0)\n\telse:\n\t\tdistance = x[-1] - x[0]\n\t\tdis_list = []\n\t\tfor j in range(n - 1):\n\t\t\tdis_list.append(x[j + 1] - x[j])\n\t\tdis_list.sort()\n\t\tdis_list.reverse()\n\t\tfor j in range(k - 1):\n\t\t\tdistance -= dis_list[j]\n\t\tprint(distance)\n", "t = int(input())\nfor k in range(t):\n\t(n, k) = map(int, input().split())\n\thouse = list(map(int, input().split()))\n\tdiv = []\n\tfor i in range(n - 1):\n\t\tdiv.append(house[i + 1] - house[i])\n\tdiv.sort()\n\tanswer = sum(div[:n - k])\n\tif n > k:\n\t\tprint(answer)\n\telse:\n\t\tprint(0)\n", "def solve(X, N, K):\n\tif N <= K:\n\t\treturn 0\n\toutput = []\n\tfor i in range(1, N):\n\t\toutput.append(X[i] - X[i - 1])\n\toutput.sort(reverse=True)\n\tdel output[0:K - 1]\n\treturn sum(output)\nn = int(input())\nfor j in range(n):\n\t(N, K) = map(int, input().strip().split())\n\tX = list(map(int, input().strip().split()))\n\tif N == 0:\n\t\tbreak\n\tprint(solve(X, N, K))\n", "import sys\nfile_input = sys.stdin\nt = int(file_input.readline())\nfor i in range(t):\n\t(n, k) = map(int, file_input.readline().split())\n\tif n <= k:\n\t\tfile_input.readline()\n\t\tprint(0)\n\telse:\n\t\tx_list = list(map(int, file_input.readline().split()))\n\t\tdistance = [d2 - d1 for (d1, d2) in zip(x_list, x_list[1:])]\n\t\tif k == 1:\n\t\t\tprint(sum(distance))\n\t\telse:\n\t\t\tdistance.sort()\n\t\t\tprint(sum(distance[:1 - k]))\n", "import sys\nfrom sys import stdin\ninput = stdin.readline\n\ndef main(args):\n\tt = int(input())\n\tfor _ in range(t):\n\t\t(n, k) = map(int, input().split())\n\t\thouses = [int(x) for x in input().split()]\n\t\tif k >= n:\n\t\t\tprint(0)\n\t\t\tcontinue\n\t\tgaps = []\n\t\tprev = houses[0]\n\t\tfor (i, h) in enumerate(houses[1:]):\n\t\t\tgaps.append((h - prev, i))\n\t\t\tprev = h\n\t\tgaps.sort(reverse=True)\n\t\tgaps = gaps[:k - 1]\n\t\tcable_total = 0\n\t\tprev = 0\n\t\tfor (_, p) in gaps:\n\t\t\tcable_total += houses[p] - houses[prev]\n\t\t\tprev = p + 1\n\t\tif prev != n - 1:\n\t\t\tcable_total += houses[-1] - houses[prev]\n\t\tprint(cable_total)\nmain(sys.argv[1:])\n", "t = int(input())\nans = [0 for i in range(t)]\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\tli = list(map(int, input().split()))\n\tif n <= k:\n\t\tcontinue\n\tdis = []\n\tfor i in range(n - 1):\n\t\tdis.append(li[i + 1] - li[i])\n\tdis.sort()\n\tans[_] = sum(dis[:n - k])\nfor a in ans:\n\tprint(a)\n", "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\txs = list(map(int, input().split()))\n\trs = sorted([xs[i + 1] - xs[i] for i in range(n - 1)])\n\tif k >= n:\n\t\tprint(0)\n\telse:\n\t\tprint(sum(rs[:n - k]))\n", "c = int(input())\n\ndef solve(n, k, x):\n\tdiff = []\n\tfor i in range(n - 1):\n\t\tdiff.append(x[i + 1] - x[i])\n\tdiff.sort()\n\tans = x[-1] - x[0]\n\tfor i in range(min(k - 1, len(diff))):\n\t\tans -= diff.pop()\n\treturn print(ans)\nfor j in range(c):\n\t(n, k) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\tsolve(n, k, x)\n", "t = int(input())\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\txlst = list(map(int, input().split()))\n\tdiff = [j - i for (i, j) in zip(xlst, xlst[1:])]\n\tdiff.sort(reverse=True)\n\tprint(xlst[-1] - xlst[0] - sum(diff[:min(n - 1, k - 1)]))\n", "a = int(input())\nfor i in range(a):\n\t(n, k) = [int(j) for j in input().split()]\n\tx = [int(j) for j in input().split()]\n\tif n <= k:\n\t\tprint(0)\n\telse:\n\t\tdistance = x[-1] - x[0]\n\t\tdist_list = []\n\t\tfor j in range(n - 1):\n\t\t\tdist_list.append(x[j + 1] - x[j])\n\t\tdist_list.sort()\n\t\tdist_list.reverse()\n\t\tfor j in range(k - 1):\n\t\t\tdistance -= dist_list[j]\n\t\tprint(distance)\n", "t = int(input())\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\thouses = list(map(int, input().split()))\n\tif n <= k:\n\t\tprint(0)\n\t\tcontinue\n\tsa = [houses[i + 1] - houses[i] for i in range(n - 1)]\n\tsa.sort()\n\tres = houses[-1] - houses[0]\n\tfor i in range(k - 1):\n\t\tres -= sa.pop()\n\tprint(res)\n", "t = int(input())\nfor t in range(t):\n\t(N, K) = map(int, input().strip().split(' '))\n\tX = list(map(int, input().strip().split(' ')))\n\tL = [X[i + 1] - X[i] for i in range(0, N - 1)]\n\tL.sort()\n\ts = 0\n\tfor i in range(0, N - K):\n\t\ts = s + L[i]\n\tprint(s)\n", "T = int(input())\nfor i in range(T):\n\t(n, k) = map(int, input().strip().split(' '))\n\ta = list(input().split(' '))\n\tif n <= k:\n\t\tprint(0)\n\telse:\n\t\tfor m in range(len(a)):\n\t\t\ta[m] = int(a[m])\n\t\tb = []\n\t\tfor j in range(len(a) - 1):\n\t\t\tc = a[j + 1] - a[j]\n\t\t\tb.append(c)\n\t\tb.sort()\n\t\tanswer = sum(b)\n\t\tfor l in range(k - 1):\n\t\t\tanswer = answer - b[len(b) - l - 1]\n\t\tprint(answer)\n", "def cuntry(N, K, X):\n\tif N <= K:\n\t\treturn 0\n\tXX = []\n\tfor a in range(1, N):\n\t\tXX.append(X[a] - X[a - 1])\n\tXX.sort(reverse=True)\n\tdel XX[0:K - 1]\n\treturn sum(XX)\nn = int(input())\nfor j in range(n):\n\t(N, K) = map(int, input().strip().split())\n\tX = list(map(int, input().strip().split()))\n\tif N == 0:\n\t\tbreak\n\tprint(cuntry(N, K, X))\n", "t = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\txlist = list(map(int, input().split()))\n\tif n <= k:\n\t\tprint(0)\n\telse:\n\t\tbetweenx = [xlist[i + 1] - xlist[i] for i in range(n - 1)]\n\t\tbetweenx.sort()\n\t\tprint(sum(betweenx[:n - k]))\n", "import sys\nfrom sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\n\ndef main(args):\n\tt = int(input())\n\tfor _ in range(t):\n\t\t(n, k) = map(int, input().split())\n\t\thouses = [int(x) for x in input().split()]\n\t\tif k >= n:\n\t\t\tprint(0)\n\t\t\tcontinue\n\t\tdiff = []\n\t\tprev = houses[0]\n\t\tfor (i, h) in enumerate(houses[1:]):\n\t\t\tdiff.append((h - prev, i))\n\t\t\tprev = h\n\t\tdiff.sort(reverse=True)\n\t\tpoints = diff[:k - 1]\n\t\tcable_total = 0\n\t\tprev = 0\n\t\tfor (_, p) in points:\n\t\t\tcable_total += houses[p] - houses[prev]\n\t\t\tprev = p + 1\n\t\tif prev != n - 1:\n\t\t\tcable_total += houses[-1] - houses[prev]\n\t\tprint(cable_total)\nmain(sys.argv[1:])\n", "t = int(input())\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\tx = [int(y) for y in input().split()]\n\td = []\n\tfor i in range(n - 1):\n\t\td.append(x[i + 1] - x[i])\n\td.sort(reverse=True)\n\tans = x[n - 1] - x[0] - sum(d[:k - 1])\n\tprint(ans)\n", "for _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tc = list(map(int, input().split()))\n\tc = sorted([c[i + 1] - c[i] for i in range(a - 1)])\n\tprint([0, sum(c[:a - b])][b < a])\n", "trial = int(input())\nfor t in range(trial):\n\t(housecnt, elec) = (int(n) for n in input().split(' '))\n\thouse = [int(n) for n in input().split(' ')]\n\tmaxlist = []\n\tfor h in range(housecnt - 1):\n\t\tmaxlist.append(house[h + 1] - house[h])\n\tmaxlist.sort()\n\tfor p in range(min(housecnt - 1, elec - 1)):\n\t\tmaxlist.pop()\n\tprint(sum(maxlist))\n", "t = int(input())\nfor j in range(t):\n\t(n, k) = map(int, input().split())\n\tl = list(map(int, input().split()))\n\tl1 = []\n\tfor i in range(n - 1):\n\t\tl1.append(l[i + 1] - l[i])\n\tl1 = sorted(l1)\n\tif n <= k:\n\t\tprint(0)\n\telse:\n\t\tfor i in range(k - 1):\n\t\t\tdel l1[-1]\n\t\ts = 0\n\t\tfor i in l1:\n\t\t\ts += i\n\t\tprint(s)\n", "def croad():\n\t(n, k) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\ty = []\n\tfor i in range(n - 1):\n\t\ty.append(x[i + 1] - x[i])\n\ty.sort()\n\ty.reverse()\n\twhile k > 1 and len(y) > 0:\n\t\ty.pop(0)\n\t\tk -= 1\n\tprint(sum(y))\na = int(input())\nfor i in range(a):\n\tcroad()\n", "def f(n, k, x):\n\tif n <= k - 1:\n\t\treturn 0\n\tdis = [x[i + 1] - x[i] for i in range(n - 1)]\n\tdis.sort()\n\treturn sum(dis[:n - k])\nt = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\tprint(f(n, k, x))\n", "for i in range(int(input())):\n\t(t, k) = map(int, input().split())\n\td = list(map(int, input().split()))\n\td = sorted([d[i + 1] - d[i] for i in range(t - 1)])\n\tprint(sum(d[:t - k]) if t > k else 0)\n", "t = int(input())\nfor t in range(t):\n\t(N, K) = map(int, input().strip().split(' '))\n\tX = list(map(int, input().strip().split(' ')))\n\tL = [X[i + 1] - X[i] for i in range(0, N - 1)]\n\tL.sort()\n\ts = 0\n\tfor i in range(0, N - K):\n\t\ts = s + L[i]\n\tprint(s)\n", "def solve(n, k, x):\n\td = [x[i + 1] - x[i] for i in range(n - 1)]\n\td.sort(key=lambda e: -e)\n\tif k >= n:\n\t\ts = 0\n\telse:\n\t\ts = sum(d[k - 1:n])\n\treturn s\nhoge = int(input())\nfor j in range(hoge):\n\t(n, k) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\tprint(solve(n, k, x))\n", "q = int(input())\nfor i in range(q):\n\t(n, k) = map(int, input().split())\n\ts = list(map(int, input().split()))\n\tsa = [0]\n\tfor j in range(1, n):\n\t\tsa.append(s[j] - s[j - 1])\n\tsa.sort(reverse=True)\n\tprint(sum(sa[k - 1:]))\n", "t = int(input())\nfor i in range(t):\n\t(N, K) = map(int, input().split())\n\tX = list(map(int, input().strip().split()))\n\ta = [0]\n\tfor j in range(N - 1):\n\t\ta.append(X[j + 1] - X[j])\n\tb = sorted(a, reverse=True)\n\tif K > 1:\n\t\tdel b[0:K - 1]\n\tprint(sum(b))\n", "n = int(input())\nfor i in range(n):\n\t(houseNum, genNum) = map(int, input().split())\n\tlocation = list(map(int, input().split()))\n\tdistance = []\n\tfor j in range(1, houseNum):\n\t\tdistance.append(location[j] - location[j - 1])\n\tdistance.sort(reverse=True)\n\tprint(location[-1] - location[0] - sum(distance[:genNum - 1]))\n", "t = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\tposition_array = list(map(int, input().split()))\n\tdistance_array = []\n\tfor j in range(n - 1):\n\t\tdistance_array.append(position_array[j + 1] - position_array[j])\n\tdistance_array.sort(reverse=True)\n\tprint(sum(distance_array[k - 1:]))\n"], "public_test_cases": [{"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n20\n", "type": "stdin"}], "test_cases": [{"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "60\n12\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 3 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n13\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "51\n12\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "-5\n12\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 5\n0 10 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n10\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 33 40 50", "output": "51\n12\n0\n1000000\n0\n17\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "-5\n12\n0\n999999\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 31 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 5\n0 10 20 30 40 50", "output": "60\n-1\n0\n1000000\n0\n10\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 8 10 17 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "-5\n13\n0\n999999\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 5\n0 10 20 30 40 50", "output": "60\n-23\n0\n1000000\n0\n10\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n10 70 211\n6 4\n0 10 20 30 24 50", "output": "60\n13\n0\n1000000\n0\n4\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 5\n0 10 20 30 40 50", "output": "60\n-23\n0\n1000001\n0\n10\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 24 50", "output": "60\n13\n0\n1000000\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 5\n0 10 20 8 40 50", "output": "60\n-23\n0\n1000001\n0\n-12\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 24 50", "output": "60\n13\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 33 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 29 50", "output": "60\n-3\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 95 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "35\n13\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n1 10 20 30 40 50", "output": "60\n12\n0\n1000000\n0\n19\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 4\n0 10 20 10 40 50", "output": "60\n12\n0\n1000000\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1001000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "60\n13\n0\n1001000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 8 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n20 70 211\n6 4\n0 10 20 30 40 50", "output": "60\n7\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 6 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n16\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n0 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "51\n15\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 5\n0 10 20 30 40 37", "output": "60\n13\n0\n1000000\n0\n-3\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 16 30 40 50", "output": "-5\n12\n0\n999999\n0\n16\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 31 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 5\n0 18 20 30 40 50", "output": "60\n-1\n0\n1000000\n0\n2\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 8 10 9 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "-5\n8\n0\n999999\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 5\n0 10 22 30 40 50", "output": "60\n-23\n0\n1000000\n0\n8\n", "type": "stdin"}, {"input": "6\n5 1\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 5\n0 10 20 30 40 50", "output": "90\n-23\n0\n1000001\n0\n10\n", "type": "stdin"}, {"input": "6\n5 1\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 24 50", "output": "90\n13\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 95 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 33 50", "output": "35\n13\n0\n1000000\n0\n13\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 13 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n1 10 20 30 40 50", "output": "33\n12\n0\n1000000\n0\n19\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 0000000\n3 5\n30 70 211\n6 4\n0 10 20 10 40 50", "output": "60\n12\n0\n0\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1001000\n3 5\n30 70 211\n6 4\n0 10 20 6 40 50", "output": "60\n13\n0\n1001000\n0\n-4\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n0 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 21", "output": "51\n15\n0\n1000000\n0\n-9\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 110\n7 3\n3 12 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 69\n6 4\n0 3 20 30 40 50", "output": "60\n9\n0\n1000000\n0\n13\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 46 135 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 16 30 40 50", "output": "1\n12\n0\n999999\n0\n16\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n15 70 211\n6 4\n0 7 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n17\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 8 10 15 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "-5\n14\n0\n999999\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n0 1000010\n3 5\n30 70 211\n6 5\n0 10 22 30 40 50", "output": "60\n-23\n0\n1000010\n0\n8\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 26 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 4\n0 10 20 30 24 50", "output": "60\n13\n0\n1000001\n0\n4\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 5\n0 18 5 8 40 50", "output": "60\n-23\n0\n1000001\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 1\n10 30 40 70 100\n7 3\n3 0 10 17 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 24 50", "output": "90\n8\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 8 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 29 36", "output": "60\n-2\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 2\n3 7 10 33 21 26 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 29 50", "output": "60\n2\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 33 25 43 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 56 29 25", "output": "60\n-16\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 4 10 17 21 26 33\n1 1\n100\n2 1\n0 0000000\n3 5\n30 70 211\n6 4\n0 10 20 10 40 50", "output": "60\n16\n0\n0\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 6 40 70 100\n7 3\n3 8 10 8 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n20 70 211\n6 4\n0 10 20 30 40 50", "output": "56\n7\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n0 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 2\n0 10 20 30 40 21", "output": "51\n15\n0\n1000000\n0\n11\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 46 135 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n1 1000000\n3 5\n30 70 211\n6 4\n0 10 17 30 40 50", "output": "1\n12\n0\n999999\n0\n17\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 31 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 4\n30 70 211\n6 5\n0 18 16 30 40 50", "output": "60\n-1\n0\n1000000\n0\n-2\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 8\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 5\n0 18 5 8 40 50", "output": "60\n-43\n0\n1000001\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 6\n3 5 10 17 21 8 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 29 36", "output": "60\n-13\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 33 25 43 28\n1 1\n100\n2 1\n0 1000000\n3 5\n10 70 211\n6 7\n0 10 20 56 29 25", "output": "60\n-16\n0\n1000000\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n1 30 40 70 100\n7 3\n3 4 10 17 21 26 33\n1 1\n100\n2 1\n0 0000000\n3 5\n30 70 211\n6 4\n0 10 20 10 40 50", "output": "69\n16\n0\n0\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 18 17 21 26 28\n1 1\n100\n2 1\n0 1001000\n3 5\n30 70 211\n6 4\n0 10 20 6 40 95", "output": "60\n7\n0\n1001000\n0\n-4\n", "type": "stdin"}, {"input": "6\n5 3\n10 30 40 70 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 86 180\n6 4\n0 6 20 30 40 50", "output": "30\n13\n0\n1000000\n0\n16\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 26 46\n1 1\n101\n2 1\n0 1000000\n3 5\n30 011 211\n6 4\n0 10 20 30 40 50", "output": "-5\n16\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 110\n7 3\n3 12 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 8\n30 70 69\n6 4\n0 0 20 30 40 50", "output": "60\n9\n0\n1000000\n0\n10\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 53 21 26 8\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 9\n0 18 5 8 40 50", "output": "60\n-43\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 2\n3 7 10 33 21 26 47\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 29 50", "output": "60\n21\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 15 40 95 100\n7 3\n3 6 10 27 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 156\n6 4\n0 10 20 30 33 50", "output": "35\n3\n0\n1000000\n0\n13\n", "type": "stdin"}, {"input": "6\n5 2\n4 30 13 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n25 70 150\n6 4\n1 10 20 30 40 50", "output": "39\n12\n0\n1000000\n0\n19\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 16 46\n1 1\n101\n2 1\n0 1000000\n3 5\n30 011 211\n6 4\n0 10 20 30 40 50", "output": "-5\n6\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 110\n7 3\n3 12 10 17 21 26 28\n1 1\n100\n2 1\n0 1010000\n3 8\n30 70 69\n6 4\n0 0 20 30 40 50", "output": "60\n9\n0\n1010000\n0\n10\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 10 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 4\n0 10 20 23 24 71", "output": "60\n8\n0\n1000001\n0\n4\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 5\n3 5 10 17 21 8 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 20 30 51 36", "output": "60\n-11\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n3 5 10 33 25 43 28\n1 1\n100\n2 1\n0 1000000\n3 5\n10 70 211\n6 7\n0 10 20 56 29 5", "output": "51\n-16\n0\n1000000\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 18 17 21 26 28\n1 1\n100\n2 1\n1 1001000\n3 5\n30 70 211\n6 4\n0 10 20 6 40 64", "output": "60\n7\n0\n1000999\n0\n-4\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 16 46\n1 1\n101\n2 1\n0 1000000\n3 5\n30 011 211\n6 8\n0 10 20 30 40 50", "output": "-5\n6\n0\n1000000\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 110\n7 3\n3 12 10 17 21 26 28\n1 1\n100\n2 1\n0 1010000\n3 8\n30 70 69\n6 4\n0 0 20 7 40 50", "output": "60\n9\n0\n1010000\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 5 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 4\n0 10 20 23 24 71", "output": "60\n1\n0\n1000001\n0\n4\n", "type": "stdin"}, {"input": "6\n5 2\n10 24 40 129 100\n7 3\n3 5 10 53 21 26 8\n1 1\n100\n2 1\n-1 1000000\n3 5\n30 70 211\n6 9\n0 18 5 8 40 50", "output": "1\n-43\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n13 30 40 70 100\n7 3\n3 5 10 33 25 43 28\n1 1\n100\n2 1\n0 1000000\n3 5\n10 70 211\n6 7\n0 10 20 56 29 5", "output": "57\n-16\n0\n1000000\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 15 40 95 110\n7 3\n3 6 10 27 21 26 28\n1 1\n110\n2 1\n0 1000000\n3 5\n30 70 156\n6 4\n0 10 20 30 33 50", "output": "45\n3\n0\n1000000\n0\n13\n", "type": "stdin"}, {"input": "6\n5 2\n1 30 40 70 100\n7 3\n3 4 10 17 28 26 33\n1 2\n101\n2 1\n0 0000000\n3 5\n30 70 211\n6 4\n0 10 20 10 40 50", "output": "69\n12\n0\n0\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 135 100\n7 3\n3 4 10 17 21 16 46\n1 1\n101\n2 1\n0 1000100\n3 5\n30 011 211\n6 8\n0 10 20 30 40 50", "output": "-5\n6\n0\n1000100\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 110\n7 3\n3 12 10 2 21 26 28\n1 1\n100\n2 1\n0 1010000\n3 8\n30 70 69\n6 4\n0 0 20 7 40 50", "output": "60\n-3\n0\n1010000\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 5\n3 5 10 17 42 8 28\n1 1\n100\n2 1\n-1 1000000\n3 5\n10 70 211\n6 7\n0 10 39 30 51 36", "output": "60\n-32\n0\n1000001\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n2 30 40 135 100\n7 3\n3 4 10 17 21 16 46\n1 1\n101\n2 1\n0 1000100\n3 5\n30 011 211\n6 8\n0 10 20 30 40 50", "output": "3\n6\n0\n1000100\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n1 30 40 70 100\n7 3\n3 4 10 20 28 26 46\n1 2\n101\n2 1\n0 0000000\n3 5\n30 70 211\n6 4\n0 10 20 10 40 50", "output": "69\n13\n0\n0\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n2 30 40 135 100\n7 5\n3 4 10 17 21 16 46\n1 1\n101\n2 1\n0 1000100\n3 5\n30 011 211\n6 8\n0 10 20 30 40 50", "output": "3\n-4\n0\n1000100\n0\n0\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 18 100\n7 3\n3 5 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 218\n6 4\n0 10 20 23 24 71", "output": "8\n1\n0\n1000001\n0\n4\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 18 100\n7 3\n3 5 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 218\n6 4\n0 10 20 6 24 71", "output": "8\n1\n0\n1000001\n0\n-4\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 69 70 110\n7 3\n3 7 10 2 21 26 28\n1 1\n100\n2 1\n0 1010000\n3 5\n30 70 37\n6 4\n0 0 20 7 40 50", "output": "60\n1\n0\n1010000\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 5 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 218\n6 4\n0 10 20 6 24 71", "output": "7\n1\n0\n1000001\n0\n-4\n", "type": "stdin"}, {"input": "6\n5 2\n1 30 40 70 100\n7 3\n3 4 10 20 28 26 46\n1 2\n101\n2 1\n0 0000000\n3 5\n30 56 146\n6 4\n0 17 20 10 40 50", "output": "69\n13\n0\n0\n0\n-7\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 5 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 5\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n1\n0\n1000001\n0\n1\n", "type": "stdin"}, {"input": "6\n5 2\n1 30 40 70 100\n7 3\n3 4 10 20 28 26 46\n1 2\n101\n2 1\n0 0000000\n3 1\n30 56 146\n6 4\n0 17 20 10 40 50", "output": "69\n13\n0\n0\n116\n-7\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 69 70 110\n7 3\n3 7 10 2 21 26 28\n1 1\n100\n2 1\n-1 1010000\n3 5\n30 70 37\n6 4\n0 0 20 7 40 84", "output": "60\n1\n0\n1010001\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 5 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 1\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n1\n0\n1000001\n208\n1\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 1 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 1\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n-3\n0\n1000001\n208\n1\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 2 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 1\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n-2\n0\n1000001\n208\n1\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 0 19 17 21 31 28\n1 2\n100\n2 1\n-1 1000000\n3 1\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n-4\n0\n1000001\n208\n1\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 3\n3 0 19 17 31 31 28\n1 2\n100\n2 1\n-1 1000000\n3 1\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n-8\n0\n1000001\n208\n1\n", "type": "stdin"}, {"input": "6\n5 2\n11 30 40 18 100\n7 1\n3 0 19 17 31 31 28\n1 2\n100\n2 1\n-1 1000000\n3 1\n10 70 218\n6 4\n0 10 20 11 24 71", "output": "7\n25\n0\n1000001\n208\n1\n", "type": "stdin"}, {"input": "6\n5 2\n0 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "70\n12\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 95 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 211\n6 4\n0 10 20 30 40 50", "output": "35\n12\n0\n1000000\n0\n20\n", "type": "stdin"}, {"input": "6\n5 2\n19 30 40 70 100\n7 3\n3 4 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 73 50", "output": "51\n12\n0\n1000000\n0\n-13\n", "type": "stdin"}, {"input": "6\n5 2\n10 30 40 70 100\n7 3\n3 6 10 17 21 26 28\n1 1\n100\n2 1\n0 1000000\n3 5\n30 70 150\n6 4\n0 10 20 30 40 50", "output": "60\n13\n0\n1000000\n0\n20", "type": "stdin"}], "problem_id": "taco_train_548", "metadata": {"config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 101}, "generated_solutions": []}
{"problem": "Nicholas has an array a that contains n distinct integers from 1 to n. In other words, Nicholas has a permutation of size n.\n\nNicholas want the minimum element (integer 1) and the maximum element (integer n) to be as far as possible from each other. He wants to perform exactly one swap in order to maximize the distance between the minimum and the maximum elements. The distance between two elements is considered to be equal to the absolute difference between their positions.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 \u2264 n \u2264 100)\u00a0\u2014 the size of the permutation.\n\nThe second line of the input contains n distinct integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 n), where a_{i} is equal to the element at the i-th position.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the maximum possible distance between the minimum and the maximum elements Nicholas can achieve by performing exactly one swap.\n\n\n-----Examples-----\nInput\n5\n4 5 1 3 2\n\nOutput\n3\n\nInput\n7\n1 6 5 3 4 7 2\n\nOutput\n6\n\nInput\n6\n6 5 4 3 2 1\n\nOutput\n5\n\n\n\n-----Note-----\n\nIn the first sample, one may obtain the optimal answer by swapping elements 1 and 2.\n\nIn the second sample, the minimum and the maximum elements will be located in the opposite ends of the array if we swap 7 and 2.\n\nIn the third sample, the distance between the minimum and the maximum elements is already maximum possible, so we just perform some unnecessary swap, for example, one can swap 5 and 2.", "solutions": ["N = int(input(''))\nLine2 = input('')\nArray = list(map(int, Line2.split(' ')))\nmin_elem_index = Array.index(min(Array))\nmax_elem_index = Array.index(max(Array))\nmin_index = 0\nmax_index = N - 1\nL_inv1 = abs(min_elem_index - min_index)\nR_inv1 = abs(max_index - min_elem_index)\nans1 = 0\nif L_inv1 >= R_inv1:\n\tans1 = L_inv1\nelif L_inv1 < R_inv1:\n\tans1 = R_inv1\nans2 = 0\nL_inv2 = abs(max_elem_index - min_index)\nR_inv2 = abs(max_index - max_elem_index)\nif L_inv2 >= R_inv2:\n\tans2 = L_inv2\nelif L_inv2 < R_inv2:\n\tans2 = R_inv2\nif ans1 >= ans2:\n\tprint(ans1)\nelif ans1 < ans2:\n\tprint(ans2)\n", "n = int(input().strip())\nll = list(map(int, input().split()))\nminn = min(ll)\nmaxx = max(ll)\nfor i in range(n):\n\tif ll[i] == minn:\n\t\tminn1 = i + 1\n\telif ll[i] == maxx:\n\t\tmaxx1 = i + 1\nprint(max(abs(1 - minn1), abs(n - minn1), abs(1 - maxx1), abs(n - maxx1)))\n", "n = int(input())\nl = list(map(int, input().split()))\np1 = 0\np2 = 0\nma = 0\nmi = 10000000\nfor i in range(n):\n\tif mi > l[i]:\n\t\tmi = l[i]\n\t\tp1 = i\n\tif ma < l[i]:\n\t\tma = l[i]\n\t\tp2 = i\nif p1 > p2:\n\tif n - p2 - 1 > p1:\n\t\tprint(n - p2 - 1)\n\telse:\n\t\tprint(p1)\nelif n - p1 - 1 > p2:\n\tprint(n - p1 - 1)\nelse:\n\tprint(p2)\n", "n = int(input())\nt = list(map(int, input().split()))\nmx = max(t)\nmi = min(t)\na = t.index(mx)\nb = t.index(mi)\nprint(max(abs(n - 1 - a), abs(n - 1 - b), abs(0 - a), abs(0 - b)))\n", "n = int(input())\nl = list(map(int, input().split()))\nprint(max(abs(1 - (l.index(n) + 1)), abs(n - (l.index(n) + 1)), abs(n - (l.index(1) + 1)), abs(1 - (l.index(1) + 1))))\n", "n = int(input())\nl = list(map(int, input().split()))\nind1 = l.index(1)\nindn = l.index(n)\nprint(max(ind1, indn, n - ind1 - 1, n - 1 - indn))\n", "n = int(input())\na = list(map(int, input().split()))\nt1 = a.index(1)\nt2 = max(abs(t1 - n + 1), abs(t1))\nt3 = a.index(n)\nt4 = max(abs(t3 - n + 1), abs(t3))\nprint(max(t2, t4))\n", "n = int(input())\nA = list(map(int, input().split()))\nfor i in range(n):\n\tif A[i] == 1:\n\t\tposMin = i\n\tif A[i] == n:\n\t\tposMax = i\nif posMin > posMax:\n\t(posMin, posMax) = (posMax, posMin)\nprint(max(posMax, n - posMin - 1))\n", "n = int(input())\na = list(map(int, input().split()))\nidx = a.index(min(a))\njdx = a.index(max(a))\nprint(max(max(jdx, n - 1 - jdx), max(idx, n - 1 - idx)))\n", "n = int(input())\na = list(map(int, input().split()))\nminIndex = a.index(1)\nmaxIndex = a.index(n)\nprint(max(minIndex, n - 1 - minIndex, maxIndex, n - 1 - maxIndex))\n", "n = int(input().strip())\narr = list(map(int, input().strip().split()))\nminInd = arr.index(min(arr))\nmaxInd = arr.index(max(arr))\nprint(max(max(minInd, maxInd), n - min(minInd, maxInd) - 1))\n", "n = int(input())\na = list(map(int, input().split()))\nx = a.index(min(a))\ny = a.index(max(a))\nprint(max(x, y, n - x - 1, n - y - 1))\n", "n = int(input())\ns = input()\nA = []\nfor i in s.split():\n\tA.append(int(i))\na = A.index(min(A)) + 1\nb = A.index(max(A)) + 1\nif abs((n + 1) / 2 - a) >= abs((n + 1) / 2 - b):\n\tif a > (n + 1) / 2:\n\t\tprint(a - 1)\n\telse:\n\t\tprint(n - a)\nelif b > (n + 1) / 2:\n\tprint(b - 1)\nelse:\n\tprint(n - b)\n", "Input = lambda : map(int, input().split())\nn = int(input())\nl = list(Input())\nif l[0] in [1, n] or l[n - 1] in [1, n]:\n\tprint(n - 1)\nelse:\n\ti = l.index(1)\n\tj = l.index(n)\n\tif i < j:\n\t\tprint(max(n - 1 - i, j))\n\telse:\n\t\tprint(max(n - 1 - j, i))\n", "n = int(input())\na = [int(x) for x in input().split()]\npos1 = 0\npos2 = 0\nfor i in range(n):\n\tif a[i] == 1 or a[i] == n:\n\t\tpos1 = i\n\t\tbreak\nfor i in range(pos1 + 1, n):\n\tif a[i] == 1 or a[i] == n:\n\t\tpos2 = i\n\t\tbreak\nprint(pos2 - pos1 + max(n - pos2 - 1, pos1))\n", "def solve(n, data):\n\tfor i in range(n):\n\t\tif data[i] == n:\n\t\t\tb2 = i + 1\n\t\tif data[i] == 1:\n\t\t\tb1 = i + 1\n\tres = max(n - b2, n - b1, b1 - 1, b2 - 1)\n\treturn res\nn = int(input())\ndata = [int(x) for x in input().split()]\nprint(solve(n, data))\n", "from __future__ import print_function\nfrom __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nimport math\nimport string\nimport itertools\nimport fractions\nimport heapq\nimport collections\nimport re\nimport array\nimport bisect\n\ndef array2d(d1, d2, init=None):\n\treturn [[init for _ in range(d1)] for _ in range(d2)]\nn = int(input())\nal = list(map(int, input().split(' ')))\nind_1 = al.index(1)\nind_n = al.index(n)\nmd = (n - 1) / 2.0\nd1 = abs(ind_1 - md)\ndn = abs(ind_n - md)\nif d1 > dn:\n\tprint(max(ind_1, n - ind_1 - 1))\nelse:\n\tprint(max(ind_n, n - ind_n - 1))\n", "n = int(input())\nx = [int(y) for y in input().split()]\nocc = []\nfor i in range(n):\n\tif x[i] == 1 or x[i] == n:\n\t\tocc.append(i)\n\tif len(occ) == 2:\n\t\tbreak\nprint(max([occ[0], occ[1], n - occ[0] - 1, n - occ[1] - 1]))\n", "n = int(input())\nx = list(map(int, input().split()))\na = x.index(1)\nb = x.index(n)\nprint(max(abs(a - b), b, a, n - 1 - b, n - 1 - a))\n", "n = int(input())\n\ndef maxi(a, b, c, d):\n\tx = max(a, b)\n\ty = max(c, d)\n\treturn max(x, y)\na = [int(i) for i in input().split()]\np = a.index(min(a))\nq = a.index(max(a))\nprint(maxi(abs(p - 0), abs(p - (n - 1)), abs(q - 0), abs(q - (n - 1))))\n", "n = input()\na = input()\na = a.split()\nlow = int()\nhigh = int()\nfor i in range(int(n)):\n\tif a[i] == '1':\n\t\tlow = i + 1\n\tif a[i] == n:\n\t\thigh = i + 1\nif low < high:\n\tif low - 1 <= int(n) - high:\n\t\tprint(int(n) - low)\n\telse:\n\t\tprint(high - 1)\nelif high - 1 <= int(n) - low:\n\tprint(int(n) - high)\nelse:\n\tprint(low - 1)\n", "n = int(input())\na = list(map(int, input().split()))\nidx1 = a.index(1)\nidxN = a.index(n)\nif idxN - idx1 > 0:\n\tif n - 1 - idxN > idx1 - 0:\n\t\tans = n - 1 - idx1\n\telse:\n\t\tans = idxN\nelif n - 1 - idx1 > idxN - 0:\n\tans = n - 1 - idxN\nelse:\n\tans = idx1\nprint(ans)\n", "from sys import stdin\nn = int(input())\narr = list(map(int, stdin.readline().split()))\nlow = min(arr)\nbig = max(arr)\nlindex = arr.index(low)\nbindex = arr.index(big)\nif lindex == 0 or lindex == n - 1 or bindex == 0 or (bindex == n - 1):\n\tprint(n - 1)\nelif lindex < bindex:\n\ta = bindex\n\tb = n - 1 - lindex\n\tprint(max(a, b))\nelse:\n\ta = lindex\n\tb = n - 1 - bindex\n\tprint(max(a, b))\n", "def nicholas(a):\n\tmin_ele = 1000\n\tmax_ele = -1\n\tfor i in range(len(a)):\n\t\tif a[i] < min_ele:\n\t\t\tmin_ele = a[i]\n\t\t\tmin_pos = i\n\tfor i in range(len(a)):\n\t\tif a[i] > max_ele:\n\t\t\tmax_ele = a[i]\n\t\t\tmax_pos = i\n\tif min_pos == len(a) - 1 or max_pos == len(a) - 1 or min_pos == 0 or (max_pos == len(a) - 1):\n\t\tdist = len(a) - 1\n\t\tprint(dist)\n\t\treturn\n\telse:\n\t\tdist = abs(min_pos - max_pos) + max(min(min_pos, max_pos), len(a) - 1 - max(min_pos, max_pos))\n\t\tprint(dist)\n\t\treturn\nn = int(input(''))\na = list(map(int, input('').split()))\nnicholas(a)\n", "def dist(l):\n\treturn abs(l.index(1) - l.index(len(l)))\nn = int(input())\nl = list(map(int, input().split()))\none_ind = l.index(1)\nn_ind = l.index(n)\nd = dist(l)\nfor x in [one_ind, n_ind]:\n\t(l[x], l[0]) = (l[0], l[x])\n\td = max(d, dist(l))\n\t(l[x], l[0]) = (l[0], l[x])\n\t(l[x], l[-1]) = (l[-1], l[x])\n\td = max(d, dist(l))\n\t(l[x], l[-1]) = (l[-1], l[x])\nprint(d)\n", "n = int(input())\na = list(map(int, input().split()))\npos_1 = None\npos_N = None\nfor (i, e) in enumerate(a):\n\tif e == 1:\n\t\tpos_1 = i\n\tif e == n:\n\t\tpos_N = i\np = []\np.append([0, pos_1])\np.append([0, pos_N])\np.append([pos_1, n - 1])\np.append([pos_N, n - 1])\nansw = max(map(lambda e: abs(e[0] - e[1]), p))\nprint(answ)\n", "n = int(input())\na = list(map(int, input().split()))\nx = 0\ny = n - 1\nfor i in range(n):\n\tif a[i] == 1:\n\t\tx = i\n\tif a[i] == n:\n\t\ty = i\nold = abs(x - y)\nif n == 2:\n\tprint(1)\nelse:\n\tprint(max(old, x, n - 1 - x, y, n - 1 - y))\n", "n = int(input())\nl = [int(i) for i in input().split()]\nz = l.index(1)\nz1 = l.index(n)\nprint(max(z, z1, n - z - 1, n - z1 - 1))\n", "def nicholas():\n\tn = int(input())\n\ta = list(map(int, input().split()[0:n]))\n\tpos1 = a.index(1)\n\tposn = a.index(n)\n\tvmax = abs(posn - pos1)\n\tn = n - 1\n\tif vmax < abs(posn - 0):\n\t\tvmax = abs(posn - 0)\n\tif vmax < abs(posn - n):\n\t\tvmax = abs(posn - n)\n\tif vmax < abs(pos1 - 0):\n\t\tvmax = abs(pos1 - 0)\n\tif vmax < abs(pos1 - n):\n\t\tvmax = abs(pos1 - n)\n\treturn vmax\nprint(nicholas())\n", "n = int(input())\na = [int(x) for x in input().split()]\nminIndex = a.index(1)\nmaxIndex = a.index(n)\nif minIndex < maxIndex:\n\tprint(max(maxIndex, n - 1 - minIndex))\nelse:\n\tprint(max(minIndex, n - 1 - maxIndex))\n", "n = int(input())\nl = list(map(int, input().split()))\ni1 = l.index(min(l))\ni2 = l.index(max(l))\nprint(max(n - 1 - min(i1, i2), max(i1, i2)))\n", "n = int(input())\nl = list(map(int, input().split()))\na = min(l.index(max(l)), l.index(min(l)))\nb = min(l[::-1].index(max(l)), l[::-1].index(min(l)))\nprint(n - min(a, b) - 1)\n", "n = int(input())\narr = list(map(int, input().split()))\ndist1 = distn = 0\nfor i in range(n):\n\tif arr[i] == 1:\n\t\tdist1 = i\n\tif arr[i] == n:\n\t\tdistn = i\nif dist1 == 0 or dist1 == n - 1:\n\tprint(n - 1)\nelif distn == 0 or distn == n - 1:\n\tprint(n - 1)\nelse:\n\taux = n / 2\n\tif dist1 > aux:\n\t\tdist1 = n - dist1 - 1\n\tif distn > aux:\n\t\tdistn = n - distn - 1\n\tprint(n - 1 - min(distn, dist1))\n", "from sys import *\ninp = lambda : stdin.readline()\n\ndef main():\n\tn = int(inp())\n\t(a, b) = (0, 0)\n\tl = [int(i) for i in inp().split()]\n\tfor i in range(len(l)):\n\t\tif l[i] == 1:\n\t\t\ta = i\n\t\tif l[i] == n:\n\t\t\tb = i\n\tif a > b:\n\t\t(a, b) = (b, a)\n\tans = max(n - 1 - a, b)\n\tprint(ans)\nmain()\n", "n = int(input())\narray = [i for i in map(int, input().split())]\nif array[0] == 1 or array[0] == n or array[n - 1] == 1 or (array[n - 1] == n):\n\tprint(n - 1)\nelse:\n\ti = 1\n\twhile i < n - 3:\n\t\tif array[i] == 1 or array[i] == n:\n\t\t\ti_num = i\n\t\t\tbreak\n\t\telse:\n\t\t\ti += 1\n\tj = n - 2\n\twhile j > 1:\n\t\tif array[j] == 1 or array[j] == n:\n\t\t\tj_num = j\n\t\t\tbreak\n\t\telse:\n\t\t\tj -= 1\n\tprint(max(i, j, n - 1 - i, n - 1 - j))\n", "n = int(input())\na = list(map(int, input().split()))\nimax = 0\nimin = 0\nvmax = 0\nvmin = 100001\nfor i in range(n):\n\tif vmax < a[i]:\n\t\tvmax = a[i]\n\t\timax = i\n\tif vmin > a[i]:\n\t\tvmin = a[i]\n\t\timin = i\nmi = min(imax, imin)\nma = max(imax, imin)\nres = max(n - 1 - mi, ma)\nprint(res)\n", "n = int(input())\nl = list(map(int, input().split()))\nif abs(l.index(min(l)) - l.index(max(l))) == n - 1:\n\tprint(n - 1)\nelse:\n\tma = l.index(max(l))\n\tmi = l.index(min(l))\n\tprint(max(max(abs(mi - 0), abs(mi - n + 1)), max(abs(ma - 0), abs(ma - n + 1))))\n", "n = int(input())\nlist = [int(i) for i in input().split()]\na = list.index(min(list))\nb = n - 1 - list.index(min(list))\nc = list.index(max(list))\nd = n - 1 - list.index(max(list))\nprint(max(a, b, c, d))\n", "n = int(input())\nl = list(map(int, input().split()))\npos_n = l.index(n)\npos_1 = l.index(1)\nif pos_n - pos_1 == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(n - 1 - min(pos_1, pos_n), max(pos_1, pos_n)))\n", "n = int(input())\nrow = input().split()\nidx = 0\nfor i in row:\n\trow[idx] = int(i)\n\tidx += 1\nidxmax = row.index(max(row)) + 1\nidxmin = row.index(min(row)) + 1\nif idxmax > idxmin:\n\tif n - idxmax >= idxmin:\n\t\tprint(n - idxmin)\n\telse:\n\t\tprint(idxmax - 1)\nelif n - idxmin >= idxmax:\n\tprint(n - idxmax)\nelse:\n\tprint(idxmin - 1)\n", "import math\nn = int(input())\na = [int(i) for i in input().split()]\na1 = max(a)\na2 = min(a)\nfor i in range(n):\n\tif a[i] == a1:\n\t\tmax = i\n\tif a[i] == a2:\n\t\tmin = i\nd = []\ns = math.fabs(max - (n - 1))\ns = int(s)\nd.append(s)\ns = math.fabs(min - (n - 1))\ns = int(s)\nd.append(s)\nd.append(max)\nd.append(min)\nmin = d[0]\nfor i in range(len(d)):\n\tif d[i] > min:\n\t\tmin = d[i]\nprint(min)\n", "import sys\ninput = sys.stdin.readline\nn = int(input())\na = [int(i) for i in input().split()]\n(x, y) = (a.index(1), a.index(n))\nans = max(x, y, n - x - 1, n - y - 1)\nprint(ans)\n", "N = int(input())\nA = [int(a) for a in input().split()]\npos = [-1, -1]\nfor i in range(N):\n\tif A[i] == 1:\n\t\tpos[0] = i\n\telif A[i] == N:\n\t\tpos[1] = i\n\tif pos[0] != -1 and pos[1] != -1:\n\t\tbreak\nif pos[0] < pos[1]:\n\tif pos[0] > N - 1 - pos[1]:\n\t\tpos[0] = 0\n\telse:\n\t\tpos[1] = N - 1\nelif pos[0] > pos[1]:\n\tif pos[1] > N - 1 - pos[0]:\n\t\tpos[1] = 0\n\telse:\n\t\tpos[0] = N - 1\nprint(abs(pos[0] - pos[1]))\n", "n = int(input())\nnums = [int(_) for _ in input().split()]\na = nums.index(1)\nb = nums.index(n)\nprint(max(a, n - 1 - a, b, n - 1 - b))\n", "N = int(input())\nX = list(map(int, input().split()))\nprint(max(X.index(1), N - 1 - X.index(1), X.index(N), N - 1 - X.index(N)))\n", "n = int(input())\nnumbers = list(map(int, input().split()))\nminpos = numbers.index(1)\nmaxpos = numbers.index(n)\nprint(max(minpos, maxpos, n - minpos - 1, n - maxpos - 1))\n", "import math\nn = int(input())\na = map(int, input().split(' '))\na = [i for i in a]\nmi = min(a)\nma = max(a)\nfor i in range(n):\n\tif a[i] == mi:\n\t\tminI = i\n\tif a[i] == ma:\n\t\tmaxI = i\nmaxRet = math.fabs(minI - maxI)\nfor i in range(n):\n\tmaxRet = max(maxRet, math.fabs(minI - i), math.fabs(i - maxI))\nprint(int(maxRet))\n", "n = int(input())\na = list(map(int, input().split()))\nk = max(a)\np = min(a)\nmaxidx = a.index(k)\nminidx = a.index(p)\nlength = n - 1\nleftmovidx = min(maxidx, minidx)\nrightmovidx = max(maxidx, minidx)\nscopeleft = leftmovidx - 0\nscoperight = length - rightmovidx\nif scopeleft > scoperight:\n\tleftmovidx -= scopeleft\nelse:\n\trightmovidx += scoperight\nprint(rightmovidx - leftmovidx)\n", "n = int(input())\nnum = list(map(int, input().split()))\na = num.index(n)\nb = num.index(1)\nans = [b - a]\nif b > a:\n\tans.append(n - a - 1)\n\tans.append(b - 0)\nelif a > b:\n\tans.append(n - b - 1)\n\tans.append(a - 0)\nprint(max(ans))\n", "n = int(input())\nl = list(map(int, input().split()))\nfirst = l.index(1)\nlast = l.index(n)\nif first == 0 and last == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(abs(0 - last), abs(0 - first), abs(first - (n - 1)), abs(last - (n - 1))))\n", "def single_integer():\n\treturn int(input())\n\ndef multi_integer():\n\treturn map(int, input().split())\n\ndef string():\n\treturn input()\n\ndef multi_string():\n\treturn input().split()\nn = single_integer()\npermutation = tuple(multi_integer())\ni = 1\nmax_value = min_value = permutation[0]\nmax_index = min_index = 1\nwhile i < n:\n\tif permutation[i] > max_value:\n\t\t(max_index, max_value) = (i + 1, permutation[i])\n\tif permutation[i] < min_value:\n\t\t(min_index, min_value) = (i + 1, permutation[i])\n\ti += 1\nprint(max(abs(n - max_index), abs(n - min_index), abs(1 - max_index), abs(1 - min_index)))\n", "import copy, itertools\n\ndef dist(v, n):\n\treturn abs(v.index(1) - v.index(n))\nn = int(input())\na = list(map(int, input().split()))\nbest = dist(a, n)\nfor (lo, hi) in itertools.product(range(n), range(n)):\n\tif lo == hi:\n\t\tcontinue\n\t(a[lo], a[hi]) = (a[hi], a[lo])\n\tbest = max(best, dist(a, n))\n\t(a[lo], a[hi]) = (a[hi], a[lo])\nprint(best)\n", "from sys import stdin\nN = 100\n\ndef parse():\n\tglobal N, SAMPLE\n\tN = int(stdin.readline().strip())\n\t(pos1, pos2) = (-1, -1)\n\tline = stdin.readline().split()\n\tfor i in range(N):\n\t\tnum = int(line[i])\n\t\tif num == N:\n\t\t\tpos2 = i\n\t\telif num == 1:\n\t\t\tpos1 = i\n\t\tif pos1 != -1 and pos2 != -1:\n\t\t\tbreak\n\tif pos1 > pos2:\n\t\ttemp = pos2\n\t\tpos2 = pos1\n\t\tpos1 = temp\n\tresult = max(N - pos1 - 1, pos2)\n\tprint(result)\nparse()\n", "n = int(input())\nl = list(map(int, input().split()))\nmi = min(l)\nma = max(l)\nmi_pos = l.index(mi)\nma_pos = l.index(ma)\nl = min(mi_pos, ma_pos)\nr = max(mi_pos, ma_pos)\nans = r - l\nr_dist = n - 1 - r\nans = ans + max(l, r_dist)\nprint(ans)\n", "def nicholas():\n\tpar1 = int(input())\n\tif par1 == 2:\n\t\treturn 1\n\tpar2 = list(map(int, input().split()[0:par1]))\n\tindexMax = par2.index(par1)\n\tindexMin = par2.index(1)\n\tif indexMax == 0 or indexMax == par1 - 1 or indexMin == 0 or (indexMin == par1 - 1):\n\t\treturn par1 - 1\n\tlistresult = []\n\tlistresult.append(par1 - 1 - indexMax)\n\tlistresult.append(indexMax)\n\tlistresult.append(par1 - 1 - indexMin)\n\tlistresult.append(indexMin)\n\treturn max(listresult)\nprint(nicholas())\n", "n = int(input())\nl = 0\nr = 0\na = list(map(int, input().split()))\nfor i in range(n):\n\tif a[i] == 1:\n\t\tl = i + 1\n\telif a[i] == n:\n\t\tr = i + 1\nprint(max(l - 1, r - 1, n - l, n - r))\n", "n = int(input())\na = list(map(int, input().split()))\nfor x in range(n):\n\tif a[x] == 1:\n\t\tindex1 = x\n\tif a[x] == n:\n\t\tindexn = x\nif abs(index1 - indexn) == n - 1:\n\tprint(n - 1)\nelse:\n\tmaximum = max(index1, abs(index1 - (n - 1)), indexn, abs(indexn - (n - 1)))\n\tprint(maximum)\n", "x = int(input())\ns = list(map(int, input().split()))\nif s[0] == 1 and s[x - 1] == x:\n\tprint(x - 1)\nelse:\n\tfor n in range(0, x):\n\t\tif s[n] == 1:\n\t\t\ta = n + 1\n\t\tif s[n] == x:\n\t\t\tb = n + 1\n\tif a < b:\n\t\tc = x - a\n\t\td = b - 1\n\t\tif c >= d:\n\t\t\tprint(c)\n\t\telse:\n\t\t\tprint(d)\n\telif a > b:\n\t\tc = x - b\n\t\td = a - 1\n\t\tif c >= d:\n\t\t\tprint(c)\n\t\telse:\n\t\t\tprint(d)\n", "k = int(input())\nn = list(map(int, input().split()))\nif n[0] == 1 and n[k - 1] == k or (n[0] == k and n[k - 1] == 1):\n\tprint(k - 1)\nelse:\n\ta = n.index(1) + 1\n\tb = n.index(k) + 1\n\tif a == k or b == k:\n\t\tprint(k - 1)\n\telif a > b:\n\t\tprint(max(a - 1, k - b))\n\telse:\n\t\tprint(max(b - 1, k - a))\n", "n = int(input())\na = list(map(int, input().split()))\nmina = 0\nmaxa = 0\nfor i in range(n):\n\tif a[i] > a[maxa]:\n\t\tmaxa = i\n\telif a[i] < a[mina]:\n\t\tmina = i\nif abs(maxa - mina) == n - 1:\n\tprint(n - 1)\n\texit()\nout = abs(maxa - mina)\nfor i in range(n):\n\tif i != maxa and i != mina:\n\t\tif abs(maxa - i) > out:\n\t\t\tout = abs(maxa - i)\n\t\tif abs(mina - i) > out:\n\t\t\tout = abs(mina - i)\nprint(out)\n", "import sys\nimport math\nget_string = lambda : sys.stdin.readline().strip()\nget_int_list = lambda : list(map(int, sys.stdin.readline().strip().split()))\nget_int = lambda : int(sys.stdin.readline())\nn = get_int()\nlst = get_int_list()\nmi = lst.index(min(lst))\nmx = lst.index(max(lst))\nif mi < mx:\n\ta = abs(mi - 0)\n\tb = abs(n - 1 - mx)\n\tprint(abs(mx - mi) + max(a, b))\nelse:\n\ta = abs(n - 1 - mi)\n\tb = abs(mx - 0)\n\tprint(abs(mx - mi) + max(a, b))\n", "import math\nn = int(input())\na = list(map(int, input().split(' ')))\nfor i in range(len(a)):\n\tif a[i] == 1:\n\t\tsmall = i\n\telif a[i] == n:\n\t\tbig = i\nif abs(n / 2.0 - small) < abs(n / 2.0 - big):\n\tif big > n / 2.0:\n\t\tprint(big)\n\telse:\n\t\tprint(n - 1 - big)\nelif abs(n / 2.0 - small) > abs(n / 2.0 - big):\n\tif small > n / 2.0:\n\t\tprint(small)\n\telse:\n\t\tprint(n - 1 - small)\nelse:\n\tprint(int(n / 2 + math.ceil(abs(n / 2.0 - small))))\n", "n = int(input())\nL = list(map(int, input().split()))\nans = 1\nii = 0\niip = 0\nfor i in range(n):\n\tif L[i] == max(L):\n\t\tii = i\n\telif L[i] == min(L):\n\t\tiip = i\nm = abs(ii - 0)\nk = abs(ii - (n - 1))\nans1 = max(m, k)\nm1 = abs(iip - 0)\nm2 = abs(iip - (n - 1))\nans2 = max(m1, m2)\nprint(max(ans1, ans2))\n", "n = int(input())\na = list(map(int, input().split()))\ni_max = a.index(n)\ni_min = a.index(1)\nres = max(i_max, n - i_max - 1, i_min, n - i_min - 1)\nprint(res)\n", "n = int(input())\narr = list(map(int, input().split()))\nmax_i = 0\nmin_i = 0\nfor (i, val) in enumerate(arr):\n\tif arr[i] == 1:\n\t\tmin_i = i\n\tif arr[i] == n:\n\t\tmax_i = i\nlast_index = n - 1\nans = max(abs(last_index - max_i), abs(max_i))\nans = max(ans, abs(last_index - min_i))\nans = max(ans, abs(min_i))\nprint(ans)\n", "n = int(input())\nq = [int(x) for x in input().split()]\nmaxindex = q.index(n)\nminindex = q.index(1)\nprint(max(abs(maxindex - minindex), abs(maxindex - 0), abs(minindex - 0), abs(maxindex - (n - 1)), abs(minindex - (n - 1))))\n", "n = int(input())\na = list(map(int, input().split()))\ni1 = a.index(1)\ni2 = a.index(n)\nif i1 > i2:\n\t(i1, i2) = (i2, i1)\ndif1 = i1\ndif2 = n - i2 - 1\nif dif1 > dif2:\n\ti1 = 0\nelse:\n\ti2 = n - 1\nprint(i2 - i1)\n", "n = int(input())\narr = [int(x) for x in input().split()]\naaa = []\nfor i in range(n):\n\tif arr[i] == 1:\n\t\taaa.append(i)\n\telif arr[i] == n:\n\t\taaa.append(i)\na = aaa[0]\nb = n - 1 - aaa[1]\nif a > b:\n\tprint(n - b - 1)\nelse:\n\tprint(n - a - 1)\n", "n = int(input())\nl = list(map(int, input().split()))\nmx = l.index(max(l))\nmn = l.index(min(l))\nif mn > mx:\n\t(mn, mx) = (mx, mn)\nprint(max(mx, n - mn - 1))\n", "n = int(input().strip()) - 1\narr = list(map(int, input().strip().split(' ')))\nbig = arr.index(max(arr))\nlittle = arr.index(min(arr))\ndistance = max([abs(big), abs(n - big), abs(little), abs(n - little)])\nprint(distance)\n", "n = int(input()) - 1\nx = list(map(int, input().split()))\na = x.index(1)\nb = x.index(n + 1)\nif min(a, b) == 0 or max(a, b) == n:\n\tprint(n)\nelse:\n\tprint(max(a, b, n - a, n - b))\n", "a = int(input())\nb = list(map(int, input().split()))\nx = b.index(1)\ny = b.index(a)\nprint(max(abs(x - 0), abs(x - a + 1), abs(y - 0), abs(y - a + 1)))\n", "read = lambda : list(map(int, input().split()))\nn = int(input())\na = list(read())\n(x, y) = (a.index(1), a.index(n))\nans = max(x, y, n - x - 1, n - y - 1)\nprint(ans)\n", "n = int(input())\nm = list(map(int, input().split()))\na = m.index(1) + 1\nb = m.index(n) + 1\nprint(max(n - a, n - b, a - 1, b - 1))\n", "v = [int(x) for x in input().split()]\nv = [int(x) for x in input().split()]\npoz_min = 0\npoz_max = 0\nfor (i, x) in enumerate(v):\n\tif x == 1:\n\t\tpoz_min = i + 1\n\telif x == len(v):\n\t\tpoz_max = i + 1\nx = max(abs(poz_min - 1), abs(len(v) - poz_min))\ny = max(abs(poz_max - 1), abs(len(v) - poz_max))\nprint(max(x, y))\n", "n = int(input())\nnums = list(map(int, input().split()))\nsmall = nums.index(min(nums))\nlarge = nums.index(max(nums))\nprint(max([small - 0, n - 1 - small, large - 0, n - 1 - large]))\n", "n = input()\narr = [int(i) for i in input().split()]\ninmin = arr.index(min(arr))\ninmax = arr.index(max(arr))\na = [inmin, inmax, int(n) - 1 - inmin, int(n) - 1 - inmax]\nprint(max(a))\n", "n = int(input())\na = list(map(int, input().split()))\nm1 = 0\nm2 = 0\nfor (i, v) in enumerate(a):\n\tif v == 1:\n\t\tm1 = i + 1\n\telif v == n:\n\t\tm2 = i + 1\nprint(max([m1 - 1, n - m1, m2 - 1, n - m2]))\n", "n = int(input())\nA = list(map(int, input().split()))\nindMax = A.index(max(A))\nindMin = A.index(min(A))\nprint(max(indMax, indMin, n - 1 - indMax, n - 1 - indMin))\n", "n = int(input())\na = list(map(int, input().split(' ')))\n(mini, maxi) = (1000, 0)\n(ni, xi) = (0, 0)\nfor i in range(n):\n\tif a[i] < mini:\n\t\tmini = a[i]\n\t\tni = i\n\tif a[i] > maxi:\n\t\tmaxi = a[i]\n\t\txi = i\nif ni < xi:\n\tdis_ni = ni\n\tdis_xi = n - xi - 1\n\tif dis_ni > dis_xi:\n\t\tni = 0\n\telse:\n\t\txi = n - 1\n\tdis_n_x = xi - ni\nelse:\n\tdis_ni = n - ni - 1\n\tdis_xi = xi\n\tif dis_xi > dis_ni:\n\t\txi = 0\n\telse:\n\t\tni = n - 1\n\tdis_n_x = ni - xi\nprint(dis_n_x)\n", "n = int(input())\na = [int(x) for x in input().split()]\n(c1, c2) = (-1, -1)\nfor i in range(n):\n\tif a[i] == 1:\n\t\tc1 = i\n\tif a[i] == n:\n\t\tc2 = i\nprint(max(abs(c1 - c2), c1, c2, n - 1 - c1, n - 1 - c2))\n", "n = int(input())\na = list(map(int, input().split()))\namin = min(a)\namax = max(a)\nres = 0\nfor i in range(len(a)):\n\tfor j in range(i + 1, len(a)):\n\t\t(a[i], a[j]) = (a[j], a[i])\n\t\tpmin = 0\n\t\tpmax = n - 1\n\t\tfor k in range(len(a)):\n\t\t\tif a[k] == amin:\n\t\t\t\tpmin = k\n\t\t\t\tbreak\n\t\tfor k in range(len(a)):\n\t\t\tif a[k] == amax:\n\t\t\t\tpmax = k\n\t\tres = max(res, abs(pmin - pmax))\n\t\tfor k in range(len(a)):\n\t\t\tif a[k] == amin:\n\t\t\t\tpmin = k\n\t\tfor k in range(len(a)):\n\t\t\tif a[k] == amax:\n\t\t\t\tpmax = k\n\t\t\t\tbreak\n\t\tres = max(res, abs(pmin - pmax))\n\t\t(a[i], a[j]) = (a[j], a[i])\nprint(res)\n", "def max(a, b):\n\tif a > b:\n\t\treturn a\n\telse:\n\t\treturn b\n\ndef magic(lista):\n\tfor i in range(len(lista)):\n\t\tlista[i] = int(lista[i])\n\treturn lista\nn = int(input())\nlis = input()\nlis = lis.split()\nlis = magic(lis)\nmith = -1\nmath = -1\nfor i in range(n):\n\tif lis[i] == 1:\n\t\tmith = i\n\tif lis[i] == n:\n\t\tmath = i\n\tif mith != -1 and math != -1:\n\t\tbreak\nans = max(max(mith, math), max(n - 1 - mith, n - 1 - math))\nprint(ans)\n", "import sys\nn = int(input())\na = list(map(int, sys.stdin.readline().split()))\na1 = a.index(1)\nan = a.index(n)\nans = max(a1, n - a1 - 1, an, n - an - 1)\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nmaxPos = a.index(max(a)) + 1\nminPos = a.index(min(a)) + 1\nend = len(a)\nprint(max([maxPos - 1, minPos - 1, end - maxPos, end - minPos]))\n", "n = int(input())\nl = list(map(int, input().split()))\ns = [(l[i], i) for i in range(n)]\n(mi, ma) = (min(s)[1] + 1, max(s)[1] + 1)\nprint(max(n - mi, abs(mi - ma), mi - 1, ma - 1, n - ma))\n", "n = int(input())\na = list(map(int, input().split()))\nmi = 101\nma = 0\nfor x in range(n):\n\tif a[x] > ma:\n\t\tma = a[x]\n\t\tpos_ma = x\n\tif a[x] < mi:\n\t\tmi = a[x]\n\t\tpos_mi = x\npos_ma += 1\npos_mi += 1\nans_1 = max(abs(n - pos_mi), abs(n - pos_ma))\nans_2 = max(abs(1 - pos_mi), abs(1 - pos_ma))\nprint(max(ans_1, ans_2))\n", "n = int(input())\nx = list(map(int, input().split()))\nind1 = -1\nindn = -1\nfor i in range(n):\n\tif x[i] == 1:\n\t\tind1 = i\n\tif x[i] == n:\n\t\tindn = i\nprint(max(abs(max(ind1, indn)), abs(n - 1 - min(ind1, indn))))\n", "n = int(input())\nans = 0\ns = input().split()\nfor i in range(len(s)):\n\tif int(s[i]) == 1 or int(s[i]) == n:\n\t\tif ans < i:\n\t\t\tans = i\n\t\tif ans < n - i - 1:\n\t\t\tans = n - i - 1\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\n(a1, a2) = (a.index(1) + 1, a.index(n) + 1)\nprint(max(n - min(a1, a2), max(a1, a2) - 1))\n", "n = int(input())\nl = list(map(int, input().split()))\nmax_element = l.index(n)\none = l.index(1)\nbest = lambda x: max(abs(x - 0), abs(x - n + 1))\nprint(max(best(max_element), best(one)))\n", "x = int(input())\ny = [int(i) for i in input().split()]\nprint(max(x - 1 - y.index(max(y)), x - 1 - y.index(min(y)), y.index(max(y)), y.index(min(y))))\n", "def count(L):\n\tmaxIndex = 0\n\tminIndex = 0\n\tn = len(L)\n\tfor i in range(n):\n\t\tif L[i] == 1:\n\t\t\tminIndex = i\n\t\tif L[i] == n:\n\t\t\tmaxIndex = i\n\tif minIndex > maxIndex:\n\t\t(minIndex, maxIndex) = (maxIndex, minIndex)\n\t(minIndex, maxIndex) = (minIndex + 1, maxIndex + 1)\n\treturn max(minIndex - 1, n - maxIndex) + (maxIndex - minIndex)\n\ndef for_input():\n\tl = []\n\tn = int(input())\n\tfor i in range(n):\n\t\tl += dear_number_input()\n\t\tif len(l) >= n:\n\t\t\tbreak\n\treturn l\n\ndef dear_number_input():\n\ta = input()\n\tb = a.split(' ')\n\tl = []\n\tfor i in range(len(b)):\n\t\tl.append(int(b[i]))\n\treturn l\nl = for_input()\nprint(count(l))\n", "from sys import stdin, stdout\nimport bisect\nimport math\n\ndef st():\n\treturn list(stdin.readline().strip())\n\ndef inp():\n\treturn int(stdin.readline())\n\ndef li():\n\treturn list(map(int, stdin.readline().split()))\n\ndef mp():\n\treturn map(int, stdin.readline().split())\n\ndef pr(n):\n\tstdout.write(str(n) + '\\n')\n\ndef soe(limit):\n\tl = [1] * (limit + 1)\n\tprime = []\n\tfor i in range(2, limit + 1):\n\t\tif l[i]:\n\t\t\tfor j in range(i * i, limit + 1, i):\n\t\t\t\tl[j] = 0\n\tfor i in range(2, limit + 1):\n\t\tif l[i]:\n\t\t\tprime.append(i)\n\treturn prime\n\ndef segsoe(low, high):\n\tlimit = int(high ** 0.5) + 1\n\tprime = soe(limit)\n\tn = high - low + 1\n\tl = [0] * (n + 1)\n\tfor i in range(len(prime)):\n\t\tlowlimit = low // prime[i] * prime[i]\n\t\tif lowlimit < low:\n\t\t\tlowlimit += prime[i]\n\t\tif lowlimit == prime[i]:\n\t\t\tlowlimit += prime[i]\n\t\tfor j in range(lowlimit, high + 1, prime[i]):\n\t\t\tl[j - low] = 1\n\tfor i in range(low, high + 1):\n\t\tif not l[i - low]:\n\t\t\tif i != 1:\n\t\t\t\tprint(i)\n\ndef power(a, n):\n\tr = 1\n\twhile n:\n\t\tif n & 1:\n\t\t\tr = r * a\n\t\ta *= a\n\t\tn = n >> 1\n\treturn r\n\ndef solve():\n\tc = 0\n\tn = inp()\n\tl = li()\n\ta = l.index(1)\n\tb = l.index(n)\n\tprint(max(a, b, abs(a - n + 1), abs(b - n + 1)))\nfor _ in range(1):\n\tsolve()\n", "n = int(input())\nls = list(map(int, input().split()))\nfor i in range(n):\n\tif ls[i] == 1:\n\t\tfirst_pos = i\n\tif ls[i] == n:\n\t\tsecond_pos = i\nmax_pos = max(first_pos, second_pos)\nmin_pos = min(first_pos, second_pos)\ndelta_left = min_pos\ndelta_right = n - 1 - max_pos\nprint(max_pos - min_pos + max(delta_left, delta_right))\n", "n = int(input())\narr = [int(i) for i in input().split()]\nmin_loc = arr.index(1)\nmax_loc = arr.index(n)\nprint(max(max_loc, min_loc, n - max_loc - 1, n - min_loc - 1))\n", "def main():\n\tnumber_of_elements = int(input())\n\tnicholas_lst = [int(i) for i in input().split()]\n\tmax_idx = nicholas_lst.index(max(nicholas_lst))\n\tmin_idx = nicholas_lst.index(min(nicholas_lst))\n\tlen_lst = len(nicholas_lst)\n\tdistance = abs(max_idx - min_idx)\n\tmax_distance = 0\n\tif distance == len_lst - 1:\n\t\treturn len_lst - 1\n\tif max_idx > min_idx:\n\t\tdistance_from_max_to_end = len_lst - max_idx\n\t\tdistance_from_min_to_start = min_idx\n\t\tif distance_from_max_to_end > distance_from_min_to_start:\n\t\t\treturn len_lst - min_idx - 1\n\t\treturn max_idx\n\tdistance_from_min_to_end = len_lst - min_idx\n\tdistance_from_max_to_start = max_idx\n\tif distance_from_min_to_end > distance_from_max_to_start:\n\t\treturn len_lst - max_idx - 1\n\treturn min_idx\nprint(main())\n", "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n\tif a[i] == 1:\n\t\tpos_min = i\n\tif a[i] == n:\n\t\tpos_max = i\nprint(max(pos_min - 0, n - 1 - pos_min, pos_max - 0, n - 1 - pos_max))\n", "n = int(input())\na = [int(x) for x in input().split(' ')]\nima = a.index(max(a))\nimi = a.index(min(a))\nif ima <= imi:\n\t(left, right) = (ima, imi)\nelse:\n\t(left, right) = (imi, ima)\nd_left = left\nd_right = len(a) - 1 - right\nif d_left <= d_right:\n\tans = len(a) - 1 - left\nelse:\n\tans = right\nprint(ans)\n", "from sys import stdin\n\ndef main():\n\tn = int(stdin.readline()[0:-1])\n\tnumbers = stdin.readline().split()\n\t(minPos, maxPos) = (-1, -1)\n\tfor i in range(0, n):\n\t\tif numbers[i] == '1':\n\t\t\tminPos = i\n\t\telif numbers[i] == str(n):\n\t\t\tmaxPos = i\n\tif minPos > maxPos:\n\t\t(minPos, maxPos) = (maxPos, minPos)\n\tif minPos == 0 and maxPos == n - 1:\n\t\tprint(n - 1)\n\telif maxPos > n - 1 - minPos:\n\t\tprint(maxPos)\n\telse:\n\t\tprint(n - 1 - minPos)\nmain()\n", "Narray = int(input())\nBarray = input().split()\nBarray = [int(y) for y in Barray]\na = Barray.index(max(Barray))\nb = Barray.index(min(Barray))\ng = max([len(Barray[:a + 1]), len(Barray[a:]), len(Barray[:b + 1]), len(Barray[b:])]) - 1\nprint(g)\n", "import sys\ninput = sys.stdin.readline\nfrom math import log2, log, ceil\n\ndef swaparr(arr, a, b):\n\ttemp = arr[a]\n\tarr[a] = arr[b]\n\tarr[b] = temp\n\ndef gcd(a, b):\n\tif a == 0:\n\t\treturn b\n\treturn gcd(b % a, a)\n\ndef nCr(n, k):\n\tif k > n - k:\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn res\n\ndef upper_bound(a, x, lo=0):\n\thi = len(a)\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif a[mid] < x:\n\t\t\tlo = mid + 1\n\t\telse:\n\t\t\thi = mid\n\treturn lo\n\ndef primefs(n):\n\tprimes = {}\n\twhile n % 2 == 0:\n\t\tprimes[2] = primes.get(2, 0) + 1\n\t\tn = n // 2\n\tfor i in range(3, int(n ** 0.5) + 2, 2):\n\t\twhile n % i == 0:\n\t\t\tprimes[i] = primes.get(i, 0) + 1\n\t\t\tn = n // i\n\tif n > 2:\n\t\tprimes[n] = primes.get(n, 0) + 1\n\treturn primes\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef swap(a, b):\n\ttemp = a\n\ta = b\n\tb = temp\n\treturn (a, b)\n\ndef find(x, link):\n\twhile x != link[x]:\n\t\tx = link[x]\n\treturn x\n\ndef union(x, y, link, size):\n\tx = find(x, link)\n\ty = find(y, link)\n\tif size[x] < size[y]:\n\t\t(x, y) = swap(x, y)\n\tif x != y:\n\t\tsize[x] += size[y]\n\t\tlink[y] = x\n\ndef sieve(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\nMAXN = int(1000000.0 + 5)\n\ndef spf_sieve():\n\tspf[1] = 1\n\tfor i in range(2, MAXN):\n\t\tspf[i] = i\n\tfor i in range(4, MAXN, 2):\n\t\tspf[i] = 2\n\tfor i in range(3, ceil(MAXN ** 0.5), 2):\n\t\tif spf[i] == i:\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif spf[j] == j:\n\t\t\t\t\tspf[j] = i\n\ndef factoriazation(x):\n\tret = {}\n\twhile x != 1:\n\t\tret[spf[x]] = ret.get(spf[x], 0) + 1\n\t\tx = x // spf[x]\n\treturn ret\n\ndef int_array():\n\treturn list(map(int, input().strip().split()))\n\ndef str_array():\n\treturn input().strip().split()\nMOD = int(1000000000.0) + 7\nCMOD = 998244353\nINF = float('inf')\nNINF = -float('inf')\nn = int(input())\na = int_array()\nx = a.index(1)\ny = a.index(n)\nprint(max(x, n - 1 - x, y, n - 1 - y))\n", "n = int(input())\narr = [int(x) for x in input().split()]\nmax1 = max(arr)\ni2 = arr.index(max1) + 1\nmin1 = min(arr)\ni1 = arr.index(min1) + 1\nans = max(abs(n - i1), abs(n - i2), abs(1 - i1), abs(1 - i2))\nprint(ans)\n", "n = int(input())\nt = list(map(int, input().split()))\n(pa, pb) = (t.index(1), t.index(n))\nprint(max(pb, n - 1 - pa, pa, n - 1 - pb))\n", "n = int(input())\na = [int(i) for i in input().split()]\nfor i in range(n):\n\tif a[i] == 1:\n\t\tvt1 = i\n\tif a[i] == n:\n\t\tvtn = i\nprint(max(abs(0 - vtn), abs(0 - vt1), abs(n - vt1 - 1), abs(n - vtn - 1)))\n", "n = int(input())\nlst = list(map(int, input().split()))\nprint(max(lst.index(1), lst.index(n), n - 1 - lst.index(n), n - 1 - lst.index(1)))\n", "n = int(input())\na = list(map(int, input().split()))\n\ndef main():\n\tmin_pos = a.index(1)\n\tmax_pos = a.index(n)\n\tif len(a) % 2 == 0:\n\t\tmid = len(a) // 2 - 0.5\n\telse:\n\t\tmid = len(a) // 2\n\tif abs(min_pos - mid) < abs(max_pos - mid):\n\t\tif min_pos > mid:\n\t\t\tif max_pos > mid:\n\t\t\t\tprint(max_pos)\n\t\t\telse:\n\t\t\t\tprint(n - max_pos - 1)\n\t\telif max_pos < mid:\n\t\t\tprint(n - max_pos - 1)\n\t\telse:\n\t\t\tprint(max_pos)\n\telif max_pos > mid:\n\t\tif min_pos > mid:\n\t\t\tprint(min_pos)\n\t\telse:\n\t\t\tprint(n - min_pos - 1)\n\telif min_pos < mid:\n\t\tprint(n - min_pos - 1)\n\telse:\n\t\tprint(min_pos)\n\treturn\nmain()\n", "n = int(input())\nl = list(map(int, input().split()))\nx = 0\ny = 0\nfor i in range(n):\n\tif l[i] == 1:\n\t\tx = i\n\tif l[i] == n:\n\t\ty = i\na = min(x, y)\nb = max(x, y)\nprint(max(b, n - a - 1))\n", "n = input()\ns = input().split(' ')\nM = s.index(n)\nn = int(n)\nm = s.index('1')\nprint(max(m, M, n - m - 1, n - 1 - M))\n", "n = int(input())\na = [int(i) for i in input().split()]\nb = a.index(n)\nc = a.index(1)\nans = 0\nif c < b:\n\td = n - 1 - c\n\tans = max(b, d)\nelse:\n\td = n - 1 - b\n\tans = max(d, c)\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\n(mini, minx, maxi, maxx) = (0, a[0], 0, a[0])\nfor i in range(n):\n\tx = a[i]\n\tif x > maxx:\n\t\t(maxx, maxi) = (x, i)\n\tif x < minx:\n\t\t(minx, mini) = (x, i)\nm = max(abs(mini - maxi), maxi, abs(n - 1 - maxi), mini, abs(n - 1 - mini))\nprint(m)\n", "n = int(input())\ns = list(map(int, input().split()))\nq = min(s)\nq = s.index(q) + 1\np = s.index(n) + 1\nif p == n or q == n:\n\tprint(n - 1)\nelse:\n\ta = abs(1 - p)\n\tb = abs(n - p)\n\tc = abs(1 - q)\n\td = abs(n - q)\n\te = max(a, b)\n\tf = max(c, d)\n\tprint(max(e, f))\n", "from sys import *\n\ndef input():\n\treturn stdin.readline()\nn = int(input())\nl = list(map(int, input().split()))\nmini = float('inf')\nmaxi = float('-inf')\nfor (i, ai) in enumerate(l):\n\tif ai < mini:\n\t\timini = i\n\t\tmini = ai\n\tif ai > maxi:\n\t\timaxi = i\n\t\tmaxi = ai\n(iser, iber) = (min(imini, imaxi), max(imini, imaxi))\nif iser <= n - iber - 1:\n\tans = n - iser - 1\nelse:\n\tans = iber\nprint(ans)\n", "n = int(input())\nm = input().split(' ')\nintm = []\nfor i in m:\n\ti = int(i)\n\tintm.append(i)\nv1 = 0\nv2 = 0\nv3 = 0\nv4 = 0\nmaxm = int(intm.index(max(intm)))\nminm = int(intm.index(min(intm)))\nv1 = abs(maxm - 0)\nv2 = abs(maxm - n + 1)\nv3 = abs(minm - 0)\nv4 = abs(minm - n + 1)\nv = max(v1, v2, v3, v4)\nprint(v)\n", "n = input()\nindexes = [k for (k, v) in enumerate(input().split()) if v == '1' or v == n]\nprint(max(indexes[1], int(n) - indexes[0] - 1))\n", "n = int(input())\nl = list(map(int, input().split()))\nfor i in range(n):\n\tif l[i] == 1 or l[i] == n or l[n - 1 - i] == 1 or (l[n - 1 - i] == n):\n\t\tprint(n - 1 - i)\n\t\tbreak\n", "n = int(input())\na = [int(x) for x in input().split()]\n(x, y) = (0, 0)\nfor i in range(n):\n\tif a[i] < a[x]:\n\t\tx = i\n\tif a[i] > a[y]:\n\t\ty = i\nprint(max([x, y, n - 1 - x, n - 1 - y, abs(x - y)]))\n", "n = int(input())\na = list(map(int, input().split()))\nprint(max(abs(a.index(max(a)) - n + 1), abs(a.index(min(a)) - n + 1), abs(a.index(max(a))), abs(a.index(min(a)))))\n", "n = int(input())\na = [int(x) for x in input().split()]\nx1 = a.index(1)\nx2 = a.index(n)\nprint(max(n - 1 - x1, x1, n - 1 - x2, x2))\n", "n = int(input())\nl = [int(i) for i in input().split()]\nmi = min(l)\nma = max(l)\ninitial = abs(l.index(ma) - l.index(mi))\ns = n - max(l.index(mi), l.index(ma)) - 1\nf = n - initial - s - 1\nprint(initial + max(f, s))\n", "n = int(input())\nl = list(map(int, input().split()))\na = l.index(1)\nb = l.index(n)\nt = abs(a - b)\nif a > b:\n\tp = n - (a + 1)\n\tq = b\nelse:\n\tp = n - (b + 1)\n\tq = a\nif p > q:\n\tprint(t + p)\nelse:\n\tprint(t + q)\n", "n = int(input())\nls = [int(x) for x in input().split()]\npoz1 = ls.index(1)\npozn = ls.index(n)\nprint(str(max(poz1, n - poz1 - 1, pozn, n - pozn - 1)))\n", "import time\nn = int(input())\na = [int(i) for i in input().split()]\nstart = time.time()\nmn = 0\nmx = 0\nfor i in range(n):\n\tif a[i] < a[mn]:\n\t\tmn = i\n\telif a[i] > a[mx]:\n\t\tmx = i\nprint(max(mn, mx, n - mn - 1, n - mx - 1))\nfinish = time.time()\n", "n = int(input())\nx = list(map(int, input().split()))\nleft = min(x.index(min(x)), x.index(max(x))) + 1\nright = max(x.index(min(x)), x.index(max(x))) + 1\nif left != 1 and right != n:\n\tprint(max(right - 1, n - left))\nelse:\n\tprint(n - 1)\n", "n = int(input())\na = list(map(int, input().split()))\nminindex = a.index(1)\nmaxindex = a.index(n)\nprint(max(minindex, n - 1 - minindex, maxindex, n - 1 - maxindex))\n", "n = int(input())\nlst = [int(i) for i in input().split()]\na = lst.index(min(lst))\nb = lst.index(max(lst))\nmin1 = min([a, b])\nmax1 = max([a, b])\nprint(max([max1, n - 1 - min1]))\n", "n = int(input()) - 1\narr = list(map(int, input().split()))\nm = arr.index(min(arr))\nM = arr.index(max(arr))\nl = abs(M - m)\nprint(max(l, m - 0, M - 0, n - m, n - M))\n", "n = int(input())\narray = input()\narray = array.split()\nfor i in range(n):\n\tif int(array[i]) == 1:\n\t\tn1 = i\n\telif int(array[i]) == n:\n\t\tn2 = i\nn3 = n - n1 - 1\nn4 = n - n2 - 1\nout = max(n1, n2, n3, n4)\nprint(out)\n", "n = int(input())\na = list(map(int, input().split()))\nmini = a.index(min(a))\nmaxi = a.index(max(a))\nmid = n // 2\nif maxi > mini and maxi > mid and (mini > mid):\n\tprint(maxi)\nelif maxi > mini and maxi > mid and (mini == 0):\n\tprint(n - 1)\nelif maxi > mini and maxi > mid and (mini < mid):\n\tprint(max(maxi, abs(mini - (n - 1))))\nelif mini > maxi and mini > mid and (maxi < mid):\n\tprint(max(mini, abs(maxi - (n - 1))))\nelif maxi > mini and maxi <= mid:\n\tprint(abs(mini - (n - 1)))\nelif mini > maxi and mini <= mid:\n\tprint(abs(maxi - (n - 1)))\nelif mini > maxi:\n\tprint(mini)\nelif maxi > mini:\n\tprint(maxi)\nelse:\n\tprint(1)\n", "n = int(input())\na = list(map(int, input().split()))\nk1 = a.index(1)\nkn = a.index(n)\nprint(max(max(k1, kn), n - 1 - min(k1, kn)))\n", "def main():\n\t(n, l) = (int(input()), list(map(int, input().split())))\n\t(lo, hi) = (l.index(1), l.index(n))\n\tif lo > hi:\n\t\t(lo, hi) = (hi, lo)\n\tprint(max(hi, n - lo - 1))\nmain()\n", "n = int(input())\nx = list(map(int, input().split(' ')))\n(Max, Min) = (x.index(max(x)) + 1, x.index(min(x)) + 1)\nprint(max(abs(Max - n), abs(Max - 1), abs(Min - n), abs(Min - 1)))\n", "n = int(input())\na = list(map(int, input().split()))\nind_min = a.index(min(a))\nind_max = a.index(max(a))\nleft = ind_min if ind_min < ind_max else ind_max\nright = ind_min if ind_min >= ind_max else ind_max\nif left > n - right - 1:\n\tprint(right)\nelse:\n\tprint(n - left - 1)\n", "n = int(input())\na = list(map(int, input().split()))\nmini = 0\nmaxi = 0\nfor i in range(n):\n\tif a[i] < a[mini]:\n\t\tmini = i\n\tif a[i] > a[maxi]:\n\t\tmaxi = i\ndist0 = abs(maxi - mini)\ndist1 = abs(0 - mini)\ndist2 = abs(n - 1 - mini)\ndist3 = abs(0 - maxi)\ndist4 = abs(n - 1 - maxi)\nprint(max((dist0, dist1, dist2, dist3, dist4)))\n", "n = int(input().strip())\na = list(map(int, input().split()))\nmax_index = a.index(n)\nmin_index = a.index(1)\nresult = max(max_index, n - 1 - max_index, min_index, n - 1 - min_index)\nprint(str(result))\n", "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n\tif a[i] == n:\n\t\tindex_max = i\n\telif a[i] == 1:\n\t\tindex_min = i\nprint(max(n - 1 - min(index_max, index_min), max(index_max, index_min)))\n", "n = int(input())\narr = input().split()\narr = [int(x) for x in arr]\ninx = [0, n - 1, arr.index(1), arr.index(n)]\nprint(max([abs(inx[0] - inx[2]), abs(inx[1] - inx[2]), abs(inx[0] - inx[3]), abs(inx[1] - inx[3])]))\n", "n = int(input())\na = list(map(int, input().split()))\nmx = max(a)\nmn = min(a)\nmxind = a.index(mx) + 1\nmnind = a.index(mn) + 1\nprint(max(abs(mxind - 1), abs(mnind - 1), abs(n - mnind), abs(n - mxind)))\n", "import sys\nimport math\nimport bisect\nimport itertools\nimport random\nimport re\n\ndef main():\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tB = []\n\tfor i in range(n):\n\t\tif A[i] == 1 or A[i] == n:\n\t\t\tB.append(i)\n\tans = max(n - 1 - B[0], B[1])\n\tprint(ans)\nmain()\n", "n = int(input())\nA = list(map(int, input().split()))\nminIndex = A.index(1)\nmaxIndex = A.index(n)\ndistance = n - 1\nif abs(minIndex - maxIndex) == n - 1:\n\tdistance = n - 1\nif minIndex < maxIndex:\n\tif minIndex < n - 1 - maxIndex:\n\t\tdistance = n - 1 - minIndex\n\telse:\n\t\tdistance = maxIndex\nelif maxIndex < n - 1 - minIndex:\n\tdistance = n - 1 - maxIndex\nelse:\n\tdistance = minIndex\nprint(distance)\n", "n = int(input())\nls = list(map(int, input().split()))\nmax_index = ls.index(n)\nmin_index = ls.index(1)\ndelta_left = min(max_index, min_index)\ndelta_right = min(n - 1 - max_index, n - 1 - min_index)\nmax_distance = abs(max_index - min_index) + max(delta_right, delta_left)\nprint(max_distance)\n", "import math, itertools, fractions, heapq, collections, bisect, sys, queue, copy\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef LI():\n\treturn [int(x) for x in sys.stdin.readline().split()]\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef F():\n\treturn float(sys.stdin.readline())\n\ndef LS():\n\treturn sys.stdin.readline().split()\n\ndef S():\n\treturn input()\n\ndef main():\n\tn = I()\n\tl = LI()\n\tx = l.index(1) + 1\n\ty = l.index(n) + 1\n\treturn max(n - x, n - y, x - 1, y - 1)\nprint(main())\n", "n = int(input())\na = list(map(int, input().split()))\nmin = a[0]\nid_min = 0\nfor i in range(1, n):\n\tif a[i] < min:\n\t\tmin = a[i]\n\t\tid_min = i\nmax = a[0]\nid_max = 0\nfor i in range(1, n):\n\tif a[i] > max:\n\t\tmax = a[i]\n\t\tid_max = i\nresult = id_max\nif result < n - 1 - id_max:\n\tresult = n - 1 - id_max\nif result < id_min:\n\tresult = id_min\nif result < n - 1 - id_min:\n\tresult = n - 1 - id_min\nprint(result)\n", "n = int(input())\nA = [int(x) for x in input().split()]\n(a, b) = (A.index(1), A.index(n))\nprint(max(a, b, n - a - 1, n - b - 1))\n", "n = int(input())\na = list(map(int, input().split()))\n(x, y) = (a.index(1), a.index(n))\nif x > y:\n\t(x, y) = (y, x)\nif x == 0 or y == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(n - 1 - x, y))\n", "n = int(input())\na = [int(i) for i in input().split()]\nb = a.index(max(a))\ne = a.index(min(a))\nc = b - 0\nd = n - 1 - b\nf = e - 0\ng = n - 1 - e\nprint(max(c, d, f, g))\n", "n = int(input())\na = list(map(int, input().split()))\npos = []\nfor i in range(n):\n\tif a[i] == 1 or a[i] == n:\n\t\tpos.append(i)\nif pos[0] > pos[1]:\n\tt = pos[0]\n\tpos[0] = pos[1]\n\tpos[1] = t\nprint(max(n - 1 - pos[0], pos[1] - 0))\n", "n = int(input())\narr = list(map(int, input().split()))\nmini = arr.index(min(arr))\nmaxi = arr.index(max(arr))\nprint(max(max(mini, maxi), n - min(mini, maxi) - 1))\n", "n = int(input())\na = [int(x) for x in input().split()]\nmx = a.index(max(a))\nmi = a.index(min(a))\nl = len(a) - 1\nprint(max(mx - mi, l - mx, l - mi, mx, mi))\n", "n = int(input(''))\ns1 = input('').split(' ')\nmyList = []\ns = []\ncounter = 0\nwhile counter < n:\n\ts.append(int(s1[counter]))\n\tcounter = counter + 1\nmax_value = max(s)\nmax_index = s.index(max_value)\nmin_value = min(s)\nmin_index = s.index(min_value)\nmin_toend = n - min_index - 1\nmax_toend = n - max_index - 1\nl1 = min_index\nmyList.append(l1)\nl2 = max_index\nmyList.append(l2)\nl3 = min_toend\nmyList.append(l3)\nl4 = max_toend\nmyList.append(l4)\nsol = max(myList)\nprint(str(sol))\n", "arrsize = int(input())\narr = input().split(' ')\nintarr = [int(i) for i in arr]\nmax_index = intarr.index(max(intarr))\nmin_index = intarr.index(min(intarr))\nmm = []\nldistm = min_index\nrdistm = len(intarr) - 1 - min_index\nif ldistm >= rdistm:\n\tmm.append(ldistm)\nelse:\n\tmm.append(rdistm)\nldistn = max_index\nrdistn = len(intarr) - 1 - max_index\nif ldistn >= rdistn:\n\tmm.append(ldistn)\nelse:\n\tmm.append(rdistn)\nprint(max(mm))\n", "n = int(input())\narr = list(map(int, input().split()))[:n]\nmini = 0\nmaxu = 1\nmaxi = 0\nfor i in range(0, n):\n\tif arr[i] == 1:\n\t\tmini = i\n\telif arr[i] > maxu:\n\t\tmaxu = arr[i]\n\t\tmaxi = i\nif abs(maxi - mini) == n - 1:\n\tprint(abs(maxi - mini))\nelse:\n\tc = mini\n\td = maxi\n\te = max(n - mini - 1, n - maxi - 1)\n\tprint(max(c, d, e))\n", "import sys, math\nn = int(input())\nz = list(map(int, input().split()))\nf = 0\nd = 0\nfor i in range(n):\n\tif z[i] == 1:\n\t\tf = i\n\tif z[i] == n:\n\t\td = i\nbst = 0\nif math.fabs(d - f) == n - 1:\n\tprint(n - 1)\n\tsys.exit()\nbst = max(math.fabs(d), math.fabs(f), math.fabs(n - 1 - f), math.fabs(n - 1 - d))\nprint(int(bst))\n", "n = int(input())\narr = list(map(int, input().split()))\nsmall = arr.index(min(arr))\nbig = arr.index(max(arr))\nmaxx = abs(big - small)\nn = n - 1\nv = max(abs(n - small), abs(big - n))\ndd = max(small, big)\nfu = max(v, dd)\nprint(max(fu, maxx))\n", "n = int(input())\nL = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n\tfor j in range(n):\n\t\t(L[i], L[j]) = (L[j], L[i])\n\t\tans = max(ans, abs(L.index(1) - L.index(n)))\n\t\t(L[i], L[j]) = (L[j], L[i])\nprint(ans)\n", "def main():\n\tn = int(input())\n\tpermutation = [0] + [int(_) for _ in input().split()]\n\tindex_1 = permutation.index(1)\n\tindex_n = permutation.index(n)\n\tprint(max(max(index_1, index_n) - 1, n - min(index_1, index_n)))\nmain()\n", "n = int(input())\na = list(map(int, input().split()))\n(i, j) = sorted([a.index(1), a.index(n)])\nprint(max(j, n - i - 1))\n", "n = int(input())\narr = [int(i) for i in input().split()]\nmn_in = arr.index(1)\nmx_in = arr.index(n)\nfirst = max(abs(mn_in), abs(mn_in - (n - 1)))\nsecond = max(abs(mx_in), abs(mx_in - (n - 1)))\nprint(max(first, second))\n", "n = int(input())\na = list(map(int, input().split()))\nmx_index = 0\nmn_index = 0\nfor i in range(n):\n\tif a[i] == n:\n\t\tmx_index = i\n\tif a[i] == 1:\n\t\tmn_index = i\nprint(max(n - 1 - mx_index, n - 1 - mn_index, mx_index, mn_index))\n", "from math import ceil\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\narr = list(map(int, input().split()))\nfp = None\nsp = None\nfor (i, x) in enumerate(arr):\n\tif x == n or x == 1:\n\t\tif fp is None:\n\t\t\tfp = i\n\t\telse:\n\t\t\tsp = i\nprint(max(n - fp - 1, sp))\n", "n = int(input())\nlst = list(map(int, input().split()))\nif n % 2 == 0:\n\tmiddle = (n - 1) / 2\nelse:\n\tmiddle = (n - 1) / 2\nif abs(lst.index(1) - middle) < abs(lst.index(n) - middle):\n\tif lst.index(1) < lst.index(n):\n\t\tprint(lst.index(n))\n\telse:\n\t\tprint(n - lst.index(n) - 1)\nelif lst.index(n) < lst.index(1):\n\tprint(lst.index(1))\nelse:\n\tprint(n - lst.index(1) - 1)\n", "n = int(input())\narr = list(map(int, input().split()))\nans = max(n - arr.index(1) - 1, n - arr.index(n) - 1, arr.index(n), arr.index(1))\nprint(ans)\n", "def max(a, b):\n\tif a > b:\n\t\treturn a\n\treturn b\nn = int(input())\na = list(map(int, input().split()))\npos1 = 0\nposn = 0\nfor i in range(n):\n\tif a[i] == 1:\n\t\tpos1 = i\n\tif a[i] == n:\n\t\tposn = i\nprint(max(pos1, max(n - 1 - pos1, max(posn, n - 1 - posn))))\n", "n = int(input())\ns = [int(i) for i in input().split()]\na = s.index(min(s))\nb = s.index(max(s))\nif a > b:\n\tif n - 1 - a > b:\n\t\tprint(n - 1 - b)\n\telse:\n\t\tprint(a)\nelif n - 1 - b > a:\n\tprint(n - 1 - a)\nelse:\n\tprint(b)\n", "n = int(input())\narr = list(map(int, input().split()))\nfor i in range(n):\n\tif arr[i] == 1:\n\t\tfir = i + 1\n\telif arr[i] == n:\n\t\tlst = i + 1\nprint(max(n - fir, n - lst, fir - 1, lst - 1) if (fir != 1 or fir != n) and (lst != 1 or lst != n) else n - 1)\n", "n = int(input())\na = list(map(int, input().split()))\n\ndef m(a, b):\n\treturn abs(a - b)\n(_max, _min) = (0, 0)\nfor i in range(n):\n\tif a[i] == n:\n\t\t_max = i\n\telif a[i] == 1:\n\t\t_min = i\nprint(max(m(_max, _min), m(0, _min), m(0, _max), m(n - 1, _min), m(n - 1, _max)))\n", "n = int(input())\na = list(map(int, input().split()))\nseqMin = a.index(1)\nseqMax = a.index(n)\nif seqMin < seqMax:\n\tprint(max(n - 1 - seqMin, seqMax))\nelse:\n\tprint(max(n - 1 - seqMax, seqMin))\n", "n = int(input())\nA = list(map(int, input().split()))\nmin = 0\nmax = n - 1\nfor i in range(n):\n\tif A[i] > A[max]:\n\t\tmax = i\n\tif A[i] < A[min]:\n\t\tmin = i\nif min == 0 or min == n - 1 or max == 0 or (max == n - 1):\n\tprint(n - 1)\nelse:\n\tdistance1 = 0\n\tdistance2 = 0\n\tif n - 1 - min > n - 1 - max:\n\t\tdistance1 = n - 1 - min\n\telse:\n\t\tdistance1 = n - 1 - max\n\tif min - 0 > max - 0:\n\t\tdistance2 = min - 0\n\telse:\n\t\tdistance2 = max - 0\n\tif distance1 > distance2:\n\t\tprint(distance1)\n\telse:\n\t\tprint(distance2)\n", "import sys\nimport math\nimport collections\nfrom pprint import pprint\nmod = 1000000007\n\ndef vector(size, val=0):\n\tvec = [val for i in range(size)]\n\treturn vec\n\ndef matrix(rowNum, colNum, val=0):\n\tmat = []\n\tfor i in range(rowNum):\n\t\tcollumn = [val for j in range(colNum)]\n\t\tmat.append(collumn)\n\treturn mat\nn = int(input())\na = list(map(int, input().split()))\nx = 0\ny = 0\nans = 0\nfor i in range(n):\n\tif a[i] == 1:\n\t\tx = i\n\t\tbreak\nfor i in range(n):\n\tif a[i] == n:\n\t\ty = i\n\t\tbreak\nans = abs(y - x)\nif x < y:\n\tans += max(x, n - y - 1)\nelse:\n\tans += max(n - x - 1, y)\nprint(ans)\n", "n = int(input())\nl = [int(i) for i in input().split()]\nif l[0] == n or l[0] == 1 or l[n - 1] == 1 or (l[n - 1] == n):\n\tprint(n - 1)\nelse:\n\ti = l.index(1)\n\tj = l.index(n)\n\tif i > j:\n\t\tk = n - i\n\t\tprint(max(n - j - 1, i))\n\telse:\n\t\tk = n - j\n\t\tprint(max(n - i - 1, j))\n", "n = int(input())\na = [int(i) for i in input().split()]\n(k, l) = (a.index(1), a.index(n))\nprint(max(k, l, n - k - 1, n - l - 1))\n", "n = int(input())\n\ndef test(A):\n\tni = -1\n\ti1 = -1\n\tfor i in range(len(A)):\n\t\tif A[i] == n:\n\t\t\tni = i\n\t\tif A[i] == 1:\n\t\t\ti1 = i\n\treturn abs(ni - i1)\nA = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n\tfor j in range(i):\n\t\t(A[i], A[j]) = (A[j], A[i])\n\t\tans = max(ans, test(A))\n\t\t(A[i], A[j]) = (A[j], A[i])\nprint(ans)\n", "size = int(input())\narray = input().split(' ')\nfor i in range(0, size):\n\tarray[i] = int(array[i])\nmin_value = min(array)\nmin_to_head = array.index(min_value)\nmin_to_tail = size - min_to_head - 1\nmax_value = max(array)\nmax_to_head = array.index(max_value)\nmax_to_tail = size - max_to_head - 1\nmax_distance = max(min_to_head, min_to_tail, max_to_head, max_to_tail)\nprint(max_distance)\n", "n = int(input())\na = list(map(int, input().split()))\nmax_pos = a.index(max(a))\nmin_pos = a.index(min(a))\nc = [max_pos, n - max_pos - 1, min_pos, n - min_pos - 1]\nprint(max(c))\n", "n = int(input())\na = list(map(int, input().split()))\npos1 = a.index(1) + 1\nposn = a.index(n) + 1\nres = abs(pos1 - posn)\nres = max(res, abs(1 - pos1))\nres = max(res, abs(n - pos1))\nres = max(res, abs(1 - posn))\nres = max(res, abs(n - posn))\nprint(res)\n", "n = int(input())\nints = list(map(int, input().split()))\nleftest = min(ints.index(1), ints.index(n))\nrightest = max(ints.index(1), ints.index(n))\nprint(max(n - 1 - rightest, leftest) + rightest - leftest)\n", "n = int(input())\na = list(map(int, input().split()))\nx = a.index(1)\ny = a.index(n)\nif abs(x - y) == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(x, n - 1 - y, n - 1 - x, y))\n", "a = int(input())\nb = list(map(int, input().split()))\nc = len(b) - 1\nprint(max(c - b.index(a), c - b.index(1), b.index(a), b.index(1)))\n", "n = int(input())\na = list(map(int, input().split()))\nposa = a.index(1)\nposb = a.index(n)\nif posa > posb:\n\ttmp = posa\n\tposa = posb\n\tposb = tmp\nprint(max(n - posa - 1, posb))\n", "n = int(input())\nm = list(map(int, input().split()))\nmini = min(m)\nmaxi = max(m)\nx = m.index(mini)\ny = m.index(maxi)\nif y > x:\n\ttemp = x\n\tx = y\n\ty = temp\nif x - y == n - 1:\n\tprint(n - 1)\nelif y >= n - x:\n\tprint(x)\nelse:\n\tprint(n - y - 1)\n", "import sys\nnum = int(input())\nnumbers = input()\nnumber = [int(x) for x in numbers.split()]\nfor (id, value) in enumerate(number):\n\tif number[id] == max(number):\n\t\tmax_offset = id\n\tif number[id] == min(number):\n\t\tmin_offset = id\nif max_offset < min_offset:\n\tdistance_end = len(number) - min_offset - 1\n\tif distance_end == 0:\n\t\tmax_offset = 0\n\t\tresult = min_offset - max_offset\n\t\tprint(result)\n\t\tsys.exit()\n\tdistance_head = max_offset - 0\n\tif distance_head == 0:\n\t\tmin_offset = len(number) - 1\n\t\tresult = min_offset - max_offset\n\t\tprint(result)\n\t\tsys.exit()\n\tif distance_head == distance_end:\n\t\tmax_offset = 0\n\t\tresult = min_offset - max_offset\n\t\tprint(result)\n\t\tsys.exit()\n\telif distance_head > distance_end:\n\t\tmax_offset = 0\n\telse:\n\t\tmin_offset = len(number) - 1\n\tresult = min_offset - max_offset\n\tprint(result)\n\tsys.exit()\nelse:\n\tdistance_end = len(number) - max_offset - 1\n\tdistance_head = min_offset - 0\n\tif distance_end == 0:\n\t\tmin_offset = 0\n\t\tresult = max_offset - min_offset\n\t\tprint(result)\n\t\tsys.exit()\n\tif distance_head == 0:\n\t\tmax_offset = len(number) - 1\n\t\tresult = max_offset - min_offset\n\t\tprint(result)\n\t\tsys.exit()\n\tif distance_head == distance_end:\n\t\tmin_offset = 0\n\t\tresult = max_offset - min_offset\n\t\tprint(result)\n\t\tsys.exit()\n\telif distance_head > distance_end:\n\t\tmin_offset = 0\n\telse:\n\t\tmax_offset = len(number) - 1\n\tresult = max_offset - min_offset\n\tprint(result)\n", "n = int(input())\nlst = list(map(int, input().split()))\nindex_one = lst.index(1)\nindex_n = lst.index(n)\nprint(max(n - index_one - 1, n - index_n - 1, index_one, index_n))\n", "n = int(input())\nl = list(map(int, input().split()))\nh = max(l)\nm = min(l)\np1 = l.index(h) + 1\np2 = l.index(m) + 1\nt = abs(p1 - p2)\nt1 = abs(p1 - n)\nt2 = abs(p2 - n)\nt3 = abs(1 - p2)\nt4 = abs(1 - p1)\nprint(max(t, t1, t2, t3, t4))\n", "(n, A) = (int(input()), list(map(int, input().split())))\n(i, j) = (A.index(min(A)), A.index(max(A)))\nprint(max(i, j, n - i - 1, n - j - 1))\n", "n = int(input())\nl = [int(x) for x in input().split()]\n(mini, maxi) = (l.index(min(l)), l.index(max(l)))\nprint(max(mini, maxi, n - maxi - 1, n - mini - 1))\n", "n = int(input())\nL = [int(x) for x in input().split()]\n[m, M] = [min(L.index(1), L.index(n)), max(L.index(1), L.index(n))]\nprint(max(n - 1 - m, M))\n", "n = int(input())\na = [int(x) for x in input().split()]\nx = a.index(1)\ny = a.index(n)\nhsl = max(abs(x - y), abs(n - 1 - x), abs(n - 1 - y), x, y)\nprint(hsl)\n", "def swap(a, b):\n\treturn (b, a)\nn = int(input())\na = list(map(int, input().split()))\nposL = 0\nposR = 0\nfor i in range(n):\n\tif a[i] == 1:\n\t\tposL = i\n\tif a[i] == n:\n\t\tposR = i\nif posL > posR:\n\t(posL, posR) = swap(posL, posR)\nprint(max(n - posL - 1, posR))\n", "n = int(input())\na = [int(s) for s in input().split(' ')]\nm = [a.index(1), a.index(n)]\nprint(max(max(m), n - min(m) - 1))\n", "count = int(input())\na = [int(x) for x in input().split()]\nlowIndex = a.index(1)\nhighIndex = a.index(count)\nprint(max(highIndex - 0, lowIndex - 0, count - 1 - lowIndex, count - 1 - highIndex))\n", "n = int(input())\nl = list(map(int, input().split()))\nindexN = l.index(n)\nindex1 = l.index(1)\nt = max(index1, len(l) - 1 - index1, indexN, len(l) - 1 - indexN)\nprint(t)\n", "n = int(input())\nl = list(map(int, input().split()))\nx = max(l)\ny = min(l)\nc = 0\nt1 = 0\nt2 = 0\nfor i in range(n):\n\tif x == l[i]:\n\t\tt1 = i\nfor i in range(n):\n\tif y == l[i]:\n\t\tt2 = i\np = [0] * 7\np[1] = t1 - t2\np[2] = t1 - 0\np[3] = n - 1 - t1\np[4] = t2 - t1\np[5] = n - 1 - t2\np[6] = t2 - 0\nprint(max(p))\n", "n = int(input())\npermu = map(int, input().split())\nminimum = 1000\nmaximum = -1\nminPos = -1\nmaxPos = -1\nfor (pos, nombre) in enumerate(permu):\n\tif nombre < minimum:\n\t\tminimum = nombre\n\t\tminPos = pos\n\tif nombre > maximum:\n\t\tmaximum = nombre\n\t\tmaxPos = pos\nprint(max(minPos, maxPos, n - minPos - 1, n - maxPos - 1))\n", "n = int(input())\na = [int(x) for x in input().split()]\nfor i in range(len(a)):\n\tif a[i] == 1:\n\t\tb = i\n\tif a[i] == n:\n\t\tc = i\nprint(max([abs(b - c), abs(c), abs(b), abs(n - 1 - b), abs(n - 1 - c)]))\n", "n = int(input())\na = list(map(int, input().split()))\nmi = -1\nma = -1\nfor i in range(n):\n\tif a[i] == 1:\n\t\tmi = i + 1\n\telif a[i] == n:\n\t\tma = i + 1\nif mi > ma:\n\t(mi, ma) = (ma, mi)\nprint(max(min(n - 1, abs(n - mi)), min(n - 1, abs(ma - 1))))\n", "n = int(input())\nx = 0\ny = 0\narr = list(map(int, input().split()))\nfor i in range(n):\n\tif arr[i] == 1:\n\t\tx = i\n\telif arr[i] == n:\n\t\ty = i\nif x > y:\n\t(x, y) = (y, x)\nprint(max(n - 1 - x, y))\n", "n = int(input())\nnums = list(zip(map(int, input().split()), range(0, 100)))\nxmin = min(nums)\nxmax = max(nums)\na = abs(xmax[1] - xmin[1])\nb = abs(xmax[1])\nc = abs(n - xmax[1] - 1)\nd = abs(xmin[1])\ne = abs(n - xmin[1] - 1)\nprint(max(a, b, c, d, e))\n", "def far_distance(array, n):\n\tindex_min = array.index(1)\n\tindex_max = array.index(n)\n\tdistances = [index_min, index_max, n - index_min - 1, n - index_max - 1]\n\treturn max(distances)\nn = int(input())\na = [int(x) for x in input().split()]\nprint(far_distance(a, n))\n", "arr_size = int(input())\narray = list(map(int, input().split()))\nmin_elem_index = array.index(min(array))\nmax_elem_index = array.index(max(array))\nmin_to_start = max_elem_index\nmin_to_end = arr_size - 1 - max_elem_index\nmax_to_start = min_elem_index\nmax_to_end = arr_size - 1 - min_elem_index\nmax_dis = max(min_to_start, min_to_end, max_to_start, max_to_end)\nprint(max_dis)\n", "b = int(input())\na = input()\na = a.split(' ')\na = [int(i) for i in a]\nc = a.index(1)\nd = a.index(b)\ne = 0\nb = b - 1\nif abs(c - d) == b:\n\tprint(b)\nelif c < d:\n\tif abs(b - c) >= abs(d):\n\t\tprint(abs(b - c))\n\telse:\n\t\tprint(abs(d))\nelif c > d:\n\tif abs(b - d) >= abs(c):\n\t\tprint(abs(b - d))\n\telse:\n\t\tprint(abs(c))\n", "n = input()\na = [int(i) for i in input().split()]\nmax1 = max(a)\nmin1 = min(a)\nans1 = a.index(max1)\nans2 = len(a) - a.index(max1) - 1\nans3 = a.index(min1)\nans4 = len(a) - a.index(min1) - 1\nprint(max(ans1, ans2, ans3, ans4))\n", "n = int(input())\na = [int(item) for item in input().split()]\nindex_max = a.index(max(a))\nindex_min = a.index(min(a))\nif abs(index_max - index_min) == n - 1:\n\tprint(n - 1)\nelif index_min < index_max:\n\tresult = max(index_max, n - 1 - index_min)\n\tprint(result)\nelse:\n\tresult = max(index_min, n - 1 - index_max)\n\tprint(result)\n", "number = int(input())\narray = input().split()\nnArray = []\nfor i in array:\n\tnArray.append(int(i))\ndistance = abs(nArray.index(1) - nArray.index(number))\ndis1 = number - 1 - max(nArray.index(1), nArray.index(number))\ndis2 = min(nArray.index(1), nArray.index(number))\ndistance = distance + max(dis1, dis2)\nprint(distance)\n", "n = int(input())\na = list(map(int, input().split()))\nans = 0\nl = a.index(n)\nr = a.index(1)\nfor i in range(n):\n\tb = a.copy()\n\t(b[i], b[l]) = (b[l], b[i])\n\tans = max(abs(b.index(1) - b.index(n)), ans)\n\tb = a.copy()\n\t(b[i], b[r]) = (b[r], b[i])\n\tans = max(abs(b.index(1) - b.index(n)), ans)\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nmi = a.index(1)\nmx = a.index(n)\nprint(max(max(n - 1 - mi, n - 1 - mx), max(mi, mx)))\n", "n = int(input())\ninps = list(map(int, input().split(' ')))\n\ndef dist_of_higher_index_from_ri(max_ind):\n\tdist = n - 1 - max_ind\n\treturn dist\n\ndef dist_of_lower_from_li(min_ind):\n\tdist = min_ind - 0\n\treturn dist\nindices = []\nmax_ind = inps.index(max(inps))\nindices.append(max_ind)\nmin_ind = inps.index(min(inps))\nindices.append(min_ind)\nindices.sort()\ndiffs = []\nmaxr = dist_of_higher_index_from_ri(indices[1])\ndiffs.append(maxr)\nminl = dist_of_lower_from_li(indices[0])\ndiffs.append(minl)\nif minl == 0 and maxr == 0:\n\tprint(abs(min_ind - max_ind))\nelif minl == maxr:\n\tprint(abs(n - 1 - indices[0]))\nelif maxr > minl:\n\tprint(abs(n - 1 - indices[0]))\nelse:\n\tprint(indices[1])\n", "n = int(input())\na = list(map(int, input().split()))\npos1 = a.index(1)\nposn = a.index(n)\nvmax = abs(posn - pos1)\nif vmax < abs(posn - 0):\n\tvmax = abs(posn - 0)\nif vmax < abs(n - 1 - posn):\n\tvmax = abs(n - 1 - posn)\nif vmax < abs(pos1 - 0):\n\tvmax = abs(pos1 - 0)\nif vmax < abs(n - 1 - pos1):\n\tvmax = abs(n - 1 - pos1)\nprint(vmax)\n", "n = int(input())\na = (*map(int, input().split()),)\n(x, y) = sorted([a.index(1), a.index(n)])\nprint(max(y, n - 1 - x))\n", "n = int(input())\nl = [int(x) for x in input().split()]\nprint(max(l.index(n), l.index(1), n - l.index(n) - 1, n - l.index(1) - 1))\n", "n = int(input())\nl = list(map(int, input().split()))\nmini = l.index(1)\nmaxi = l.index(n)\nprint(abs(mini - maxi) + max(abs(max(mini, maxi) - (n - 1)), min(mini, maxi)))\n", "n = int(input())\na = list(map(int, input().split()))\nminInd = a.index(1)\nmaxInd = a.index(n)\nm = abs(minInd - maxInd)\nif minInd < maxInd:\n\tif minInd > 0 and m < maxInd:\n\t\tm = maxInd\n\tif maxInd < n - 1 and m < n - 1 - minInd:\n\t\tm = n - 1 - minInd\nelse:\n\tif maxInd > 0 and m < minInd:\n\t\tm = minInd\n\tif minInd < n - 1 and m < n - 1 - maxInd:\n\t\tm = n - 1 - maxInd\nprint(m)\n", "n = int(input())\na = list(map(int, input().split()))\nfirst = 0\nend = 0\nfor (index, i) in enumerate(a):\n\tif i == 1:\n\t\tfirst = index\n\tif i == n:\n\t\tend = index\nprint(max(abs(end - first), max(end, max(first, max(abs(n - 1 - first), abs(n - 1 - end))))))\n", "n = int(input())\na = [int(i) for i in input().split()]\nninp = -1\nmaxp = -1\nfor i in range(n):\n\tif a[i] == 1:\n\t\tminp = i\n\tif a[i] == n:\n\t\tmaxp = i\nprint(max(abs(maxp), abs(n - 1 - maxp), abs(minp), abs(n - 1 - minp)))\n", "def main():\n\tN = int(input())\n\tarr = list(map(int, input().split()))\n\t(mic, mac) = (0, 0)\n\tfor i in range(len(arr)):\n\t\tif arr[i] == 1:\n\t\t\tmic = i\n\t\tif arr[i] == N:\n\t\t\tmac = i\n\ttemp = min(mac, mic)\n\ttemp2 = max(mic, mac)\n\tif temp < N - temp2:\n\t\tprint(N - (temp + 1))\n\telse:\n\t\tprint(temp2)\nmain()\n", "def main():\n\tn = int(input())\n\ta = tuple(map(int, input().split()))\n\t(b, c) = (a.index(1), a.index(n))\n\t(b, c) = (min(b, c), n - max(b, c) - 1)\n\tprint(n - min(b, c) - 1)\nmain()\n", "readInts = lambda : list(map(int, input().split()))\nn = int(input())\na = readInts()\np1 = a.index(1)\npn = a.index(n)\nprint(max(p1, pn, n - 1 - p1, n - 1 - pn))\n", "n = int(input())\nlst = list(map(int, input().strip().split(' ')))\nmaxN = minN = lst[0]\nindexMax = indexMin = 0\nfor b in range(n):\n\tif lst[b] > maxN:\n\t\tmaxN = lst[b]\n\t\tindexMax = b\n\tif lst[b] < minN:\n\t\tminN = lst[b]\n\t\tindexMin = b\ndisMax_0 = indexMax\ndisMax_n = n - indexMax - 1\ndisMin_0 = indexMin\ndisMin_n = n - indexMin - 1\nans = disMax_0\nif ans < disMax_n:\n\tans = disMax_n\nif ans < disMin_0:\n\tans = disMin_0\nif ans < disMin_n:\n\tans = disMin_n\nprint(ans)\n", "n = input()\nz = input()\nz = z.split()\na = []\na.append(1)\na.append(int(n))\nb = []\nb.append(z.index('1') + 1)\nb.append(z.index(n) + 1)\nans = 0\nfor i in b:\n\tfor j in a:\n\t\tp = i - j\n\t\tif p < 0:\n\t\t\tp = -p\n\t\tif p > ans:\n\t\t\tans = p\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\n_max = -1\n_min = 101\nfor i in range(n):\n\tif a[i] > _max:\n\t\t_max = a[i]\n\t\tidx1 = i\n\tif a[i] < _min:\n\t\t_min = a[i]\n\t\tidx2 = i\nif idx1 > idx2:\n\t(idx1, idx2) = (idx2, idx1)\nprint(max(n - 1 - idx1, idx2))\n", "n = int(input())\na = list(map(int, input().split()))[:n]\nmino = a[0]\nmaxo = a[0]\nmaxi = 0\nmini = 0\nfor i in range(1, n):\n\tif a[i] < mino:\n\t\tmino = a[i]\n\t\tmini = i\n\tif a[i] > maxo:\n\t\tmaxo = a[i]\n\t\tmaxi = i\nx = [maxi, mini, n - maxi - 1, n - mini - 1]\nx.sort()\nprint(max(n - x[0] - 1, x[3]))\n", "def main_function():\n\tn = int(input())\n\tp = [int(i) for i in input().split(' ')]\n\tcounter_one = 0\n\tcounter_two = 0\n\tfirts_item_found = False\n\tsecond_item_found = False\n\tind_one = -1000\n\tind_two = -1000\n\tfor i in range(len(p)):\n\t\tif (p[i] == 1 or p[i] == n) and (not firts_item_found):\n\t\t\tfirts_item_found = True\n\t\t\tind_one = i + 1\n\t\telif not firts_item_found:\n\t\t\tcounter_one += 1\n\t\telif firts_item_found and (p[i] == 1 or p[i] == n):\n\t\t\tsecond_item_found = True\n\t\t\tind_two = i + 1\n\t\telif second_item_found:\n\t\t\tcounter_two += 1\n\tif counter_one > counter_two:\n\t\tind_one = 1\n\telse:\n\t\tind_two = n\n\treturn ind_two - ind_one\nprint(main_function())\n", "t = int(input())\nl = list(map(int, input().split()))\nk = l.index(max(l))\nr = l.index(min(l))\nl1 = max(k, r, t - k - 1, t - r - 1)\nif l1 == t:\n\tprint(t - 1)\nelse:\n\tprint(l1)\n", "n = int(input())\nA = list(map(int, input().split()))\npmin = 0\npmax = 0\nfor i in range(n):\n\tif A[i] == 1:\n\t\tpmin = i\n\tif A[i] == n:\n\t\tpmax = i\nif pmin > pmax:\n\ttam = pmin\n\tpmin = pmax\n\tpmax = tam\nif pmax <= n / 2:\n\tprint(n - 1 - pmin)\nelif pmin <= n / 2:\n\tif n - 1 - pmin > pmax:\n\t\tprint(n - 1 - pmin)\n\telse:\n\t\tprint(pmax)\nelse:\n\tprint(pmax)\n", "n = int(input())\narr = list(map(int, input().split()))\n_min = arr[0]\n_max = arr[0]\nfor i in range(n):\n\tif _min > arr[i]:\n\t\t_min = arr[i]\n\tif _max < arr[i]:\n\t\t_max = arr[i]\nv1 = arr.index(_min) - 0\nv2 = n - 1 - arr.index(_min)\nv3 = arr.index(_max) - 0\nv4 = n - 1 - arr.index(_max)\nprint(max(v1, v2, v3, v4))\n", "n = int(input())\nL = [int(e) for e in input().split(' ')]\nprint(max([n - L.index(n) - 1, L.index(n), n - L.index(1) - 1, L.index(1)]))\n", "size = int(input(''))\noriginal_list = list(map(int, input('').split()))\nmax_value = max(original_list)\nmax_index = original_list.index(max_value)\nmin_value = min(original_list)\nmin_index = original_list.index(min_value)\nleft = 0\nright = len(original_list) - 1\nif max_index > min_index:\n\tdelta_right = right - max_index\n\tdelta_left = min_index\nelse:\n\tdelta_right = right - min_index\n\tdelta_left = max_index\nif delta_right == delta_left:\n\tprint(abs(max_index - min_index) + delta_right)\nelif delta_right > delta_left:\n\tprint(abs(max_index - min_index) + delta_right)\nelse:\n\tprint(abs(max_index - min_index) + delta_left)\n", "import math\n(n, x) = (int(input()), [int(i) for i in input().split()])\n(min_index, max_index) = (x.index(min(x)), x.index(max(x)))\nprint(max([min_index, max_index, n - 1 - min_index, n - 1 - max_index]))\n", "n = int(input())\nl = list(map(int, input().rstrip().split()))\nb = l.index(n)\na = l.index(1)\nm = []\nif a == 0 or b == 0 or a == n - 1 or (b == n - 1):\n\tm.append(n - 1)\np = a\nq = n - 1 - a\nx = b\ny = n - 1 - b\nm.append(max(max(p, q), max(x, y)))\nprint(m[0])\n", "x = input()\nx = int(x)\na = list(map(int, input().split()))\nfor i in range(x):\n\tif a[i] == 1:\n\t\ta1 = i\n\telif a[i] == x:\n\t\ta2 = i\nprint(max(abs(x - 1 - a2), abs(x - 1 - a1), abs(a1), abs(a2)))\n", "n = int(input())\nli = [int(x) for x in input().split()]\nmi = 1\nma = n\nind_ma = li.index(ma)\nind_mi = li.index(mi)\nif ind_ma == n - 1 or ind_mi == 0:\n\tprint(n - 1)\nelse:\n\tdma = n - 1 - ind_ma\n\tdmi = n - 1 - ind_mi\n\tprint(max([dma, dmi, ind_ma, ind_mi]))\n", "n = int(input())\na = list(map(int, input().split()))\nb = a * 1\nb.sort()\nlow = a.index(b[0]) + 1\nhigh = a.index(b[-1]) + 1\nif low > high:\n\t(low, high) = (high, low)\nprint(max(n - low, high - 1))\n", "import math, sys, re, itertools\n(rs, ri, rai) = (input, lambda : int(input()), lambda : list(map(int, input().split())))\n(n, a, m) = (ri(), rai(), -1)\nfor (i, j) in itertools.product(range(n), range(n)):\n\t(a[i], a[j]) = (a[j], a[i])\n\tm = max(m, abs(a.index(1) - a.index(n)))\n\t(a[i], a[j]) = (a[j], a[i])\nprint(m)\n", "n = input()\np = list(input().split())\ns = max(p.index(n), int(n) - p.index(n) - 1)\nt = max(p.index('1'), int(n) - p.index('1') - 1)\nprint(max(s, t))\n", "n = int(input())\na = list(map(int, input().split()))\ni1 = a.index(1)\ni2 = a.index(n)\nif i1 > i2:\n\t(i1, i2) = (i2, i1)\nres = max(i2, n - i1 - 1)\nprint(res)\n", "n = int(input())\na = list(map(int, input().split()))\nx = a.index(min(a))\ny = a.index(max(a))\nif x > y:\n\tx1 = n - x - 1\n\ty1 = y\n\tif x1 > y1:\n\t\tprint(n - 1 - y1)\n\telse:\n\t\tprint(x)\nelse:\n\ty1 = n - y - 1\n\tx1 = x\n\tif y1 > x1:\n\t\tprint(n - 1 - x1)\n\telse:\n\t\tprint(y)\n", "n = int(input())\na = list(map(int, input().split()))\nx = a.index(1)\ny = a.index(n)\nif x > y:\n\t(x, y) = (y, x)\nans = max(x, n - 1 - y) + y - x\nprint(ans)\n", "n = int(input())\nlista = [int(x) for x in input().split()]\nindmin = lista.index(min(lista))\nindmax = lista.index(max(lista))\ntotal = indmin - indmax\nfor i in range(2):\n\tif n - 1 - indmin > total:\n\t\ttotal = n - 1 - indmin\n\tif n - 1 - indmax > total:\n\t\ttotal = n - 1 - indmax\n\tif indmin > total:\n\t\ttotal = indmin\n\tif indmax > total:\n\t\ttotal = indmax\nprint(total)\n", "n = int(input())\narr = [int(i) for i in list(input().split())]\nmn = float('inf')\nmx = -float('inf')\nmn_i = 0\nmx_i = 0\nfor i in range(n):\n\tif mx < arr[i]:\n\t\tmx = arr[i]\n\t\tmx_i = i\n\tif mn > arr[i]:\n\t\tmn = arr[i]\n\t\tmn_i = i\nprint(max(n - 1 - min(mn_i, mx_i), max(mn_i, mx_i)))\n", "n = int(input())\na = list(map(int, input().split()))\nb = a.index(n)\nc = a.index(1)\nd = abs(b - c)\nprint(max(d + min(b, c), d + abs(max(b, c) - n + 1)))\n", "n = int(input())\narr = list(map(int, input().split()))\n(posMax, posMin) = (0, 0)\nfor i in range(n):\n\tif arr[i] == 1:\n\t\tposMin = i + 1\n\telif arr[i] == n:\n\t\tposMax = i + 1\nres = max(max(n - posMax, posMax - 1), max(n - posMin, posMin - 1))\nprint(res)\n", "n = int(input())\na = [int(i) for i in input().split()]\nk = h = 0\nfor i in range(n):\n\tif a[i] == 1 or a[i] == n:\n\t\tk = i\n\t\tbreak\nfor i in range(k + 1, n):\n\tif a[i] == 1 or a[i] == n:\n\t\th = i\nif k > n - h - 1:\n\tprint(h)\nelse:\n\tprint(n - k - 1)\n", "n = int(input())\nl_n = list(map(int, input().split()))\nmax_i = l_n.index(max(l_n))\nmin_i = l_n.index(min(l_n))\nprint(max(max_i, min_i, n - min_i - 1, n - max_i - 1))\n", "n = int(input())\narr = [int(x) for x in input().split(' ')]\n(a, b) = [min(arr.index(1), arr.index(n)), max(arr.index(1), arr.index(n))]\nprint(b - a + max(a, n - b - 1))\n", "n = int(input().strip())\na = [int(i) for i in input().strip().split(' ')]\ni = a.index(1)\nj = a.index(n)\nprint(max(max(i, j), n - min(i, j) - 1))\n", "import sys\ninput = sys.stdin.buffer.readline\nn = int(input())\narr = list(map(int, input().split()))\na = min(arr)\nb = max(arr)\npos = []\nfor i in range(n):\n\tif arr[i] == a or arr[i] == b:\n\t\tpos.append(i)\n\tif len(pos) == 2:\n\t\tbreak\nprint(max(n - 1 - min(pos), max(pos) - 0))\n", "n = int(input())\ndata = list(map(int, input().split()))\nindexmax = data.index(max(data))\nindexmin = data.index(min(data))\nprint(max(indexmax, indexmin, n - indexmax - 1, n - indexmin - 1))\n", "a = int(input())\n(*b,) = map(int, input().split())\nc = b.index(1)\nd = b.index(a)\nprint(max(abs(a - c - 1), c, abs(a - d - 1), d))\n", "n = int(input())\nl = list(map(int, input().split()))\nr = sorted(l)\np = l.index(r[0])\nh = l.index(r[n - 1])\nif p < h:\n\to = p\n\ty = n - 1 - h\n\tif o > y:\n\t\tprint(h)\n\telse:\n\t\tprint(n - 1 - p)\nelse:\n\to = h\n\ty = n - 1 - p\n\tif o > y:\n\t\tprint(p)\n\telse:\n\t\tprint(n - 1 - h)\n", "n = int(input().rstrip())\na = list(map(int, input().split()))\np1 = 0\np2 = 0\nfor i in range(n):\n\tif a[i] == 1:\n\t\tp1 = i\n\tif a[i] == n:\n\t\tp2 = i\nprint(max(max(max(max(abs(n - 1 - p1), abs(n - 1 - p2)), p1), p2), abs(p2 - p1)))\n", "n = int(input())\narr = [int(x) for x in input().split()]\nans = 0\nfor i in range(n):\n\tfor j in range(i):\n\t\t(arr[i], arr[j]) = (arr[j], arr[i])\n\t\tmini = min(arr)\n\t\tpos_mini = arr.index(mini)\n\t\tmaxi = max(arr)\n\t\tpos_maxi = arr.index(maxi)\n\t\tans = max(ans, abs(pos_maxi - pos_mini))\n\t\t(arr[i], arr[j]) = (arr[j], arr[i])\nprint(ans)\n", "f = int(input())\nm = 0\nn = 0\na = list(map(int, input().split()))\nx = min(a)\ny = max(a)\nif a.index(x) > a.index(y):\n\tm = x\n\tn = y\nelse:\n\tm = y\n\tn = x\nprint(max(abs(len(a) - 1 - a.index(n)), abs(0 - a.index(m))))\n", "input()\ndata = list(map(int, input().split()))\nfirst = -1\nlast = -1\nfor (index, value) in enumerate(data):\n\tif value == 1:\n\t\tfirst = index\n\tif value == len(data):\n\t\tlast = index\nif first > last:\n\t(first, last) = (last, first)\nprint(last - first + max(first, len(data) - 1 - last))\n", "n = int(input())\nl = list(map(int, input().split()))\ni = -1\nj = -1\nfor k in range(n):\n\tif l[k] == 1:\n\t\ti = k\nfor k in range(n):\n\tif l[k] == n:\n\t\tj = k\nprint(max([j, n - i - 1, n - j - 1, i]))\n", "n = int(input())\nb = input()\na = b.split()\nfor i in range(n):\n\tif int(a[i]) == 1:\n\t\tl = i + 1\n\telif int(a[i]) == n:\n\t\tr = i + 1\nans = n - l\nif ans < l - 1:\n\tans = l - 1\nif ans < n - r:\n\tans = n - r\nif ans < r - 1:\n\tans = r - 1\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nmin_elt = 105\nmax_elt = 0\nmax_ind = -1\nmin_ind = -1\nfor i in range(n):\n\tif a[i] > max_elt:\n\t\tmax_elt = a[i]\n\t\tmax_ind = i\n\tif a[i] < min_elt:\n\t\tmin_elt = a[i]\n\t\tmin_ind = i\nif min_ind in [0, n - 1] or max_ind in [0, n - 1]:\n\tprint(n - 1)\nelse:\n\tmn = min(min_ind, max_ind)\n\tmx = max(min_ind, max_ind)\n\tans = max(mx, n - 1 - mn)\n\tprint(ans)\n", "n = int(input())\nm = list(map(int, input().split()))\n(ma, mi) = (m.index(n), m.index(1))\n(ma, mi) = (max(ma, mi), min(ma, mi))\nprint(max(ma, n - ma - 1, n - 1 - mi, mi - 1))\n", "n = int(input())\na = list(map(int, input().split()))\nb = list(reversed(a))\nmx = max(a)\nmn = min(a)\nif a.index(mn) <= b.index(mn):\n\tmi = a.index(mn)\nelse:\n\tmi = b.index(mn)\nif a.index(mx) <= b.index(mx):\n\tma = a.index(mx)\nelse:\n\tma = b.index(mx)\nif mi >= ma:\n\tprint(n - 1 - ma)\nelse:\n\tprint(n - 1 - mi)\n", "n = int(input())\na = input()\nba = a.split(' ')\nba = [int(i) for i in ba]\niz = min(ba.index(max(ba)), ba.index(min(ba)))\nde = max(ba.index(max(ba)), ba.index(min(ba)))\nd_iz = iz\nd_de = n - 1 - de\nif d_iz > d_de:\n\tprint(de)\nelse:\n\tprint(n - 1 - iz)\n", "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n\tif a[i] == 1:\n\t\tposMin = i\n\tif a[i] == n:\n\t\tposMax = i\nans = max(posMin, n - 1 - posMin, posMax, n - 1 - posMax)\nprint(ans)\n", "n = int(input())\nl = list(map(int, input().split()))\na = min(l)\nb = max(l)\nif a == l[0] or b == l[0] or a == l[n - 1] or (b == l[n - 1]):\n\tprint(n - 1)\nelse:\n\ta1 = abs(n - 1 - l.index(a))\n\ta2 = abs(l.index(a))\n\tb1 = abs(n - 1 - l.index(b))\n\tb2 = abs(l.index(b))\n\tprint(max(a1, a2, b1, b2))\n", "n = int(input())\na = list(map(int, input().split()))\nmini = 0\nmaxi = 0\ni = 0\nc = 0\nwhile i < n:\n\tif a[i] == 1:\n\t\tmini = i\n\t\tc += 1\n\tif a[i] == n:\n\t\tmaxi = i\n\t\tc += 1\n\tif c == 2:\n\t\tbreak\n\ti = i + 1\nif mini < maxi:\n\tk1 = mini - 0\n\tk2 = n - 1 - maxi\n\tif k1 > k2:\n\t\tmini = 0\n\telse:\n\t\tmaxi = n - 1\n\tprint(abs(maxi - mini))\nelse:\n\tk1 = n - 1 - mini\n\tk2 = maxi\n\tif k1 > k2:\n\t\tmini = n - 1\n\telse:\n\t\tmaxi = 0\n\tprint(abs(mini - maxi))\n", "n = int(input())\na = list(map(int, input().split()))\nminIdx = 0\nmaxIdx = 0\nfor i in range(n):\n\tif a[i] < a[minIdx]:\n\t\tminIdx = i\n\tif a[i] > a[maxIdx]:\n\t\tmaxIdx = i\nans = abs(maxIdx - minIdx)\nif ans != n:\n\tif minIdx < maxIdx:\n\t\tans = max(abs(maxIdx - 0), abs(n - 1 - minIdx))\n\telse:\n\t\tans = max(abs(minIdx - 0), abs(n - 1 - maxIdx))\nprint(ans)\n", "n = int(input())\na = [int(c) for c in input().split()]\n(pos1, pos2) = (a.index(1), a.index(n))\n_min = min(pos1, pos2)\n_max = max(pos1, pos2)\nif _min <= n // 2 and _max <= n // 2:\n\tprint(n - _min - 1)\nelif _min >= n // 2 and _max >= n // 2:\n\tprint(_max)\nelif _min < n - _max - 1:\n\tprint(n - _min - 1)\nelse:\n\tprint(_max)\n", "n = int(input())\na = list(map(int, input().split()))\nmaxa = a[0]\nmini = a[0]\nmaxapo = 0\nminipo = 0\nfor i in range(n):\n\tif a[i] > maxa:\n\t\tmaxa = a[i]\n\t\tmaxapo = i\n\tif a[i] < mini:\n\t\tmini = a[i]\n\t\tminipo = i\nans = abs(minipo - maxapo)\nyo = min(minipo, maxapo) + 1\nro = max(minipo, maxapo) + 1\nroro = n - ro + 1\nif roro > yo:\n\tans = ans + roro - 1\nelse:\n\tans = ans + yo - 1\nprint(ans)\n", "n = int(input())\nx = list(map(int, input().split()))\n(p, q) = (x.index(1) + 1, x.index(n) + 1)\n(a, b) = (min(p, q), max(p, q))\nif a - 1 > n - b:\n\tprint(b - 1)\nelse:\n\tprint(n - a)\n", "n = int(input())\na = list(map(int, input().split(' ')))\npos_1 = a.index(1)\npos_n = a.index(n)\nmax_d = abs(pos_n - pos_1)\nfor swap in ((0, pos_1), (0, pos_n), (n - 1, pos_1), (n - 1, pos_n)):\n\t(a[swap[0]], a[swap[1]]) = (a[swap[1]], a[swap[0]])\n\tmax_d = max(max_d, abs(a.index(1) - a.index(n)))\n\t(a[swap[0]], a[swap[1]]) = (a[swap[1]], a[swap[0]])\nprint(max_d)\n", "n = int(input())\nl = list(map(int, input().split()))\nz1 = l.index(min(l))\nz2 = len(l) - 1 - l.index(min(l))\nz3 = l.index(max(l))\nz4 = len(l) - 1 - l.index(max(l))\nprint(max(z1, z2, z3, z4))\n", "n = int(input())\nval = list(map(int, input().split()))\n(po, pn) = (-1, -1)\nfor i in range(n):\n\tif val[i] == 1:\n\t\tpo = i\n\tif val[i] == n:\n\t\tpn = i\nprint(max(abs(pn - po), abs(max(pn, po) - 0), abs(n - 1 - min(po, pn))))\n", "n = int(input())\na = list(map(int, input().split()))\nm0 = max(a)\nm1 = min(a)\nfor i in range(n):\n\tif a[i] == m0:\n\t\tma = i + 1\n\telif a[i] == m1:\n\t\tmi = i + 1\nd = abs(mi - ma)\nif ma < mi:\n\td0 = ma - 1\n\td1 = n - mi\n\tif d1 > d0:\n\t\td += d1\n\telse:\n\t\td += d0\nelse:\n\td0 = mi - 1\n\td1 = n - ma\n\tif d1 > d0:\n\t\td += d1\n\telse:\n\t\td += d0\nprint(d)\n", "n = int(input())\na = list(map(int, input().split()))\nprint(max(len(a) - 1 - a.index(n), len(a) - 1 - a.index(1), a.index(n), a.index(1)))\n", "n = int(input())\nS = list(map(int, input().split()))\np1 = S.index(min(S))\np2 = S.index(max(S))\ns1 = n - p1 - 1\ns2 = n - p2 - 1\nans = max([s1, s2, p1, p2])\nprint(ans)\n", "n = int(input())\narr = list(map(int, input().split()))\none = arr.index(1)\nlast = arr.index(n)\nanswer = 0\nfor i in range(n):\n\tanswer = max(abs(one - i), abs(last - i), answer)\nprint(answer)\n", "a = int(input())\nb = list(map(int, input().split()))\nz = b.index(a)\nz1 = b.index(1)\nprint(max(z, z1, a - z - 1, a - z1 - 1))\n", "n = int(input())\na = list(map(int, input().split()))\nm = min(a)\nM = max(a)\nmidx = a.index(m)\nMidx = a.index(M)\nif midx > Midx:\n\tprint(max(n - 1 - Midx, midx))\nelse:\n\tprint(max(n - 1 - midx, Midx))\n", "n = int(input())\narr = list(map(int, input().split()))\ni_max = 0\ni_min = 0\nfor i in range(n):\n\tif arr[i_max] < arr[i]:\n\t\ti_max = i\n\tif arr[i_min] > arr[i]:\n\t\ti_min = i\nif i_max > i_min:\n\t(l, r) = (i_min, i_max)\nelse:\n\t(l, r) = (i_max, i_min)\nif r > n - l - 1:\n\tprint(r)\nelse:\n\tprint(n - l - 1)\n", "n = int(input())\nL = [int(x) for x in input().split()]\np1 = L.index(1)\np2 = L.index(n)\nrezwan = max(p1, p2, n - p1 - 1, n - p2 - 1)\nprint(rezwan)\n", "n = int(input())\na = [int(i) for i in input().split()]\nfor i in range(n):\n\tif a[i] == 1:\n\t\tpos1 = i\n\tif a[i] == n:\n\t\tposn = i\nprint(max(posn, pos1, n - pos1 - 1, n - posn - 1))\n", "from itertools import combinations\n\ndef main():\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tval = 0\n\tfor (x, y) in combinations(range(n), 2):\n\t\t(arr[x], arr[y]) = (arr[y], arr[x])\n\t\tval = max(val, abs(arr.index(1) - arr.index(n)))\n\t\t(arr[x], arr[y]) = (arr[y], arr[x])\n\tprint(val)\nmain()\n", "n = int(input())\nl = list(map(int, input().split()))\nminimum = min(l)\nmaximum = max(l)\nindexMax = 0\nindexMin = 0\nfor i in range(0, len(l)):\n\tif l[i] == maximum:\n\t\tindexMax = i\n\tif l[i] == minimum:\n\t\tindexMin = i\ncount = 0\nif indexMin == 0 or indexMax == 0 or indexMin == n - 1 or (indexMax == n - 1):\n\tcount = n - 1\nelif indexMin < indexMax and indexMin < n - indexMax:\n\tcount = n - 1 - indexMin\nelif indexMin < indexMax and indexMin >= n - indexMax:\n\tcount = indexMax\nelif indexMax < indexMin and indexMax < n - indexMin:\n\tcount = n - 1 - indexMax\nelif indexMax < indexMin and indexMax >= n - indexMin:\n\tcount = indexMin\nprint(count)\n", "n = int(input())\n(p, p2) = (0, 0)\nmas = list(map(int, input().split()))\nfor i in range(n):\n\tif mas[i] == 1:\n\t\tp = i + 1\n\tif mas[i] == n:\n\t\tp2 = i + 1\nprint(max(p - 1, p2 - 1, n - p, n - p2))\n", "n = int(input())\narr = list(map(int, input().split()))\nminA = arr.index(1)\nmaxA = arr.index(n)\nprint(max(maxA, n - 1 - maxA, minA, n - 1 - minA))\n", "n = int(input())\nlst = [int(x) for x in input().split()]\nmi = lst.index(1)\nma = lst.index(n)\nprint(max(abs(ma - mi), abs(n - mi - 1), abs(n - ma - 1), ma, mi))\n", "n = int(input())\na = [int(i) for i in input().split()]\none = a.index(1) + 1\nlast = a.index(n) + 1\nprint(max(n - one, n - last, one - 1, last - 1))\n", "n = int(input())\na = list(map(int, input().split()))\nminpos = a.index(min(a))\nmaxpos = a.index(max(a))\nprint(max(minpos, maxpos, n - minpos - 1, n - maxpos - 1))\n", "n = int(input())\nA = list(map(int, input().split()))\nmini = 0\nmaxi = 0\nmaxim = 0\nminim = 10 ** 10\nfor i in range(n):\n\tif A[i] > maxim:\n\t\tmaxim = A[i]\n\t\tmaxi = i\n\tif A[i] < minim:\n\t\tminim = A[i]\n\t\tmini = i\na = abs(n - mini - 1)\nb = abs(0 - mini)\nc = abs(n - maxi - 1)\nd = abs(0 - maxi)\nprint(max(a, b, c, d))\n", "n = int(input())\nal = list(map(int, input().split()))\n(a, b) = (al.index(min(al)), al.index(max(al)))\nif a > b:\n\t(a, b) = (b, a)\nif n > 3:\n\tif a - 0 > n - 1 - b:\n\t\ta = 0\n\telse:\n\t\tb = n - 1\nelif n == 3:\n\ta = 0\n\tb = 2\nprint(b - a)\n", "n = int(input())\na = list(map(int, input().split()))\npos1 = -1\npos2 = -1\nfor i in range(0, n):\n\tif a[i] == 1:\n\t\tpos1 = i + 1\n\telif a[i] == n:\n\t\tpos2 = i + 1\nprint(max(max(max(n - pos1, pos1 - 1), n - pos2), pos2 - 1))\n", "(n, a) = (input(), input().split())\n(i, j) = (a.index('1'), a.index(n))\nprint(max(max(i, j), int(n) - 1 - min(i, j)))\n", "def main():\n\tn = input()\n\ta = input().split(' ') * 1\n\tnum_1 = a.index('1') + 1\n\tnum_max = a.index(str(n)) + 1\n\tmax_len = 0\n\tif max_len < num_max - 1:\n\t\tmax_len = num_max - 1\n\tif max_len < num_1 - 1:\n\t\tmax_len = num_1 - 1\n\tif max_len < len(a) - num_max:\n\t\tmax_len = len(a) - num_max\n\tif max_len < len(a) - num_1:\n\t\tmax_len = len(a) - num_1\n\tprint(max_len)\nmain()\n", "n = int(input())\narr_list = list(map(int, input().split()))\n\ndef swap_max(x, y):\n\tglobal arr_list\n\t(arr_list[x], arr_list[y]) = (arr_list[y], arr_list[x])\n\tmin_pos = 0\n\tmax_pos = n\n\tfor (index, ele) in enumerate(arr_list):\n\t\tif ele == 1:\n\t\t\tmin_pos = index\n\t\tif ele == n:\n\t\t\tmax_pos = index\n\t(arr_list[x], arr_list[y]) = (arr_list[y], arr_list[x])\n\tret = max_pos - min_pos\n\tif ret < 0:\n\t\tret = -ret\n\treturn ret\nans = 0\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\tans = max(ans, swap_max(i, j))\nprint(ans)\n", "__author__ = 'artyom'\n\ndef main():\n\tn = read()\n\ta = read(3)\n\ti = 0\n\twhile a[i] != 1 and a[i] != n:\n\t\ti += 1\n\tj = 1\n\twhile a[-j] != 1 and a[-j] != n:\n\t\tj += 1\n\treturn n - min(i + 1, j)\n\ndef read(mode=1, size=None):\n\tif mode == 0:\n\t\treturn input().strip()\n\tif mode == 1:\n\t\treturn int(input().strip())\n\tif mode == 2:\n\t\treturn input().strip().split()\n\tif mode == 3:\n\t\treturn list(map(int, input().strip().split()))\n\ta = []\n\tfor _ in range(size):\n\t\ta.append(read(3))\n\treturn a\n\ndef write(s='\\n'):\n\tif s is None:\n\t\ts = ''\n\tif isinstance(s, tuple) or isinstance(s, list):\n\t\ts = ' '.join(map(str, s))\n\ts = str(s)\n\tprint(s, end='\\n')\nwrite(main())\n", "import sys\nimport math\nn = [int(i) for i in input().split()][0]\nar = [int(i) for i in input().split()]\nprint(max(abs(ar.index(n)), abs(ar.index(n) - n + 1), abs(ar.index(1)), abs(ar.index(1) - n + 1)))\nsys.stdout.close()\n", "num = int(input())\narr = list(map(int, input().split()))\nans = []\nfor (i, n) in enumerate(arr, start=1):\n\tif n == 1 or n == num:\n\t\tans.append(abs(num - i))\n\t\tans.append(i - 1)\nprint(max(ans))\n", "n = int(input())\ns = [int(i) for i in input().split()]\nx = s.index(1)\ny = s.index(n)\nif y > x:\n\tprint(max(y, n - x - 1))\nelse:\n\tprint(max(x, n - y - 1))\n", "def calc_max_dist(_a, _n):\n\t(pos_min, pos_max) = (0, 0)\n\tfor i in range(_n):\n\t\tif _a[i] == n:\n\t\t\tpos_max = i\n\t\tif _a[i] == 1:\n\t\t\tpos_min = i\n\treturn max(n - 1 - pos_max, n - 1 - pos_min, pos_max, pos_min)\nn = int(input())\na = list(map(int, input().split()))\nprint(calc_max_dist(a, n))\n", "def maxDistance(arr):\n\ta = []\n\tfor (idx, val) in enumerate(arr):\n\t\tif val == 1 or val == len(arr):\n\t\t\ta.append(idx)\n\treturn max(a[1], len(arr) - a[0] - 1)\nn = int(input())\narr = list(map(int, input().split()))\nprint(maxDistance(arr))\n", "n = int(input())\na = [int(x) for x in input().split()]\nans = 0\nfor i in range(n):\n\tfor j in range(n):\n\t\t(a[i], a[j]) = (a[j], a[i])\n\t\tfor k in range(n):\n\t\t\tif a[k] == n:\n\t\t\t\tr = k\n\t\t\tif a[k] == 1:\n\t\t\t\tl = k\n\t\tans = max(ans, abs(r - l))\n\t\t(a[i], a[j]) = (a[j], a[i])\nprint(ans)\n", "n = int(input())\narr = list(map(int, input().split()))\none_index = arr.index(1)\nn_index = arr.index(n)\nif one_index < n_index:\n\tif one_index >= n - 1 - n_index:\n\t\tprint(n_index)\n\telse:\n\t\tprint(n - 1 - one_index)\nelif n_index >= n - 1 - one_index:\n\tprint(one_index)\nelse:\n\tprint(n - 1 - n_index)\n", "n = int(input())\nL = list(map(int, input().split()))\n(index1, index2) = (L.index(1), L.index(n))\nif index1 > index2:\n\t(index1, index2) = (index2, index1)\nd = index2 - index1\nd = max(d, n - 1 - index1)\nd = max(d, index2)\nprint(d)\n", "n = int(input())\nch = input().split()\nch = [int(x) for x in ch]\na = ch.index(min(ch))\nb = ch.index(max(ch))\nif a > b:\n\tprint(max(a, n - 1 - b))\nelse:\n\tprint(max(b, n - 1 - a))\n", "n = int(input())\ns = [int(z) for z in input().split()]\nd = 0\nfor i in range(n):\n\tif s[i] == 1 or s[i] == n:\n\t\td = max(d, i, n - 1 - i)\nprint(d)\n", "def max_index(xs):\n\treturn max(enumerate(xs), key=lambda x: x[1])[0]\n\ndef min_index(xs):\n\treturn min(enumerate(xs), key=lambda x: x[1])[0]\n\ndef main():\n\tinput()\n\txs = [int(x) for x in input().split()]\n\ti_max = max_index(xs)\n\ti_min = min_index(xs)\n\tmax_first = xs[:]\n\tmax_last = xs[:]\n\tmin_first = xs[:]\n\tmin_last = xs[:]\n\t(max_first[0], max_first[i_max]) = (max_first[i_max], max_first[0])\n\t(min_first[0], min_first[i_min]) = (min_first[i_min], min_first[0])\n\t(max_last[-1], max_last[i_max]) = (max_last[i_max], max_last[-1])\n\t(min_last[-1], min_last[i_min]) = (min_last[i_min], min_last[-1])\n\tb = abs(max_index(xs) - min_index(xs))\n\tb = max(abs(max_index(max_first) - min_index(max_first)), b)\n\tb = max(abs(max_index(min_first) - min_index(min_first)), b)\n\tb = max(abs(max_index(max_last) - min_index(max_last)), b)\n\tb = max(abs(max_index(min_last) - min_index(min_last)), b)\n\tprint(b)\nmain()\n", "n = int(input())\na = list(map(int, input().split()))\na1 = a.index(max(a))\na2 = a.index(min(a))\nif a1 > a2:\n\t(a1, a2) = (a2, a1)\nif abs(a2 > n - a1 - 1):\n\tprint(a2)\nelse:\n\tprint(n - a1 - 1)\n", "n = int(input())\na = list(map(int, input().split(' ')))\nmaxIndex = 0\nminIndex = 0\nfor i in range(0, n):\n\tif a[i] > a[maxIndex]:\n\t\tmaxIndex = i\n\tif a[i] < a[minIndex]:\n\t\tminIndex = i\nprint(max(maxIndex, minIndex, n - maxIndex - 1, n - minIndex - 1))\n", "def main():\n\tm = int(input())\n\tvals = [int(v) for v in input().split()]\n\t(mx, mn) = (0, 0)\n\tfor (i, v) in enumerate(vals):\n\t\tif v == m:\n\t\t\tmx = i\n\t\telif v == 1:\n\t\t\tmn = i\n\tif max(mx, mn) != m - 1 and min(mx, mn) != 0:\n\t\tprint(max(m - min(mn, mx) - 1, max(mn, mx)))\n\telse:\n\t\tprint(m - 1)\nmain()\n", "n = int(input())\nlst = list(map(int, input().split()))\nmin_index = lst.index(min(lst))\nmax_index = lst.index(max(lst))\ndelta_left = min(min_index, max_index)\ndelta_right = min(len(lst) - 1 - min_index, len(lst) - 1 - max_index)\nresult = 0\nif delta_left < delta_right:\n\tresult = delta_right + abs(max_index - min_index)\nelif delta_left > delta_right:\n\tresult = delta_left + abs(max_index - min_index)\nelse:\n\tresult = delta_left + abs(max_index - min_index)\nprint(result)\n", "def maxmax(numbers):\n\tmaxn = len(numbers)\n\tm1 = 0\n\tm2 = 0\n\tfor (i, n) in enumerate(numbers):\n\t\tif n == 1:\n\t\t\tm1 = i\n\t\telif n == maxn:\n\t\t\tm2 = i\n\tm1 = max(m1, maxn - m1 - 1)\n\tm2 = max(m2, maxn - m2 - 1)\n\treturn max(m1, m2)\n\ndef solve(instr):\n\treturn maxmax(list(map(int, instr.split(' '))))\n_ = input()\nprint(solve(input()))\n", "num = int(input())\narr = list(map(int, input().split()))\nmx = 0\nfor (i, n) in enumerate(arr, start=1):\n\tif n == 1 or n == num:\n\t\tmx = max(mx, num - i)\n\t\tmx = max(mx, i - 1)\nprint(mx)\n", "n = int(input())\nind1 = 0\nindn = 0\na = input().split()\nfor i in range(0, n):\n\tx = int(a[i])\n\tif x == 1:\n\t\tind1 = i\n\telif x == n:\n\t\tindn = i\nprint(max(n - 1 - ind1, ind1, n - 1 - indn, indn))\n", "n = int(input())\narr = list(map(int, input().split()))\nimax = 0\nimin = 0\nmx = 0\nmn = 101\nfor (i, k) in enumerate(arr):\n\tif k > mx:\n\t\tmx = k\n\t\timax = i\n\tif k < mn:\n\t\tmn = k\n\t\timin = i\nprint(max(imax, len(arr) - 1 - imax, imin, len(arr) - 1 - imin))\n", "n = int(input())\ntp = []\np = list(map(int, input().split()))\nta = p.index(1)\nsa = p.index(n)\ntp.append(abs(ta - (n - 1)))\ntp.append(ta)\ntp.append(abs(sa - (n - 1)))\ntp.append(sa)\nprint(max(tp))\n", "n = int(input())\nelements = list(map(int, input().split()))\nif len(elements) != n:\n\traise ValueError('wrong element number')\nindices = []\nfor (i, element) in enumerate(elements):\n\tif element in (1, n):\n\t\tindices.append(i)\nprint(indices[1] - indices[0] + max(indices[0], n - 1 - indices[1]))\n", "number = int(input()) - 1\nindex = 0\npositions = []\nfor element in input().split():\n\tif int(element) == number + 1:\n\t\tpositions.append(index)\n\telif int(element) == 1:\n\t\tpositions.append(index)\n\tindex += 1\n\tif len(positions) == 2:\n\t\tbreak\npositions.sort()\nanswer = max(positions[0], number - positions[1]) + abs(positions[0] - positions[1])\nprint(answer)\n", "n = int(input())\na = list(map(int, input().split()))\nif n == 2:\n\tprint(1)\nelse:\n\tmaxa = 0\n\tmina = 101\n\tmaxap = 0\n\tminap = 0\n\tfor i in range(n):\n\t\tif a[i] < mina:\n\t\t\tmina = a[i]\n\t\t\tminap = i\n\t\tif a[i] > maxa:\n\t\t\tmaxa = a[i]\n\t\t\tmaxap = i\n\tif abs(minap - maxap) == n - 1:\n\t\tprint(n - 1)\n\telse:\n\t\tprint(max([minap, maxap, abs(n - 1 - maxap), abs(n - 1 - minap)]))\n", "n = input('')\nn = int(n)\narr = input('').split()\nelement1 = 0\nelement2 = 0\nfor i in range(0, n):\n\tx = int(arr[i])\n\tif x is 1:\n\t\telement1 = i\n\tif x is n:\n\t\telement2 = i\n\tif element1 != 0 and element2 != 0:\n\t\tbreak\nif element2 < element1:\n\tm = element1\n\telement1 = element2\n\telement2 = m\nif element1 is 0 or element2 is n - 1:\n\tprint(n - 1)\nelse:\n\td1 = element1\n\td2 = n - 1 - element2\n\tif d1 > d2:\n\t\tprint(element2)\n\telse:\n\t\tprint(n - 1 - element1)\n", "n = int(input())\ndata = list(map(int, input().split()))\nfirstindex = -1\nlastindex = -1\nfor i in range(0, len(data)):\n\tif data[i] == 1:\n\t\tfirstindex = i\n\tif data[i] == n:\n\t\tlastindex = i\nif firstindex < lastindex:\n\tdiff1 = lastindex\n\tdiff2 = n - firstindex - 1\nelse:\n\tdiff1 = firstindex\n\tdiff2 = n - lastindex - 1\nprint(max(diff1, diff2))\n", "n = int(input())\na = [int(x) for x in input().split()]\nl = oi = a.index(1)\nr = ni = a.index(n)\nif l > r:\n\t(l, r) = (r, l)\ndr = n - 1 - r\nif l > dr:\n\tdr = l\nprint(r - l + dr)\n", "n = int(input())\ni1 = i2 = -1\ni = 0\nfor x in map(int, input().split()):\n\ti += 1\n\tif x == 1 or x == n:\n\t\tif i1 < 0:\n\t\t\ti1 = i\n\t\telse:\n\t\t\ti2 = i\nif i1 - 1 <= n - i2:\n\tprint(n - i1)\nelse:\n\tprint(i2 - 1)\n", "t = 1\nwhile t:\n\tt -= 1\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tmini = 101\n\tmaxi = 0\n\tmini_i = 0\n\tmaxi_i = 0\n\tfor i in range(0, n):\n\t\tif l[i] < mini:\n\t\t\tmini = l[i]\n\t\t\tmini_i = i + 1\n\t\tif l[i] > maxi:\n\t\t\tmaxi = l[i]\n\t\t\tmaxi_i = i + 1\n\tans = max(abs(n - maxi_i), abs(n - mini_i))\n\tans = max(ans, abs(1 - mini_i))\n\tans = max(ans, abs(1 - maxi_i))\n\tprint(ans)\n", "p = int(input())\nn = list(map(int, input().split()))\nf = n.index(p)\ns = p - 1 - f\nt = n.index(1)\nc = p - 1 - t\nprint(max(f, s, t, c))\n", "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n\tif a[i] == 1:\n\t\tp1 = i\n\tif a[i] == n:\n\t\tpn = i\nprint(max(abs(p1 - pn), p1, pn, abs(n - 1 - p1), abs(n - 1 - pn)))\n", "n = int(input())\na = list(map(int, input().split()))\nmina = 1000\nmaxa = 0\ni_min = 0\ni_max = 0\nN = n - 1\nfor i in range(n):\n\tif a[i] > maxa:\n\t\ti_max = i\n\t\tmaxa = a[i]\n\tif a[i] < mina:\n\t\ti_min = i\n\t\tmina = a[i]\nif abs(i_max - i_min) == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(i_min, N - i_min, i_max, N - i_max))\n", "n = int(input())\nlst = list(map(int, input().split()))\nmaxPos = lst.index(n)\nminPos = lst.index(1)\nrangeMax = [maxPos, n - 1 - maxPos]\nrangeMin = [minPos, n - 1 - minPos]\nans = max(max(rangeMax), max(rangeMin))\nprint(ans)\n", "n = int(input())\nline = str(input()).split()\nline = [int(it) for it in line]\nmax_ptr = line.index(max(line))\nmin_ptr = line.index(min(line))\nprint(n - 1 - min(min(min_ptr, max_ptr), n - 1 - max(min_ptr, max_ptr)))\n", "n = int(input())\narray = [i for i in map(int, input().split())]\nif array[0] == 1 or array[0] == n or array[n - 1] == 1 or (array[n - 1] == n):\n\tprint(n - 1)\nelse:\n\tresult = 0\n\tfor i in range(n):\n\t\tif array[i] == 1 or array[i] == n:\n\t\t\tresult = max(result, i, n - 1 - i)\n\tprint(result)\n", "n = int(input())\nl = list(map(int, input().split()))\na = min(l)\nb = max(l)\nlist1 = []\nfor i in l:\n\tif i == a or i == b:\n\t\tlist1.append(l.index(i))\nx = list1[0] - 0\ny = n - 1 - list1[1]\nif x > y:\n\tprint(list1[1] - 0)\nelse:\n\tprint(n - 1 - list1[0])\n", "n = int(input())\ncheck = [int(x) for x in input().split()]\nx = min(check)\ny = max(check)\npos_x = check.index(x) + 1\npos_y = check.index(y) + 1\ntemp = pos_y\nmaxdistance = 0\nwhile temp <= n:\n\ttemp += 1\n\tmaxdistance = max(maxdistance, abs(pos_x - temp))\ntemp = pos_y\nwhile temp >= 1:\n\ttemp -= 1\n\tmaxdistance = max(maxdistance, abs(pos_x - temp))\ntemp = pos_x\nwhile temp <= n:\n\ttemp += 1\n\tmaxdistance = max(maxdistance, abs(pos_y - temp))\ntemp = pos_x\nwhile temp >= 1:\n\ttemp -= 1\n\tmaxdistance = max(maxdistance, abs(pos_y - temp))\nprint(maxdistance - 1)\n", "n = int(input())\np = list(map(int, input().split()))\nposmin = p.index(min(p))\nposmax = p.index(max(p))\nif posmin == n - 1 or posmax == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(n - 1 - posmin, n - 1 - posmax, posmin, posmax))\n", "def arr_inp():\n\treturn [int(x) for x in input().split()]\nn = int(input())\na = arr_inp()\n(ix_max, ix_min) = (a.index(max(a)) + 1, a.index(min(a)) + 1)\nsum = abs(ix_max - ix_min)\n(ixs_max, ixs_min) = (max(ix_max, ix_min), min(ix_max, ix_min))\nif sum < n - 1:\n\tsum += max(n - ixs_max, ixs_min - 1)\nprint(sum)\n", "n = int(input())\na = list(map(int, input().split()))\nmx = max(a)\nmn = min(a)\nfor i in range(len(a)):\n\tif a[i] == mn:\n\t\ti_min = i\n\tif a[i] == mx:\n\t\ti_max = i\nprint(max(i_max, i_min, len(a) - i_max - 1, len(a) - i_min - 1))\n", "def main():\n\tn = int(input())\n\tpermu = list(map(int, input().split()))\n\tmax_index = permu.index(max(permu))\n\tmin_index = permu.index(min(permu))\n\tdist = abs(max_index - min_index)\n\tif dist == n - 1:\n\t\tprint(n - 1)\n\telse:\n\t\tprint(max(max_index, min_index, n - 1 - max_index, n - 1 - min_index))\nmain()\n", "n = int(input())\na = list(map(int, input().split()))\nmax_a = a.index(max(a))\nmin_a = a.index(min(a))\nans = max(max_a, n - max_a - 1, min_a, n - min_a - 1)\nprint(ans)\n", "n = int(input())\nnums = [int(x) for x in input().split()]\npos = []\nfor i in range(0, n):\n\tif nums[i] == 1 or nums[i] == n:\n\t\tpos.append(i)\na = max(pos) + 1\nb = min(pos) + 1\nif n - b >= a - 1:\n\tprint(n - b)\nelse:\n\tprint(a - 1)\n", "import sys\nn = int(input())\ninput_str = sys.stdin.readline()\nar = input_str.split()\nfor i in range(len(ar)):\n\tar[i] = int(ar[i])\nfor i in range(n):\n\tif ar[i] == 1:\n\t\tminind = i\n\tif ar[i] == n:\n\t\tmaxind = i\nprint(abs(maxind - minind) + max(n - max(maxind, minind) - 1, min(minind, maxind)))\n", "n = int(input())\nt = n - 1\nl = list(map(int, input().split()))\nmx = max(l)\nmn = min(l)\nidx = l.index(mx)\nidn = l.index(mn)\nprint(max(t - idn, idn, t - idx, idx))\n", "n = int(input())\ninp = list(map(int, input().split()))\none = -1\nlast = -1\nfor i in range(0, len(inp)):\n\tif inp[i] == 1:\n\t\tone = i\n\tif inp[i] == n:\n\t\tlast = i\n\tif one != -1 and last != -1:\n\t\tbreak\nl = [abs(len(inp) - 1 - last), abs(last), abs(one), abs(len(inp) - 1 - one)]\nprint(max(l))\n", "__author__ = 'zihaozhu'\nfrom sys import stdin\ncases = int(stdin.readline())\nnumbers = list(map(int, stdin.readline().split()))\nint1 = 0\nintn = 0\nfor i in range(0, len(numbers)):\n\tif numbers[i] == 1:\n\t\tint1 = i + 1\n\tif numbers[i] == cases:\n\t\tintn = i + 1\nmaxDist = abs(intn - int1)\nif maxDist == cases - 1:\n\tprint(maxDist)\n\texit(0)\nif abs(int1 - 1) > maxDist:\n\tmaxDist = abs(int1 - 1)\nif abs(int1 - cases) > maxDist:\n\tmaxDist = abs(int1 - cases)\nif abs(intn - 1) > maxDist:\n\tmaxDist = abs(intn - 1)\nif abs(intn - cases) > maxDist:\n\tmaxDist = abs(intn - cases)\nprint(maxDist)\n", "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef LI():\n\treturn [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_():\n\treturn [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF():\n\treturn [float(x) for x in sys.stdin.readline().split()]\n\ndef LS():\n\treturn sys.stdin.readline().split()\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef F():\n\treturn float(sys.stdin.readline())\n\ndef S():\n\treturn input()\n\ndef pf(s):\n\treturn print(s, flush=True)\n\ndef main():\n\tn = I()\n\ta = LI()\n\tm1 = a.index(min(a))\n\tm2 = a.index(max(a))\n\tm = sorted([m1, m2])\n\tr = 0\n\tfor c in m:\n\t\tk = min(c, n - c - 1)\n\t\tt = n - k - 1\n\t\tif r < t:\n\t\t\tr = t\n\treturn r\nprint(main())\n", "n = int(input())\na = list(map(int, input().split()))\np1 = a.index(1)\np2 = a.index(n)\nop = min(p1 - 0, n - p1 - 1, p2 - 0, n - p2 - 1)\nprint(n - op - 1)\n", "def answer():\n\ta = int(input())\n\tb = input().split()\n\tb = [int(x) for x in b]\n\tup = max(b)\n\tdown = min(b)\n\tprint(max(len(b) - b.index(up) - 1, len(b) - b.index(down) - 1, b.index(up), b.index(down)))\nanswer()\n", "n = int(input())\ninput1 = input()\nLis = input1.split(' ', n)\nList = []\nfor ele in Lis:\n\tList.append(int(ele))\nmaxValue = max(List)\nminValue = min(List)\nminIndex = List.index(minValue)\nmaxIndex = List.index(maxValue)\nDistance = abs(maxIndex - minIndex)\nDistance1 = []\nDistance2 = []\nif maxIndex - minIndex == n - 1:\n\tprint(n - 1)\nelse:\n\tfor i in range(0, n):\n\t\tDistance1.append(abs(i - maxIndex))\n\t\tDistance2.append(abs(i - minIndex))\n\tif max(Distance1) >= max(Distance2):\n\t\tif max(Distance1) >= Distance:\n\t\t\tprint(max(Distance1))\n\t\telse:\n\t\t\tprint(Distance)\n\telif max(Distance1) < max(Distance2):\n\t\tif max(Distance2) >= Distance:\n\t\t\tprint(max(Distance2))\n\t\telse:\n\t\t\tprint(Distance)\n", "import sys\nn = int(input())\nan = list(map(int, sys.stdin.readline().split()))\nmmin = an[0]\nimin = 0\nmmax = an[0]\nimax = 0\nfor i in range(1, n):\n\tif an[i] > mmax:\n\t\t(mmax, imax) = (an[i], i)\n\telif an[i] < mmin:\n\t\t(mmin, imin) = (an[i], i)\nbig = max(imin, imax)\nsmall = min(imin, imax)\nprint(max(big - 0, n - 1 - small))\n", "n = int(input())\nlst = list(map(int, input().split()))\nmx = lst.index(max(lst))\nmn = lst.index(min(lst))\nif mx < mn:\n\t(mx, mn) = (mn, mx)\na = max(mx, n - 1 - mn)\nprint(a)\n", "n = int(input())\na = list(map(int, input().split()))\nmax_distance = 0\nindex_max = a.index(max(a))\nindex_min = a.index(min(a))\nif index_min < index_max:\n\tif index_min + 1 > n - index_max - 1:\n\t\t(a[0], a[index_min]) = (a[index_min], a[0])\n\telse:\n\t\t(a[-1], a[index_max]) = (a[index_max], a[-1])\nelif index_max + 1 > n - index_min - 1:\n\t(a[0], a[index_max]) = (a[index_max], a[0])\nelse:\n\t(a[-1], a[index_min]) = (a[index_min], a[-1])\nindex_max = a.index(max(a))\nindex_min = a.index(min(a))\nprint(max(index_max, index_min) - min(index_max, index_min))\n", "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n\tif a[i] == 1 or a[i] == n:\n\t\tans = max(ans, i, n - 1 - i)\nprint(ans)\n", "x = int(input())\np = list(map(int, input().split()))\n(k, m) = (p.index(1) + 1, p.index(x) + 1)\nprint(max(abs(k - 1), abs(m - 1), abs(k - x), abs(m - x)))\n", "def nicolas_swap():\n\tlenght = int(input())\n\tarray = input().split()\n\tarray = [int(i) for i in array]\n\tun_swap = False\n\tif int(min(array)) == int(array[-1]):\n\t\tif int(max(array)) == int(array[0]):\n\t\t\tun_swap = True\n\telif int(min(array)) == int(array[0]):\n\t\tif int(max(array)) == int(array[-1]):\n\t\t\tun_swap = True\n\tif un_swap:\n\t\tprint(abs(int(len(array) - 1) - int(0)))\n\telif int(min(array)) == int(array[0]) or int(min(array)) == int(array[-1]):\n\t\tprint(abs(int(len(array) - 1) - int(0)))\n\telif int(max(array)) == int(array[0]) or int(max(array)) == int(array[-1]):\n\t\tprint(abs(int(len(array) - 1) - int(0)))\n\telse:\n\t\tdic = {}\n\t\tdic[int(max(array))] = 0\n\t\tdic[int(min(array))] = 0\n\t\to = 0\n\t\tfor x in range(len(array)):\n\t\t\tif int(array[x]) in dic:\n\t\t\t\tdic[int(array[x])] = x\n\t\t\t\to += 1\n\t\t\tif o == 2:\n\t\t\t\tbreak\n\t\tmaximum = abs(dic[min(dic)] - 0)\n\t\tif abs(dic[min(dic)] - int(len(array) - 1)) > maximum:\n\t\t\tmaximum = abs(dic[min(dic)] - int(len(array) - 1))\n\t\tif abs(dic[max(dic)] - 0) > maximum:\n\t\t\tmaximum = abs(dic[max(dic)] - 0)\n\t\tif abs(dic[max(dic)] - int(len(array) - 1)) > maximum:\n\t\t\tmaximum = abs(dic[max(dic)] - int(len(array) - 1))\n\t\tprint(maximum)\nnicolas_swap()\n", "n = int(input())\na = [int(i) for i in input().split()]\nmind = a.index(1)\nmaxd = a.index(n)\nprint(max(mind, maxd, n - 1 - mind, n - 1 - maxd))\n", "n = int(input())\na = input().split()\nb = 0\nc = 0\nfor i in range(n):\n\tif a[i] == '1':\n\t\tb = i\n\tif a[i] == str(n):\n\t\tc = i\nif c < b:\n\t(b, c) = (c, b)\nprint(max(c, n - b - 1))\n", "n = int(input())\nper = list(map(int, input().split()))\nprint(max(per.index(1), per.index(n), n - per.index(1) - 1, n - per.index(n) - 1))\n", "n = int(input())\nfor i in range(1):\n\tt = [int(x) for x in input().split()]\nx = t.index(1) + 1\ny = t.index(n) + 1\nprint(max(n - x, n - y, x - 1, y - 1))\n", "n = int(input())\nList = [int(x) for x in input().split()]\nMin = List.index(1)\nMax = List.index(n)\nprint(max(abs(n - 1 - Min), abs(n - 1 - Max), Min, Max))\n", "e = int(input())\nt = list(map(int, input().split()))\np = t.index(min(t)) + 1\nq = t.index(max(t)) + 1\ns = []\nfor k in range(1, len(t) + 1):\n\ts.append(abs(k - p))\n\ts.append(abs(k - q))\nprint(max(s))\n", "n = int(input())\na = n\na = list(map(int, input().split()))\na1 = a.index(1)\nan = a.index(n)\nk = 0\nb = a1 - 0\nc = n - 1 - a1\nd = an - 0\ne = n - 1 - an\nif len(a) == 3:\n\tif a.index(1) != 1 and a.index(3) != 1:\n\t\ta = a\n\telif a.index(1) == 1:\n\t\tif a.index(3) == 2:\n\t\t\ta.remove(1)\n\t\t\ta = [1] + a\n\t\telse:\n\t\t\ta.remove(1)\n\t\t\ta.append(1)\n\telif a.index(1) == 0:\n\t\ta.remove(3)\n\t\ta.append(3)\n\telse:\n\t\ta.remove(3)\n\t\ta = [3] + a\nelif len(a) == 2:\n\tprint(1)\nelif len(a) > 3:\n\tif a.index(1) != 0 and a.index(1) != n - 1 and (a.index(n) != 0) and (a.index(n) != n - 1):\n\t\tif b > c and b > d and (b > e):\n\t\t\ta.remove(n)\n\t\t\ta = [n] + a\n\t\telif c > b and c > d and (c > e):\n\t\t\ta.remove(n)\n\t\t\ta.append(n)\n\t\telif d > c and d > b and (d > e):\n\t\t\ta.remove(1)\n\t\t\ta = [1] + a\n\t\telif e > c and e > d and (e > b):\n\t\t\ta.remove(1)\n\t\t\ta.append(1)\n\t\telif c == d and c > e and (c > b) and (d > e) and (d > b):\n\t\t\ta.remove(n)\n\t\t\ta.append(n)\n\t\telif b == e and b > c and (b > d) and (e > c) and (e > d):\n\t\t\ta.remove(1)\n\t\t\ta.append(1)\n\telif a.index(1) == 0:\n\t\ta.remove(n)\n\t\ta.append(n)\n\telif a.index(1) == n - 1:\n\t\ta.remove(n)\n\t\ta = [n] + a\n\telif a.index(n) == 0:\n\t\ta.remove(1)\n\t\ta.append(1)\n\telif a.index(n) == n - 1:\n\t\ta.remove(1)\n\t\ta = [1] + a\nq = a.index(1)\nw = a.index(n)\nif len(a) != 2:\n\tif q > w:\n\t\tprint(q - w)\n\telse:\n\t\tprint(w - q)\n", "n = int(input())\na = list(map(int, input().split(' ')))\n(amax, amin) = (a.index(max(a)), a.index(min(a)))\nprint(max(amax, amin, n - 1 - amin, n - 1 - amax))\n", "n = int(input())\ns = input().split()\na = []\nfor i in range(n):\n\ta.append(int(s[i]))\n(q, w) = (a.index(1) + 1, a.index(n) + 1)\nprint(max(abs(q - n), abs(q - 1), abs(w - n), abs(w - 1)))\n", "n = int(input())\nL = list(map(int, input().split()))\nma = L.index(n)\nmi = L.index(1)\nif n == 2:\n\tprint(1)\nelse:\n\tprint(n - 1 - min(ma, mi, n - 1 - ma, n - 1 - mi))\n", "n = int(input())\narr = list(map(int, input().split()))\n(l, r) = (arr.index(min(arr)) + 1, arr.index(max(arr)) + 1)\nprint(max(l - 1, r - 1, n - l, n - r))\n", "n = int(input())\nl = list(map(int, input().split()))\nmin_element = 1\nmax_element = n\nmin_index = l.index(min_element)\nmax_index = l.index(max_element)\nif min_index < max_index:\n\tif min_index > n - max_index - 1:\n\t\tprint(max_index)\n\telse:\n\t\tprint(n - min_index - 1)\nelif max_index > n - min_index - 1:\n\tprint(min_index)\nelse:\n\tprint(n - max_index - 1)\n", "n = int(input())\nnumbers = input().split()\nindex_1 = numbers.index('1')\nindex_n = numbers.index(str(n))\nresult = abs(index_n - index_1)\nif result != n - 1:\n\t(left, right) = (index_1, index_n) if index_1 < index_n else (index_n, index_1)\n\tresult += max(left, n - right - 1)\nprint(result)\n", "n = int(input())\nmas = list(map(int, input().split()))\nfor i in range(n):\n\tif mas[i] == 1:\n\t\tn_min = i\n\tif mas[i] == n:\n\t\tn_max = i\nprint(max(n_max - n_min, n_max, n_min, n - 1 - n_min, n - 1 - n_max, n_min - n_max))\n", "import sys\nn = int(input())\na = list(map(int, sys.stdin.readline().split()))\ni = 0\nwhile a[i] != 1:\n\ti += 1\nj = 0\nwhile a[j] != n:\n\tj += 1\nif a[n - 1] == n or a[n - 1] == 1 or a[0] == n or (a[0] == 1):\n\tprint(n - 1)\nelse:\n\tprint(max(max(n - j - 1, j), max(n - i - 1, i)))\n", "n = int(input())\narr = list(map(int, input().split()))\n(x, y) = (min(arr), max(arr))\nif arr.index(x) == 0 or arr.index(y) == 0 or arr.index(x) == n - 1 or (arr.index(y) == n - 1):\n\tprint(n - 1)\nelif arr.index(x) < arr.index(y):\n\tprint(max(n - 1 - arr.index(x), arr.index(y)))\nelif arr.index(x) > arr.index(y):\n\tprint(max(n - 1 - arr.index(y), arr.index(x)))\n", "n = int(input())\nl = list(map(int, input().split()))\nif l[0] == 1 and l[-1] == n or (l[0] == n and l[-1] == 1):\n\tprint(n - 1)\nelse:\n\ta = l.index(1)\n\tb = l.index(n)\n\tprint(max(a, b, abs(n - 1 - b), abs(n - 1 - a)))\n", "N = int(input())\nA = list(map(int, input().split()))\nmini = A.index(1)\nmaxi = A.index(N)\nans = -1\nans = max(ans, abs(mini - 0))\nans = max(ans, abs(mini - N + 1))\nans = max(ans, abs(maxi - 0))\nans = max(ans, abs(maxi - N + 1))\nprint(ans)\n", "c = []\nz = int(input())\nx = list(map(int, input().split()))\nc.append(x.index(max(x)) + 1)\nc.append(x.index(min(x)) + 1)\nc.sort()\nprint(['%d' % (c[1] - 1), '%d' % (z - c[0])][z - c[0] >= c[1] - 1])\n", "n = int(input())\narr = [int(i) for i in input().split(' ')]\nidx1 = arr.index(1)\nidx2 = arr.index(n)\nprint(max(idx1, n - 1 - idx1, idx2, n - 1 - idx2))\n", "n = int(input())\ntheperm = list((int(x) for x in input().split()))\nfirstpos = theperm.index(1) + 1\nlastpos = theperm.index(n) + 1\nprint(max(n - firstpos, n - lastpos, firstpos - 1, lastpos - 1))\n", "n = int(input())\na = list(map(int, input().split(' ')))\nm = max(a)\nmi = min(a)\ni = a.index(m)\nj = a.index(mi)\nr = 0\nif i < j:\n\tc = n - i - 1\n\ts = j\n\tr = max(c, s)\nelse:\n\tc = n - j - 1\n\ts = i\n\tr = max(c, s)\nprint(r)\n", "n = int(input()) - 1\ns = [int(i) for i in input().split()]\nind1 = s.index(1)\nindn = s.index(n + 1)\nprinte = [abs(ind1 - indn), n - ind1, n - indn, ind1, indn]\nif (ind1 or indn) == (0 or n):\n\tprint(n)\nelse:\n\tprint(max(printe))\n", "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n\tif a[i] == 1:\n\t\tpos1 = i + 1\n\tif a[i] == n:\n\t\tposn = i + 1\nres = max(posn - 1, n - posn, pos1 - 1, n - pos1)\nprint(res)\n", "n = int(input())\narr = list(map(int, input().split()))\nminimum = n + 1\nmaximum = 1 - 1\nindexMax = -1\nindexMin = -1\nk = n // 2\nfor i in range(k):\n\tif arr[i] > maximum:\n\t\tmaximum = arr[i]\n\t\tindexMax = i\n\tif arr[i] < minimum:\n\t\tminimum = arr[i]\n\t\tindexMin = i\n\tif arr[n - 1 - i] > maximum:\n\t\tmaximum = arr[n - 1 - i]\n\t\tindexMax = n - 1 - i\n\tif arr[n - 1 - i] < minimum:\n\t\tminimum = arr[n - 1 - i]\n\t\tindexMin = n - 1 - i\nif n % 2 != 0:\n\tif arr[k] > maximum:\n\t\tmaximum = arr[k]\n\t\tindexMax = k\n\tif arr[k] < minimum:\n\t\tminimum = arr[k]\n\t\tindexMin = k\nleft = min(indexMin, indexMax)\nright = max(indexMin, indexMax)\nif n - 1 - left > right:\n\tprint(n - 1 - left)\nelse:\n\tprint(right)\n", "n = int(input())\na = list(map(int, input().split()))\nl = a.index(1)\nr = a.index(n)\nif l > r:\n\tprint(max(n - 1 - r, l - 0))\nelse:\n\tprint(max(n - 1 - l, r - 0))\n", "n = int(input())\nl = list(map(int, input().split()))\n(k, h) = (l.index(max(l)), l.index(min(l)))\nprint([k - h + max(n - k - 1, h), h - k + max(n - h - 1, k)][k < h])\n", "n = int(input())\nl = list(map(int, input().split()))\n(i, j) = (l.index(1), l.index(n))\nprint(max(i, j, n - i - 1, n - j - 1))\n", "n = int(input())\na = list(map(int, input().split()))\n(i, j) = (a.index(1) + 1, a.index(n) + 1)\nif abs(i - j) == n - 1:\n\tprint(n - 1)\nelse:\n\tprint(max(n - i, i - 1, n - j, j - 1))\n", "n = int(input())\nai = list(map(int, input().split()))\nmini = 0\nmaxi = 0\nfor i in range(n):\n\tif ai[i] == n:\n\t\tmaxi = i\n\tif ai[i] == 1:\n\t\tmini = i\nprint(max(maxi, mini, n - maxi - 1, n - mini - 1))\n", "arr_size = int(input())\narray = list(map(int, input().split()))\nmin_index = array.index(min(array))\nmax_index = array.index(max(array))\nlast = arr_size - 1\nmin_to_start = abs(max_index - 0)\nmin_to_end = abs(last - max_index)\nmax_to_start = abs(min_index - 0)\nmax_to_end = abs(last - min_index)\nmax_dis = max(min_to_start, min_to_end, max_to_start, max_to_end)\nprint(max_dis)\n", "n = int(input())\na = [int(i) for i in input().split()]\npos_min = a.index(min(a))\npos_max = a.index(max(a))\nprint(max(pos_min, pos_max, n - 1 - pos_min, n - 1 - pos_max))\n", "n = int(input())\na = [int(_) for _ in input().split()]\ni1 = a.index(1)\ni2 = a.index(n)\nprint(max(abs(n - i1 - 1), abs(i1), abs(i2), abs(n - i2 - 1)))\n", "n = int(input())\nl = list(map(int, input().split()))\np1 = l.index(1)\np2 = l.index(n)\nd1 = abs(p1 - p2)\np2 = n - 1\nd2 = abs(p1 - p2)\np2 = 0\nd3 = abs(p1 - p2)\np2 = l.index(n)\np1 = n - 1\nd4 = abs(p1 - p2)\np1 = 0\nd5 = abs(p1 - p2)\nprint(max(d1, d2, d3, d4, d5))\n", "n = int(input())\nl = list(map(int, input().split()))\nx = l.index(1)\ny = l.index(n)\nif abs(x - y) == n - 1:\n\tprint(n - 1)\nelse:\n\tif x < y:\n\t\tp = x\n\t\tq = n - y - 1\n\telse:\n\t\tp = n - x - 1\n\t\tq = y\n\tz = max(p, q)\n\tprint(z + abs(y - x))\n", "(n, a) = (int(input()), list(map(int, input().split())))\n(*b,) = reversed(a)\nprint(max(len(a) - min(a.index(n), a.index(1)) - 1, len(b) - min(b.index(n), b.index(1)) - 1))\n", "n = int(input())\nl = list(map(int, input().split()))\nidx_min = l.index(1)\nidx_max = l.index(n)\narr = []\narr.append(abs(0 - idx_max))\narr.append(abs(n - 1 - idx_max))\narr.append(abs(0 - idx_min))\narr.append(abs(n - 1 - idx_min))\nprint(max(arr))\n", "n = int(input())\nls = list(map(int, input().split()))\nminin = ls.index(min(ls))\nmaxin = ls.index(max(ls))\nls2 = ls[:]\nif maxin > minin:\n\ttemp = ls[-1]\n\tls[-1] = max(ls)\n\tls[maxin] = temp\nelse:\n\ttemp = ls[-1]\n\tls[-1] = min(ls)\n\tls[minin] = temp\nminin = ls.index(min(ls))\nmaxin = ls.index(max(ls))\nresult1 = abs(maxin - minin)\nif maxin < minin:\n\ttemp = ls2[0]\n\tls2[0] = max(ls2)\n\tls2[maxin] = temp\nelse:\n\ttemp = ls2[0]\n\tls2[0] = min(ls2)\n\tls2[minin] = temp\nminin = ls2.index(min(ls2))\nmaxin = ls2.index(max(ls2))\nresult2 = abs(maxin - minin)\nif result1 > result2:\n\tprint(result1)\nelse:\n\tprint(result2)\n", "n = int(input())\na = list(map(int, input().split()))\np1 = a.index(1)\np2 = a.index(n)\nprint(max(abs(n - 1 - p1), abs(n - 1 - p2), abs(p1), abs(p2)))\n", "import math\nfrom operator import itemgetter\n\ndef get_primes(prime_supr):\n\tis_prime = [0] * 2 + [1] * prime_supr\n\tfor i in range(2, int(math.sqrt(prime_supr)) + 1):\n\t\tif is_prime[i]:\n\t\t\tfor j in range(i * i, prime_supr + 1, i):\n\t\t\t\tis_prime[j] = 0\n\treturn is_prime\nget_int = lambda : map(int, input().split())\nn = int(input())\na = list(get_int())\nprint(n - 1 - min(min(a.index(1), n - 1 - a.index(1)), min(a.index(n), n - 1 - a.index(n))))\n", "n = int(input())\nlst = list(map(int, input().split()))\nx = lst.index(max(lst))\ny = lst.index(min(lst))\na = x\nb = n - 1 - x\nc = y\nd = n - 1 - y\nprint(max(a, b, c, d))\n", "n = int(input())\nlst = list(map(lambda s: int(s), input().split(' ')))\n\ndef solve1(n, lst):\n\tfor (i, elm) in enumerate(lst):\n\t\tif elm == 1:\n\t\t\tpos_min = i\n\t\tif elm == n:\n\t\t\tpos_max = i\n\tpos_min = min(n - 1 - pos_min, pos_min)\n\tpos_max = min(n - 1 - pos_max, pos_max)\n\treturn n - 1 - min(pos_min, pos_max)\nprint(solve1(n, lst))\n", "n = int(input())\nl = list(map(int, input().split()))\nma = max(l)\nmi = min(l)\n(x, y) = (-1, -1)\nfor i in range(n):\n\tif l[i] == ma:\n\t\tx = i + 1\n\tif l[i] == mi:\n\t\ty = i + 1\n(x, y) = (max(x, y), min(x, y))\na = max(x - 1, n - y)\nprint(max(a, x - y))\n", "n = int(input())\na = list(map(int, input().split()))\nmaxLocate = a.index(n)\nminLocate = a.index(1)\ndistanceMax = len(a) - 1 - a.index(n)\ndistanceMin = len(a) - 1 - a.index(1)\nprint(max(maxLocate, minLocate, distanceMax, distanceMin))\n", "n = int(input().strip())\na = [int(x) for x in input().strip().split()]\nif n == 2:\n\tprint(1)\nelif n == 3:\n\tprint(2)\nelse:\n\tm = a.index(min(a))\n\tM = a.index(max(a))\n\td1 = min(m, M)\n\td2 = n - max(m, M) - 1\n\tprint(max(n - d2 - 1, n - d1 - 1))\n", "def f(n):\n\tz = n.index(max(n))\n\tzz = n.index(min(n))\n\treturn abs(z - zz)\nn = int(input())\na = [int(i) for i in input().split()]\nb = a[:]\nc = a[:]\nd = a[:]\nzzz = a.index(max(a))\nzzzz = a.index(min(a))\n(a[0], a[zzz]) = (a[zzz], a[0])\n(b[0], b[zzzz]) = (b[zzzz], b[0])\n(c[-1], c[zzzz]) = (c[zzzz], c[-1])\n(d[-1], d[zzz]) = (d[zzz], d[-1])\nprint(max([f(a), f(b), f(c), f(d)]))\n"], "public_test_cases": [{"input": "5\n4 5 1 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "7\n1 6 5 3 4 7 2\n", "output": "6\n", "type": "stdin"}, {"input": "6\n6 5 4 3 2 1\n", "output": "5\n", "type": "stdin"}], "test_cases": [{"input": "5\n4 5 1 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "7\n1 6 5 3 4 7 2\n", "output": "6\n", "type": "stdin"}, {"input": "6\n6 5 4 3 2 1\n", "output": "5\n", "type": "stdin"}, {"input": "2\n1 2\n", "output": "1\n", "type": "stdin"}, {"input": "2\n2 1\n", "output": "1\n", "type": "stdin"}, {"input": "3\n2 3 1\n", "output": "2\n", "type": "stdin"}, {"input": "4\n4 1 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "5\n1 4 5 2 3\n", "output": "4\n", "type": "stdin"}, {"input": "6\n4 6 3 5 2 1\n", "output": "5\n", "type": "stdin"}, {"input": "7\n1 5 3 6 2 4 7\n", "output": "6\n", "type": "stdin"}, {"input": "100\n76 70 67 54 40 1 48 63 64 36 42 90 99 27 47 17 93 7 13 84 16 57 74 5 83 61 19 56 52 92 38 91 82 79 34 66 71 28 37 98 35 94 77 53 73 10 26 80 15 32 8 81 3 95 44 46 72 6 33 11 21 85 4 30 24 51 49 96 87 55 14 31 12 60 45 9 29 22 58 18 88 2 50 59 20 86 23 41 100 39 62 68 69 97 78 43 25 89 65 75\n", "output": "94\n", "type": "stdin"}, {"input": "8\n4 5 3 8 6 7 1 2\n", "output": "6\n", "type": "stdin"}, {"input": "9\n6 8 5 3 4 7 9 2 1\n", "output": "8\n", "type": "stdin"}, {"input": "10\n8 7 10 1 2 3 4 6 5 9\n", "output": "7\n", "type": "stdin"}, {"input": "11\n5 4 6 9 10 11 7 3 1 2 8\n", "output": "8\n", "type": "stdin"}, {"input": "12\n3 6 7 8 9 10 12 5 4 2 11 1\n", "output": "11\n", "type": "stdin"}, {"input": "13\n8 4 3 7 5 11 9 1 10 2 13 12 6\n", "output": "10\n", "type": "stdin"}, {"input": "14\n6 10 13 9 7 1 12 14 3 2 5 4 11 8\n", "output": "8\n", "type": "stdin"}, {"input": "15\n3 14 13 12 7 2 4 11 15 1 8 6 5 10 9\n", "output": "9\n", "type": "stdin"}, {"input": "16\n11 6 9 8 7 14 12 13 10 15 2 5 3 1 4 16\n", "output": "15\n", "type": "stdin"}, {"input": "17\n13 12 5 3 9 16 8 14 2 4 10 1 6 11 7 15 17\n", "output": "16\n", "type": "stdin"}, {"input": "18\n8 6 14 17 9 11 15 13 5 3 18 1 2 7 12 16 4 10\n", "output": "11\n", "type": "stdin"}, {"input": "19\n12 19 3 11 15 6 18 14 5 10 2 13 9 7 4 8 17 16 1\n", "output": "18\n", "type": "stdin"}, {"input": "20\n15 17 10 20 7 2 16 9 13 6 18 5 19 8 11 14 4 12 3 1\n", "output": "19\n", "type": "stdin"}, {"input": "21\n1 9 14 18 13 12 11 20 16 2 4 19 15 7 6 17 8 5 3 10 21\n", "output": "20\n", "type": "stdin"}, {"input": "22\n8 3 17 4 16 21 14 11 10 15 6 18 13 12 22 20 5 2 9 7 19 1\n", "output": "21\n", "type": "stdin"}, {"input": "23\n1 23 11 20 9 3 12 4 7 17 5 15 2 10 18 16 8 22 14 13 19 21 6\n", "output": "22\n", "type": "stdin"}, {"input": "24\n2 10 23 22 20 19 18 16 11 12 15 17 21 8 24 13 1 5 6 7 14 3 9 4\n", "output": "16\n", "type": "stdin"}, {"input": "25\n12 13 22 17 1 18 14 5 21 2 10 4 3 23 11 6 20 8 24 16 15 19 9 7 25\n", "output": "24\n", "type": "stdin"}, {"input": "26\n6 21 20 16 26 17 11 2 24 4 1 12 14 8 25 7 15 10 22 5 13 18 9 23 19 3\n", "output": "21\n", "type": "stdin"}, {"input": "27\n20 14 18 10 5 3 9 4 24 22 21 27 17 15 26 2 23 7 12 11 6 8 19 25 16 13 1\n", "output": "26\n", "type": "stdin"}, {"input": "28\n28 13 16 6 1 12 4 27 22 7 18 3 21 26 25 11 5 10 20 24 19 15 14 8 23 17 9 2\n", "output": "27\n", "type": "stdin"}, {"input": "29\n21 11 10 25 2 5 9 16 29 8 17 4 15 13 6 22 7 24 19 12 18 20 1 3 23 28 27 14 26\n", "output": "22\n", "type": "stdin"}, {"input": "30\n6 19 14 22 26 17 27 8 25 3 24 30 4 18 23 16 9 13 29 20 15 2 5 11 28 12 1 10 21 7\n", "output": "26\n", "type": "stdin"}, {"input": "31\n29 13 26 27 9 28 2 16 30 21 12 11 3 31 23 6 22 20 1 5 14 24 19 18 8 4 10 17 15 25 7\n", "output": "18\n", "type": "stdin"}, {"input": "32\n15 32 11 3 18 23 19 14 5 8 6 21 13 24 25 4 16 9 27 20 17 31 2 22 7 12 30 1 26 10 29 28\n", "output": "30\n", "type": "stdin"}, {"input": "33\n22 13 10 33 8 25 15 14 21 28 27 19 26 24 1 12 5 11 32 20 30 31 18 4 6 23 7 29 16 2 17 9 3\n", "output": "29\n", "type": "stdin"}, {"input": "34\n34 30 7 16 6 1 10 23 29 13 15 25 32 26 18 11 28 3 14 21 19 5 31 33 4 17 8 9 24 20 27 22 2 12\n", "output": "33\n", "type": "stdin"}, {"input": "35\n24 33 20 8 34 11 31 25 2 4 18 13 9 35 16 30 23 32 17 1 14 22 19 21 28 26 3 15 5 12 27 29 10 6 7\n", "output": "21\n", "type": "stdin"}, {"input": "36\n1 32 27 35 22 7 34 15 18 36 31 28 13 2 10 21 20 17 16 4 3 24 19 29 11 12 25 5 33 26 14 6 9 23 30 8\n", "output": "35\n", "type": "stdin"}, {"input": "37\n24 1 12 23 11 6 30 15 4 21 13 20 25 17 5 8 36 19 32 26 14 9 7 18 10 29 37 35 16 2 22 34 3 27 31 33 28\n", "output": "35\n", "type": "stdin"}, {"input": "38\n9 35 37 28 36 21 10 25 19 4 26 5 22 7 27 18 6 14 15 24 1 17 11 34 20 8 2 16 3 23 32 31 13 12 38 33 30 29\n", "output": "34\n", "type": "stdin"}, {"input": "39\n16 28 4 33 26 36 25 23 22 30 27 7 12 34 17 6 3 38 10 24 13 31 29 39 14 32 9 20 35 11 18 21 8 2 15 37 5 19 1\n", "output": "38\n", "type": "stdin"}, {"input": "40\n35 39 28 11 9 31 36 8 5 32 26 19 38 33 2 22 23 25 6 37 12 7 3 10 17 24 20 16 27 4 34 15 40 14 18 13 29 21 30 1\n", "output": "39\n", "type": "stdin"}, {"input": "41\n24 18 7 23 3 15 1 17 25 5 30 10 34 36 2 14 9 21 41 40 20 28 33 35 12 22 11 8 19 16 31 27 26 32 29 4 13 38 37 39 6\n", "output": "34\n", "type": "stdin"}, {"input": "42\n42 15 24 26 4 34 19 29 38 32 31 33 14 41 21 3 11 39 25 6 5 20 23 10 16 36 18 28 27 1 7 40 22 30 9 2 37 17 8 12 13 35\n", "output": "41\n", "type": "stdin"}, {"input": "43\n43 24 20 13 22 29 28 4 30 3 32 40 31 8 7 9 35 27 18 5 42 6 17 19 23 12 41 21 16 37 33 34 2 14 36 38 25 10 15 39 26 11 1\n", "output": "42\n", "type": "stdin"}, {"input": "44\n4 38 6 40 29 3 44 2 30 35 25 36 34 10 11 31 21 7 14 23 37 19 27 18 5 22 1 16 17 9 39 13 15 32 43 8 41 26 42 12 24 33 20 28\n", "output": "37\n", "type": "stdin"}, {"input": "45\n45 29 24 2 31 5 34 41 26 44 33 43 15 3 4 11 21 37 27 12 14 39 23 42 16 6 13 19 8 38 20 9 25 22 40 17 32 35 18 10 28 7 30 36 1\n", "output": "44\n", "type": "stdin"}, {"input": "46\n29 3 12 33 45 40 19 17 25 27 28 1 16 23 24 46 31 8 44 15 5 32 22 11 4 36 34 10 35 26 21 7 14 2 18 9 20 41 6 43 42 37 38 13 39 30\n", "output": "34\n", "type": "stdin"}, {"input": "47\n7 3 8 12 24 16 29 10 28 38 1 20 37 40 21 5 15 6 45 23 36 44 25 43 41 4 11 42 18 35 32 31 39 33 27 30 22 34 14 13 17 47 19 9 46 26 2\n", "output": "41\n", "type": "stdin"}, {"input": "48\n29 26 14 18 34 33 13 39 32 1 37 20 35 19 28 48 30 23 46 27 5 22 24 38 12 15 8 36 43 45 16 47 6 9 31 40 44 17 2 41 11 42 25 4 21 3 10 7\n", "output": "38\n", "type": "stdin"}, {"input": "49\n16 7 42 32 11 35 15 8 23 41 6 20 47 24 9 45 49 2 37 48 25 28 5 18 3 19 12 4 22 33 13 14 10 36 44 17 40 38 30 26 1 43 29 46 21 34 27 39 31\n", "output": "40\n", "type": "stdin"}, {"input": "50\n31 45 3 34 13 43 32 4 42 9 7 8 24 14 35 6 19 46 44 17 18 1 25 20 27 41 2 16 12 10 11 47 38 21 28 49 30 15 50 36 29 26 22 39 48 5 23 37 33 40\n", "output": "38\n", "type": "stdin"}, {"input": "51\n47 29 2 11 43 44 27 1 39 14 25 30 33 21 38 45 34 51 16 50 42 31 41 46 15 48 13 19 6 37 35 7 22 28 20 4 17 10 5 8 24 40 9 36 18 49 12 26 23 3 32\n", "output": "43\n", "type": "stdin"}, {"input": "52\n16 45 23 7 15 19 43 20 4 32 35 36 9 50 5 26 38 46 13 33 12 2 48 37 41 31 10 28 8 42 3 21 11 1 17 27 34 30 44 40 6 51 49 47 25 22 18 24 52 29 14 39\n", "output": "48\n", "type": "stdin"}, {"input": "53\n53 30 50 22 51 31 32 38 12 7 39 43 1 23 6 8 24 52 2 21 34 13 3 35 5 15 19 11 47 18 9 20 29 4 36 45 27 41 25 48 16 46 44 17 10 14 42 26 40 28 33 37 49\n", "output": "52\n", "type": "stdin"}, {"input": "54\n6 39 17 3 45 52 16 21 23 48 42 36 13 37 46 10 43 27 49 7 38 32 31 30 15 25 2 29 8 51 54 19 41 44 24 34 22 5 20 14 12 1 33 40 4 26 9 35 18 28 47 50 11 53\n", "output": "41\n", "type": "stdin"}, {"input": "55\n26 15 31 21 32 43 34 51 7 12 5 44 17 54 18 25 48 47 20 3 41 24 45 2 11 22 29 39 37 53 35 28 36 9 50 10 30 38 19 13 4 8 27 1 42 6 49 23 55 40 33 16 46 14 52\n", "output": "48\n", "type": "stdin"}, {"input": "56\n6 20 38 46 10 11 40 19 5 1 47 33 4 18 32 36 37 45 56 49 48 52 12 26 31 14 2 9 24 3 16 51 41 43 23 17 34 7 29 50 55 25 39 44 22 27 54 8 28 35 30 42 13 53 21 15\n", "output": "46\n", "type": "stdin"}, {"input": "57\n39 28 53 36 3 6 12 56 55 20 50 19 43 42 18 40 24 52 38 17 33 23 22 41 14 7 26 44 45 16 35 1 8 47 31 5 30 51 32 4 37 25 13 34 54 21 46 10 15 11 2 27 29 48 49 9 57\n", "output": "56\n", "type": "stdin"}, {"input": "58\n1 26 28 14 22 33 57 40 9 42 44 37 24 19 58 12 48 3 34 31 49 4 16 47 55 52 27 23 46 18 20 32 56 6 39 36 41 38 13 43 45 21 53 54 29 17 5 10 25 30 2 35 11 7 15 51 8 50\n", "output": "57\n", "type": "stdin"}, {"input": "59\n1 27 10 37 53 9 14 49 46 26 50 42 59 11 47 15 24 56 43 45 44 38 5 8 58 30 52 12 23 32 22 3 31 41 2 25 29 6 54 16 35 33 18 55 4 51 57 28 40 19 13 21 7 39 36 48 34 17 20\n", "output": "58\n", "type": "stdin"}, {"input": "60\n60 27 34 32 54 55 33 12 40 3 47 44 50 39 38 59 11 25 17 15 16 30 21 31 10 52 5 23 4 48 6 26 36 57 14 22 8 56 58 9 24 7 37 53 42 43 20 49 51 19 2 46 28 18 35 13 29 45 41 1\n", "output": "59\n", "type": "stdin"}, {"input": "61\n61 11 26 29 31 40 32 30 35 3 18 52 9 53 42 4 50 54 20 58 28 49 22 12 2 19 16 15 57 34 51 43 7 17 25 41 56 47 55 60 46 14 44 45 24 27 33 1 48 13 59 23 38 39 6 5 36 10 8 37 21\n", "output": "60\n", "type": "stdin"}, {"input": "62\n21 23 34 38 11 61 55 30 37 48 54 51 46 47 6 56 36 49 1 35 12 28 29 20 43 42 5 8 22 57 44 4 53 10 58 33 27 25 16 45 50 40 18 15 3 41 39 2 7 60 59 13 32 24 52 31 14 9 19 26 17 62\n", "output": "61\n", "type": "stdin"}, {"input": "63\n2 5 29 48 31 26 21 16 47 24 43 22 61 28 6 39 60 27 14 52 37 7 53 8 62 56 63 10 50 18 44 13 4 9 25 11 23 42 45 41 59 12 32 36 40 51 1 35 49 54 57 20 19 34 38 46 33 3 55 15 30 58 17\n", "output": "46\n", "type": "stdin"}, {"input": "64\n23 5 51 40 12 46 44 8 64 31 58 55 45 24 54 39 21 19 52 61 30 42 16 18 15 32 53 22 28 26 11 25 48 56 27 9 29 41 35 49 59 38 62 7 34 1 20 33 60 17 2 3 43 37 57 14 6 36 13 10 50 4 63 47\n", "output": "55\n", "type": "stdin"}, {"input": "65\n10 11 55 43 53 25 35 26 16 37 41 38 59 21 48 2 65 49 17 23 18 30 62 36 3 4 47 15 28 63 57 54 31 46 44 12 51 7 29 13 56 52 14 22 39 19 8 27 45 5 6 34 32 61 20 50 9 24 33 58 60 40 1 42 64\n", "output": "62\n", "type": "stdin"}, {"input": "66\n66 39 3 2 55 53 60 54 12 49 10 30 59 26 32 46 50 56 7 13 43 36 24 28 11 8 6 21 35 25 42 57 23 45 64 5 34 61 27 51 52 9 15 1 38 17 63 48 37 20 58 14 47 19 22 41 31 44 33 65 4 62 40 18 16 29\n", "output": "65\n", "type": "stdin"}, {"input": "67\n66 16 2 53 35 38 49 28 18 6 36 58 21 47 27 5 50 62 44 12 52 37 11 56 15 31 25 65 17 29 59 41 7 42 4 43 39 10 1 40 24 13 20 54 19 67 46 60 51 45 64 30 8 33 26 9 3 22 34 23 57 48 55 14 63 61 32\n", "output": "45\n", "type": "stdin"}, {"input": "68\n13 6 27 21 65 23 59 14 62 43 33 31 38 41 67 20 16 25 42 4 28 40 29 9 64 17 2 26 32 58 60 53 46 48 47 54 44 50 39 19 30 57 61 1 11 18 37 24 55 15 63 34 8 52 56 7 10 12 35 66 5 36 45 49 68 22 51 3\n", "output": "64\n", "type": "stdin"}, {"input": "69\n29 49 25 51 21 35 11 61 39 54 40 37 60 42 27 33 59 53 34 10 46 2 23 69 8 47 58 36 1 38 19 12 7 48 13 3 6 22 18 5 65 24 50 41 66 44 67 57 4 56 62 43 9 30 14 15 28 31 64 26 16 55 68 17 32 20 45 52 63\n", "output": "45\n", "type": "stdin"}, {"input": "70\n19 12 15 18 36 16 61 69 24 7 11 13 3 48 55 21 37 17 43 31 41 22 28 32 27 63 38 49 59 56 30 25 67 51 52 45 50 44 66 57 26 60 5 46 33 6 23 34 8 40 2 68 14 39 65 64 62 42 47 54 10 53 9 1 70 58 20 4 29 35\n", "output": "64\n", "type": "stdin"}, {"input": "71\n40 6 62 3 41 52 31 66 27 16 35 5 17 60 2 15 51 22 67 61 71 53 1 64 8 45 28 18 50 30 12 69 20 26 10 37 36 49 70 32 33 11 57 14 9 55 4 58 29 25 44 65 39 48 24 47 19 46 56 38 34 42 59 63 54 23 7 68 43 13 21\n", "output": "50\n", "type": "stdin"}, {"input": "72\n52 64 71 40 32 10 62 21 11 37 38 13 22 70 1 66 41 50 27 20 42 47 25 68 49 12 15 72 44 60 53 5 23 14 43 29 65 36 51 54 35 67 7 19 55 48 58 46 39 24 33 30 61 45 57 2 31 3 18 59 6 9 4 63 8 16 26 34 28 69 17 56\n", "output": "57\n", "type": "stdin"}, {"input": "73\n58 38 47 34 39 64 69 66 72 57 9 4 67 22 35 13 61 14 28 52 56 20 31 70 27 24 36 1 62 17 10 5 12 33 16 73 18 49 63 71 44 65 23 30 40 8 50 46 60 25 11 26 37 55 29 68 42 2 3 32 59 7 15 43 41 48 51 53 6 45 54 19 21\n", "output": "45\n", "type": "stdin"}, {"input": "74\n19 51 59 34 8 40 42 55 65 16 74 26 49 63 64 70 35 72 7 12 43 18 61 27 47 31 13 32 71 22 25 67 9 1 48 50 33 10 21 46 11 45 17 37 28 60 69 66 38 2 30 3 39 15 53 68 57 41 6 36 24 73 4 23 5 62 44 14 20 29 52 54 56 58\n", "output": "63\n", "type": "stdin"}, {"input": "75\n75 28 60 19 59 17 65 26 32 23 18 64 8 62 4 11 42 16 47 5 72 46 9 1 25 21 2 50 33 6 36 68 30 12 20 40 53 45 34 7 37 39 38 44 63 61 67 3 66 51 29 73 24 57 70 27 10 56 22 55 13 49 35 15 54 41 14 74 69 48 52 31 71 43 58\n", "output": "74\n", "type": "stdin"}, {"input": "76\n1 47 54 17 38 37 12 32 14 48 43 71 60 56 4 13 64 41 52 57 62 24 23 49 20 10 63 3 25 66 59 40 58 33 53 46 70 7 35 61 72 74 73 19 30 5 29 6 15 28 21 27 51 55 50 9 65 8 67 39 76 42 31 34 16 2 36 11 26 44 22 45 75 18 69 68\n", "output": "75\n", "type": "stdin"}, {"input": "77\n10 20 57 65 53 69 59 45 58 32 28 72 4 14 1 33 40 47 7 5 51 76 37 16 41 61 42 2 21 26 38 74 35 64 43 77 71 50 39 48 27 63 73 44 52 66 9 18 23 54 25 6 8 56 13 67 36 22 15 46 62 75 55 11 31 17 24 29 60 68 12 30 3 70 49 19 34\n", "output": "62\n", "type": "stdin"}, {"input": "78\n7 61 69 47 68 42 65 78 70 3 32 59 49 51 23 71 11 63 22 18 43 34 24 13 27 16 19 40 21 46 48 77 28 66 54 67 60 15 75 62 9 26 52 58 4 25 8 37 41 76 1 6 30 50 44 36 5 14 29 53 17 12 2 57 73 35 64 39 56 10 33 20 45 74 31 55 38 72\n", "output": "70\n", "type": "stdin"}, {"input": "79\n75 79 43 66 72 52 29 65 74 38 24 1 5 51 13 7 71 33 4 61 2 36 63 47 64 44 34 27 3 21 17 37 54 53 49 20 28 60 39 10 16 76 6 77 73 22 50 48 78 30 67 56 31 26 40 59 41 11 18 45 69 62 15 23 32 70 19 55 68 57 35 25 12 46 14 42 9 8 58\n", "output": "77\n", "type": "stdin"}, {"input": "80\n51 20 37 12 68 11 28 52 76 21 7 5 3 16 64 34 25 2 6 40 60 62 75 13 45 17 56 29 32 47 79 73 49 72 15 46 30 54 80 27 43 24 74 18 42 71 14 4 44 63 65 33 1 77 55 57 41 59 58 70 69 35 19 67 10 36 26 23 48 50 39 61 9 66 38 8 31 22 53 78\n", "output": "52\n", "type": "stdin"}, {"input": "81\n63 22 4 41 43 74 64 39 10 35 20 81 11 28 70 67 53 79 16 61 68 52 27 37 58 9 50 49 18 30 72 47 7 60 78 51 23 48 73 66 44 13 15 57 56 38 1 76 25 45 36 34 42 8 75 26 59 14 71 21 6 77 5 17 2 32 40 54 46 24 29 3 31 19 65 62 33 69 12 80 55\n", "output": "69\n", "type": "stdin"}, {"input": "82\n50 24 17 41 49 18 80 11 79 72 57 31 21 35 2 51 36 66 20 65 38 3 45 32 59 81 28 30 70 55 29 76 73 6 33 39 8 7 19 48 63 1 77 43 4 13 78 54 69 9 40 46 74 82 60 71 16 64 12 14 47 26 44 5 10 75 53 25 27 15 56 42 58 34 23 61 67 62 68 22 37 52\n", "output": "53\n", "type": "stdin"}, {"input": "83\n64 8 58 17 67 46 3 82 23 70 72 16 53 45 13 20 12 48 40 4 6 47 76 60 19 44 30 78 28 22 75 15 25 29 63 74 55 32 14 51 35 31 62 77 27 42 65 71 56 61 66 41 68 49 7 34 2 83 36 5 33 26 37 80 59 50 1 9 54 21 18 24 38 73 81 52 10 39 43 79 57 11 69\n", "output": "66\n", "type": "stdin"}, {"input": "84\n75 8 66 21 61 63 72 51 52 13 59 25 28 58 64 53 79 41 34 7 67 11 39 56 44 24 50 9 49 55 1 80 26 6 73 74 27 69 65 37 18 43 36 17 30 3 47 29 76 78 32 22 12 68 46 5 42 81 57 31 33 83 54 48 14 62 10 16 4 20 71 70 35 15 45 19 60 77 2 23 84 40 82 38\n", "output": "80\n", "type": "stdin"}, {"input": "85\n1 18 58 8 22 76 3 61 12 33 54 41 6 24 82 15 10 17 38 64 26 4 62 28 47 14 66 9 84 75 2 71 67 43 37 32 85 21 69 52 55 63 81 51 74 59 65 34 29 36 30 45 27 53 13 79 39 57 5 70 19 40 7 42 68 48 16 80 83 23 46 35 72 31 11 44 73 77 50 56 49 25 60 20 78\n", "output": "84\n", "type": "stdin"}, {"input": "86\n64 56 41 10 31 69 47 39 37 36 27 19 9 42 15 6 78 59 52 17 71 45 72 14 2 54 38 79 4 18 16 8 46 75 50 82 44 24 20 55 58 86 61 43 35 32 33 40 63 30 28 60 13 53 12 57 77 81 76 66 73 84 85 62 68 22 51 5 49 7 1 70 80 65 34 48 23 21 83 11 74 26 29 67 25 3\n", "output": "70\n", "type": "stdin"}, {"input": "87\n14 20 82 47 39 75 71 45 3 37 63 19 32 68 7 41 48 76 27 46 84 49 4 44 26 69 17 64 1 18 58 33 11 23 21 86 67 52 70 16 77 78 6 74 15 87 10 59 13 34 22 2 65 38 66 61 51 57 35 60 81 40 36 80 31 43 83 56 79 55 29 5 12 8 50 30 53 72 54 9 24 25 42 62 73 28 85\n", "output": "58\n", "type": "stdin"}, {"input": "88\n1 83 73 46 61 31 39 86 57 43 16 29 26 80 82 7 36 42 13 20 6 64 19 40 24 12 47 87 8 34 75 9 69 3 11 52 14 25 84 59 27 10 54 51 81 74 65 77 70 17 60 35 23 44 49 2 4 88 5 21 41 32 68 66 15 55 48 58 78 53 22 38 45 33 30 50 85 76 37 79 63 18 28 62 72 56 71 67\n", "output": "87\n", "type": "stdin"}, {"input": "89\n68 40 14 58 56 25 8 44 49 55 9 76 66 54 33 81 42 15 59 17 21 30 75 60 4 48 64 6 52 63 61 27 12 57 72 67 23 86 77 80 22 13 43 73 26 78 50 51 18 62 1 29 82 16 74 2 87 24 3 41 11 46 47 69 10 84 65 39 35 79 70 32 34 31 20 19 53 71 36 28 83 88 38 85 7 5 37 45 89\n", "output": "88\n", "type": "stdin"}, {"input": "90\n2 67 26 58 9 49 76 22 60 30 77 20 13 7 37 81 47 16 19 12 14 45 41 68 85 54 28 24 46 1 27 43 32 89 53 35 59 75 18 51 17 64 66 80 31 88 87 90 38 72 55 71 42 11 73 69 62 78 23 74 65 79 84 4 86 52 10 6 3 82 56 5 48 33 21 57 40 29 61 63 34 36 83 8 15 44 50 70 39 25\n", "output": "60\n", "type": "stdin"}, {"input": "91\n91 69 56 16 73 55 14 82 80 46 57 81 22 71 63 76 43 37 77 75 70 3 26 2 28 17 51 38 30 67 41 47 54 62 34 25 84 11 87 39 32 52 31 36 50 19 21 53 29 24 79 8 74 64 44 7 6 18 10 42 13 9 83 58 4 88 65 60 20 90 66 49 86 89 78 48 5 27 23 59 61 15 72 45 40 33 68 85 35 12 1\n", "output": "90\n", "type": "stdin"}, {"input": "92\n67 57 76 78 25 89 6 82 11 16 26 17 59 48 73 10 21 31 27 80 4 5 22 13 92 55 45 85 63 28 75 60 54 88 91 47 29 35 7 87 1 39 43 51 71 84 83 81 46 9 38 56 90 24 37 41 19 86 50 61 79 20 18 14 69 23 62 65 49 52 58 53 36 2 68 64 15 42 30 34 66 32 44 40 8 33 3 77 74 12 70 72\n", "output": "67\n", "type": "stdin"}, {"input": "93\n76 35 5 87 7 21 59 71 24 37 2 73 31 74 4 52 28 20 56 27 65 86 16 45 85 67 68 70 47 72 91 88 14 32 62 69 78 41 15 22 57 18 50 13 39 58 17 83 64 51 25 11 38 77 82 90 8 26 29 61 10 43 79 53 48 6 23 55 63 49 81 92 80 44 89 60 66 30 1 9 36 33 19 46 75 93 3 12 42 84 40 54 34\n", "output": "85\n", "type": "stdin"}, {"input": "94\n29 85 82 78 61 83 80 63 11 38 50 43 9 24 4 87 79 45 3 17 90 7 34 27 1 76 26 39 84 47 22 41 81 19 44 23 56 92 35 31 72 62 70 53 40 88 13 14 73 2 59 86 46 94 15 12 77 57 89 42 75 48 18 51 32 55 71 30 49 91 20 60 5 93 33 64 21 36 10 28 8 65 66 69 74 58 6 52 25 67 16 37 54 68\n", "output": "69\n", "type": "stdin"}, {"input": "95\n36 73 18 77 15 71 50 57 79 65 94 88 9 69 52 70 26 66 78 89 55 20 72 83 75 68 32 28 45 74 19 22 54 23 84 90 86 12 42 58 11 81 39 31 85 47 60 44 59 43 21 7 30 41 64 76 93 46 87 48 10 40 3 14 38 49 29 35 2 67 5 34 13 37 27 56 91 17 62 80 8 61 53 95 24 92 6 82 63 33 51 25 4 16 1\n", "output": "94\n", "type": "stdin"}, {"input": "96\n64 3 47 83 19 10 72 61 73 95 16 40 54 84 8 86 28 4 37 42 92 48 63 76 67 1 59 66 20 35 93 2 43 7 45 70 34 33 26 91 85 89 13 29 58 68 44 25 87 75 49 71 41 17 55 36 32 31 74 22 52 79 30 88 50 78 38 39 65 27 69 77 81 94 82 53 21 80 57 60 24 46 51 9 18 15 96 62 6 23 11 12 90 5 14 56\n", "output": "86\n", "type": "stdin"}, {"input": "97\n40 63 44 64 84 92 38 41 28 91 3 70 76 67 94 96 35 79 29 22 78 88 85 8 21 1 93 54 71 80 37 17 13 26 62 59 75 87 69 33 89 49 77 61 12 39 6 36 58 18 73 50 82 45 74 52 11 34 95 7 23 30 15 32 31 16 55 19 20 83 60 72 10 53 51 14 27 9 68 47 5 2 81 46 57 86 56 43 48 66 24 25 4 42 65 97 90\n", "output": "95\n", "type": "stdin"}, {"input": "98\n85 94 69 86 22 52 27 79 53 91 35 55 33 88 8 75 76 95 64 54 67 30 70 49 6 16 2 48 80 32 25 90 98 46 9 96 36 81 10 92 28 11 37 97 15 41 38 40 83 44 29 47 23 3 31 61 87 39 78 20 68 12 17 73 59 18 77 72 43 51 84 24 89 65 26 7 74 93 21 19 5 14 50 42 82 71 60 56 34 62 58 57 45 66 13 63 4 1\n", "output": "97\n", "type": "stdin"}, {"input": "99\n33 48 19 41 59 64 16 12 17 13 7 1 9 6 4 92 61 49 60 25 74 65 22 97 30 32 10 62 14 55 80 66 82 78 31 23 87 93 27 98 20 29 88 84 77 34 83 96 79 90 56 89 58 72 52 47 21 76 24 70 44 94 5 39 8 18 57 36 40 68 43 75 3 2 35 99 63 26 67 73 15 11 53 28 42 46 69 50 51 95 38 37 54 85 81 91 45 86 71\n", "output": "87\n", "type": "stdin"}, {"input": "100\n28 30 77 4 81 67 31 25 66 56 88 73 83 51 57 34 21 90 38 76 22 99 53 70 91 3 64 54 6 94 8 5 97 80 50 45 61 40 16 95 36 98 9 2 17 44 72 55 18 58 47 12 87 24 7 32 14 23 65 41 63 48 62 39 92 27 43 19 46 13 42 52 96 84 26 69 100 79 93 49 35 60 71 59 68 15 10 29 20 1 78 33 75 86 11 85 74 82 89 37\n", "output": "89\n", "type": "stdin"}, {"input": "100\n100 97 35 55 45 3 46 98 77 64 94 85 73 43 49 79 72 9 70 62 80 88 29 58 61 20 89 83 66 86 82 15 6 87 42 96 90 75 63 38 81 40 5 23 4 18 41 19 99 60 8 12 76 51 39 93 53 26 21 50 47 28 13 30 68 59 34 54 24 56 31 27 65 16 32 10 36 52 44 91 22 14 33 25 7 78 67 17 57 37 92 11 2 69 84 95 74 71 48 1\n", "output": "99\n", "type": "stdin"}, {"input": "100\n83 96 73 70 30 25 7 77 58 89 76 85 49 82 45 51 14 62 50 9 31 32 16 15 97 64 4 37 20 93 24 10 80 71 100 39 75 72 78 74 8 29 53 86 79 48 3 68 90 99 56 87 63 94 36 1 40 65 6 44 43 84 17 52 34 95 38 47 60 57 98 59 33 41 46 81 23 27 19 2 54 91 55 35 26 12 92 18 28 66 69 21 5 67 13 11 22 88 61 42\n", "output": "65\n", "type": "stdin"}, {"input": "100\n96 80 47 60 56 9 78 20 37 72 68 15 100 94 51 26 65 38 50 19 4 70 25 63 22 30 13 58 43 69 18 33 5 66 39 73 12 55 95 92 97 1 14 83 10 28 64 31 46 91 32 86 74 54 29 52 89 53 90 44 62 40 16 24 67 81 36 34 7 23 79 87 75 98 84 3 41 77 76 42 71 35 49 61 2 27 59 82 99 85 21 11 45 6 88 48 17 57 8 93\n", "output": "87\n", "type": "stdin"}, {"input": "100\n5 6 88 37 97 51 25 81 54 17 57 98 99 44 67 24 30 93 100 36 8 38 84 42 21 4 75 31 85 48 70 77 43 50 65 94 29 32 68 86 56 39 69 47 20 60 52 53 10 34 79 2 95 40 89 64 71 26 22 46 1 62 91 76 83 41 9 78 16 63 13 3 28 92 27 49 7 12 96 72 80 23 14 19 18 66 59 87 90 45 73 82 33 74 35 61 55 15 58 11\n", "output": "81\n", "type": "stdin"}, {"input": "100\n100 97 92 12 62 17 19 58 37 26 30 95 31 35 87 10 13 43 98 61 28 89 76 1 23 21 11 22 50 56 91 74 3 24 96 55 64 67 14 4 71 16 18 9 77 68 51 81 32 82 46 88 86 60 29 66 72 85 70 7 53 63 33 45 83 2 25 94 52 93 5 69 20 47 49 54 57 39 34 27 90 80 78 59 40 42 79 6 38 8 48 15 65 73 99 44 41 84 36 75\n", "output": "99\n", "type": "stdin"}, {"input": "100\n22 47 34 65 69 5 68 78 53 54 41 23 80 51 11 8 2 85 81 75 25 58 29 73 30 49 10 71 17 96 76 89 79 20 12 15 55 7 46 32 19 3 82 35 74 44 38 40 92 14 6 50 97 63 45 93 37 18 62 77 87 36 83 9 90 61 57 28 39 43 52 42 24 56 21 84 26 99 88 59 33 70 4 60 98 95 94 100 13 48 66 72 16 31 64 91 1 86 27 67\n", "output": "96\n", "type": "stdin"}, {"input": "100\n41 67 94 18 14 83 59 12 19 54 13 68 75 26 15 65 80 40 23 30 34 78 47 21 63 79 4 70 3 31 86 69 92 10 61 74 97 100 9 99 32 27 91 55 85 52 16 17 28 1 64 29 58 76 98 25 84 7 2 96 20 72 36 46 49 82 93 44 45 6 38 87 57 50 53 35 60 33 8 89 39 42 37 48 62 81 73 43 95 11 66 88 90 22 24 77 71 51 5 56\n", "output": "62\n", "type": "stdin"}, {"input": "100\n1 88 38 56 62 99 39 80 12 33 57 24 28 84 37 42 10 95 83 58 8 40 20 2 30 78 60 79 36 71 51 31 27 65 22 47 6 19 61 94 75 4 74 35 15 23 92 9 70 13 11 59 90 18 66 81 64 72 16 32 34 67 46 91 21 87 77 97 82 41 7 86 26 43 45 3 93 17 52 96 50 63 48 5 53 44 29 25 98 54 49 14 73 69 89 55 76 85 68 100\n", "output": "99\n", "type": "stdin"}, {"input": "100\n22 59 25 77 68 79 32 45 20 28 61 60 38 86 33 10 100 15 53 75 78 39 67 13 66 34 96 4 63 23 73 29 31 35 71 55 16 14 72 56 94 97 17 93 47 84 57 8 21 51 54 85 26 76 49 81 2 92 62 44 91 87 11 24 95 69 5 7 99 6 65 48 70 12 41 18 74 27 42 3 80 30 50 98 58 37 82 89 83 36 40 52 19 9 88 46 43 1 90 64\n", "output": "97\n", "type": "stdin"}, {"input": "100\n12 1 76 78 97 82 59 80 48 8 91 51 54 74 16 10 89 99 83 63 93 90 55 25 30 33 29 6 9 65 92 79 44 39 15 58 37 46 32 19 27 3 75 49 62 71 98 42 69 50 26 81 96 5 7 61 60 21 20 36 18 34 40 4 47 85 64 38 22 84 2 68 11 56 31 66 17 14 95 43 53 35 23 52 70 13 72 45 41 77 73 87 88 94 28 86 24 67 100 57\n", "output": "98\n", "type": "stdin"}, {"input": "100\n66 100 53 88 7 73 54 41 31 42 8 46 65 90 78 14 94 30 79 39 89 5 83 50 38 61 37 86 22 95 60 98 34 57 91 10 75 25 15 43 23 17 96 35 93 48 87 47 56 13 19 9 82 62 67 80 11 55 99 70 18 26 58 85 12 44 16 45 4 49 20 71 92 24 81 2 76 32 6 21 84 36 52 97 59 63 40 51 27 64 68 3 77 72 28 33 29 1 74 69\n", "output": "98\n", "type": "stdin"}, {"input": "100\n56 64 1 95 72 39 9 49 87 29 94 7 32 6 30 48 50 25 31 78 90 45 60 44 80 68 17 20 73 15 75 98 83 13 71 22 36 26 96 88 35 3 85 54 16 41 92 99 69 86 93 33 43 62 77 46 47 37 12 10 18 40 27 4 63 55 28 59 23 34 61 53 76 42 51 91 21 70 8 58 38 19 5 66 84 11 52 24 81 82 79 67 97 65 57 74 2 89 100 14\n", "output": "98\n", "type": "stdin"}, {"input": "3\n1 2 3\n", "output": "2\n", "type": "stdin"}, {"input": "3\n1 3 2\n", "output": "2\n", "type": "stdin"}, {"input": "3\n2 1 3\n", "output": "2\n", "type": "stdin"}, {"input": "3\n2 3 1\n", "output": "2\n", "type": "stdin"}, {"input": "3\n3 1 2\n", "output": "2\n", "type": "stdin"}, {"input": "3\n3 2 1\n", "output": "2\n", "type": "stdin"}, {"input": "4\n1 2 3 4\n", "output": "3\n", "type": "stdin"}, {"input": "4\n1 2 4 3\n", "output": "3\n", "type": "stdin"}, {"input": "4\n1 3 2 4\n", "output": "3\n", "type": "stdin"}, {"input": "4\n1 3 4 2\n", "output": "3\n", "type": "stdin"}, {"input": "4\n1 4 2 3\n", "output": "3\n", "type": "stdin"}, {"input": "4\n1 4 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "4\n2 1 3 4\n", "output": "3\n", "type": "stdin"}, {"input": "4\n2 1 4 3\n", "output": "2\n", "type": "stdin"}, {"input": "4\n2 4 1 3\n", "output": "2\n", "type": "stdin"}, {"input": "4\n2 4 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "4\n3 1 2 4\n", "output": "3\n", "type": "stdin"}, {"input": "4\n3 1 4 2\n", "output": "2\n", "type": "stdin"}, {"input": "4\n3 2 1 4\n", "output": "3\n", "type": "stdin"}, {"input": "4\n3 2 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "4\n3 4 1 2\n", "output": "2\n", "type": "stdin"}, {"input": "4\n3 4 2 1\n", "output": "3\n", "type": "stdin"}, {"input": "4\n4 1 2 3\n", "output": "3\n", "type": "stdin"}, {"input": "4\n4 1 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "4\n4 2 1 3\n", "output": "3\n", "type": "stdin"}, {"input": "4\n4 2 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "4\n4 3 1 2\n", "output": "3\n", "type": "stdin"}, {"input": "4\n4 3 2 1\n", "output": "3\n", "type": "stdin"}, {"input": "8\n2 5 6 4 8 3 1 7\n", "output": "6\n", "type": "stdin"}, {"input": "5\n2 3 1 5 4\n", "output": "3\n", "type": "stdin"}, {"input": "6\n2 5 3 6 4 1\n", "output": "5\n", "type": "stdin"}, {"input": "6\n5 4 2 6 1 3\n", "output": "4\n", "type": "stdin"}, {"input": "6\n4 2 3 1 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "6\n5 4 2 1 6 3\n", "output": "4\n", "type": "stdin"}, {"input": "9\n7 2 3 4 5 6 1 9 8\n", "output": "7\n", "type": "stdin"}, {"input": "6\n3 2 1 4 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "6\n2 3 4 1 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "10\n5 2 3 4 1 6 7 8 10 9\n", "output": "8\n", "type": "stdin"}, {"input": "6\n5 2 3 1 6 4\n", "output": "4\n", "type": "stdin"}, {"input": "10\n2 9 3 4 1 10 5 6 7 8\n", "output": "5\n", "type": "stdin"}, {"input": "10\n2 3 4 5 6 7 1 8 10 9\n", "output": "8\n", "type": "stdin"}, {"input": "8\n2 3 4 5 1 6 8 7\n", "output": "6\n", "type": "stdin"}, {"input": "6\n2 1 3 4 5 6\n", "output": "5\n", "type": "stdin"}, {"input": "76\n1 47 54 17 38 37 12 32 14 48 43 71 60 56 4 13 64 41 52 57 62 24 23 49 20 10 63 3 25 66 59 40 58 33 53 46 70 7 35 61 72 74 73 19 30 5 29 6 15 28 21 27 51 55 50 9 65 8 67 39 76 42 31 34 16 2 36 11 26 44 22 45 75 18 69 68\n", "output": "75\n", "type": "stdin"}, {"input": "12\n3 6 7 8 9 10 12 5 4 2 11 1\n", "output": "11\n", "type": "stdin"}, {"input": "81\n63 22 4 41 43 74 64 39 10 35 20 81 11 28 70 67 53 79 16 61 68 52 27 37 58 9 50 49 18 30 72 47 7 60 78 51 23 48 73 66 44 13 15 57 56 38 1 76 25 45 36 34 42 8 75 26 59 14 71 21 6 77 5 17 2 32 40 54 46 24 29 3 31 19 65 62 33 69 12 80 55\n", "output": "69\n", "type": "stdin"}, {"input": "98\n85 94 69 86 22 52 27 79 53 91 35 55 33 88 8 75 76 95 64 54 67 30 70 49 6 16 2 48 80 32 25 90 98 46 9 96 36 81 10 92 28 11 37 97 15 41 38 40 83 44 29 47 23 3 31 61 87 39 78 20 68 12 17 73 59 18 77 72 43 51 84 24 89 65 26 7 74 93 21 19 5 14 50 42 82 71 60 56 34 62 58 57 45 66 13 63 4 1\n", "output": "97\n", "type": "stdin"}, {"input": "22\n8 3 17 4 16 21 14 11 10 15 6 18 13 12 22 20 5 2 9 7 19 1\n", "output": "21\n", "type": "stdin"}, {"input": "14\n6 10 13 9 7 1 12 14 3 2 5 4 11 8\n", "output": "8\n", "type": "stdin"}, {"input": "100\n76 70 67 54 40 1 48 63 64 36 42 90 99 27 47 17 93 7 13 84 16 57 74 5 83 61 19 56 52 92 38 91 82 79 34 66 71 28 37 98 35 94 77 53 73 10 26 80 15 32 8 81 3 95 44 46 72 6 33 11 21 85 4 30 24 51 49 96 87 55 14 31 12 60 45 9 29 22 58 18 88 2 50 59 20 86 23 41 100 39 62 68 69 97 78 43 25 89 65 75\n", "output": "94\n", "type": "stdin"}, {"input": "4\n1 2 4 3\n", "output": "3\n", "type": "stdin"}, {"input": "70\n19 12 15 18 36 16 61 69 24 7 11 13 3 48 55 21 37 17 43 31 41 22 28 32 27 63 38 49 59 56 30 25 67 51 52 45 50 44 66 57 26 60 5 46 33 6 23 34 8 40 2 68 14 39 65 64 62 42 47 54 10 53 9 1 70 58 20 4 29 35\n", "output": "64\n", "type": "stdin"}, {"input": "11\n5 4 6 9 10 11 7 3 1 2 8\n", "output": "8\n", "type": "stdin"}, {"input": "6\n5 4 2 6 1 3\n", "output": "4\n", "type": "stdin"}, {"input": "82\n50 24 17 41 49 18 80 11 79 72 57 31 21 35 2 51 36 66 20 65 38 3 45 32 59 81 28 30 70 55 29 76 73 6 33 39 8 7 19 48 63 1 77 43 4 13 78 54 69 9 40 46 74 82 60 71 16 64 12 14 47 26 44 5 10 75 53 25 27 15 56 42 58 34 23 61 67 62 68 22 37 52\n", "output": "53\n", "type": "stdin"}, {"input": "6\n2 1 3 4 5 6\n", "output": "5\n", "type": "stdin"}, {"input": "99\n33 48 19 41 59 64 16 12 17 13 7 1 9 6 4 92 61 49 60 25 74 65 22 97 30 32 10 62 14 55 80 66 82 78 31 23 87 93 27 98 20 29 88 84 77 34 83 96 79 90 56 89 58 72 52 47 21 76 24 70 44 94 5 39 8 18 57 36 40 68 43 75 3 2 35 99 63 26 67 73 15 11 53 28 42 46 69 50 51 95 38 37 54 85 81 91 45 86 71\n", "output": "87\n", "type": "stdin"}, {"input": "67\n66 16 2 53 35 38 49 28 18 6 36 58 21 47 27 5 50 62 44 12 52 37 11 56 15 31 25 65 17 29 59 41 7 42 4 43 39 10 1 40 24 13 20 54 19 67 46 60 51 45 64 30 8 33 26 9 3 22 34 23 57 48 55 14 63 61 32\n", "output": "45\n", "type": "stdin"}, {"input": "19\n12 19 3 11 15 6 18 14 5 10 2 13 9 7 4 8 17 16 1\n", "output": "18\n", "type": "stdin"}, {"input": "13\n8 4 3 7 5 11 9 1 10 2 13 12 6\n", "output": "10\n", "type": "stdin"}, {"input": "32\n15 32 11 3 18 23 19 14 5 8 6 21 13 24 25 4 16 9 27 20 17 31 2 22 7 12 30 1 26 10 29 28\n", "output": "30\n", "type": "stdin"}, {"input": "31\n29 13 26 27 9 28 2 16 30 21 12 11 3 31 23 6 22 20 1 5 14 24 19 18 8 4 10 17 15 25 7\n", "output": "18\n", "type": "stdin"}, {"input": "7\n1 5 3 6 2 4 7\n", "output": "6\n", "type": "stdin"}, {"input": "4\n3 1 4 2\n", "output": "2\n", "type": "stdin"}, {"input": "84\n75 8 66 21 61 63 72 51 52 13 59 25 28 58 64 53 79 41 34 7 67 11 39 56 44 24 50 9 49 55 1 80 26 6 73 74 27 69 65 37 18 43 36 17 30 3 47 29 76 78 32 22 12 68 46 5 42 81 57 31 33 83 54 48 14 62 10 16 4 20 71 70 35 15 45 19 60 77 2 23 84 40 82 38\n", "output": "80\n", "type": "stdin"}, {"input": "100\n22 47 34 65 69 5 68 78 53 54 41 23 80 51 11 8 2 85 81 75 25 58 29 73 30 49 10 71 17 96 76 89 79 20 12 15 55 7 46 32 19 3 82 35 74 44 38 40 92 14 6 50 97 63 45 93 37 18 62 77 87 36 83 9 90 61 57 28 39 43 52 42 24 56 21 84 26 99 88 59 33 70 4 60 98 95 94 100 13 48 66 72 16 31 64 91 1 86 27 67\n", "output": "96\n", "type": "stdin"}, {"input": "9\n6 8 5 3 4 7 9 2 1\n", "output": "8\n", "type": "stdin"}, {"input": "44\n4 38 6 40 29 3 44 2 30 35 25 36 34 10 11 31 21 7 14 23 37 19 27 18 5 22 1 16 17 9 39 13 15 32 43 8 41 26 42 12 24 33 20 28\n", "output": "37\n", "type": "stdin"}, {"input": "6\n5 2 3 1 6 4\n", "output": "4\n", "type": "stdin"}, {"input": "52\n16 45 23 7 15 19 43 20 4 32 35 36 9 50 5 26 38 46 13 33 12 2 48 37 41 31 10 28 8 42 3 21 11 1 17 27 34 30 44 40 6 51 49 47 25 22 18 24 52 29 14 39\n", "output": "48\n", "type": "stdin"}, {"input": "100\n100 97 92 12 62 17 19 58 37 26 30 95 31 35 87 10 13 43 98 61 28 89 76 1 23 21 11 22 50 56 91 74 3 24 96 55 64 67 14 4 71 16 18 9 77 68 51 81 32 82 46 88 86 60 29 66 72 85 70 7 53 63 33 45 83 2 25 94 52 93 5 69 20 47 49 54 57 39 34 27 90 80 78 59 40 42 79 6 38 8 48 15 65 73 99 44 41 84 36 75\n", "output": "99\n", "type": "stdin"}, {"input": "2\n1 2\n", "output": "1\n", "type": "stdin"}, {"input": "4\n2 4 1 3\n", "output": "2\n", "type": "stdin"}, {"input": "50\n31 45 3 34 13 43 32 4 42 9 7 8 24 14 35 6 19 46 44 17 18 1 25 20 27 41 2 16 12 10 11 47 38 21 28 49 30 15 50 36 29 26 22 39 48 5 23 37 33 40\n", "output": "38\n", "type": "stdin"}, {"input": "6\n3 2 1 4 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "51\n47 29 2 11 43 44 27 1 39 14 25 30 33 21 38 45 34 51 16 50 42 31 41 46 15 48 13 19 6 37 35 7 22 28 20 4 17 10 5 8 24 40 9 36 18 49 12 26 23 3 32\n", "output": "43\n", "type": "stdin"}, {"input": "5\n2 3 1 5 4\n", "output": "3\n", "type": "stdin"}, {"input": "94\n29 85 82 78 61 83 80 63 11 38 50 43 9 24 4 87 79 45 3 17 90 7 34 27 1 76 26 39 84 47 22 41 81 19 44 23 56 92 35 31 72 62 70 53 40 88 13 14 73 2 59 86 46 94 15 12 77 57 89 42 75 48 18 51 32 55 71 30 49 91 20 60 5 93 33 64 21 36 10 28 8 65 66 69 74 58 6 52 25 67 16 37 54 68\n", "output": "69\n", "type": "stdin"}, {"input": "3\n1 3 2\n", "output": "2\n", "type": "stdin"}, {"input": "34\n34 30 7 16 6 1 10 23 29 13 15 25 32 26 18 11 28 3 14 21 19 5 31 33 4 17 8 9 24 20 27 22 2 12\n", "output": "33\n", "type": "stdin"}, {"input": "42\n42 15 24 26 4 34 19 29 38 32 31 33 14 41 21 3 11 39 25 6 5 20 23 10 16 36 18 28 27 1 7 40 22 30 9 2 37 17 8 12 13 35\n", "output": "41\n", "type": "stdin"}, {"input": "4\n1 4 2 3\n", "output": "3\n", "type": "stdin"}, {"input": "37\n24 1 12 23 11 6 30 15 4 21 13 20 25 17 5 8 36 19 32 26 14 9 7 18 10 29 37 35 16 2 22 34 3 27 31 33 28\n", "output": "35\n", "type": "stdin"}, {"input": "97\n40 63 44 64 84 92 38 41 28 91 3 70 76 67 94 96 35 79 29 22 78 88 85 8 21 1 93 54 71 80 37 17 13 26 62 59 75 87 69 33 89 49 77 61 12 39 6 36 58 18 73 50 82 45 74 52 11 34 95 7 23 30 15 32 31 16 55 19 20 83 60 72 10 53 51 14 27 9 68 47 5 2 81 46 57 86 56 43 48 66 24 25 4 42 65 97 90\n", "output": "95\n", "type": "stdin"}, {"input": "10\n2 9 3 4 1 10 5 6 7 8\n", "output": "5\n", "type": "stdin"}, {"input": "89\n68 40 14 58 56 25 8 44 49 55 9 76 66 54 33 81 42 15 59 17 21 30 75 60 4 48 64 6 52 63 61 27 12 57 72 67 23 86 77 80 22 13 43 73 26 78 50 51 18 62 1 29 82 16 74 2 87 24 3 41 11 46 47 69 10 84 65 39 35 79 70 32 34 31 20 19 53 71 36 28 83 88 38 85 7 5 37 45 89\n", "output": "88\n", "type": "stdin"}, {"input": "4\n4 2 1 3\n", "output": "3\n", "type": "stdin"}, {"input": "48\n29 26 14 18 34 33 13 39 32 1 37 20 35 19 28 48 30 23 46 27 5 22 24 38 12 15 8 36 43 45 16 47 6 9 31 40 44 17 2 41 11 42 25 4 21 3 10 7\n", "output": "38\n", "type": "stdin"}, {"input": "8\n2 3 4 5 1 6 8 7\n", "output": "6\n", "type": "stdin"}, {"input": "10\n8 7 10 1 2 3 4 6 5 9\n", "output": "7\n", "type": "stdin"}, {"input": "4\n1 4 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "15\n3 14 13 12 7 2 4 11 15 1 8 6 5 10 9\n", "output": "9\n", "type": "stdin"}, {"input": "29\n21 11 10 25 2 5 9 16 29 8 17 4 15 13 6 22 7 24 19 12 18 20 1 3 23 28 27 14 26\n", "output": "22\n", "type": "stdin"}, {"input": "25\n12 13 22 17 1 18 14 5 21 2 10 4 3 23 11 6 20 8 24 16 15 19 9 7 25\n", "output": "24\n", "type": "stdin"}, {"input": "88\n1 83 73 46 61 31 39 86 57 43 16 29 26 80 82 7 36 42 13 20 6 64 19 40 24 12 47 87 8 34 75 9 69 3 11 52 14 25 84 59 27 10 54 51 81 74 65 77 70 17 60 35 23 44 49 2 4 88 5 21 41 32 68 66 15 55 48 58 78 53 22 38 45 33 30 50 85 76 37 79 63 18 28 62 72 56 71 67\n", "output": "87\n", "type": "stdin"}, {"input": "100\n66 100 53 88 7 73 54 41 31 42 8 46 65 90 78 14 94 30 79 39 89 5 83 50 38 61 37 86 22 95 60 98 34 57 91 10 75 25 15 43 23 17 96 35 93 48 87 47 56 13 19 9 82 62 67 80 11 55 99 70 18 26 58 85 12 44 16 45 4 49 20 71 92 24 81 2 76 32 6 21 84 36 52 97 59 63 40 51 27 64 68 3 77 72 28 33 29 1 74 69\n", "output": "98\n", "type": "stdin"}, {"input": "18\n8 6 14 17 9 11 15 13 5 3 18 1 2 7 12 16 4 10\n", "output": "11\n", "type": "stdin"}, {"input": "6\n5 4 2 1 6 3\n", "output": "4\n", "type": "stdin"}, {"input": "8\n2 5 6 4 8 3 1 7\n", "output": "6\n", "type": "stdin"}, {"input": "3\n2 3 1\n", "output": "2\n", "type": "stdin"}, {"input": "6\n4 6 3 5 2 1\n", "output": "5\n", "type": "stdin"}, {"input": "4\n4 3 1 2\n", "output": "3\n", "type": "stdin"}, {"input": "61\n61 11 26 29 31 40 32 30 35 3 18 52 9 53 42 4 50 54 20 58 28 49 22 12 2 19 16 15 57 34 51 43 7 17 25 41 56 47 55 60 46 14 44 45 24 27 33 1 48 13 59 23 38 39 6 5 36 10 8 37 21\n", "output": "60\n", "type": "stdin"}, {"input": "4\n4 3 2 1\n", "output": "3\n", "type": "stdin"}, {"input": "65\n10 11 55 43 53 25 35 26 16 37 41 38 59 21 48 2 65 49 17 23 18 30 62 36 3 4 47 15 28 63 57 54 31 46 44 12 51 7 29 13 56 52 14 22 39 19 8 27 45 5 6 34 32 61 20 50 9 24 33 58 60 40 1 42 64\n", "output": "62\n", "type": "stdin"}, {"input": "3\n1 2 3\n", "output": "2\n", "type": "stdin"}, {"input": "92\n67 57 76 78 25 89 6 82 11 16 26 17 59 48 73 10 21 31 27 80 4 5 22 13 92 55 45 85 63 28 75 60 54 88 91 47 29 35 7 87 1 39 43 51 71 84 83 81 46 9 38 56 90 24 37 41 19 86 50 61 79 20 18 14 69 23 62 65 49 52 58 53 36 2 68 64 15 42 30 34 66 32 44 40 8 33 3 77 74 12 70 72\n", "output": "67\n", "type": "stdin"}, {"input": "23\n1 23 11 20 9 3 12 4 7 17 5 15 2 10 18 16 8 22 14 13 19 21 6\n", "output": "22\n", "type": "stdin"}, {"input": "4\n3 1 2 4\n", "output": "3\n", "type": "stdin"}, {"input": "54\n6 39 17 3 45 52 16 21 23 48 42 36 13 37 46 10 43 27 49 7 38 32 31 30 15 25 2 29 8 51 54 19 41 44 24 34 22 5 20 14 12 1 33 40 4 26 9 35 18 28 47 50 11 53\n", "output": "41\n", "type": "stdin"}, {"input": "69\n29 49 25 51 21 35 11 61 39 54 40 37 60 42 27 33 59 53 34 10 46 2 23 69 8 47 58 36 1 38 19 12 7 48 13 3 6 22 18 5 65 24 50 41 66 44 67 57 4 56 62 43 9 30 14 15 28 31 64 26 16 55 68 17 32 20 45 52 63\n", "output": "45\n", "type": "stdin"}, {"input": "60\n60 27 34 32 54 55 33 12 40 3 47 44 50 39 38 59 11 25 17 15 16 30 21 31 10 52 5 23 4 48 6 26 36 57 14 22 8 56 58 9 24 7 37 53 42 43 20 49 51 19 2 46 28 18 35 13 29 45 41 1\n", "output": "59\n", "type": "stdin"}, {"input": "4\n2 1 4 3\n", "output": "2\n", "type": "stdin"}, {"input": "57\n39 28 53 36 3 6 12 56 55 20 50 19 43 42 18 40 24 52 38 17 33 23 22 41 14 7 26 44 45 16 35 1 8 47 31 5 30 51 32 4 37 25 13 34 54 21 46 10 15 11 2 27 29 48 49 9 57\n", "output": "56\n", "type": "stdin"}, {"input": "4\n3 4 1 2\n", "output": "2\n", "type": "stdin"}, {"input": "3\n2 1 3\n", "output": "2\n", "type": "stdin"}, {"input": "4\n1 2 3 4\n", "output": "3\n", "type": "stdin"}, {"input": "86\n64 56 41 10 31 69 47 39 37 36 27 19 9 42 15 6 78 59 52 17 71 45 72 14 2 54 38 79 4 18 16 8 46 75 50 82 44 24 20 55 58 86 61 43 35 32 33 40 63 30 28 60 13 53 12 57 77 81 76 66 73 84 85 62 68 22 51 5 49 7 1 70 80 65 34 48 23 21 83 11 74 26 29 67 25 3\n", "output": "70\n", "type": "stdin"}, {"input": "100\n22 59 25 77 68 79 32 45 20 28 61 60 38 86 33 10 100 15 53 75 78 39 67 13 66 34 96 4 63 23 73 29 31 35 71 55 16 14 72 56 94 97 17 93 47 84 57 8 21 51 54 85 26 76 49 81 2 92 62 44 91 87 11 24 95 69 5 7 99 6 65 48 70 12 41 18 74 27 42 3 80 30 50 98 58 37 82 89 83 36 40 52 19 9 88 46 43 1 90 64\n", "output": "97\n", "type": "stdin"}, {"input": "83\n64 8 58 17 67 46 3 82 23 70 72 16 53 45 13 20 12 48 40 4 6 47 76 60 19 44 30 78 28 22 75 15 25 29 63 74 55 32 14 51 35 31 62 77 27 42 65 71 56 61 66 41 68 49 7 34 2 83 36 5 33 26 37 80 59 50 1 9 54 21 18 24 38 73 81 52 10 39 43 79 57 11 69\n", "output": "66\n", "type": "stdin"}, {"input": "53\n53 30 50 22 51 31 32 38 12 7 39 43 1 23 6 8 24 52 2 21 34 13 3 35 5 15 19 11 47 18 9 20 29 4 36 45 27 41 25 48 16 46 44 17 10 14 42 26 40 28 33 37 49\n", "output": "52\n", "type": "stdin"}, {"input": "87\n14 20 82 47 39 75 71 45 3 37 63 19 32 68 7 41 48 76 27 46 84 49 4 44 26 69 17 64 1 18 58 33 11 23 21 86 67 52 70 16 77 78 6 74 15 87 10 59 13 34 22 2 65 38 66 61 51 57 35 60 81 40 36 80 31 43 83 56 79 55 29 5 12 8 50 30 53 72 54 9 24 25 42 62 73 28 85\n", "output": "58\n", "type": "stdin"}, {"input": "55\n26 15 31 21 32 43 34 51 7 12 5 44 17 54 18 25 48 47 20 3 41 24 45 2 11 22 29 39 37 53 35 28 36 9 50 10 30 38 19 13 4 8 27 1 42 6 49 23 55 40 33 16 46 14 52\n", "output": "48\n", "type": "stdin"}, {"input": "75\n75 28 60 19 59 17 65 26 32 23 18 64 8 62 4 11 42 16 47 5 72 46 9 1 25 21 2 50 33 6 36 68 30 12 20 40 53 45 34 7 37 39 38 44 63 61 67 3 66 51 29 73 24 57 70 27 10 56 22 55 13 49 35 15 54 41 14 74 69 48 52 31 71 43 58\n", "output": "74\n", "type": "stdin"}, {"input": "56\n6 20 38 46 10 11 40 19 5 1 47 33 4 18 32 36 37 45 56 49 48 52 12 26 31 14 2 9 24 3 16 51 41 43 23 17 34 7 29 50 55 25 39 44 22 27 54 8 28 35 30 42 13 53 21 15\n", "output": "46\n", "type": "stdin"}, {"input": "77\n10 20 57 65 53 69 59 45 58 32 28 72 4 14 1 33 40 47 7 5 51 76 37 16 41 61 42 2 21 26 38 74 35 64 43 77 71 50 39 48 27 63 73 44 52 66 9 18 23 54 25 6 8 56 13 67 36 22 15 46 62 75 55 11 31 17 24 29 60 68 12 30 3 70 49 19 34\n", "output": "62\n", "type": "stdin"}, {"input": "47\n7 3 8 12 24 16 29 10 28 38 1 20 37 40 21 5 15 6 45 23 36 44 25 43 41 4 11 42 18 35 32 31 39 33 27 30 22 34 14 13 17 47 19 9 46 26 2\n", "output": "41\n", "type": "stdin"}, {"input": "2\n2 1\n", "output": "1\n", "type": "stdin"}, {"input": "79\n75 79 43 66 72 52 29 65 74 38 24 1 5 51 13 7 71 33 4 61 2 36 63 47 64 44 34 27 3 21 17 37 54 53 49 20 28 60 39 10 16 76 6 77 73 22 50 48 78 30 67 56 31 26 40 59 41 11 18 45 69 62 15 23 32 70 19 55 68 57 35 25 12 46 14 42 9 8 58\n", "output": "77\n", "type": "stdin"}, {"input": "4\n2 1 3 4\n", "output": "3\n", "type": "stdin"}, {"input": "8\n4 5 3 8 6 7 1 2\n", "output": "6\n", "type": "stdin"}, {"input": "68\n13 6 27 21 65 23 59 14 62 43 33 31 38 41 67 20 16 25 42 4 28 40 29 9 64 17 2 26 32 58 60 53 46 48 47 54 44 50 39 19 30 57 61 1 11 18 37 24 55 15 63 34 8 52 56 7 10 12 35 66 5 36 45 49 68 22 51 3\n", "output": "64\n", "type": "stdin"}, {"input": "100\n41 67 94 18 14 83 59 12 19 54 13 68 75 26 15 65 80 40 23 30 34 78 47 21 63 79 4 70 3 31 86 69 92 10 61 74 97 100 9 99 32 27 91 55 85 52 16 17 28 1 64 29 58 76 98 25 84 7 2 96 20 72 36 46 49 82 93 44 45 6 38 87 57 50 53 35 60 33 8 89 39 42 37 48 62 81 73 43 95 11 66 88 90 22 24 77 71 51 5 56\n", "output": "62\n", "type": "stdin"}, {"input": "100\n5 6 88 37 97 51 25 81 54 17 57 98 99 44 67 24 30 93 100 36 8 38 84 42 21 4 75 31 85 48 70 77 43 50 65 94 29 32 68 86 56 39 69 47 20 60 52 53 10 34 79 2 95 40 89 64 71 26 22 46 1 62 91 76 83 41 9 78 16 63 13 3 28 92 27 49 7 12 96 72 80 23 14 19 18 66 59 87 90 45 73 82 33 74 35 61 55 15 58 11\n", "output": "81\n", "type": "stdin"}, {"input": "95\n36 73 18 77 15 71 50 57 79 65 94 88 9 69 52 70 26 66 78 89 55 20 72 83 75 68 32 28 45 74 19 22 54 23 84 90 86 12 42 58 11 81 39 31 85 47 60 44 59 43 21 7 30 41 64 76 93 46 87 48 10 40 3 14 38 49 29 35 2 67 5 34 13 37 27 56 91 17 62 80 8 61 53 95 24 92 6 82 63 33 51 25 4 16 1\n", "output": "94\n", "type": "stdin"}, {"input": "66\n66 39 3 2 55 53 60 54 12 49 10 30 59 26 32 46 50 56 7 13 43 36 24 28 11 8 6 21 35 25 42 57 23 45 64 5 34 61 27 51 52 9 15 1 38 17 63 48 37 20 58 14 47 19 22 41 31 44 33 65 4 62 40 18 16 29\n", "output": "65\n", "type": "stdin"}, {"input": "9\n7 2 3 4 5 6 1 9 8\n", "output": "7\n", "type": "stdin"}, {"input": "4\n4 2 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "28\n28 13 16 6 1 12 4 27 22 7 18 3 21 26 25 11 5 10 20 24 19 15 14 8 23 17 9 2\n", "output": "27\n", "type": "stdin"}, {"input": "38\n9 35 37 28 36 21 10 25 19 4 26 5 22 7 27 18 6 14 15 24 1 17 11 34 20 8 2 16 3 23 32 31 13 12 38 33 30 29\n", "output": "34\n", "type": "stdin"}, {"input": "43\n43 24 20 13 22 29 28 4 30 3 32 40 31 8 7 9 35 27 18 5 42 6 17 19 23 12 41 21 16 37 33 34 2 14 36 38 25 10 15 39 26 11 1\n", "output": "42\n", "type": "stdin"}, {"input": "3\n3 1 2\n", "output": "2\n", "type": "stdin"}, {"input": "30\n6 19 14 22 26 17 27 8 25 3 24 30 4 18 23 16 9 13 29 20 15 2 5 11 28 12 1 10 21 7\n", "output": "26\n", "type": "stdin"}, {"input": "4\n3 2 4 1\n", "output": "3\n", "type": "stdin"}, {"input": "100\n12 1 76 78 97 82 59 80 48 8 91 51 54 74 16 10 89 99 83 63 93 90 55 25 30 33 29 6 9 65 92 79 44 39 15 58 37 46 32 19 27 3 75 49 62 71 98 42 69 50 26 81 96 5 7 61 60 21 20 36 18 34 40 4 47 85 64 38 22 84 2 68 11 56 31 66 17 14 95 43 53 35 23 52 70 13 72 45 41 77 73 87 88 94 28 86 24 67 100 57\n", "output": "98\n", "type": "stdin"}, {"input": "16\n11 6 9 8 7 14 12 13 10 15 2 5 3 1 4 16\n", "output": "15\n", "type": "stdin"}, {"input": "4\n3 2 1 4\n", "output": "3\n", "type": "stdin"}, {"input": "59\n1 27 10 37 53 9 14 49 46 26 50 42 59 11 47 15 24 56 43 45 44 38 5 8 58 30 52 12 23 32 22 3 31 41 2 25 29 6 54 16 35 33 18 55 4 51 57 28 40 19 13 21 7 39 36 48 34 17 20\n", "output": "58\n", "type": "stdin"}, {"input": "4\n4 1 2 3\n", "output": "3\n", "type": "stdin"}, {"input": "96\n64 3 47 83 19 10 72 61 73 95 16 40 54 84 8 86 28 4 37 42 92 48 63 76 67 1 59 66 20 35 93 2 43 7 45 70 34 33 26 91 85 89 13 29 58 68 44 25 87 75 49 71 41 17 55 36 32 31 74 22 52 79 30 88 50 78 38 39 65 27 69 77 81 94 82 53 21 80 57 60 24 46 51 9 18 15 96 62 6 23 11 12 90 5 14 56\n", "output": "86\n", "type": "stdin"}, {"input": "100\n28 30 77 4 81 67 31 25 66 56 88 73 83 51 57 34 21 90 38 76 22 99 53 70 91 3 64 54 6 94 8 5 97 80 50 45 61 40 16 95 36 98 9 2 17 44 72 55 18 58 47 12 87 24 7 32 14 23 65 41 63 48 62 39 92 27 43 19 46 13 42 52 96 84 26 69 100 79 93 49 35 60 71 59 68 15 10 29 20 1 78 33 75 86 11 85 74 82 89 37\n", "output": "89\n", "type": "stdin"}, {"input": "4\n4 1 3 2\n", "output": "3\n", "type": "stdin"}, {"input": "6\n2 3 4 1 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "10\n5 2 3 4 1 6 7 8 10 9\n", "output": "8\n", "type": "stdin"}, {"input": "85\n1 18 58 8 22 76 3 61 12 33 54 41 6 24 82 15 10 17 38 64 26 4 62 28 47 14 66 9 84 75 2 71 67 43 37 32 85 21 69 52 55 63 81 51 74 59 65 34 29 36 30 45 27 53 13 79 39 57 5 70 19 40 7 42 68 48 16 80 83 23 46 35 72 31 11 44 73 77 50 56 49 25 60 20 78\n", "output": "84\n", "type": "stdin"}, {"input": "4\n3 4 2 1\n", "output": "3\n", "type": "stdin"}, {"input": "74\n19 51 59 34 8 40 42 55 65 16 74 26 49 63 64 70 35 72 7 12 43 18 61 27 47 31 13 32 71 22 25 67 9 1 48 50 33 10 21 46 11 45 17 37 28 60 69 66 38 2 30 3 39 15 53 68 57 41 6 36 24 73 4 23 5 62 44 14 20 29 52 54 56 58\n", "output": "63\n", "type": "stdin"}, {"input": "100\n1 88 38 56 62 99 39 80 12 33 57 24 28 84 37 42 10 95 83 58 8 40 20 2 30 78 60 79 36 71 51 31 27 65 22 47 6 19 61 94 75 4 74 35 15 23 92 9 70 13 11 59 90 18 66 81 64 72 16 32 34 67 46 91 21 87 77 97 82 41 7 86 26 43 45 3 93 17 52 96 50 63 48 5 53 44 29 25 98 54 49 14 73 69 89 55 76 85 68 100\n", "output": "99\n", "type": "stdin"}, {"input": "41\n24 18 7 23 3 15 1 17 25 5 30 10 34 36 2 14 9 21 41 40 20 28 33 35 12 22 11 8 19 16 31 27 26 32 29 4 13 38 37 39 6\n", "output": "34\n", "type": "stdin"}, {"input": "10\n2 3 4 5 6 7 1 8 10 9\n", "output": "8\n", "type": "stdin"}, {"input": "78\n7 61 69 47 68 42 65 78 70 3 32 59 49 51 23 71 11 63 22 18 43 34 24 13 27 16 19 40 21 46 48 77 28 66 54 67 60 15 75 62 9 26 52 58 4 25 8 37 41 76 1 6 30 50 44 36 5 14 29 53 17 12 2 57 73 35 64 39 56 10 33 20 45 74 31 55 38 72\n", "output": "70\n", "type": "stdin"}, {"input": "33\n22 13 10 33 8 25 15 14 21 28 27 19 26 24 1 12 5 11 32 20 30 31 18 4 6 23 7 29 16 2 17 9 3\n", "output": "29\n", "type": "stdin"}, {"input": "80\n51 20 37 12 68 11 28 52 76 21 7 5 3 16 64 34 25 2 6 40 60 62 75 13 45 17 56 29 32 47 79 73 49 72 15 46 30 54 80 27 43 24 74 18 42 71 14 4 44 63 65 33 1 77 55 57 41 59 58 70 69 35 19 67 10 36 26 23 48 50 39 61 9 66 38 8 31 22 53 78\n", "output": "52\n", "type": "stdin"}, {"input": "36\n1 32 27 35 22 7 34 15 18 36 31 28 13 2 10 21 20 17 16 4 3 24 19 29 11 12 25 5 33 26 14 6 9 23 30 8\n", "output": "35\n", "type": "stdin"}, {"input": "27\n20 14 18 10 5 3 9 4 24 22 21 27 17 15 26 2 23 7 12 11 6 8 19 25 16 13 1\n", "output": "26\n", "type": "stdin"}, {"input": "93\n76 35 5 87 7 21 59 71 24 37 2 73 31 74 4 52 28 20 56 27 65 86 16 45 85 67 68 70 47 72 91 88 14 32 62 69 78 41 15 22 57 18 50 13 39 58 17 83 64 51 25 11 38 77 82 90 8 26 29 61 10 43 79 53 48 6 23 55 63 49 81 92 80 44 89 60 66 30 1 9 36 33 19 46 75 93 3 12 42 84 40 54 34\n", "output": "85\n", "type": "stdin"}, {"input": "4\n1 3 4 2\n", "output": "3\n", "type": "stdin"}, {"input": "40\n35 39 28 11 9 31 36 8 5 32 26 19 38 33 2 22 23 25 6 37 12 7 3 10 17 24 20 16 27 4 34 15 40 14 18 13 29 21 30 1\n", "output": "39\n", "type": "stdin"}, {"input": "17\n13 12 5 3 9 16 8 14 2 4 10 1 6 11 7 15 17\n", "output": "16\n", "type": "stdin"}, {"input": "58\n1 26 28 14 22 33 57 40 9 42 44 37 24 19 58 12 48 3 34 31 49 4 16 47 55 52 27 23 46 18 20 32 56 6 39 36 41 38 13 43 45 21 53 54 29 17 5 10 25 30 2 35 11 7 15 51 8 50\n", "output": "57\n", "type": "stdin"}, {"input": "6\n2 5 3 6 4 1\n", "output": "5\n", "type": "stdin"}, {"input": "46\n29 3 12 33 45 40 19 17 25 27 28 1 16 23 24 46 31 8 44 15 5 32 22 11 4 36 34 10 35 26 21 7 14 2 18 9 20 41 6 43 42 37 38 13 39 30\n", "output": "34\n", "type": "stdin"}, {"input": "90\n2 67 26 58 9 49 76 22 60 30 77 20 13 7 37 81 47 16 19 12 14 45 41 68 85 54 28 24 46 1 27 43 32 89 53 35 59 75 18 51 17 64 66 80 31 88 87 90 38 72 55 71 42 11 73 69 62 78 23 74 65 79 84 4 86 52 10 6 3 82 56 5 48 33 21 57 40 29 61 63 34 36 83 8 15 44 50 70 39 25\n", "output": "60\n", "type": "stdin"}, {"input": "24\n2 10 23 22 20 19 18 16 11 12 15 17 21 8 24 13 1 5 6 7 14 3 9 4\n", "output": "16\n", "type": "stdin"}, {"input": "3\n3 2 1\n", "output": "2\n", "type": "stdin"}, {"input": "100\n56 64 1 95 72 39 9 49 87 29 94 7 32 6 30 48 50 25 31 78 90 45 60 44 80 68 17 20 73 15 75 98 83 13 71 22 36 26 96 88 35 3 85 54 16 41 92 99 69 86 93 33 43 62 77 46 47 37 12 10 18 40 27 4 63 55 28 59 23 34 61 53 76 42 51 91 21 70 8 58 38 19 5 66 84 11 52 24 81 82 79 67 97 65 57 74 2 89 100 14\n", "output": "98\n", "type": "stdin"}, {"input": "71\n40 6 62 3 41 52 31 66 27 16 35 5 17 60 2 15 51 22 67 61 71 53 1 64 8 45 28 18 50 30 12 69 20 26 10 37 36 49 70 32 33 11 57 14 9 55 4 58 29 25 44 65 39 48 24 47 19 46 56 38 34 42 59 63 54 23 7 68 43 13 21\n", "output": "50\n", "type": "stdin"}, {"input": "35\n24 33 20 8 34 11 31 25 2 4 18 13 9 35 16 30 23 32 17 1 14 22 19 21 28 26 3 15 5 12 27 29 10 6 7\n", "output": "21\n", "type": "stdin"}, {"input": "100\n83 96 73 70 30 25 7 77 58 89 76 85 49 82 45 51 14 62 50 9 31 32 16 15 97 64 4 37 20 93 24 10 80 71 100 39 75 72 78 74 8 29 53 86 79 48 3 68 90 99 56 87 63 94 36 1 40 65 6 44 43 84 17 52 34 95 38 47 60 57 98 59 33 41 46 81 23 27 19 2 54 91 55 35 26 12 92 18 28 66 69 21 5 67 13 11 22 88 61 42\n", "output": "65\n", "type": "stdin"}, {"input": "64\n23 5 51 40 12 46 44 8 64 31 58 55 45 24 54 39 21 19 52 61 30 42 16 18 15 32 53 22 28 26 11 25 48 56 27 9 29 41 35 49 59 38 62 7 34 1 20 33 60 17 2 3 43 37 57 14 6 36 13 10 50 4 63 47\n", "output": "55\n", "type": "stdin"}, {"input": "4\n2 4 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "45\n45 29 24 2 31 5 34 41 26 44 33 43 15 3 4 11 21 37 27 12 14 39 23 42 16 6 13 19 8 38 20 9 25 22 40 17 32 35 18 10 28 7 30 36 1\n", "output": "44\n", "type": "stdin"}, {"input": "39\n16 28 4 33 26 36 25 23 22 30 27 7 12 34 17 6 3 38 10 24 13 31 29 39 14 32 9 20 35 11 18 21 8 2 15 37 5 19 1\n", "output": "38\n", "type": "stdin"}, {"input": "62\n21 23 34 38 11 61 55 30 37 48 54 51 46 47 6 56 36 49 1 35 12 28 29 20 43 42 5 8 22 57 44 4 53 10 58 33 27 25 16 45 50 40 18 15 3 41 39 2 7 60 59 13 32 24 52 31 14 9 19 26 17 62\n", "output": "61\n", "type": "stdin"}, {"input": "26\n6 21 20 16 26 17 11 2 24 4 1 12 14 8 25 7 15 10 22 5 13 18 9 23 19 3\n", "output": "21\n", "type": "stdin"}, {"input": "6\n4 2 3 1 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "21\n1 9 14 18 13 12 11 20 16 2 4 19 15 7 6 17 8 5 3 10 21\n", "output": "20\n", "type": "stdin"}, {"input": "91\n91 69 56 16 73 55 14 82 80 46 57 81 22 71 63 76 43 37 77 75 70 3 26 2 28 17 51 38 30 67 41 47 54 62 34 25 84 11 87 39 32 52 31 36 50 19 21 53 29 24 79 8 74 64 44 7 6 18 10 42 13 9 83 58 4 88 65 60 20 90 66 49 86 89 78 48 5 27 23 59 61 15 72 45 40 33 68 85 35 12 1\n", "output": "90\n", "type": "stdin"}, {"input": "100\n100 97 35 55 45 3 46 98 77 64 94 85 73 43 49 79 72 9 70 62 80 88 29 58 61 20 89 83 66 86 82 15 6 87 42 96 90 75 63 38 81 40 5 23 4 18 41 19 99 60 8 12 76 51 39 93 53 26 21 50 47 28 13 30 68 59 34 54 24 56 31 27 65 16 32 10 36 52 44 91 22 14 33 25 7 78 67 17 57 37 92 11 2 69 84 95 74 71 48 1\n", "output": "99\n", "type": "stdin"}, {"input": "4\n1 3 2 4\n", "output": "3\n", "type": "stdin"}, {"input": "5\n1 4 5 2 3\n", "output": "4\n", "type": "stdin"}, {"input": "49\n16 7 42 32 11 35 15 8 23 41 6 20 47 24 9 45 49 2 37 48 25 28 5 18 3 19 12 4 22 33 13 14 10 36 44 17 40 38 30 26 1 43 29 46 21 34 27 39 31\n", "output": "40\n", "type": "stdin"}, {"input": "73\n58 38 47 34 39 64 69 66 72 57 9 4 67 22 35 13 61 14 28 52 56 20 31 70 27 24 36 1 62 17 10 5 12 33 16 73 18 49 63 71 44 65 23 30 40 8 50 46 60 25 11 26 37 55 29 68 42 2 3 32 59 7 15 43 41 48 51 53 6 45 54 19 21\n", "output": "45\n", "type": "stdin"}, {"input": "100\n96 80 47 60 56 9 78 20 37 72 68 15 100 94 51 26 65 38 50 19 4 70 25 63 22 30 13 58 43 69 18 33 5 66 39 73 12 55 95 92 97 1 14 83 10 28 64 31 46 91 32 86 74 54 29 52 89 53 90 44 62 40 16 24 67 81 36 34 7 23 79 87 75 98 84 3 41 77 76 42 71 35 49 61 2 27 59 82 99 85 21 11 45 6 88 48 17 57 8 93\n", "output": "87\n", "type": "stdin"}, {"input": "63\n2 5 29 48 31 26 21 16 47 24 43 22 61 28 6 39 60 27 14 52 37 7 53 8 62 56 63 10 50 18 44 13 4 9 25 11 23 42 45 41 59 12 32 36 40 51 1 35 49 54 57 20 19 34 38 46 33 3 55 15 30 58 17\n", "output": "46\n", "type": "stdin"}, {"input": "20\n15 17 10 20 7 2 16 9 13 6 18 5 19 8 11 14 4 12 3 1\n", "output": "19\n", "type": "stdin"}, {"input": "72\n52 64 71 40 32 10 62 21 11 37 38 13 22 70 1 66 41 50 27 20 42 47 25 68 49 12 15 72 44 60 53 5 23 14 43 29 65 36 51 54 35 67 7 19 55 48 58 46 39 24 33 30 61 45 57 2 31 3 18 59 6 9 4 63 8 16 26 34 28 69 17 56\n", "output": "57\n", "type": "stdin"}, {"input": "76\n1 47 54 17 38 37 12 32 14 48 43 71 60 56 4 13 64 41 52 57 62 6 23 49 20 10 63 3 25 66 59 40 58 33 53 46 70 7 35 61 72 74 73 19 30 5 29 6 15 28 21 27 51 55 50 9 65 8 67 39 76 42 31 34 16 2 36 11 26 44 22 45 75 18 69 68\n", "output": "75\n", "type": "stdin"}, {"input": "12\n3 6 7 8 13 10 12 5 4 2 11 1\n", "output": "11\n", "type": "stdin"}, {"input": "81\n63 22 4 41 43 74 64 39 10 35 20 81 11 28 70 67 53 79 16 61 68 52 27 37 58 9 50 49 24 30 72 47 7 60 78 51 23 48 73 66 44 13 15 57 56 38 1 76 25 45 36 34 42 8 75 26 59 14 71 21 6 77 5 17 2 32 40 54 46 24 29 3 31 19 65 62 33 69 12 80 55\n", "output": "69\n", "type": "stdin"}, {"input": "98\n85 94 69 86 22 52 27 79 53 91 35 55 53 88 8 75 76 95 64 54 67 30 70 49 6 16 2 48 80 32 25 90 98 46 9 96 36 81 10 92 28 11 37 97 15 41 38 40 83 44 29 47 23 3 31 61 87 39 78 20 68 12 17 73 59 18 77 72 43 51 84 24 89 65 26 7 74 93 21 19 5 14 50 42 82 71 60 56 34 62 58 57 45 66 13 63 4 1\n", "output": "97\n", "type": "stdin"}, {"input": "22\n8 3 17 4 16 21 14 11 10 15 6 18 13 12 22 37 5 2 9 7 19 1\n", "output": "21\n", "type": "stdin"}, {"input": "100\n76 70 67 54 40 1 48 63 64 36 42 90 99 27 47 17 93 7 13 84 16 57 74 5 83 61 19 56 52 92 38 91 82 79 34 66 71 28 37 98 35 94 77 53 73 10 26 80 15 32 8 81 3 95 44 46 72 6 33 11 21 85 4 48 24 51 49 96 87 55 14 31 12 60 45 9 29 22 58 18 88 2 50 59 20 86 23 41 100 39 62 68 69 97 78 43 25 89 65 75\n", "output": "94\n", "type": "stdin"}, {"input": "70\n19 12 15 18 36 16 61 69 24 0 11 13 3 48 55 21 37 17 43 31 41 22 28 32 27 63 38 49 59 56 30 25 67 51 52 45 50 44 66 57 26 60 5 46 33 6 23 34 8 40 2 68 14 39 65 64 62 42 47 54 10 53 9 1 70 58 20 4 29 35\n", "output": "64\n", "type": "stdin"}, {"input": "6\n5 7 2 6 1 3\n", "output": "4\n", "type": "stdin"}, {"input": "99\n33 48 19 41 59 64 16 12 17 13 7 1 9 6 4 92 61 49 60 25 74 65 22 97 30 32 10 62 14 55 80 66 82 78 31 23 87 93 27 98 20 29 88 84 77 34 83 96 79 90 56 89 58 72 52 47 21 76 24 70 44 94 5 39 8 18 57 36 40 68 43 75 3 2 35 99 63 26 67 73 15 11 53 28 42 46 69 50 51 95 38 37 2 85 81 91 45 86 71\n", "output": "87\n", "type": "stdin"}, {"input": "67\n66 16 2 53 35 38 49 28 18 6 36 58 21 47 42 5 50 62 44 12 52 37 11 56 15 31 25 65 17 29 59 41 7 42 4 43 39 10 1 40 24 13 20 54 19 67 46 60 51 45 64 30 8 33 26 9 3 22 34 23 57 48 55 14 63 61 32\n", "output": "45\n", "type": "stdin"}, {"input": "19\n12 19 3 11 15 6 18 14 5 10 4 13 9 7 4 8 17 16 1\n", "output": "18\n", "type": "stdin"}, {"input": "13\n8 4 3 7 2 11 9 1 10 2 13 12 6\n", "output": "10\n", "type": "stdin"}, {"input": "32\n15 32 11 3 18 23 19 14 7 8 6 21 13 24 25 4 16 9 27 20 17 31 2 22 7 12 30 1 26 10 29 28\n", "output": "30\n", "type": "stdin"}, {"input": "7\n1 4 3 6 2 4 7\n", "output": "6\n", "type": "stdin"}, {"input": "84\n75 8 66 21 61 63 72 51 52 13 59 25 28 58 64 53 79 41 34 7 67 11 39 56 44 24 50 9 49 55 1 80 26 6 73 74 27 69 65 37 18 43 36 17 30 3 47 29 76 78 32 22 12 68 46 5 42 81 57 31 33 83 54 48 14 62 10 16 4 20 71 70 35 15 45 19 60 77 2 23 84 40 82 70\n", "output": "80\n", "type": "stdin"}, {"input": "100\n22 47 34 65 69 5 68 78 53 54 41 23 80 51 11 7 2 85 81 75 25 58 29 73 30 49 10 71 17 96 76 89 79 20 12 15 55 7 46 32 19 3 82 35 74 44 38 40 92 14 6 50 97 63 45 93 37 18 62 77 87 36 83 9 90 61 57 28 39 43 52 42 24 56 21 84 26 99 88 59 33 70 4 60 98 95 94 100 13 48 66 72 16 31 64 91 1 86 27 67\n", "output": "96\n", "type": "stdin"}, {"input": "9\n6 11 5 3 4 7 9 2 1\n", "output": "8\n", "type": "stdin"}, {"input": "44\n4 38 6 40 29 3 44 2 30 35 25 22 34 10 11 31 21 7 14 23 37 19 27 18 5 22 1 16 17 9 39 13 15 32 43 8 41 26 42 12 24 33 20 28\n", "output": "37\n", "type": "stdin"}, {"input": "100\n100 97 92 12 12 17 19 58 37 26 30 95 31 35 87 10 13 43 98 61 28 89 76 1 23 21 11 22 50 56 91 74 3 24 96 55 64 67 14 4 71 16 18 9 77 68 51 81 32 82 46 88 86 60 29 66 72 85 70 7 53 63 33 45 83 2 25 94 52 93 5 69 20 47 49 54 57 39 34 27 90 80 78 59 40 42 79 6 38 8 48 15 65 73 99 44 41 84 36 75\n", "output": "99\n", "type": "stdin"}, {"input": "50\n31 45 3 34 13 43 32 4 42 9 7 8 24 14 35 6 19 46 44 10 18 1 25 20 27 41 2 16 12 10 11 47 38 21 28 49 30 15 50 36 29 26 22 39 48 5 23 37 33 40\n", "output": "38\n", "type": "stdin"}, {"input": "51\n47 29 2 11 43 44 27 1 39 13 25 30 33 21 38 45 34 51 16 50 42 31 41 46 15 48 13 19 6 37 35 7 22 28 20 4 17 10 5 8 24 40 9 36 18 49 12 26 23 3 32\n", "output": "43\n", "type": "stdin"}, {"input": "5\n2 3 1 5 2\n", "output": "3\n", "type": "stdin"}, {"input": "34\n34 30 7 16 6 1 10 29 29 13 15 25 32 26 18 11 28 3 14 21 19 5 31 33 4 17 8 9 24 20 27 22 2 12\n", "output": "33\n", "type": "stdin"}, {"input": "42\n42 15 24 26 4 34 19 29 38 32 31 33 14 41 21 3 11 39 25 6 5 20 23 10 16 36 18 28 27 1 7 40 22 30 9 2 37 17 8 12 2 35\n", "output": "41\n", "type": "stdin"}, {"input": "97\n40 63 44 64 84 92 38 72 28 91 3 70 76 67 94 96 35 79 29 22 78 88 85 8 21 1 93 54 71 80 37 17 13 26 62 59 75 87 69 33 89 49 77 61 12 39 6 36 58 18 73 50 82 45 74 52 11 34 95 7 23 30 15 32 31 16 55 19 20 83 60 72 10 53 51 14 27 9 68 47 5 2 81 46 57 86 56 43 48 66 24 25 4 42 65 97 90\n", "output": "95\n", "type": "stdin"}, {"input": "10\n2 9 3 4 1 10 5 6 3 8\n", "output": "5\n", "type": "stdin"}, {"input": "89\n68 40 14 58 56 25 8 44 49 55 9 76 66 54 33 81 42 15 59 17 21 30 75 60 4 48 64 6 52 63 61 27 12 57 72 67 23 86 77 80 22 13 43 73 26 78 50 51 18 62 1 29 82 16 74 2 87 24 3 41 11 46 47 69 10 84 65 39 35 79 70 32 34 31 20 19 53 71 36 35 83 88 38 85 7 5 37 45 89\n", "output": "88\n", "type": "stdin"}, {"input": "15\n6 14 13 12 7 2 4 11 15 1 8 6 5 10 9\n", "output": "9\n", "type": "stdin"}, {"input": "29\n21 11 10 25 2 5 9 16 29 8 17 4 27 13 6 22 7 24 19 12 18 20 1 3 23 28 27 14 26\n", "output": "22\n", "type": "stdin"}, {"input": "100\n66 100 53 88 7 73 54 41 31 42 8 46 65 90 78 14 94 30 79 39 89 5 83 50 38 61 37 86 22 95 60 98 34 46 91 10 75 25 15 43 23 17 96 35 93 48 87 47 56 13 19 9 82 62 67 80 11 55 99 70 18 26 58 85 12 44 16 45 4 49 20 71 92 24 81 2 76 32 6 21 84 36 52 97 59 63 40 51 27 64 68 3 77 72 28 33 29 1 74 69\n", "output": "98\n", "type": "stdin"}, {"input": "61\n61 11 26 29 31 40 32 30 35 3 18 52 9 53 42 4 50 54 20 58 28 49 22 12 2 19 16 15 57 34 51 43 7 17 25 41 56 47 38 60 46 14 44 45 24 27 33 1 48 13 59 23 38 39 6 5 36 10 8 37 21\n", "output": "60\n", "type": "stdin"}, {"input": "65\n10 11 55 43 53 25 35 26 16 37 41 38 59 21 48 2 65 49 17 23 18 30 62 36 3 4 47 15 28 63 57 54 31 46 45 12 51 7 29 13 56 52 14 22 39 19 8 27 45 5 6 34 32 61 20 50 9 24 33 58 60 40 1 42 64\n", "output": "62\n", "type": "stdin"}, {"input": "60\n60 27 34 32 54 55 33 12 40 3 47 44 50 39 38 59 11 25 17 15 16 30 21 31 10 52 5 23 4 48 6 26 36 57 14 22 8 56 58 9 24 7 37 53 42 43 20 49 51 19 2 46 28 18 46 13 29 45 41 1\n", "output": "59\n", "type": "stdin"}, {"input": "57\n39 28 53 36 3 6 12 56 55 20 50 19 43 42 18 40 24 52 38 17 33 23 22 41 14 7 26 44 45 16 35 1 8 47 31 5 30 51 32 4 37 25 13 34 54 21 34 10 15 11 2 27 29 48 49 9 57\n", "output": "56\n", "type": "stdin"}, {"input": "86\n64 56 41 10 31 69 47 39 37 36 27 19 9 42 15 6 78 59 52 17 71 45 72 14 2 54 38 79 4 18 16 8 46 75 50 82 44 24 20 55 58 86 61 43 35 32 33 40 63 30 28 60 13 53 12 57 77 81 76 66 73 84 85 62 68 22 51 6 49 7 1 70 80 65 34 48 23 21 83 11 74 26 29 67 25 3\n", "output": "70\n", "type": "stdin"}, {"input": "83\n64 8 58 17 67 46 3 82 23 70 72 16 53 45 13 20 12 48 40 4 6 47 76 60 19 44 30 78 28 22 75 15 25 29 63 74 55 32 14 51 35 31 62 77 27 42 65 71 56 61 66 41 68 49 7 34 2 83 36 5 33 26 37 80 59 50 1 9 54 21 18 17 38 73 81 52 10 39 43 79 57 11 69\n", "output": "66\n", "type": "stdin"}, {"input": "53\n53 30 28 22 51 31 32 38 12 7 39 43 1 23 6 8 24 52 2 21 34 13 3 35 5 15 19 11 47 18 9 20 29 4 36 45 27 41 25 48 16 46 44 17 10 14 42 26 40 28 33 37 49\n", "output": "52\n", "type": "stdin"}, {"input": "87\n14 4 82 47 39 75 71 45 3 37 63 19 32 68 7 41 48 76 27 46 84 49 4 44 26 69 17 64 1 18 58 33 11 23 21 86 67 52 70 16 77 78 6 74 15 87 10 59 13 34 22 2 65 38 66 61 51 57 35 60 81 40 36 80 31 43 83 56 79 55 29 5 12 8 50 30 53 72 54 9 24 25 42 62 73 28 85\n", "output": "58\n", "type": "stdin"}, {"input": "55\n26 15 31 21 32 43 43 51 7 12 5 44 17 54 18 25 48 47 20 3 41 24 45 2 11 22 29 39 37 53 35 28 36 9 50 10 30 38 19 13 4 8 27 1 42 6 49 23 55 40 33 16 46 14 52\n", "output": "48\n", "type": "stdin"}, {"input": "75\n75 28 60 19 59 17 65 26 32 23 18 64 8 62 4 11 42 16 47 5 72 46 9 1 25 21 2 50 33 6 36 68 30 12 20 40 53 45 34 7 37 39 38 44 63 61 67 3 66 51 57 73 24 57 70 27 10 56 22 55 13 49 35 15 54 41 14 74 69 48 52 31 71 43 58\n", "output": "74\n", "type": "stdin"}, {"input": "79\n75 79 43 66 72 52 29 65 74 38 24 1 5 51 13 7 71 33 4 61 2 36 63 47 64 44 34 27 3 21 17 37 54 53 49 20 28 60 39 10 16 9 6 77 73 22 50 48 78 30 67 56 31 26 40 59 41 11 18 45 69 62 15 23 32 70 19 55 68 57 35 25 12 46 14 42 9 8 58\n", "output": "77\n", "type": "stdin"}, {"input": "100\n5 6 88 37 97 51 25 81 54 17 57 98 99 44 67 24 30 93 100 36 8 38 84 42 21 4 75 31 85 48 70 77 43 50 65 94 29 32 68 86 56 39 69 47 20 60 52 53 10 34 79 2 95 40 89 64 71 26 22 46 1 62 91 76 39 41 9 78 16 63 13 3 28 92 27 49 7 12 96 72 80 23 14 19 18 66 59 87 90 45 73 82 33 74 35 61 55 15 58 11\n", "output": "81\n", "type": "stdin"}, {"input": "66\n66 39 3 2 55 53 60 54 12 49 10 30 59 26 32 46 50 56 7 13 43 36 24 28 11 8 6 21 35 25 42 57 23 45 64 5 34 61 27 51 52 9 15 1 38 17 63 48 37 20 58 14 47 19 22 41 31 44 33 5 4 62 40 18 16 29\n", "output": "65\n", "type": "stdin"}, {"input": "9\n7 2 3 5 5 6 1 9 8\n", "output": "7\n", "type": "stdin"}, {"input": "28\n28 18 16 6 1 12 4 27 22 7 18 3 21 26 25 11 5 10 20 24 19 15 14 8 23 17 9 2\n", "output": "27\n", "type": "stdin"}, {"input": "38\n9 35 37 28 36 21 10 25 19 7 26 5 22 7 27 18 6 14 15 24 1 17 11 34 20 8 2 16 3 23 32 31 13 12 38 33 30 29\n", "output": "34\n", "type": "stdin"}, {"input": "43\n43 24 20 13 22 29 28 4 30 3 32 32 31 8 7 9 35 27 18 5 42 6 17 19 23 12 41 21 16 37 33 34 2 14 36 38 25 10 15 39 26 11 1\n", "output": "42\n", "type": "stdin"}, {"input": "30\n12 19 14 22 26 17 27 8 25 3 24 30 4 18 23 16 9 13 29 20 15 2 5 11 28 12 1 10 21 7\n", "output": "26\n", "type": "stdin"}, {"input": "16\n11 6 9 8 10 14 12 13 10 15 2 5 3 1 4 16\n", "output": "15\n", "type": "stdin"}, {"input": "96\n64 3 47 83 19 10 72 61 73 95 16 40 54 84 8 86 28 4 37 42 92 48 63 76 67 1 59 66 20 35 93 2 43 7 45 70 34 33 26 91 85 89 13 29 58 68 44 25 87 75 49 71 41 17 55 36 32 31 36 22 52 79 30 88 50 78 38 39 65 27 69 77 81 94 82 53 21 80 57 60 24 46 51 9 18 15 96 62 6 23 11 12 90 5 14 56\n", "output": "86\n", "type": "stdin"}, {"input": "100\n28 30 77 4 81 67 31 25 66 56 88 73 83 51 57 34 21 90 38 76 22 99 53 70 91 3 64 54 6 94 8 5 97 80 50 45 61 40 16 95 36 98 9 2 31 44 72 55 18 58 47 12 87 24 7 32 14 23 65 41 63 48 62 39 92 27 43 19 46 13 42 52 96 84 26 69 100 79 93 49 35 60 71 59 68 15 10 29 20 1 78 33 75 86 11 85 74 82 89 37\n", "output": "89\n", "type": "stdin"}, {"input": "85\n1 18 58 8 22 76 3 61 12 33 54 41 6 24 82 15 10 17 17 64 26 4 62 28 47 14 66 9 84 75 2 71 67 43 37 32 85 21 69 52 55 63 81 51 74 59 65 34 29 36 30 45 27 53 13 79 39 57 5 70 19 40 7 42 68 48 16 80 83 23 46 35 72 31 11 44 73 77 50 56 49 25 60 20 78\n", "output": "84\n", "type": "stdin"}, {"input": "36\n1 32 27 35 22 7 34 15 18 36 31 4 13 2 10 21 20 17 16 4 3 24 19 29 11 12 25 5 33 26 14 6 9 23 30 8\n", "output": "35\n", "type": "stdin"}, {"input": "93\n76 35 5 87 7 21 59 71 24 37 2 73 31 42 4 52 28 20 56 27 65 86 16 45 85 67 68 70 47 72 91 88 14 32 62 69 78 41 15 22 57 18 50 13 39 58 17 83 64 51 25 11 38 77 82 90 8 26 29 61 10 43 79 53 48 6 23 55 63 49 81 92 80 44 89 60 66 30 1 9 36 33 19 46 75 93 3 12 42 84 40 54 34\n", "output": "85\n", "type": "stdin"}, {"input": "40\n35 39 28 11 9 31 36 8 5 32 26 19 38 33 2 22 23 25 7 37 12 7 3 10 17 24 20 16 27 4 34 15 40 14 18 13 29 21 30 1\n", "output": "39\n", "type": "stdin"}, {"input": "58\n1 26 28 14 22 10 57 40 9 42 44 37 24 19 58 12 48 3 34 31 49 4 16 47 55 52 27 23 46 18 20 32 56 6 39 36 41 38 13 43 45 21 53 54 29 17 5 10 25 30 2 35 11 7 15 51 8 50\n", "output": "57\n", "type": "stdin"}, {"input": "24\n2 10 23 21 20 19 18 16 11 12 15 17 21 8 24 13 1 5 6 7 14 3 9 4\n", "output": "16\n", "type": "stdin"}, {"input": "71\n40 6 62 3 41 52 31 66 27 16 35 5 17 60 2 15 51 22 67 61 71 53 1 64 8 45 28 18 50 30 6 69 20 26 10 37 36 49 70 32 33 11 57 14 9 55 4 58 29 25 44 65 39 48 24 47 19 46 56 38 34 42 59 63 54 23 7 68 43 13 21\n", "output": "50\n", "type": "stdin"}, {"input": "45\n45 29 24 2 31 5 34 41 26 44 33 43 15 3 4 11 21 37 27 12 14 39 23 42 16 6 13 16 8 38 20 9 25 22 40 17 32 35 18 10 28 7 30 36 1\n", "output": "44\n", "type": "stdin"}, {"input": "62\n21 23 34 38 11 61 55 30 37 48 54 51 46 47 6 56 36 49 1 35 12 28 29 20 43 42 5 8 22 57 44 4 53 10 58 33 27 25 16 45 50 40 18 0 3 41 39 2 7 60 59 13 32 24 52 31 14 9 19 26 17 62\n", "output": "61\n", "type": "stdin"}, {"input": "91\n91 69 56 16 73 55 14 82 80 46 57 81 22 71 63 76 43 37 77 75 70 3 26 2 28 17 51 38 30 67 41 47 54 62 34 25 84 11 87 39 32 52 31 36 50 27 21 53 29 24 79 8 74 64 44 7 6 18 10 42 13 9 83 58 4 88 65 60 20 90 66 49 86 89 78 48 5 27 23 59 61 15 72 45 40 33 68 85 35 12 1\n", "output": "90\n", "type": "stdin"}, {"input": "49\n16 7 42 32 3 35 15 8 23 41 6 20 47 24 9 45 49 2 37 48 25 28 5 18 3 19 12 4 22 33 13 14 10 36 44 17 40 38 30 26 1 43 29 46 21 34 27 39 31\n", "output": "40\n", "type": "stdin"}, {"input": "63\n2 5 29 48 31 26 21 16 47 24 43 22 61 28 6 39 60 27 14 52 37 7 53 8 62 56 63 10 50 18 31 13 4 9 25 11 23 42 45 41 59 12 32 36 40 51 1 35 49 54 57 20 19 34 38 46 33 3 55 15 30 58 17\n", "output": "46\n", "type": "stdin"}, {"input": "20\n15 17 10 20 7 2 23 9 13 6 18 5 19 8 11 14 4 12 3 1\n", "output": "19\n", "type": "stdin"}, {"input": "31\n29 13 26 27 9 28 2 16 30 21 12 11 3 31 23 6 22 20 1 5 14 24 19 18 8 4 10 17 15 25 14\n", "output": "18\n", "type": "stdin"}, {"input": "94\n29 85 82 78 61 83 80 63 11 38 50 43 9 24 4 87 79 45 3 17 90 7 34 27 1 76 26 39 84 47 4 41 81 19 44 23 56 92 35 31 72 62 70 53 40 88 13 14 73 2 59 86 46 94 15 12 77 57 89 42 75 48 18 51 32 55 71 30 49 91 20 60 5 93 33 64 21 36 10 28 8 65 66 69 74 58 6 52 25 67 16 37 54 68\n", "output": "69\n", "type": "stdin"}, {"input": "8\n2 3 0 5 1 6 8 7\n", "output": "6\n", "type": "stdin"}, {"input": "4\n1 4 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "88\n1 83 73 46 61 31 39 86 57 43 16 29 26 80 82 7 36 42 13 20 6 64 19 40 24 12 47 87 8 34 75 9 69 3 11 52 14 25 84 59 27 10 54 51 81 74 65 77 70 17 60 35 23 44 49 2 7 88 5 21 41 32 68 66 15 55 48 58 78 53 22 38 45 33 30 50 85 76 37 79 63 18 28 62 72 56 71 67\n", "output": "87\n", "type": "stdin"}, {"input": "6\n5 4 4 1 6 3\n", "output": "4\n", "type": "stdin"}, {"input": "8\n2 10 6 4 8 3 1 7\n", "output": "6\n", "type": "stdin"}, {"input": "4\n4 3 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "54\n6 39 14 3 45 52 16 21 23 48 42 36 13 37 46 10 43 27 49 7 38 32 31 30 15 25 2 29 8 51 54 19 41 44 24 34 22 5 20 14 12 1 33 40 4 26 9 35 18 28 47 50 11 53\n", "output": "41\n", "type": "stdin"}, {"input": "69\n29 49 25 51 21 35 11 61 39 54 40 37 60 42 27 33 59 53 34 10 46 2 23 69 8 47 58 36 1 38 19 12 7 48 13 3 6 22 18 5 65 24 50 41 66 44 35 57 4 56 62 43 9 30 14 15 28 31 64 26 16 55 68 17 32 20 45 52 63\n", "output": "45\n", "type": "stdin"}, {"input": "4\n1 0 3 4\n", "output": "3\n", "type": "stdin"}, {"input": "100\n22 59 25 77 68 79 32 45 20 28 61 60 38 86 33 10 100 15 63 75 78 39 67 13 66 34 96 4 63 23 73 29 31 35 71 55 16 14 72 56 94 97 17 93 47 84 57 8 21 51 54 85 26 76 49 81 2 92 62 44 91 87 11 24 95 69 5 7 99 6 65 48 70 12 41 18 74 27 42 3 80 30 50 98 58 37 82 89 83 36 40 52 19 9 88 46 43 1 90 64\n", "output": "97\n", "type": "stdin"}, {"input": "77\n10 20 57 65 53 69 59 45 58 32 28 72 4 14 1 33 40 47 7 5 51 76 37 16 41 61 42 2 21 26 38 74 35 64 43 77 71 41 39 48 27 63 73 44 52 66 9 18 23 54 25 6 8 56 13 67 36 22 15 46 62 75 55 11 31 17 24 29 60 68 12 30 3 70 49 19 34\n", "output": "62\n", "type": "stdin"}, {"input": "47\n7 3 8 12 24 16 29 10 28 38 1 20 37 40 21 5 15 6 45 23 36 44 25 43 41 4 11 42 18 35 32 31 39 33 27 30 22 34 14 13 17 47 23 9 46 26 2\n", "output": "41\n", "type": "stdin"}, {"input": "4\n2 1 0 4\n", "output": "3\n", "type": "stdin"}, {"input": "100\n41 67 94 18 14 83 59 12 19 54 13 68 75 26 15 65 80 40 23 30 34 78 47 21 63 79 4 70 3 31 86 69 92 10 61 74 97 100 9 99 32 27 91 55 85 52 16 17 28 1 64 29 58 76 98 25 84 7 2 96 20 72 36 46 49 82 93 44 45 6 38 87 57 50 53 35 60 33 8 89 39 42 37 48 62 81 73 43 95 11 66 88 90 22 36 77 71 51 5 56\n", "output": "62\n", "type": "stdin"}, {"input": "95\n36 73 18 77 15 71 50 57 79 65 94 88 9 69 72 70 26 66 78 89 55 20 72 83 75 68 32 28 45 74 19 22 54 23 84 90 86 12 42 58 11 81 39 31 85 47 60 44 59 43 21 7 30 41 64 76 93 46 87 48 10 40 3 14 38 49 29 35 2 67 5 34 13 37 27 56 91 17 62 80 8 61 53 95 24 92 6 82 63 33 51 25 4 16 1\n", "output": "94\n", "type": "stdin"}, {"input": "59\n1 27 10 37 53 9 14 49 46 26 50 42 59 11 47 15 24 56 43 45 44 38 5 10 58 30 52 12 23 32 22 3 31 41 2 25 29 6 54 16 35 33 18 55 4 51 57 28 40 19 13 21 7 39 36 48 34 17 20\n", "output": "58\n", "type": "stdin"}, {"input": "6\n4 3 4 1 6 5\n", "output": "4\n", "type": "stdin"}, {"input": "10\n5 2 3 3 1 6 7 8 10 9\n", "output": "8\n", "type": "stdin"}, {"input": "100\n1 88 38 56 62 99 39 80 12 33 57 24 28 84 37 42 10 95 83 58 8 40 20 2 30 78 60 79 36 71 51 31 27 65 22 47 6 19 61 94 75 4 74 35 15 23 92 9 70 13 11 59 90 18 66 81 64 72 16 32 34 67 46 91 21 87 77 97 82 41 7 86 26 43 45 3 93 17 88 96 50 63 48 5 53 44 29 25 98 54 49 14 73 69 89 55 76 85 68 100\n", "output": "99\n", "type": "stdin"}, {"input": "41\n24 18 7 23 3 15 1 17 25 5 2 10 34 36 2 14 9 21 41 40 20 28 33 35 12 22 11 8 19 16 31 27 26 32 29 4 13 38 37 39 6\n", "output": "34\n", "type": "stdin"}, {"input": "78\n7 61 69 47 68 42 65 78 70 3 32 59 49 51 23 71 11 63 22 18 64 34 24 13 27 16 19 40 21 46 48 77 28 66 54 67 60 15 75 62 9 26 52 58 4 25 8 37 41 76 1 6 30 50 44 36 5 14 29 53 17 12 2 57 73 35 64 39 56 10 33 20 45 74 31 55 38 72\n", "output": "70\n", "type": "stdin"}, {"input": "80\n51 20 37 12 68 11 28 52 76 21 7 5 3 16 64 34 25 2 6 40 60 62 75 13 45 17 56 29 32 47 79 73 49 72 15 46 30 54 80 27 43 24 74 18 42 71 14 4 44 63 65 33 1 77 55 57 41 59 58 70 69 35 19 67 10 36 26 23 48 50 39 61 9 66 38 8 31 39 53 78\n", "output": "52\n", "type": "stdin"}, {"input": "27\n20 14 18 10 5 3 9 4 24 22 21 27 17 15 26 2 23 4 12 11 6 8 19 25 16 13 1\n", "output": "26\n", "type": "stdin"}, {"input": "6\n2 3 3 6 4 1\n", "output": "5\n", "type": "stdin"}, {"input": "90\n2 67 26 58 9 49 76 22 60 30 77 20 13 7 37 81 47 16 19 12 14 13 41 68 85 54 28 24 46 1 27 43 32 89 53 35 59 75 18 51 17 64 66 80 31 88 87 90 38 72 55 71 42 11 73 69 62 78 23 74 65 79 84 4 86 52 10 6 3 82 56 5 48 33 21 57 40 29 61 63 34 36 83 8 15 44 50 70 39 25\n", "output": "60\n", "type": "stdin"}, {"input": "100\n56 64 1 95 72 39 9 49 87 29 94 7 32 6 30 48 50 25 31 78 90 45 60 44 80 68 17 20 73 15 75 98 83 13 71 22 36 26 96 88 35 3 85 54 16 41 92 99 69 86 93 33 43 62 77 46 47 37 12 10 18 40 27 6 63 55 28 59 23 34 61 53 76 42 51 91 21 70 8 58 38 19 5 66 84 11 52 24 81 82 79 67 97 65 57 74 2 89 100 14\n", "output": "98\n", "type": "stdin"}, {"input": "100\n83 96 73 70 30 25 7 77 58 89 76 85 49 82 45 51 14 62 50 9 31 32 16 15 97 64 4 37 20 93 24 10 80 71 100 39 75 72 78 74 8 29 53 86 79 48 3 68 90 99 56 87 63 94 53 1 40 65 6 44 43 84 17 52 34 95 38 47 60 57 98 59 33 41 46 81 23 27 19 2 54 91 55 35 26 12 92 18 28 66 69 21 5 67 13 11 22 88 61 42\n", "output": "65\n", "type": "stdin"}, {"input": "4\n3 4 3 1\n", "output": "3\n", "type": "stdin"}, {"input": "39\n16 28 4 33 26 36 25 10 22 30 27 7 12 34 17 6 3 38 10 24 13 31 29 39 14 32 9 20 35 11 18 21 8 2 15 37 5 19 1\n", "output": "38\n", "type": "stdin"}, {"input": "26\n6 21 20 16 26 17 11 0 24 4 1 12 14 8 25 7 15 10 22 5 13 18 9 23 19 3\n", "output": "21\n", "type": "stdin"}, {"input": "6\n4 2 3 1 6 4\n", "output": "4\n", "type": "stdin"}, {"input": "100\n100 97 35 55 45 3 46 98 77 64 94 85 73 43 49 79 72 9 70 62 80 88 29 58 61 20 89 83 66 86 82 15 6 87 42 96 90 75 63 38 81 40 5 23 4 18 41 19 99 60 8 12 76 51 39 93 53 26 21 50 47 28 13 30 68 59 34 54 24 56 31 27 65 16 32 10 36 52 44 91 22 14 50 25 7 78 67 17 57 37 92 11 2 69 84 95 74 71 48 1\n", "output": "99\n", "type": "stdin"}, {"input": "73\n58 38 47 34 39 64 69 66 72 57 9 4 67 22 35 13 61 14 28 52 56 20 31 70 27 24 36 1 62 17 10 5 12 33 16 73 18 29 63 71 44 65 23 30 40 8 50 46 60 25 11 26 37 55 29 68 42 2 3 32 59 7 15 43 41 48 51 53 6 45 54 19 21\n", "output": "45\n", "type": "stdin"}, {"input": "6\n6 5 4 3 2 1\n", "output": "5\n", "type": "stdin"}, {"input": "7\n1 6 5 3 4 7 2\n", "output": "6\n", "type": "stdin"}, {"input": "5\n4 5 1 3 2\n", "output": "3\n", "type": "stdin"}], "problem_id": "taco_train_841", "metadata": {"config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 415}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nIahub has drawn a set of n points in the cartesian plane which he calls \"special points\". A quadrilateral is a simple polygon without self-intersections with four sides (also called edges) and four vertices (also called corners). Please note that a quadrilateral doesn't have to be convex. A special quadrilateral is one which has all four vertices in the set of special points. Given the set of special points, please calculate the maximal area of a special quadrilateral. \n\n\n-----Input-----\n\nThe first line contains integer n (4 \u2264 n \u2264 300). Each of the next n lines contains two integers: x_{i}, y_{i} ( - 1000 \u2264 x_{i}, y_{i} \u2264 1000) \u2014 the cartesian coordinates of ith special point. It is guaranteed that no three points are on the same line. It is guaranteed that no two points coincide. \n\n\n-----Output-----\n\nOutput a single real number \u2014 the maximal area of a special quadrilateral. The answer will be considered correct if its absolute or relative error does't exceed 10^{ - 9}.\n\n\n-----Examples-----\nInput\n5\n0 0\n0 4\n4 0\n4 4\n2 3\n\nOutput\n16.000000\n\n\n-----Note-----\n\nIn the test example we can choose first 4 points to be the vertices of the quadrilateral. They form a square by side 4, so the area is 4\u00b74 = 16.\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\ndef cross(x1, y1, x2, y2):\n\treturn x1 * y2 - x2 * y1\n\ndef gao():\n\tn = int(input())\n\t(x, y) = ([], [])\n\tfor i in range(n):\n\t\t(x1, y1) = input().split(' ')\n\t\tx.append(int(x1))\n\t\ty.append(int(y1))\n\tmax_area = 0\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\t(max_left, max_right) = (0, 0)\n\t\t\tfor k in range(n):\n\t\t\t\tif i != k and j != k:\n\t\t\t\t\tarea = cross(x[j] - x[i], y[j] - y[i], x[k] - x[i], y[k] - y[i])\n\t\t\t\t\tif area > 0:\n\t\t\t\t\t\tmax_left = max(max_left, area)\n\t\t\t\t\telif area < 0:\n\t\t\t\t\t\tmax_right = max(max_right, -area)\n\t\t\tif max_left != 0 and max_right != 0:\n\t\t\t\tmax_area = max(max_area, max_left + max_right)\n\tprint(max_area / 2.0)\ngao()\n\n```"], "public_test_cases": [{"input": "5\n0 0\n0 4\n4 0\n4 4\n2 3\n", "output": "16.000000", "type": "stdin"}], "test_cases": [{"input": "5\n0 0\n0 4\n4 0\n4 4\n2 3\n", "output": "16.000000", "type": "stdin"}, {"input": "10\n-6 -4\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 9\n-4 -6\n2 10\n-10 -4\n", "output": "166.000000", "type": "stdin"}, {"input": "4\n-3 3\n0 3\n-2 -1\n2 2\n", "output": "11.000000", "type": "stdin"}, {"input": "5\n-4 -3\n-3 -2\n3 3\n-1 2\n3 -3\n", "output": "29.500000", "type": "stdin"}, {"input": "6\n-4 -3\n-1 3\n0 0\n2 2\n2 1\n-3 1\n", "output": "15.000000", "type": "stdin"}, {"input": "7\n-2 -1\n4 3\n2 2\n-4 0\n-2 4\n0 0\n1 -3\n", "output": "32.500000", "type": "stdin"}, {"input": "4\n-874 606\n-996 -207\n897 847\n775 191\n", "output": "1261820.500000", "type": "stdin"}, {"input": "10\n156 -415\n879 198\n-250 -676\n-594 -433\n-207 368\n296 -641\n-387 -795\n143 -304\n-468 390\n-873 226\n", "output": "1129219.500000", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 571\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -655\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-191 928\n916 263\n-975 169\n567 -967\n394 16\n-224 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2425414.000000", "type": "stdin"}, {"input": "4\n0 0\n0 5\n5 0\n1 1\n", "output": "10.000000", "type": "stdin"}, {"input": "7\n-2 -1\n4 3\n2 2\n-4 0\n-2 4\n0 0\n1 -3\n", "output": "32.500000\n", "type": "stdin"}, {"input": "10\n-6 -4\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 9\n-4 -6\n2 10\n-10 -4\n", "output": "166.000000\n", "type": "stdin"}, {"input": "4\n0 0\n0 5\n5 0\n1 1\n", "output": "10.000000\n", "type": "stdin"}, {"input": "6\n-4 -3\n-1 3\n0 0\n2 2\n2 1\n-3 1\n", "output": "15.000000\n", "type": "stdin"}, {"input": "4\n-3 3\n0 3\n-2 -1\n2 2\n", "output": "11.000000\n", "type": "stdin"}, {"input": "4\n-874 606\n-996 -207\n897 847\n775 191\n", "output": "1261820.500000\n", "type": "stdin"}, {"input": "5\n-4 -3\n-3 -2\n3 3\n-1 2\n3 -3\n", "output": "29.500000\n", "type": "stdin"}, {"input": "10\n156 -415\n879 198\n-250 -676\n-594 -433\n-207 368\n296 -641\n-387 -795\n143 -304\n-468 390\n-873 226\n", "output": "1129219.500000\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 571\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -655\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-191 928\n916 263\n-975 169\n567 -967\n394 16\n-224 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2425414.000000\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 3\n2 2\n-7 0\n-2 4\n0 0\n1 -3\n", "output": "43.0\n", "type": "stdin"}, {"input": "10\n-6 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 9\n-4 -6\n2 10\n-10 -4\n", "output": "166.0\n", "type": "stdin"}, {"input": "4\n-874 939\n-996 -207\n897 847\n775 191\n", "output": "1577005.0\n", "type": "stdin"}, {"input": "5\n-4 -3\n-3 -2\n3 3\n-1 1\n3 -3\n", "output": "26.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -676\n-594 -433\n-207 368\n296 -641\n-387 -795\n143 -304\n-468 390\n-873 226\n", "output": "1129219.5\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 571\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -655\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n916 263\n-975 169\n567 -967\n394 16\n-224 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2425414.0\n", "type": "stdin"}, {"input": "5\n0 0\n0 4\n4 0\n2 4\n2 3\n", "output": "12.0\n", "type": "stdin"}, {"input": "4\n-874 939\n-996 -207\n110 847\n775 191\n", "output": "1282667.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n296 -641\n-387 -795\n143 -304\n-468 390\n-873 226\n", "output": "1503668.0\n", "type": "stdin"}, {"input": "5\n0 1\n0 4\n4 0\n2 4\n2 3\n", "output": "10.0\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 3\n2 2\n-7 1\n-2 4\n0 -1\n1 -3\n", "output": "41.5\n", "type": "stdin"}, {"input": "4\n-874 1296\n-996 -207\n110 847\n775 191\n", "output": "1480088.0\n", "type": "stdin"}, {"input": "5\n-4 -3\n-3 -1\n3 0\n-1 1\n3 -3\n", "output": "20.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n296 -641\n-387 -795\n143 -304\n-468 390\n-183 226\n", "output": "1335559.0\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n916 263\n-975 169\n567 -967\n394 16\n-224 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2549830.0\n", "type": "stdin"}, {"input": "5\n0 1\n1 4\n4 0\n2 4\n2 3\n", "output": "8.5\n", "type": "stdin"}, {"input": "10\n-8 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 1\n-4 -6\n0 10\n-10 -4\n", "output": "150.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n296 -641\n-387 -795\n143 -304\n-495 390\n-183 226\n", "output": "1344077.5\n", "type": "stdin"}, {"input": "5\n0 1\n1 4\n4 0\n2 4\n3 3\n", "output": "9.0\n", "type": "stdin"}, {"input": "7\n-2 0\n4 3\n2 2\n-7 1\n-2 6\n0 -1\n1 -3\n", "output": "52.5\n", "type": "stdin"}, {"input": "10\n-8 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 1\n-4 -6\n0 10\n-10 0\n", "output": "152.0\n", "type": "stdin"}, {"input": "5\n0 0\n1 4\n4 0\n2 4\n3 3\n", "output": "10.5\n", "type": "stdin"}, {"input": "10\n-8 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 1\n-4 -6\n0 10\n-10 1\n", "output": "155.5\n", "type": "stdin"}, {"input": "5\n-8 -3\n-2 -1\n6 0\n-1 1\n3 -3\n", "output": "34.0\n", "type": "stdin"}, {"input": "5\n0 0\n1 4\n4 0\n2 6\n3 3\n", "output": "13.0\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 4\n2 2\n-7 1\n-2 6\n0 -1\n1 -3\n", "output": "54.0\n", "type": "stdin"}, {"input": "5\n-8 -3\n-2 -1\n6 0\n-1 1\n3 -4\n", "output": "41.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n433 -641\n-387 -795\n143 -347\n-495 395\n-183 226\n", "output": "1347760.0\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -1894\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-126 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 185\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "3283290.0\n", "type": "stdin"}, {"input": "5\n-8 -3\n-2 -1\n6 0\n-1 2\n3 -4\n", "output": "48.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n433 -749\n-387 -795\n143 -347\n-495 395\n-183 226\n", "output": "1354780.0\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 4\n2 2\n-12 1\n-2 6\n-1 -1\n1 -3\n", "output": "76.5\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 4\n2 2\n-12 1\n-2 6\n-1 -1\n2 -3\n", "output": "78.0\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -1894\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-1422 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-126 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-6 716\n-409 -845\n-291 441\n388 185\n-950 277\n-392 359\n881 198\n198 670\n828 -820\n", "output": "3494976.0\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 4\n2 2\n-7 1\n-2 6\n-1 -1\n2 -3\n", "output": "55.5\n", "type": "stdin"}, {"input": "10\n-8 0\n-3 5\n-8 -7\n5 -10\n4 -9\n-6 4\n2 1\n-4 -6\n0 10\n-10 1\n", "output": "171.5\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 3\n2 2\n-7 0\n-2 4\n0 -1\n1 -3\n", "output": "43.0\n", "type": "stdin"}, {"input": "10\n-8 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 9\n-4 -6\n2 10\n-10 -4\n", "output": "166.0\n", "type": "stdin"}, {"input": "5\n-4 -3\n-3 -1\n3 3\n-1 1\n3 -3\n", "output": "26.0\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 571\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n916 263\n-975 169\n567 -967\n394 16\n-224 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2425414.0\n", "type": "stdin"}, {"input": "10\n-8 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 7\n2 1\n-4 -6\n2 10\n-10 -4\n", "output": "166.0\n", "type": "stdin"}, {"input": "7\n-2 0\n4 3\n2 2\n-7 1\n-2 4\n0 -1\n1 -3\n", "output": "41.5\n", "type": "stdin"}, {"input": "5\n-4 -3\n-2 -1\n3 0\n-1 1\n3 -3\n", "output": "20.0\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-224 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2549830.0\n", "type": "stdin"}, {"input": "5\n-4 -3\n-2 -1\n6 0\n-1 1\n3 -3\n", "output": "26.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n433 -641\n-387 -795\n143 -304\n-495 390\n-183 226\n", "output": "1344077.5\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-126 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 379\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2549830.0\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 3\n2 2\n-7 1\n-2 6\n0 -1\n1 -3\n", "output": "52.5\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 368\n433 -641\n-387 -795\n143 -347\n-495 390\n-183 226\n", "output": "1344077.5\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -984\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-126 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 185\n-950 277\n-718 359\n881 198\n198 670\n828 -820\n", "output": "2549830.0\n", "type": "stdin"}, {"input": "10\n-8 0\n-7 5\n-7 -7\n5 -7\n4 -9\n-6 4\n2 1\n-4 -6\n0 10\n-10 1\n", "output": "155.5\n", "type": "stdin"}, {"input": "7\n-2 -1\n4 4\n2 2\n-7 1\n-2 6\n-1 -1\n1 -3\n", "output": "54.0\n", "type": "stdin"}, {"input": "10\n-8 0\n-2 5\n-7 -7\n5 -7\n4 -9\n-6 4\n2 1\n-4 -6\n0 10\n-10 1\n", "output": "155.5\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -1894\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-126 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-194 716\n-409 -845\n-291 441\n388 185\n-950 277\n-392 359\n881 198\n198 670\n828 -820\n", "output": "3283290.0\n", "type": "stdin"}, {"input": "10\n-8 0\n-3 5\n-7 -7\n5 -7\n4 -9\n-6 4\n2 1\n-4 -6\n0 10\n-10 1\n", "output": "155.5\n", "type": "stdin"}, {"input": "5\n-8 -3\n-2 -1\n6 0\n-1 2\n6 -4\n", "output": "52.5\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 508\n433 -749\n-387 -795\n143 -347\n-495 395\n-183 226\n", "output": "1354780.0\n", "type": "stdin"}, {"input": "50\n-768 -243\n-741 -1894\n-370 213\n-808 715\n-726 442\n234 452\n-105 -990\n-876 -278\n987 473\n-968 -531\n-274 -842\n259 -1299\n-59 -555\n976 -396\n878 -85\n551 213\n675 599\n-990 -507\n1 48\n-147 919\n-218 798\n-107 928\n1101 263\n-975 169\n567 -967\n394 16\n-126 915\n280 -613\n804 -877\n988 -576\n-256 -708\n757 546\n777 99\n-579 -608\n-102 1\n-309 636\n-24 -718\n644 -84\n111 -822\n-722 544\n78 595\n-6 716\n-409 -845\n-291 441\n388 185\n-950 277\n-392 359\n881 198\n198 670\n828 -820\n", "output": "3283290.0\n", "type": "stdin"}, {"input": "10\n-8 0\n-3 5\n-7 -7\n5 -10\n4 -9\n-6 4\n2 1\n-4 -6\n0 10\n-10 1\n", "output": "166.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 508\n433 -749\n-387 -795\n143 -365\n-495 395\n-183 226\n", "output": "1354780.0\n", "type": "stdin"}, {"input": "10\n69 -415\n879 198\n-250 -1330\n-594 -433\n-207 508\n433 -749\n-216 -795\n143 -365\n-495 395\n-183 226\n", "output": "1354780.0\n", "type": "stdin"}, {"input": "5\n0 0\n0 4\n4 0\n4 4\n2 3\n", "output": "16.000000\n", "type": "stdin"}], "problem_id": "primeintellect_train_13780", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 81}, "generated_solutions": []}
{"problem": "You have a new professor of graph theory and he speaks very quickly. You come up with the following plan to keep up with his lecture and make notes.\n\nYou know two languages, and the professor is giving the lecture in the first one. The words in both languages consist of lowercase English characters, each language consists of several words. For each language, all words are distinct, i.e. they are spelled differently. Moreover, the words of these languages have a one-to-one correspondence, that is, for each word in each language, there exists exactly one word in the other language having has the same meaning.\n\nYou can write down every word the professor says in either the first language or the second language. Of course, during the lecture you write down each word in the language in which the word is shorter. In case of equal lengths of the corresponding words you prefer the word of the first language.\n\nYou are given the text of the lecture the professor is going to read. Find out how the lecture will be recorded in your notes.\n\n\n-----Input-----\n\nThe first line contains two integers, n and m (1 \u2264 n \u2264 3000, 1 \u2264 m \u2264 3000) \u2014 the number of words in the professor's lecture and the number of words in each of these languages.\n\nThe following m lines contain the words. The i-th line contains two strings a_{i}, b_{i} meaning that the word a_{i} belongs to the first language, the word b_{i} belongs to the second language, and these two words have the same meaning. It is guaranteed that no word occurs in both languages, and each word occurs in its language exactly once.\n\nThe next line contains n space-separated strings c_1, c_2, ..., c_{n} \u2014 the text of the lecture. It is guaranteed that each of the strings c_{i} belongs to the set of strings {a_1, a_2, ... a_{m}}.\n\nAll the strings in the input are non-empty, each consisting of no more than 10 lowercase English letters.\n\n\n-----Output-----\n\nOutput exactly n words: how you will record the lecture in your notebook. Output the words of the lecture in the same order as in the input.\n\n\n-----Examples-----\nInput\n4 3\ncodeforces codesecrof\ncontest round\nletter message\ncodeforces contest letter contest\n\nOutput\ncodeforces round letter round\n\nInput\n5 3\njoll wuqrd\neuzf un\nhbnyiyc rsoqqveh\nhbnyiyc joll joll euzf joll\n\nOutput\nhbnyiyc joll joll un joll", "solutions": ["def main():\n\t(n, m) = map(int, input().split())\n\ttrans = {}\n\tfor _ in range(m):\n\t\ttemp = list(input().split())\n\t\t(a, b) = (temp[0], temp[1])\n\t\tif len(a) <= len(b):\n\t\t\ttrans[a] = a\n\t\telse:\n\t\t\ttrans[a] = b\n\tlecture = list(input().split())\n\tnotes = ''\n\tfor x in lecture:\n\t\tnotes += trans[x] + ' '\n\tprint(notes)\nmain()\n", "import sys, math, collections\nfrom collections import defaultdict\n\ndef file():\n\tsys.stdin = open('input.py', 'r')\n\tsys.stdout = open('output.py', 'w')\n\ndef get_array():\n\tl = list(map(int, input().split()))\n\treturn l\n\ndef get_2_ints():\n\t(a, b) = map(int, input().split())\n\treturn (a, b)\n\ndef get_3_ints():\n\t(a, b, c) = map(int, input().split())\n\treturn (a, b, c)\n\ndef sod(n):\n\t(n, c) = (str(n), 0)\n\tfor i in n:\n\t\tc += int(i)\n\treturn c\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tif n <= 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\ti = 5\n\twhile i * i <= n:\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\n\ndef getFloor(A, x):\n\t(left, right) = (0, len(A) - 1)\n\tfloor = -1\n\twhile left <= right:\n\t\tmid = (left + right) // 2\n\t\tif A[mid] == x:\n\t\t\treturn A[mid]\n\t\telif x < A[mid]:\n\t\t\tright = mid - 1\n\t\telse:\n\t\t\tfloor = A[mid]\n\t\t\tleft = mid + 1\n\treturn floor\n\ndef floorSqrt(x):\n\tif x == 0 or x == 1:\n\t\treturn x\n\tstart = 1\n\tend = x\n\twhile start <= end:\n\t\tmid = (start + end) // 2\n\t\tif mid * mid == x:\n\t\t\treturn mid\n\t\tif mid * mid < x:\n\t\t\tstart = mid + 1\n\t\t\tans = mid\n\t\telse:\n\t\t\tend = mid - 1\n\treturn ans\n\ndef main():\n\t(n, m) = get_2_ints()\n\td = {}\n\tfor i in range(m):\n\t\t(a, b) = input().split()\n\t\td[a] = b\n\tans = []\n\ts = list(input().split())\n\tfor i in s:\n\t\tif len(i) < len(d[i]):\n\t\t\tans.append(i)\n\t\telif len(i) > len(d[i]):\n\t\t\tans.append(d[i])\n\t\telse:\n\t\t\tans.append(i)\n\tprint(' '.join(ans))\nmain()\n", "def answer(n, m, a, b, c):\n\tnew_ary = []\n\tfor i in range(len(c)):\n\t\tindx = a.index(c[i])\n\t\tif len(a[indx]) <= len(b[indx]):\n\t\t\tnew_ary.append(a[indx])\n\t\telse:\n\t\t\tnew_ary.append(b[indx])\n\treturn ' '.join(new_ary)\n\ndef main():\n\t(n, m) = [int(i) for i in input().split()]\n\ta = ['x'] * m\n\tb = ['x'] * m\n\tfor j in range(m):\n\t\t(a[j], b[j]) = [i for i in input().split()]\n\tc = [i for i in input().split()]\n\tprint(answer(n, m, a, b, c))\nmain()\n", "(n, m) = map(int, input().split())\nlanguage = dict()\nfor _ in range(m):\n\t(a, b) = input().split()\n\tshort = ''\n\tif len(a) <= len(b):\n\t\tshort = a\n\telse:\n\t\tshort = b\n\tlanguage.update({a: short, b: short})\nlecture = list(input().split())\nfor word in lecture:\n\tprint(language[word], end=' ')\n", "line = input()\nline = line.split()\nn = int(line[0])\nm = int(line[1])\nlang = {}\nlength = {}\nfor i in range(0, m):\n\tline = input()\n\tline = line.split()\n\tlen1 = len(line[0])\n\tlen2 = len(line[1])\n\tlang[line[0]] = line[1]\n\tlang[line[1]] = line[0]\n\tlength[line[0]] = len(line[0])\n\tlength[line[1]] = len(line[1])\nline = input()\nline = line.split()\nfor i in range(0, n):\n\tif length[line[i]] > length[lang[line[i]]]:\n\t\tline[i] = lang[line[i]]\nnstr = ''\nfor k in line:\n\tnstr = nstr + k + ' '\nprint(nstr[:-1])\n", "(n, m) = map(int, input().split(' '))\na = []\nb = []\nfor i in range(m):\n\t(x, y) = input().split(' ')\n\ta.append(x)\n\tb.append(y)\nans = []\ns = input().split(' ')\nfor j in range(len(s)):\n\tif s[j] in a:\n\t\tindex = a.index(s[j])\n\t\tif len(a[index]) > len(b[index]):\n\t\t\tans.append(b[index])\n\t\telse:\n\t\t\tans.append(a[index])\n\telif s[j] in b:\n\t\tindex = b.index(s[j])\n\t\tif len(a[index]) > len(b[index]):\n\t\t\tans.append(b[index])\n\t\telse:\n\t\t\tans.append(a[index])\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\na = {}\nfor i in range(m):\n\t(l1, l2) = input().split()\n\ta[l1] = l2\nword = input().split()\nfor i in range(n):\n\tif word[i] in a and len(word[i]) > len(a[word[i]]):\n\t\tprint(a[word[i]], end='\\n' if i == n - 1 else ' ')\n\telse:\n\t\tprint(word[i], end='\\n' if i == n - 1 else ' ')\n", "def main():\n\t(n, m) = map(int, input().split())\n\td = {}\n\tfor i in range(m):\n\t\ta = list(map(str, input().split()))\n\t\tif a[0] not in d:\n\t\t\td[a[0]] = a[1]\n\tq = list(map(str, input().split()))\n\tfor i in range(n):\n\t\tif len(q[i]) > len(d[q[i]]):\n\t\t\tq[i] = d[q[i]]\n\tprint(*q)\nmain()\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(d1, d2) = map(str, input().split())\n\td[d1] = d2\nlec = list(input().split())\nfor i in range(n):\n\tprint(lec[i] if len(lec[i]) <= len(d[lec[i]]) else d[lec[i]], end=' ')\n", "t = input().split()\nn = int(t[0])\nm = int(t[1])\nd = {}\nfor i in range(m):\n\tt = input().split()\n\td[t[0]] = t[1]\nc = input().split()\nfor i in range(n - 1):\n\tk = d[c[i]]\n\tif len(k) < len(c[i]):\n\t\tprint(k, end=' ')\n\telse:\n\t\tprint(c[i], end=' ')\nk = d[c[n - 1]]\nif len(k) < len(c[n - 1]):\n\tprint(k)\nelse:\n\tprint(c[n - 1])\n", "(n, m) = map(int, input().split())\ndic = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tdic[a] = b\nl = [x for x in input().split()]\nfor x in l:\n\tif len(x) > len(dic[x]):\n\t\tprint(dic[x], end=' ')\n\telse:\n\t\tprint(x, end=' ')\n", "n = list(map(int, input().split(' ')))\na = []\nfor i in range(n[1]):\n\ttemp = list(input().split(' '))\n\ta.append((temp[0], temp[1]))\nnotes = list(input().split(' '))\ndict = {}\nfor (i, j) in a:\n\tdict[i] = i if len(i) <= len(j) else j\nfor i in notes:\n\tprint(dict[i], end=' ')\n", "(n, m) = map(int, input().split())\nM = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tM[a] = b\n\telse:\n\t\tM[a] = a\nlec = list(input().split())\nfor s in lec:\n\tprint(M[s], end=' ')\n", "(n, m) = map(int, input().split())\nls = {}\nfor _ in range(m):\n\tline = input().split()\n\tls[line[0]] = line[1]\nlecture = input().split()\nfor i in range(len(lecture)):\n\tword = lecture[i]\n\tif len(ls[word]) < len(word):\n\t\tlecture[i] = ls[word]\nprint(' '.join(lecture))\n", "(n, m) = map(int, input().split())\nd = dict()\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b if len(b) < len(a) else a\nprint(' '.join((d[i] for i in input().split())))\n", "(n, m) = map(int, input().split())\nwords = {}\nfor i in range(m):\n\t(word1, word2) = input().split()\n\tif len(word1) <= len(word2):\n\t\twords[word1] = word1\n\telse:\n\t\twords[word1] = word2\nlecture = input().strip().split()\ns = list(map(lambda x: words[x], lecture))\nprint(*s)\n", "def ss(s1, s2):\n\tif len(s1) <= len(s2):\n\t\treturn s1\n\telse:\n\t\treturn s2\n(m, n) = list(map(int, input().split(' ')))\ndi = {}\nfor i in range(n):\n\t(s1, s2) = input().split(' ')\n\tdi[s1] = ss(s1, s2)\n\tdi[s2] = ss(s1, s2)\np = input().split(' ')\nfor i in p:\n\tprint(di[i], end=' ')\nprint()\n", "(n, k) = map(int, input().split())\na = []\nb = []\nfor _ in range(k):\n\t(k1, k2) = map(str, input().split())\n\ta.append(k1)\n\tb.append(k2)\nc = list(input().split())\nfor i in range(len(c)):\n\tif c[i] in a:\n\t\tt = a.index(c[i])\n\t\tif len(a[t]) <= len(b[t]):\n\t\t\tprint(a[t], end=' ')\n\t\telse:\n\t\t\tprint(b[t], end=' ')\n\telse:\n\t\tt = b.index(c[i])\n\t\tif len(b[t]) <= len(a[t]):\n\t\t\tprint(b[t], end=' ')\n\t\telse:\n\t\t\tprint(a[t], end=' ')\n", "(n, m) = map(int, input().strip().split())\nd = {}\nfor i in range(m):\n\ts = input().split(' ')\n\ts1 = s[0]\n\ts2 = s[1]\n\tl1 = len(s1)\n\tl2 = len(s2)\n\tif l1 <= l2:\n\t\td[s1] = s1\n\telse:\n\t\td[s1] = s2\na = input().split(' ')\nfor i in a:\n\tprint(d[i], end=' ')\n", "def solve(n, m, t, l):\n\treturn ' '.join((w if len(w) <= len(t[w]) else t[w] for w in l))\n\ndef main():\n\t(n, m) = list(map(int, input().split()))\n\tt = dict((input().split() for _ in range(m)))\n\tl = input().split()\n\tprint(solve(n, m, t, l))\nmain()\n", "(a, b) = list(map(int, input().split()))\nt = {}\np = []\nfor i in range(b):\n\tu = list(input().split())\n\tt[u[0]] = u[1]\nf = input().split()\nfor j in range(len(f)):\n\tif len(t[f[j]]) < len(f[j]):\n\t\tp.append(t[f[j]])\n\telse:\n\t\tp.append(f[j])\nprint(*p)\n", "import sys\n(n, m) = map(int, sys.stdin.readline().split())\nadict = dict()\nfor _ in range(m):\n\t(a, b) = sys.stdin.readline().strip().split()\n\tif len(a) <= len(b):\n\t\tadict[a] = a\n\t\tadict[b] = a\n\telse:\n\t\tadict[a] = b\n\t\tadict[b] = b\ns = sys.stdin.readline().strip().split()\nprint(' '.join([adict[a] for a in s]))\n", "l = [int(x) for x in input().split()]\nn = l[0]\nm = l[1]\nl1 = []\nl2 = []\nstring = ''\nl = []\nfor i in range(m):\n\ts = input().split(' ')\n\tl1.append(s[0])\n\tl2.append(s[1])\n\tif len(s[0]) < len(s[1]):\n\t\tl.append(s[0])\n\telif len(s[1]) < len(s[0]):\n\t\tl.append(s[1])\n\telse:\n\t\tl.append(s[0])\np = input().split()\nfor i in range(len(p)):\n\tif p[i] in l1:\n\t\tx = l1.index(p[i])\n\telse:\n\t\tx = l2.index(p[i])\n\tstring = string + l[x] + ' '\nprint(string)\n", "def minstr(k, v):\n\tif len(k) <= len(v):\n\t\treturn k\n\treturn v\n\tpass\n(n, m) = input().split()\nM = {}\nres = ''\nfor i in range(int(m)):\n\t(k, v) = input().split()\n\tM[k] = v\nfirst = input().split()\nfor i in first:\n\tres += minstr(i, M[i])\n\tres += ' '\nprint(res)\n", "def s(a, b):\n\tif len(a) == len(b):\n\t\treturn a\n\telif len(a) < len(b):\n\t\treturn a\n\telse:\n\t\treturn b\n(a, b) = map(int, input().split())\ndic = dict()\nfor i in range(b):\n\t(m, n) = input().split()\n\tdic[m] = s(m, n)\nfor i in input().split():\n\tprint(dic[i], end=' ')\n", "(n, m) = map(int, input().split())\nwords = dict()\nfor i in range(0, m):\n\t(k, v) = input().split()\n\twords[k] = v\nprint(' '.join((min(w, words[w], key=lambda o: len(o)) for w in input().split())))\n", "import math\nimport sys\nimport re\n(n, m) = map(int, input().rstrip().split())\nl = {}\nfor x in range(m):\n\tx = list(input().rstrip().split())\n\tif x[0] not in l:\n\t\tl[x[0]] = x[1]\nl1 = list(input().rstrip().split())\nl2 = []\nfor y in l1:\n\tif len(y) > len(l[y]):\n\t\tl2.append(l[y])\n\telse:\n\t\tl2.append(y)\nprint(' '.join(l2))\n", "(n, m) = (int(x) for x in input().split())\nd = dict()\nfor i in range(m):\n\t(x, y) = (j for j in input().split())\n\td[x] = y\ninp = input().split()\nfor i in inp:\n\tprint(d[i] if len(d[i]) < len(i) else i, '', end='')\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nlecture = input().split()\nans = ''\nfor word in lecture:\n\tmeaning = d[word]\n\tif len(meaning) < len(word):\n\t\tans += meaning + ' '\n\telse:\n\t\tans += word + ' '\nprint(ans.strip())\n", "arr = list(map(int, input().split()))\n(lec, size) = (arr[0], arr[1])\nlang1 = []\nlang2 = []\nfor _ in range(size):\n\tarr1 = list(input().split())\n\tlang1.append(arr1[0])\n\tlang2.append(arr1[1])\nlecture = list(input().split())\noutput = []\nfor i in lecture:\n\tind = lang1.index(i)\n\tif len(lang2[ind]) < len(lang1[ind]):\n\t\toutput.append(lang2[ind])\n\telse:\n\t\toutput.append(i)\nstr = ' '.join((word for word in output))\nprint(str)\n", "d = [int(x) for x in input().split(' ')]\nc = {}\nfor x in range(d[1]):\n\tdata = [x for x in input().split(' ')]\n\tif len(data[0]) <= len(data[1]):\n\t\tc[data[0]] = data[0]\n\telse:\n\t\tc[data[0]] = data[1]\ns = [x for x in input().split(' ')]\nfor x in range(d[0]):\n\ts[x] = c[s[x]]\nprint(' '.join(s))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\td[a] = b\nh = list(map(str, input().split()))\nfor i in range(len(h)):\n\tif len(d[h[i]]) < len(h[i]):\n\t\th[i] = d[h[i]]\nprint(' '.join(h))\n", "a1 = input().split()\na = list(a1)\nd = {}\nfor i in range(int(a[1])):\n\tb1 = input().split()\n\tb = list(b1)\n\td[b[0]] = b[1]\nc1 = input().split()\nc = list(c1)\nfor i in range(int(a[0])):\n\tif len(c[i]) <= len(d[c[i]]):\n\t\tprint(c[i], end=' ')\n\telse:\n\t\tprint(d[c[i]], end=' ')\n", "import math as mt\nimport sys, string, bisect\ninput = sys.stdin.readline\nfrom collections import deque, defaultdict\nL = lambda : list(map(int, input().split()))\nLs = lambda : list(input().split())\nM = lambda : map(int, input().split())\nI = lambda : int(input())\n(n, m) = M()\nd = {}\nfor i in range(m):\n\tl = input().split()\n\tif len(l[0]) > len(l[1]):\n\t\tkey = l[1]\n\telse:\n\t\tkey = l[0]\n\td[l[0]] = key\n\td[l[1]] = key\nr = input().split()\nfor i in r:\n\tprint(d[i], end=' ')\n", "(m, n) = [int(i) for i in input().split()]\na = []\nb = []\nfor i in range(n):\n\tx = [j for j in input().split()]\n\ta.append(x[0])\n\tb.append(x[1])\nc = [i for i in input().split()]\nnotes = []\nfor i in range(len(c)):\n\tfor j in range(len(a)):\n\t\tif c[i] == a[j]:\n\t\t\tif len(a[j]) <= len(b[j]):\n\t\t\t\tnotes.append(a[j])\n\t\t\telse:\n\t\t\t\tnotes.append(b[j])\n\t\t\tbreak\nans = ' '.join(notes)\nprint(ans)\n", "(n, m) = map(int, input().split())\nf = []\ns = []\nans = ''\nfor i in range(m):\n\t(a, b) = input().split()\n\tf.append(a)\n\ts.append(b)\np = input().split()\nfor word in p:\n\ti = 0\n\tif word in f:\n\t\ti = f.index(word)\n\tif word in s:\n\t\ti = s.index(word)\n\tif len(f[i]) < len(s[i]):\n\t\tans += f[i]\n\telif len(f[i]) == len(s[i]):\n\t\tans += f[i]\n\telse:\n\t\tans += s[i]\n\tans += ' '\nprint(ans)\n", "def inp():\n\treturn map(int, input().split(' '))\n\ndef findString(word):\n\tfor i in range(m):\n\t\tif word == a[i] or word == b[i]:\n\t\t\tif len(a[i]) <= len(b[i]):\n\t\t\t\treturn a[i]\n\t\t\telse:\n\t\t\t\treturn b[i]\n(n, m) = inp()\na = []\nb = []\nfor i in range(m):\n\t(temp1, temp2) = input().split(' ')\n\ta.append(temp1)\n\tb.append(temp2)\ntext = list(input().split(' '))\nresult_text = ''\nfor i in range(len(text)):\n\ttext[i] = str(findString(text[i]))\nprint(' '.join(text))\n", "(n, m) = map(int, input().split())\ndict = {}\nfor i in range(m):\n\t(key, value) = input().split()\n\tdict[key] = value\ntext = [x for x in input().split()]\n\ndef lecture(dict, text):\n\tresult = []\n\tfor language1 in text:\n\t\twrite_down = language1\n\t\tlanguage2 = dict[language1]\n\t\tif len(language2) < len(language1):\n\t\t\twrite_down = language2\n\t\tprint(write_down, end=' ')\nlecture(dict, text)\n", "(n, m) = map(int, input().split())\nd = dict(map(lambda _: input().split(), range(m)))\nprint(' '.join(map(lambda w: min((w, d[w]), key=len), input().strip().split())))\n", "(p, q) = map(int, input().split())\nlst = []\nlst1 = []\nlst2 = []\nfor i in range(q):\n\ts = input()\n\tz = s.index(' ')\n\tlst.append(s[:z])\n\tlst1.append(s[z + 1:])\na = input()\nq2 = 0\nif p != 1:\n\tfor i in range(p - 1):\n\t\tz = a.index(' ')\n\t\tlst2.append(a[q2:z])\n\t\ta = a[:q2] + a[q2:z] + a[z + 1:]\n\t\tq2 = z\n\tlst2.append(a[z:])\nelse:\n\tlst2.append(a)\nz = []\nfor i in lst2:\n\tif i in lst:\n\t\tt = lst.index(i)\n\t\tif len(lst[t]) > len(lst1[t]):\n\t\t\tz.append(lst1[t])\n\t\telse:\n\t\t\tz.append(lst[t])\n\tif i in lst1:\n\t\tt = lst1.index(i)\n\t\tif len(lst[t]) > len(lst1[t]):\n\t\t\tz.append(lst1[t])\n\t\telse:\n\t\t\tz.append(lst[t])\nprint(*z)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(w1, w2) = input().split()\n\td[w1] = w2 if len(w2) < len(w1) else w1\nprint(' '.join([d[s] for s in input().split()]))\n", "ins = input().strip().split(' ')\n(n, m) = (int(ins[0]), int(ins[1]))\ncode = {}\nfor i in range(m):\n\tins = input().strip().split(' ')\n\tcode[ins[0]] = ins[1]\nins = input().strip().split(' ')\nfor i in range(n):\n\tif len(ins[i]) <= len(code[ins[i]]):\n\t\tprint(ins[i], end=' ')\n\telse:\n\t\tprint(code[ins[i]], end=' ')\n", "(m, n) = map(int, input().split())\nl = {}\nans = ''\nfor f in range(n):\n\ts = input().split(' ')\n\tif len(s[0]) <= len(s[1]):\n\t\tl[s[0]] = s[0]\n\t\tl[s[1]] = s[0]\n\telse:\n\t\tl[s[0]] = s[1]\n\t\tl[s[1]] = s[1]\nh = input().split(' ')\nfor f in h:\n\tans += l[f] + ' '\nprint(ans.strip())\n", "inp1 = list(map(int, input().strip().split()))[:2]\n(n, m) = (inp1[0], inp1[1])\ndict1 = {}\nfor i in range(m):\n\tstr1 = input()\n\tk = str1.split(' ')\n\tdict1[k[0]] = k[1]\nstr2 = input()\nk = str2.split(' ')\nl = ''\nfor i in k:\n\tif len(i) <= len(dict1[i]):\n\t\tl += i\n\telse:\n\t\tl += dict1[i]\n\tl += ' '\nprint(l[:-1])\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\ns = [i for i in input().split()]\nfor (i, j) in enumerate(s):\n\tif len(j) > len(d[j]):\n\t\ts[i] = d[j]\nfor i in s:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\tb.append(y)\nc = list(input().split())\nfor i in range(n):\n\tif len(a[a.index(c[i])]) <= len(b[a.index(c[i])]):\n\t\tprint(a[a.index(c[i])], end=' ')\n\telse:\n\t\tprint(b[a.index(c[i])], end=' ')\n", "(n, m) = map(int, input().split())\n(a, b, ans) = ([], [], [])\nfor _ in range(m):\n\t(x, y) = map(str, input().split())\n\ta.append(x)\n\tb.append(y)\nl = [w for w in input().split()]\nfor w in l:\n\tif w in a:\n\t\ti = a.index(w)\n\telse:\n\t\ti = b.index(w)\n\tif len(b[i]) < len(a[i]):\n\t\tans.append(b[i])\n\telse:\n\t\tans.append(a[i])\nprint(' '.join(ans))\n", "def make_translator_dictionary(a, b, m):\n\ttranslator_dic = {}\n\tfor i in range(m):\n\t\ttranslator_dic[a[i]] = b[i]\n\treturn translator_dic\n\ndef make_note(a, b, text_professor, n, m):\n\ttranslator_dic = make_translator_dictionary(a, b, m)\n\tresult = ''\n\tfor i in range(n):\n\t\tlen1 = len(translator_dic[text_professor[i]])\n\t\tlen2 = len(text_professor[i])\n\t\tterm = ''\n\t\tif len1 > len2:\n\t\t\tterm = text_professor[i]\n\t\telif len1 < len2:\n\t\t\tterm = translator_dic[text_professor[i]]\n\t\telse:\n\t\t\tterm = text_professor[i]\n\t\tif i == 0:\n\t\t\tresult = term\n\t\telse:\n\t\t\tresult = result + ' ' + term\n\treturn result\n(n, m) = [int(x) for x in input().strip().split(' ')]\na = []\nb = []\nterm_array = []\nfor i in range(1, m + 1):\n\tterm_array = [str(x) for x in input().strip().split(' ')]\n\ta.append(term_array[0])\n\tb.append(term_array[1])\ntext_professor = [str(x) for x in input().strip().split(' ')]\nprint(make_note(a, b, text_professor, n, m))\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdic[a] = b\nl = list(input().split())\nfor ele in l:\n\tif len(ele) <= len(dic[ele]):\n\t\tprint(ele, end=' ')\n\telse:\n\t\tprint(dic[ele], end=' ')\n", "(a, b) = map(int, input().split(' '))\ndicx = {}\nfor _ in range(b):\n\t(one, two) = input().split(' ')\n\tif len(one) > len(two):\n\t\tdicx[one] = two\n\telse:\n\t\tdicx[one] = one\nstring = input().split(' ')\nfor s in string:\n\tprint(dicx[s] + ' ', end='')\nprint()\n", "a = int(input().split()[1])\nb = {}\nfor i in range(a):\n\tc = input().split()\n\tif len(c[1]) < len(c[0]):\n\t\tb[c[0]] = c[1]\nprint(' '.join(map(lambda x: b[x] if x in b else x, input().split())))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\td[x] = (y, 1)\n\td[y] = (x, 2)\na = list(map(str, input().split()))\nb = []\nfor i in range(n):\n\tt1 = a[i]\n\tt2 = d[a[i]][0]\n\tif len(t1) < len(t2):\n\t\tb.append(t1)\n\telif len(t1) == len(t2):\n\t\tif d[t1][1] == 1:\n\t\t\tb.append(a[i])\n\t\telse:\n\t\t\tb.append(t2)\n\telse:\n\t\tb.append(d[t1][0])\nprint(*b)\n", "def Lecture(n, m, words, lectureNotes):\n\tresult = []\n\tfor n in lectureNotes:\n\t\tif n in words:\n\t\t\tif len(words[n]) < len(n):\n\t\t\t\tresult.append(words[n])\n\t\t\telse:\n\t\t\t\tresult.append(n)\n\tprint(' '.join(result))\n(n, m) = [int(x) for x in input().split(' ')]\nwords = {}\ni = 0\nwhile i < m:\n\t(key, value) = input().split(' ')\n\twords[key] = value\n\ti += 1\nlectureNotes = input().split(' ')\nLecture(n, m, words, lectureNotes)\n", "(n, m) = list(map(int, input().split()))\nd = {}\nfor i in range(0, m):\n\t(s1, s2) = list(input().split())\n\tif len(s1) <= len(s2):\n\t\td[s1] = s1\n\telse:\n\t\td[s1] = s2\nlecture = list(input().split())\nfor j in range(0, n):\n\tprint(d[lecture[j]], end=' ')\n", "(n, m) = map(int, input().split())\nt = []\np = []\nfor i in range(m):\n\tarr = list(map(str, input().split()))\n\tif len(arr[0]) > len(arr[1]):\n\t\tt.append(arr[0])\n\t\tp.append(arr[1])\n\telse:\n\t\tt.append(arr[1])\n\t\tp.append(arr[0])\nmain = list(map(str, input().split()))\nfor i in range(n):\n\tfor j in range(len(t)):\n\t\tif main[i] == t[j] or main[i] == p[j]:\n\t\t\tprint(p[j], end=' ')\n", "(n, m) = map(int, input().split())\nc = dict()\nfor _ in range(m):\n\t(a, b) = input().split()\n\tv = min((a, b), key=len)\n\tc[a] = v\nprint(*[c[k] for k in input().split()])\n", "(n, m) = map(int, input().split())\nshort = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tshort[a] = b if len(b) < len(a) else a\nfor word in input().split():\n\tprint(short[word], end=' ')\n", "(n, m) = [int(x) for x in input().split()]\ndictn = {}\nfor i in range(m):\n\t(lang_1, lang_2) = [x for x in input().split()]\n\tdictn[lang_1] = lang_2\ninput_string = [x for x in input().split()]\noutput_string = ''\nfor i in range(n):\n\tif len(input_string[i]) <= len(dictn[input_string[i]]):\n\t\toutput_string = output_string + input_string[i] + ' '\n\telse:\n\t\toutput_string = output_string + dictn[input_string[i]] + ' '\nprint(output_string)\n", "def shorten(word, m, a, b):\n\tfor i in range(m):\n\t\tif word == a[i] or word == b[i]:\n\t\t\tif len(a[i]) <= len(b[i]):\n\t\t\t\treturn a[i]\n\t\t\telse:\n\t\t\t\treturn b[i]\n(n, m) = map(int, input().split())\n(a, b) = ([], [])\nfor _ in range(m):\n\t(word1, word2) = input().split()\n\ta.append(word1)\n\tb.append(word2)\ntext = list(input().split())\nfor word in text:\n\tword = shorten(word, m, a, b)\n\tprint(word, end=' ')\n", "(n, m) = map(int, input().split())\nk = dict((input().split() for i in range(m)))\nprint(' '.join((min((w, k[w]), key=len) for w in input().split())))\n", "(n, m) = map(int, input().split(' '))\nl = [input().split(' ') for i in range(m)]\nsentence = input().split(' ')\n\ndef chooseLang(l1, l2):\n\tif len(l1) > len(l2):\n\t\treturn l2\n\treturn l1\nwords = []\nfor i in l:\n\twords.append(i[0])\n\twords.append(i[1])\nlang = [chooseLang(i[0], i[1]) for i in l]\nencryp_lang = ' '.join([i + ' ' + i for i in lang]).split(' ')\nprint(' '.join([encryp_lang[words.index(w)] for w in sentence if w in words]))\n", "from math import *\nmod = 1000000007\n\ndef binpow(a, b):\n\tglobal mod\n\tif b == 1:\n\t\treturn a % mod\n\tu = binpow(a, b // 2)\n\tif b % 2 == 0:\n\t\treturn u * u % mod\n\telse:\n\t\treturn u * u * a % mod\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\ndic = {}\nfor _ in range(1):\n\t(n, m) = [int(i) for i in input().split()]\n\tfor i in range(m):\n\t\t(a, b) = input().split()\n\t\tif len(a) > len(b):\n\t\t\tdic[a] = b\n\t\telse:\n\t\t\tdic[a] = a\n\ts = [dic[i] for i in input().split()]\n\tprint(' '.join(s))\n", "a = input().split()\nn = int(a[0])\nm = int(a[1])\ndic = {}\nfor i in range(m):\n\ta = input().split()\n\tdic[a[0]] = a[1]\nstate = input().split()\nans = []\nfor i in state:\n\tif len(dic[i]) < len(i):\n\t\tans.append(dic[i])\n\telse:\n\t\tans.append(i)\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\nf = []\ns = []\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tf.append(a)\n\ts.append(b)\nl = list(map(str, input().split()))\nfor i in range(n):\n\tif l[i] in f:\n\t\tc = f.index(l[i])\n\t\tif len(f[c]) > len(s[c]):\n\t\t\tl[i] = s[c]\n\telif l[i] in s:\n\t\tc = s.index(l[i])\n\t\tif len(s[c]) >= len(f[c]):\n\t\t\tl[i] = f[c]\nprint(' '.join(l))\n", "(a, b) = map(int, input().strip().split())\nlang1 = []\nlang2 = []\nfor _ in range(b):\n\tl = list(map(str, input().strip().split()))\n\tlang1.append(l[0])\n\tlang2.append(l[1])\nlecture = list(map(str, input().split()))\nfor i in lecture:\n\tindexInLang1 = lang1.index(i)\n\tif len(lang1[indexInLang1]) > len(lang2[indexInLang1]):\n\t\tprint(lang2[indexInLang1], end=' ')\n\telse:\n\t\tprint(lang1[indexInLang1], end=' ')\n", "(n, m) = map(int, input().rstrip().split(' '))\nl = []\nk = []\nr = ''\nwhile m:\n\t(f, g) = input().split(' ')\n\tl.append(f)\n\tk.append(g)\n\tm -= 1\nchek = input().split(' ')\nfor i in chek:\n\tt = l.index(i)\n\tif len(l[t]) > len(k[t]):\n\t\tr = r + ' ' + k[t]\n\telse:\n\t\tr = r + ' ' + l[t]\nprint(r[1:])\n", "inp = input().split()\n(n, m) = (int(inp[0]), int(inp[1]))\nd = {}\nfor i in range(0, m):\n\tL = input().split()\n\t(x, y) = (L[0], L[1])\n\tif len(y) < len(x):\n\t\td[x] = y\n\telse:\n\t\td[x] = x\nlec = input().split()\nfor w in lec:\n\tprint(d[w], end=' ')\n", "import sys\nnm = list(map(int, sys.stdin.readline().split()))\nn = nm[0]\nm = nm[1]\nlr = []\nfor i in range(0, m):\n\tg = sys.stdin.readline().split()\n\tif len(g[0]) <= len(g[1]):\n\t\tgg = g[0]\n\telse:\n\t\tgg = g[1]\n\tlr = lr + [[g[0], g[1], gg]]\nlr = sorted(lr)\nq = sys.stdin.readline().split()\nr = ''\nfor j in q:\n\tfor x in lr:\n\t\tif j == x[0]:\n\t\t\tr = r + x[2] + ' '\n\t\t\tbreak\nprint(r)\n", "(lectureW, languageW) = map(int, input().split())\n(lang1, lang2) = ([], [])\nfor i in range(languageW):\n\t(x, y) = input().split()\n\tlang1.append(x)\n\tlang2.append(y)\nmessage = input().split()\nfor w in range(lectureW):\n\tif len(lang1[lang1.index(message[w])]) > len(lang2[lang1.index(message[w])]):\n\t\tmessage[w] = lang2[lang1.index(message[w])]\nprint(' '.join((str(i) for i in message)))\n", "(n, m) = map(int, input().split())\nd = {}\nfor x in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telif len(a) > len(b):\n\t\td[a] = b\ni = input().split()\no = []\nfor x in i:\n\to.append(d[x])\nprint(*o)\n", "(n, m) = map(int, input().split())\nlan = {}\nfor _ in range(m):\n\tt = input().split()\n\tlan[t[0]] = t[1]\nwor = list(input().split())\nsol = []\nfor i in wor:\n\tif len(lan[i]) < len(i):\n\t\tsol.append(lan[i])\n\telse:\n\t\tsol.append(i)\nprint(*sol)\n", "ans = []\n(n, m) = map(int, input().strip().split())\nlis = []\nfor _ in range(m):\n\tarr = list(input().split())\n\tlis.append(arr)\nc = list(input().split())\nfor i in range(n):\n\tfor j in range(len(lis)):\n\t\tif lis[j][0] == c[i]:\n\t\t\tif len(lis[j][0]) <= len(lis[j][1]):\n\t\t\t\tans.append(lis[j][0])\n\t\t\telse:\n\t\t\t\tans.append(lis[j][1])\n\t\telif lis[j][1] == c[i]:\n\t\t\tif len(lis[j][0]) <= len(lis[j][1]):\n\t\t\t\tans.append(lis[j][0])\n\t\t\telse:\n\t\t\t\tans.append(lis[j][1])\nprint(*ans)\n", "def answer(n, m, a, b, c):\n\tnew_ary = []\n\tfor i in range(len(c)):\n\t\tindx = a.index(c[i])\n\t\tif len(a[indx]) <= len(b[indx]):\n\t\t\tnew_ary.append(a[indx])\n\t\telse:\n\t\t\tnew_ary.append(b[indx])\n\treturn ' '.join(new_ary)\n\ndef answer2(c, d):\n\tnew_ary = []\n\tfor e in c:\n\t\tif len(e) <= len(d[e]):\n\t\t\tnew_ary.append(e)\n\t\telse:\n\t\t\tnew_ary.append(d[e])\n\treturn ' '.join(new_ary)\n\ndef main():\n\t(n, m) = [int(i) for i in input().split()]\n\ta = ['x'] * m\n\tb = ['x'] * m\n\td = {}\n\tfor j in range(m):\n\t\t(a[j], b[j]) = [i for i in input().split()]\n\td = {k: v for (k, v) in zip(a, b)}\n\tc = [i for i in input().split()]\n\tprint(answer2(c, d))\nmain()\n", "(n, m) = map(int, input().split())\nc = {}\nd = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tc[a] = b\ntext = input().split()\nfor i in text:\n\tif len(c[i]) < len(i):\n\t\td.append(c[i])\n\telse:\n\t\td.append(i)\nprint(' '.join(d))\n", "L1 = input().split()\nn = int(L1[0])\nm = int(L1[1])\nword = {}\nc = ' '\nfor i in range(m):\n\tinp = input().split()\n\tfir = inp[0]\n\tword[fir] = {}\n\tword[fir] = inp[1]\nL = input().split()\nfor i in range(len(L)):\n\tfir = L[i]\n\tif len(fir) > len(word[fir]):\n\t\tL[i] = word[fir]\nc = ' '\nfor i in range(len(L) - 1):\n\tprint(L[i] + c, end='')\nprint(L[len(L) - 1])\n", "M = dict()\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(s, t) = input().split()\n\tif len(s) < len(t):\n\t\t(s, t) = (t, s)\n\telif len(s) == len(t):\n\t\ts = t\n\tM[s] = t\na = list(input().split())\nfor word in a:\n\tif word in M:\n\t\tprint(M[word], end=' ')\n\telse:\n\t\tprint(word, end=' ')\n", "(n, m) = list(map(int, input().split()))\ndi = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tdi[a] = b\nss = input().split()\nk = []\nfor j in ss:\n\tval = di[j]\n\tif len(val) < len(j):\n\t\tk.append(val)\n\telse:\n\t\tk.append(j)\nprint(' '.join(k))\n", "(n, m) = map(int, input().split())\nl = []\nfor i in range(m):\n\tl = l + list(input().split())\na = list(input().split())\nfor i in range(0, n):\n\tt = l.index(a[i])\n\tif t % 2 == 0:\n\t\tif len(l[t]) <= len(l[t + 1]):\n\t\t\tprint(l[t], end=' ')\n\t\telse:\n\t\t\tprint(l[t + 1], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdic[a] = a\n\tif len(a) > len(b):\n\t\tdic[a] = b\ntext = input().split()\nfor word in text:\n\tprint(dic[word], end=' ')\n", "(lection_size, dictionary_size) = map(int, input().split())\nlanguage_dict = {}\nfor _ in range(dictionary_size):\n\t(lection_word, translation) = input().split()\n\tlanguage_dict[lection_word] = translation\nlection_words = input().split()\nfor word in lection_words:\n\tword_abbr = language_dict[word]\n\tresult_word = min(word, word_abbr, key=len)\n\tprint(result_word, end=' ')\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\t(l1, l2) = input().split()\n\tif len(l1) > len(l2):\n\t\td[l1] = l2\n\telse:\n\t\td[l1] = l1\nstring = input()\nfor word in string.split():\n\tprint(d[word], end=' ')\nprint()\n", "c = 0\n(m, n) = input().split(' ')\n(m, n) = (int(m), int(n))\ndict1 = {}\nfor i in range(n):\n\t(a, b) = input().split(' ')\n\tdict1[a] = b\ns = input().split(' ')\nfor i in s:\n\tif len(i) <= len(dict1[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(dict1[i], end=' ')\n", "a = list(map(int, input().split()))\nn = a[0]\nm = a[1]\nd = {}\nfor i in range(0, m):\n\tx = list(input().split())\n\tif len(x[0]) <= len(x[1]):\n\t\tc = 0\n\telse:\n\t\tc = 1\n\td[x[0]] = x[c]\ny = list(input().split())\nl = []\nfor i in y:\n\tprint(d[i], end=' ')\n", "(n, m) = map(int, input().split())\na = [[str(x) for x in input().split()] for i in range(m)]\nb = input().split()\nc = {}\nfor j in range(len(a)):\n\tif len(a[j][0]) <= len(a[j][1]):\n\t\tc[a[j][0]] = a[j][0]\n\t\tc[a[j][1]] = a[j][0]\n\telse:\n\t\tc[a[j][0]] = a[j][1]\n\t\tc[a[j][1]] = a[j][1]\nfor p in range(len(b)):\n\tb[p] = c[b[p]]\nprint(' '.join(b))\n", "(n, m) = list(map(int, input().split()))\na = []\nb = []\nfor i in range(0, m):\n\ts = input()\n\ts = s.split()\n\ta.append(s[0])\n\tb.append(s[1])\nl = input()\nl = l.split(' ')\nw = ''\nfor i in l:\n\tp = a.index(i)\n\tif len(a[p]) <= len(b[p]):\n\t\tw = w + a[p] + ' '\n\telse:\n\t\tw = w + b[p] + ' '\nprint(w[:-1])\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\td[a] = a if len(a) <= len(b) else b\nprint(' '.join((d[x] for x in input().split())))\n", "X = list(map(int, input().split()))\nMyDict = dict()\nfor i in range(X[1]):\n\tY = list(input().split())\n\tMyDict[Y[0]] = Y[1]\nSentence = list(input().split())\nfor i in Sentence:\n\tif len(MyDict[i]) < len(i):\n\t\tprint(MyDict[i], end=' ')\n\t\tcontinue\n\tprint(i, end=' ')\n", "(i, j) = [int(x) for x in input().split(' ')]\nn = 0\nl1 = list()\nl2 = list()\nwhile n < j:\n\t(a, b) = input().split()\n\tl1.append(a)\n\tl2.append(b)\n\tn = n + 1\ns = list(input().split())\nans = list()\nfor i in s:\n\tif i in l1:\n\t\tif len(l1[l1.index(i)]) <= len(l2[l1.index(i)]):\n\t\t\tans.append(l1[l1.index(i)])\n\t\telse:\n\t\t\tans.append(l2[l1.index(i)])\n\telif len(l1[l2.index(i)]) <= len(l2[l2.index(i)]):\n\t\tans.append(l1[l2.index(i)])\n\telse:\n\t\tans.append(l2[l2.index(i)])\nprint(' '.join(ans))\n", "(m, n) = map(int, input().split())\ndec = []\nfor i in range(n):\n\t(a, b) = map(str, input().split())\n\talen = len(a)\n\tblen = len(b)\n\ttemp = []\n\ttemp.append(a)\n\ttemp.append(b)\n\tif alen <= blen:\n\t\ttemp.append(a)\n\telse:\n\t\ttemp.append(b)\n\tdec.append(temp)\nword = ''\nstat = list(map(str, input().split()))\nfor i in stat:\n\tfor array in dec:\n\t\tif array[1] == i or array[0] == i:\n\t\t\tword += array[2] + ' '\nprint(word)\n", "(a, b) = map(int, input().split())\nc = []\nfor i in range(b):\n\tc.append(input().split())\ne = [i[0] for i in c]\n\ndef small_word(i):\n\tif len(i[0]) <= len(i[1]):\n\t\treturn i[0]\n\telse:\n\t\treturn i[1]\nd = input().split()\nfor i in range(len(d)):\n\tf = e.index(d[i])\n\td[i] = small_word(c[f])\nprint(' '.join(d))\n", "(n, m) = map(int, input().split())\nl = []\nfor i in range(0, m):\n\tl.append([j for j in input().split()])\ns = []\ns = input().split()\ns2 = ''\nfor i in range(0, n):\n\tfor j in range(0, m):\n\t\tif s[i] == l[j][0] or s[i] == l[j][1]:\n\t\t\tif len(l[j][0]) > len(l[j][1]):\n\t\t\t\ts2 += l[j][1]\n\t\t\telif len(l[j][0]) == len(l[j][1]):\n\t\t\t\ts2 += l[j][0]\n\t\t\telse:\n\t\t\t\ts2 += l[j][0]\n\ts2 += ' '\nprint(s2)\n", "(n, m) = [int(x) for x in input().split(' ')]\nd = {}\n\ndef s(a, b):\n\tif len(a) < len(b):\n\t\treturn a\n\telif len(a) > len(b):\n\t\treturn b\n\telse:\n\t\treturn a\nfor i in range(m):\n\t(a, b) = [x for x in input().split(' ')]\n\tf = s(a, b)\n\td[a] = f\n\td[b] = f\nl = [s for s in input().split(' ')]\nfor i in range(len(l)):\n\tl[i] = d[l[i]]\ns = ' '.join(l)\nprint(s)\n", "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef LI():\n\treturn [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_():\n\treturn [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF():\n\treturn [float(x) for x in sys.stdin.readline().split()]\n\ndef LS():\n\treturn sys.stdin.readline().split()\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef F():\n\treturn float(sys.stdin.readline())\n\ndef S():\n\treturn input()\n\ndef pf(s):\n\treturn print(s, flush=True)\n\ndef main():\n\t(n, m) = LI()\n\ta = [LS() for _ in range(m)]\n\ts = LS()\n\td = {}\n\tfor (e, f) in a:\n\t\tt = f\n\t\tif len(e) <= len(f):\n\t\t\tt = e\n\t\td[e] = t\n\t\td[f] = t\n\tr = []\n\tfor c in s:\n\t\tr.append(d[c])\n\treturn ' '.join(map(str, r))\nprint(main())\n", "import sys\ninf = float('inf')\n(mod, MOD) = (1000000007, 998244353)\nfrom collections import deque, Counter, OrderedDict, defaultdict\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\nfrom math import ceil, floor, log, sqrt, factorial, pow, pi, gcd, log10, atan, tan\n\ndef get_array():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef get_strs():\n\treturn map(str, sys.stdin.readline().strip().split())\n\ndef input():\n\treturn sys.stdin.readline().strip()\n(n, m) = get_ints()\nmydict = dict()\nfor i in range(m):\n\t(str1, str2) = get_strs()\n\tmydict[str1] = str2\nlecture = input().split()\nfor i in range(n):\n\tif len(lecture[i]) > len(mydict[lecture[i]]):\n\t\tlecture[i] = mydict[lecture[i]]\nprint(*lecture)\n", "seq = input()\nA = seq.split()\nn = int(A[0])\nm = int(A[1])\nguide = {}\nfor i in range(m):\n\tseq = input()\n\tA = seq.split()\n\tif len(A[0]) < len(A[1]):\n\t\tkey = A[1]\n\t\tres = A[0]\n\telif len(A[0]) == len(A[1]):\n\t\tkey = A[1]\n\t\tres = A[0]\n\telse:\n\t\tkey = A[0]\n\t\tres = A[1]\n\tguide[key] = res\nseq = input()\nA = seq.split()\nB = []\nfor i1 in A:\n\tif i1 in guide.keys():\n\t\tB.append(guide[i1])\n\telse:\n\t\tB.append(i1)\nprint(' '.join(B))\n", "(n, m) = map(int, input().split())\n(z, z1) = ([], [])\nans = []\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\tz.append(min(x, y))\n\tz1.append(max(x, y))\nl = list(map(str, input().split()))\nfor i in range(n):\n\tif l[i] in z:\n\t\tb = z.index(l[i])\n\t\tif len(l[i]) <= len(z1[b]):\n\t\t\tans.append(l[i])\n\t\telse:\n\t\t\tans.append(z1[b])\n\tif l[i] in z1:\n\t\tb = z1.index(l[i])\n\t\tif len(l[i]) <= len(z[b]):\n\t\t\tans.append(l[i])\n\t\telse:\n\t\t\tans.append(z[b])\nprint(*ans)\n", "import time, math\nfrom sys import stdin, stdout\n\ndef In():\n\treturn map(int, stdin.readline().split())\n\ndef Is():\n\treturn map(str, stdin.readline().split())\n\ndef L():\n\treturn list(map(str, stdin.readline().split()))\n\ndef Si():\n\treturn sorted(list(map(int, stdin.readline().split())))\n\ndef Si():\n\treturn sorted(list(map(int, stdin.readline().split())), reverse=True)\n\ndef P(x):\n\treturn stdout.write(str(x) + ' ')\n\ndef Pi(x, y):\n\treturn stdout.write(str(x) + ' ' + str(y))\n\ndef solve():\n\t(n, m) = In()\n\td = {}\n\tfor i in range(m):\n\t\t(a, b) = Is()\n\t\td[a] = b\n\tl = L()\n\tfor i in l:\n\t\ts1 = len(i)\n\t\tif s1 > len(d[i]):\n\t\t\tP(d[i])\n\t\telse:\n\t\t\tP(i)\nsolve()\n", "(n, m) = map(int, input().split())\nlst1 = []\nlst2 = []\nfor i in range(m):\n\t(x, y) = map(str, input().split(' '))\n\tlst1.append(x)\n\tlst2.append(y)\nlst3 = list(map(str, input().split(' ')))\nlst4 = []\nfor i in lst3:\n\ta = lst1.index(i)\n\tif len(lst1[a]) <= len(lst2[a]):\n\t\tlst4.append(lst1[a])\n\telse:\n\t\tlst4.append(lst2[a])\nfor i in range(len(lst4)):\n\tprint(lst4[i], end=' ')\n", "(n, m) = map(int, input().split())\nvocab_first = {}\nvocab_joined = {}\nshortest_version = []\nfor _ in range(m):\n\t(a, b) = input().split()\n\tvocab_first[a] = b\n\tvocab_joined[a] = b\n\tvocab_joined[b] = a\nfor w in input().split():\n\tif len(vocab_joined[w]) < len(w):\n\t\tshortest_version.append(vocab_joined[w])\n\telif len(w) < len(vocab_joined[w]):\n\t\tshortest_version.append(w)\n\telif w in vocab_first:\n\t\tshortest_version.append(w)\n\telse:\n\t\tshortest_version.append(vocab_joined[w])\nprint(' '.join(shortest_version))\n", "(n, m) = [int(i) for i in input().split()]\na1 = []\nb = []\nfor a0 in range(m):\n\ta = input().split()\n\ta1.append(a[0])\n\tb.append(a[1] if len(a[1]) < len(a[0]) else a[0])\nnotes = input().split()\nfor word in notes:\n\tprint(b[a1.index(word)], end=' ')\n", "from sys import stdin, stdout\nii1 = lambda : int(stdin.readline().strip())\nis1 = lambda : stdin.readline().strip()\niia = lambda : list(map(int, stdin.readline().strip().split()))\nisa = lambda : stdin.readline().strip().split()\nmod = 1000000007\n(n, m) = iia()\nd = {}\nfor _ in range(m):\n\t(a, b) = isa()\n\td[a] = b\nans = []\nfor t in isa():\n\tif len(t) <= len(d[t]):\n\t\tans.append(t)\n\telse:\n\t\tans.append(d[t])\nprint(*ans, sep=' ')\n", "(n, m) = map(int, input().split())\nk = []\nos = ''\nfor i in range(m):\n\ts = input()\n\tl = s.strip().split()\n\tk.append(l)\nstri = input()\nstrl = stri.strip().split()\nfor i in strl:\n\tfor j in k:\n\t\tif i == j[0]:\n\t\t\tc1 = len(j[0])\n\t\t\tc2 = len(j[1])\n\t\t\tif c1 > c2:\n\t\t\t\tos = os + j[1] + ' '\n\t\t\telse:\n\t\t\t\tos = os + j[0] + ' '\nprint(os[:-1], end='')\n", "(n, m) = map(int, input().split(' '))\nd = {}\nfor i in range(m):\n\ts = input().split(' ')\n\tl1 = len(s[0])\n\tl2 = len(s[1])\n\td[s[0]] = s[1]\n\td[s[1]] = s[0]\n\tif l1 > l2:\n\t\td[s[1]] = s[1]\n\telse:\n\t\td[s[0]] = s[0]\nk = input().split(' ')\nfor i in k:\n\tprint(d[i], end=' ')\n", "(_, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\na = ''\nfor i in input().split():\n\tif len(i) <= len(d[i]):\n\t\ta += i + ' '\n\telse:\n\t\ta += d[i] + ' '\nprint(a.rstrip())\n", "(n, m) = map(int, input().split())\nf = []\ns = []\ng = ''\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tf.append(a)\n\ts.append(b)\nc = list(map(str, input().split()))\nfor i in range(n):\n\tif c[i] in f:\n\t\tx = f.index(c[i])\n\t\tif len(f[x]) <= len(s[x]):\n\t\t\tg += f[x] + ' '\n\t\telse:\n\t\t\tg += s[x] + ' '\n\telse:\n\t\tx = s.index(c[i])\n\t\tif len(s[x]) <= len(f[x]):\n\t\t\tg += s[x] + ' '\n\t\telse:\n\t\t\tg += f[x] + ' '\nprint(g)\n", "(n, m) = map(int, input().split())\nd = dict((input().split() for _ in range(m)))\nS = input().split()\nprint(' '.join((min((w, d[w]), key=len) for w in S)))\n", "def solve(dict, sentence):\n\tnotesSentence = []\n\tfor word in sentence:\n\t\tmappedWord = dict[word]\n\t\tif len(mappedWord) < len(word):\n\t\t\tnotesSentence.append(mappedWord)\n\t\telse:\n\t\t\tnotesSentence.append(word)\n\treturn ' '.join(notesSentence)\n(n, m) = map(int, input().split(' '))\ndict = {}\nfor _m in range(0, m):\n\twords = input().split(' ')\n\tdict[words[0]] = words[1]\nsentence = input().split(' ')\nprint(solve(dict, sentence))\n", "d = {}\n(n, m) = map(int, input().split())\nw = []\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nc = list(input().split())\nfor i in range(len(c)):\n\tm = d[c[i]]\n\tif len(c[i]) <= len(m):\n\t\tprint(c[i], end=' ')\n\telse:\n\t\tprint(m, end=' ')\n", "import sys\nimport math\nimport collections\nimport operator as op\nfrom collections import deque\nfrom math import gcd\nfrom functools import reduce\nfrom sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(2 ** 20)\n\ndef ncr(n, r):\n\tr = min(r, n - r)\n\tnumer = reduce(op.mul, range(n, n - r, -1), 1)\n\tdenom = reduce(op.mul, range(1, r + 1), 1)\n\treturn numer // denom\n\ndef isPowerOfTwo(x):\n\treturn x and (not x & x - 1)\n\ndef factors(n):\n\treturn list(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0))))\nT = 1\nfor _ in range(T):\n\t(n, m) = list(map(int, stdin.readline().split()))\n\td = {}\n\tfor i in range(m):\n\t\ts = str(input()).split(' ')\n\t\tif len(s[0]) > len(s[1]):\n\t\t\td[s[0]] = s[1]\n\t\t\td[s[1]] = s[1]\n\t\telse:\n\t\t\td[s[0]] = s[0]\n\t\t\td[s[1]] = s[0]\n\tl = str(input()).split(' ')\n\tfor i in l:\n\t\tprint(d[i], end=' ')\n\tprint()\n", "(n, m) = list(map(int, input().rstrip().split()))\na = []\nb = []\nfor _ in range(m):\n\tx = list(map(str, input().rstrip().split()))\n\ta += [x[0]]\n\tb += [x[1]]\nc = list(map(str, input().rstrip().split()))\nfor i in range(n):\n\td = c[i]\n\tx = a.index(d)\n\ty = b[x]\n\tif len(d) <= len(y):\n\t\tprint(d, end=' ')\n\telse:\n\t\tprint(y, end=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nwhile m > 0:\n\t(key, value) = input().split()\n\tdic[key] = value\n\tm -= 1\nl = list(input().split())\nfor el in l:\n\tif len(el) <= len(dic[el]):\n\t\tprint(el, sep=' ', end=' ')\n\telse:\n\t\tprint(dic[el], sep=' ', end=' ')\n", "from sys import stdin, stdout\n(n, q) = map(int, stdin.readline().strip().split())\nmydict = dict()\nfor i in range(q):\n\t(s1, s2) = map(str, input().split())\n\tmydict[s1] = s2\nmylist = input().split()\nresult = []\nfor i in range(n):\n\tif len(mylist[i]) <= len(mydict[mylist[i]]):\n\t\tresult.append(mylist[i])\n\telse:\n\t\tresult.append(mydict[mylist[i]])\nprint(*result, sep=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\nans = []\nC = input().split()\nfor i in range(n):\n\tans.append(d[C[i]])\nprint(' '.join(ans))\n", "nm = list(map(int, input().split()))\nwords = []\nfor i in range(nm[1]):\n\twords.append(list(map(str, input().split())))\nc = list(map(str, input().split()))\nres = []\nfor i in range(nm[0]):\n\tfor j in range(nm[1]):\n\t\tif c[i] == words[j][0]:\n\t\t\tif len(words[j][0]) <= len(words[j][1]):\n\t\t\t\tres.append(words[j][0])\n\t\t\telse:\n\t\t\t\tres.append(words[j][1])\nprint(*res)\n", "import math\n\ndef get_primes(prime_supr):\n\tis_prime = [0] * 2 + [1] * prime_supr\n\tfor i in range(2, int(math.sqrt(prime_supr)) + 1):\n\t\tif is_prime[i]:\n\t\t\tfor j in range(i * i, prime_supr + 1, i):\n\t\t\t\tis_prime[j] = 0\n\treturn is_prime\nget_int = lambda : map(int, input().split())\n(n, m) = get_int()\nans = {}\nfor i in range(m):\n\tt = input().split()\n\tans[t[0]] = t[1]\nq = input().split()\nfor i in q:\n\tprint([i, ans[i]][len(i) > len(ans[i])], end=' ')\n", "def lenmin(a, b):\n\tif len(a) > len(b):\n\t\treturn b\n\treturn a\n(n, m) = (int(i) for i in input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = (i for i in input().split())\n\tdic[a] = lenmin(a, b)\nlecture = [i for i in input().split()]\nfor i in lecture:\n\tprint(dic[i], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\td[a] = b if len(b) < len(a) else a\nstring = []\nfor word in input().split():\n\tstring.append(d[word])\nprint(' '.join(string))\n", "(n, m) = (int(i) for i in input().split())\npool = {}\nfor i in range(m):\n\t(lang1, lang2) = input().split()\n\tpool[lang1] = lang2\ntext = input().split()\nfor (n, word) in enumerate(text):\n\tif len(pool[word]) < len(word):\n\t\ttext[n] = pool[word]\nprint(' '.join(text))\n", "(n, m) = map(int, input().split())\n(fl, sl) = ([], [])\nfor i in range(m):\n\t(y, z) = input().split()\n\tfl.append(y)\n\tsl.append(z)\ns = list(input().split())\nfor i in s:\n\tj = fl.index(i)\n\tif len(fl[j]) == len(sl[j]):\n\t\ti = fl[j]\n\telif len(fl[j]) < len(sl[j]):\n\t\ti = fl[j]\n\telse:\n\t\ti = sl[j]\n\tprint(i, end=' ')\n", "def intput():\n\treturn [int(x) for x in input().split(' ')]\n\ndef main(lecture, mapping):\n\tans = []\n\tfor word in lecture:\n\t\tans.append(mapping[word])\n\tprint(' '.join(ans))\n\ndef parse():\n\t(_, words) = intput()\n\tmapping = {}\n\tfor _ in range(words):\n\t\t(l1, l2) = input().split(' ')\n\t\tlm = l2 if len(l2) < len(l1) else l1\n\t\tmapping[l1] = lm\n\tlecture = input().split(' ')\n\treturn (lecture, mapping)\nmain(*parse())\n", "(n, m) = [int(x) for x in input().split()]\ndict = {}\nrecord = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tnote = b\n\telse:\n\t\tnote = a\n\tdict[a] = note\nlecture = input().split()\nfor word in lecture:\n\td = dict[word]\n\trecord.append(d)\nfor item in record:\n\tprint(item, end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor k in range(m):\n\t(a, b) = list(input().split())\n\td[a] = b\nl = list(input().split())\nfor i in l:\n\tif len(i) > len(d[i]):\n\t\tprint(d[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = list(map(int, input().split()))\na = []\nb = []\nc = []\nres = []\nfor i in range(m):\n\tw = input().split()\n\ta.append(w[0])\n\tb.append(w[1])\nc = input().split()\nfor i in c:\n\tk = a.index(i)\n\tif len(a[k]) <= len(b[k]):\n\t\tres.append(a[k])\n\telse:\n\t\tres.append(b[k])\nprint(' '.join(res))\n", "m = int(input().split()[1])\naa = []\nfor i in range(m):\n\taa += input().split()\nst = input().split()\nans = ''\nfor x in st:\n\tind = aa.index(x)\n\tif ind % 2 == 0:\n\t\tfi = 1\n\telse:\n\t\tfi = -1\n\tif fi == 1:\n\t\tans += [aa[ind], aa[ind + fi]][len(aa[ind]) > len(aa[ind + fi])]\n\telse:\n\t\tans += [aa[ind + fi], aa[ind]][len(aa[ind + fi]) > len(aa[ind])]\n\tans += ' '\nprint(ans)\n", "(n, m) = map(int, input().split(' '))\nwords = {}\nfor i in range(m):\n\t(a, b) = input().split(' ')\n\twords[a] = b\narr = list(input().split(' '))\nfor (i, j) in enumerate(arr):\n\tif len(words[j]) < len(j):\n\t\tarr[i] = words[j]\nprint(*arr)\n", "(readText, NumOfWords) = [int(x) for x in input().split()]\naDict = {}\nfor i in range(NumOfWords):\n\taWord = input().split()\n\taDict[aWord[0]] = aWord[1]\nreadText = input().split()\nfor i in range(len(readText)):\n\tif len(readText[i]) > len(aDict[readText[i]]):\n\t\treadText[i] = aDict[readText[i]]\nreadText = ' '.join(readText)\nprint(readText)\n", "def lecture(language_mapper, lecture_list):\n\tfinal_languages = []\n\tfor language in lecture_list:\n\t\tif language in language_mapper:\n\t\t\tif len(language) <= len(language_mapper[language]):\n\t\t\t\tfinal_languages.append(language)\n\t\t\telif len(language) > len(language_mapper[language]):\n\t\t\t\tfinal_languages.append(language_mapper[language])\n\t\t\telse:\n\t\t\t\tpass\n\treturn final_languages\nX = str(input())\n(n, m) = X.split(' ')\nlanguage_mapper = {}\nfor i in range(int(m)):\n\tL = str(input())\n\t(lang1, lang2) = L.split(' ')\n\t(lang1, lang2) = (lang1.lower(), lang2.lower())\n\tlanguage_mapper[str(lang1)] = str(lang2)\nlecture_list = []\nLL = str(input())\nlecture_list = LL.split(' ')\nlecture_list = [lang.lower() for lang in lecture_list]\nfinal = lecture(language_mapper, lecture_list)\nfor lang in final:\n\tprint(lang, end=' ')\n", "(n, m) = map(int, input().split())\n(d, rev) = (dict(), dict())\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\td[a] = b\n\t\trev[b] = a\n\telse:\n\t\td[b] = a\n\t\trev[a] = b\narr = list(map(str, input().split()))\nfor i in arr:\n\tif i in d.values():\n\t\tprint(rev[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = list(map(int, input().split()))\nb = {}\nh = []\nfor i in range(m):\n\tx = list(map(str, input().split()))\n\tif len(x[0]) == len(x[1]):\n\t\tb[x[0]] = x[0]\n\t\tb[x[1]] = x[0]\n\telif len(x[0]) > len(x[1]):\n\t\tb[x[0]] = x[1]\n\t\tb[x[1]] = x[1]\n\telif len(x[0]) < len(x[1]):\n\t\tb[x[0]] = x[0]\n\t\tb[x[1]] = x[0]\nlecture = input()\nlecture = lecture.split()\nfor j in range(n):\n\th.append(b[lecture[j]])\nprint(*h)\n", "(n, m) = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n\t(k, v) = input().split()\n\td[k] = v\ns = input().split()\nfor (n, i) in enumerate(s):\n\tif len(d[i]) < len(i):\n\t\ts[n] = d[i]\nprint(' '.join(s))\n", "(n, m) = map(int, input().split())\nres1 = []\nres2 = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tres1.append(a)\n\tres2.append(b)\nip = list(input().split())\nans = ''\nfor i in range(len(ip)):\n\tif ip[i] in res1 or ip[i] in res2:\n\t\tj = res1.index(ip[i])\n\t\tif len(res1[j]) <= len(res2[j]):\n\t\t\tans += res1[j] + ' '\n\t\telse:\n\t\t\tans += res2[j] + ' '\nprint(ans)\n", "a = input()\na = a.split()\nn = int(a[0])\nm = int(a[1])\nk1 = []\nk2 = []\nfor i in range(m):\n\tl = input()\n\tl = l.split()\n\tk1.append(l[0])\n\tk2.append(l[1])\nans = input()\nans = ans.split()\nfor i in range(n):\n\tb = ans[i]\n\tif k1.count(b) != 0:\n\t\tl = len(b)\n\t\tj = k1.index(b)\n\t\tc = k2[j]\n\t\tif len(b) <= len(c):\n\t\t\tans[i] = b\n\t\telse:\n\t\t\tans[i] = c\n\telse:\n\t\tl = len(b)\n\t\tj = k2.index(b)\n\t\tc = k1[j]\n\t\tif len(b) <= len(c):\n\t\t\tans[i] = b\n\t\telse:\n\t\t\tans[i] = c\nans1 = ''\nfor i in range(n):\n\tans1 += ans[i] + ' '\nprint(ans1)\n", "from collections import defaultdict\nd = defaultdict(list)\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\tif len(x) > len(y):\n\t\td[x].append(y)\n\telse:\n\t\td[x].append(x)\ns = list(map(str, input().split()))\nfor i in range(n):\n\tprint(*d[s[i]], end=' ')\n", "import sys\n\ndef main():\n\t(n, m) = [int(i) for i in input().split()]\n\twords = {}\n\tfor k in range(m):\n\t\t(l1, l2) = [word for word in input().split()]\n\t\twords[l1] = [l1, l2]\n\tlec = input().split()\n\tfor word in lec:\n\t\tprint(words[word][0] if len(words[word][0]) <= len(words[word][1]) else words[word][1], end=' ')\nmain()\n", "(n, m) = map(int, input().split())\ns = {}\nfor i in range(m):\n\tstemp = input().split()\n\ts[stemp[0]] = stemp[1]\n\ts[stemp[1]] = stemp[0]\nst = input().split()\nfor i in range(len(st)):\n\tif i == len(st) - 1:\n\t\tif len(s[st[i]]) >= len(st[i]):\n\t\t\tprint(st[i])\n\t\telse:\n\t\t\tprint(s[st[i]])\n\telif len(s[st[i]]) >= len(st[i]):\n\t\tprint(st[i], end=' ')\n\telse:\n\t\tprint(s[st[i]], end=' ')\n", "(n, m) = list(map(int, input().split()))\ns = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\ts[a] = b if len(b) < len(a) else a\nprint(' '.join((s[i] for i in input().split())))\n", "arr = [int(x) for x in input().split()]\n(n, m) = (arr[0], arr[1])\nd = {}\nfor i in range(m):\n\ts = input().split()\n\t(l1, l2) = (s[0], s[1])\n\td[l1] = l2\ns = input().split()\nans = ''\nfor ele in s:\n\tif len(ele) <= len(d[ele]):\n\t\tans += ele + ' '\n\telse:\n\t\tans += d[ele] + ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\nA = {}\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\tif len(x) <= len(y):\n\t\tA[x] = x\n\telse:\n\t\tA[x] = y\nB = [str(i) for i in input().split()]\nfor i in B:\n\tprint(A[i], end=' ')\n", "(n, m) = map(int, input().split())\nl1 = []\nl2 = []\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tl1.append(a)\n\tl2.append(b)\ns = ''\nlist1 = map(str, input().split())\nfor i in list1:\n\tif i in l1:\n\t\tp = l1.index(i)\n\t\tif len(l1[p]) > len(l2[p]):\n\t\t\ts += l2[p] + ' '\n\t\telse:\n\t\t\ts += l1[p] + ' '\nprint(s)\n", "(len_sentence, ln_words) = map(int, input().split())\nwords = {}\nfor i in range(ln_words):\n\t(lang1, lang2) = input().split()\n\twords[lang1] = lang1 if len(lang1) <= len(lang2) else lang2\nsentence = input().split()\nwritten_sentence = []\nfor word in sentence:\n\twritten_sentence.append(words[word])\nprint(' '.join(written_sentence))\n", "(n, m) = map(int, input().split())\ndictry = {}\nfor word in range(m):\n\t(w1, w2) = input().split()\n\tdictry[w1] = w1 if len(w1) <= len(w2) else w2\nlecture = input().split()\nlecture = [dictry[x] for x in lecture]\nprint(' '.join(lecture))\n", "(m, n) = map(int, input().split())\ninter = {}\nfor i in range(n):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tinter[a] = a\n\t\tinter[b] = a\n\telse:\n\t\tinter[a] = b\n\t\tinter[b] = b\nc = input().split()\nfor i in range(m):\n\tprint(inter[c[i]], end=' ')\n", "(n, m) = map(int, input().split())\nlangDict = {}\nfor i in range(m):\n\tt = input().split()\n\tlangDict[t[0]] = t[1]\nlecture = input().split()\nnotes = ''\nfor i in lecture:\n\tif len(langDict[i]) < len(i):\n\t\tnotes += langDict[i] + ' '\n\telse:\n\t\tnotes += i + ' '\nprint(notes)\n", "(n, m) = map(int, input().split(' '))\nwords = dict()\nfor i in range(0, m):\n\t(u, v) = input().split(' ')\n\twords[u] = v\ntxt = input().split(' ')\nnote = []\nfor u in txt:\n\tv = words[u]\n\tif len(v) < len(u):\n\t\tu = v\n\tnote.append(u)\nprint(' '.join(note))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\nlect = input().split()\nfor elem in lect:\n\tprint(d[elem], end=' ')\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\ttmp = input().split()\n\td[tmp[0]] = tmp[1]\ns = input().split()\nfor i in range(n):\n\tif len(s[i]) > len(d[s[i]]):\n\t\ts[i] = d[s[i]]\nprint(' '.join(s))\n", "(n, m) = map(int, input().split())\na = {}\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\ta[s1] = s2\nb = list(map(str, input().split()))\nfor i in b[0:-1]:\n\tif len(i) <= len(a[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(a[i], end=' ')\ni = b[-1]\nif len(i) <= len(a[i]):\n\tprint(i, end=' ')\nelse:\n\tprint(a[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = dict((input().split() for _ in range(m)))\nprint(' '.join((s if len(s) <= len(d[s]) else d[s] for s in input().split())))\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(b) < len(a):\n\t\tdic[a] = b\nlst = input().split()\nfor x in lst:\n\tif x in dic:\n\t\tprint(dic[x], end=' ')\n\telse:\n\t\tprint(x, end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\td[a] = b\n\td[b] = a\nc = list(input().split())\nres = []\nfor w in c:\n\tm = w if len(w) <= len(d[w]) else d[w]\n\tres.append(m)\nprint(*res)\n", "(n, m) = list(map(int, input().split()))\n(a, b) = ([], [])\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\tb.append(y)\nlecture = input().split()\nonetotwo = {}\ntwotoone = {}\nfor i in range(m):\n\tonetotwo[a[i]] = b[i]\n\ttwotoone[b[i]] = a[i]\nans = []\nfor word in lecture:\n\tif word in onetotwo:\n\t\t(k, v) = (word, onetotwo[word])\n\t\tif len(k) <= len(v):\n\t\t\tans.append(k)\n\t\telse:\n\t\t\tans.append(v)\n\telse:\n\t\t(k, v) = (word, twotoone[word])\n\t\tif len(k) < len(v):\n\t\t\tans.append(k)\n\t\telse:\n\t\t\tans.append(v)\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split(' '))\nd = {}\nfor _ in range(m):\n\tline = input().split()\n\tif len(line[0]) > len(line[1]):\n\t\td[line[0]] = line[1]\n\telse:\n\t\td[line[0]] = line[0]\nlec = input().split()\nres = ''\nfor i in lec:\n\tres += d[i] + ' '\nprint(res)\n", "(n, m) = str(input()).split()\nn = int(n)\nm = int(m)\nlist_a = list()\nlist_b = list()\nfor i in range(m):\n\t(a, b) = str(input()).split()\n\tlist_a.append(a)\n\tlist_b.append(b)\nlist_c = str(input()).split()\nfor i in range(n):\n\tidx = list_a.index(list_c[i])\n\tif len(list_b[idx]) < len(list_a[idx]):\n\t\tlist_c[i] = list_b[idx]\nprint(' '.join(list_c))\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\ta.append(list(map(str, input().split())))\nb = list(map(str, input().split()))\nans = []\nfor i in b:\n\tfor j in range(len(a)):\n\t\tif a[j][0] == i:\n\t\t\tif len(a[j][0]) <= len(a[j][1]):\n\t\t\t\tans.append(a[j][0])\n\t\t\telse:\n\t\t\t\tans.append(a[j][1])\nprint(*ans)\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(r, l) = input().split()\n\tdic[r] = l\nfor i in input().split():\n\tprint(min(i, dic[i], key=len), end=' ')\n", "(a, b) = input().split()\ndi = {}\nfor i in range(int(b)):\n\ts = input().split()\n\ti = s[0]\n\tif len(s[0]) <= len(s[1]):\n\t\tj = s[0]\n\telse:\n\t\tj = s[1]\n\tdi.update({i: j})\nst = input().split()\nfor i in st:\n\tprint(di[i], end=' ')\n", "(n, m) = [int(i) for i in input().split()]\nl = []\na = []\nfor i in range(m):\n\t(g, h) = [str(i) for i in input().split()]\n\tl.append(g)\n\ta.append(h)\ns = str(input())\ns = s.split(' ')\nz = []\nfor i in range(0, len(s)):\n\td = s[i]\n\tif d in l:\n\t\tf = l.index(d)\n\t\tif len(l[f]) > len(a[f]):\n\t\t\tz.append(a[f])\n\t\telif len(l[f]) < len(a[f]):\n\t\t\tz.append(l[f])\n\t\telse:\n\t\t\tz.append(l[f])\n\telif d in a:\n\t\tf = l.index(d)\n\t\tif len(l[f]) > len(a[f]):\n\t\t\tz.append(a[f])\n\t\telif len(l[f]) < len(a[f]):\n\t\t\tz.append(l[f])\n\t\telse:\n\t\t\tz.append(l[f])\nprint(*z)\n", "def main():\n\tlst = {}\n\t(n, m) = list(map(int, input().split()))\n\tfor i in range(m):\n\t\t(a, b) = list(input().split(' '))\n\t\tlst[a] = b\n\tsentence = list(input().split(' '))\n\tfor i in range(n):\n\t\tif sentence[i] in lst:\n\t\t\tif len(sentence[i]) > len(lst[sentence[i]]):\n\t\t\t\tsentence[i] = lst[sentence[i]]\n\tprint(' '.join(map(str, sentence)))\nt = 1\nwhile t != 0:\n\tmain()\n\tt -= 1\n", "(n, m) = [int(x) for x in input().split()]\ndic = {}\nfor i in range(m):\n\t(fir, sec) = input().split()\n\tif len(fir) > len(sec):\n\t\tdic[fir] = sec\nli = input().split()\nfor i in range(len(li)):\n\tif li[i] in dic:\n\t\tli[i] = dic[li[i]]\nprint(' '.join(li))\n", "(n, m) = list(map(int, input().split()))\nd_1 = []\nd_2 = []\nfor i in range(m):\n\t(x, y) = list(map(str, input().split()))\n\td_1.append(x)\n\td_2.append(y)\nl = [str(x) for x in input().split()]\nfor i in range(n):\n\tif len(d_2[d_1.index(l[i])]) < len(l[i]):\n\t\tl[i] = d_2[d_1.index(l[i])]\nprint(''.join([str(l[i]) + ' ' for i in range(n)]))\n", "(n, m) = map(int, input().split())\ndic = {}\nr = ''\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\tdic.update({s1: s2})\ns = input().split()\nfor i in range(len(s)):\n\tif len(s[i]) <= len(dic[s[i]]):\n\t\tr += s[i]\n\telse:\n\t\tr += dic[s[i]]\n\tif i < len(s) - 1:\n\t\tr += ' '\nprint(r)\n", "dict = {}\n(n, m) = [int(i) for i in input().split()]\nfor _ in range(m):\n\ttest = [i for i in input().split()]\n\tif len(test[0]) <= len(test[1]):\n\t\tdict[test[1]] = test[0]\n\telse:\n\t\tdict[test[0]] = test[1]\nres = ''\nfor e in input().split():\n\tif e in dict:\n\t\tres += dict[e]\n\telse:\n\t\tres += e\n\tres += ' '\nprint(res)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\tif len(x) < len(y):\n\t\td[x] = [y, 1]\n\t\td[y] = [x, 0]\n\telif len(x) == len(y):\n\t\td[x] = [y, 2]\n\t\td[y] = [x, 2]\n\telse:\n\t\td[x] = [y, 0]\n\t\td[y] = [x, 1]\ns = input().split()\nfor i in s:\n\tx = d[i]\n\tif x[1] == 1 or x[1] == 2:\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(x[0], end=' ')\n", "(n, m) = map(int, input().split())\nl = []\na = []\no = ''\nfor _ in range(m):\n\t(l1, l2) = input().split()\n\tif len(l1) <= len(l2):\n\t\tp = l1\n\telse:\n\t\tp = l2\n\tl.append(l1)\n\ta.append(p)\nme = list(input().split())\nfor i in me:\n\tq = l.index(i)\n\to += a[q] + ' '\nprint(o)\n", "import sys\nimport math\nimport bisect\nimport itertools\nimport random\nimport re\n\ndef main():\n\t(n, m) = map(int, input().split())\n\td = dict()\n\tfor i in range(m):\n\t\t(s, t) = input().split()\n\t\td[s] = t\n\tB = []\n\tfor s in input().split():\n\t\tt = d[s]\n\t\tif len(s) <= len(t):\n\t\t\tB.append(s)\n\t\telse:\n\t\t\tB.append(t)\n\tprint(' '.join(B))\nmain()\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tif len(s1) <= len(s2):\n\t\td[s2] = s1\n\t\td[s1] = s1\n\telse:\n\t\td[s1] = s2\n\t\td[s2] = s2\ns = input().split()\nfor i in range(n):\n\ttemp = d[s[i]]\n\ts[i] = temp\nprint(' '.join(s))\n", "(n, m) = map(int, input().split())\nl1 = []\nl2 = []\nfor _ in range(m):\n\t(a, b) = input().split()\n\tl1.append(a)\n\tl2.append(b)\nnotes = list(map(str, input().split()))\nans = []\nfor w in notes:\n\tif w in l1:\n\t\tid = l1.index(w)\n\t\tif len(l1[id]) == len(l2[id]):\n\t\t\tans.append(l1[id])\n\t\telif len(l1[id]) < len(l2[id]):\n\t\t\tans.append(l1[id])\n\t\telse:\n\t\t\tans.append(l2[id])\n\telif w in l2:\n\t\tid = l2.index(w)\n\t\tif len(l1[id]) == len(l2[id]):\n\t\t\tans.append(l1[id])\n\t\telif len(l1[id]) < len(l2[id]):\n\t\t\tans.append(l1[id])\n\t\telse:\n\t\t\tans.append(l2[id])\nprint(*ans)\n", "(n, m) = map(int, input().split())\na = {}\nfor i in range(m):\n\t(p, o) = map(str, input().split())\n\tif len(p) > len(o):\n\t\ta[p] = o\n\telse:\n\t\ta[p] = p\n(s, r) = (input().split(' '), '')\nfor i in s:\n\tr += a[i] + ' '\nprint(r)\n", "dict = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(x, y) = input().split()\n\tdict[x] = y\nprint(*[dict[i] if len(i) > len(dict[i]) else i for i in input().split()])\n", "nm = input().split()\nn = int(nm[0])\nm = int(nm[1])\nl1 = []\nl2 = []\nfor i in range(m):\n\tll = input().split()\n\tl1.append(ll[0])\n\tl2.append(ll[1])\nlec = input().split()\nnote = ''\nfor i in range(n):\n\tif len(l1[l1.index(lec[i])]) > len(l2[l1.index(lec[i])]):\n\t\tnote += l2[l1.index(lec[i])] + ' '\n\telse:\n\t\tnote += l1[l1.index(lec[i])] + ' '\nprint(note)\n", "(n, m) = map(int, input().split())\nwords = []\nfor i in range(m):\n\twords.append(list(input().split()))\ns = list(input().split())\nfor i in s:\n\tfor j in range(m):\n\t\tif i in words[j]:\n\t\t\tif len(words[j][0]) > len(words[j][1]):\n\t\t\t\tprint(words[j][1], end=' ')\n\t\t\telse:\n\t\t\t\tprint(words[j][0], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\tl = list(map(str, input().split()))\n\td[l[0]] = l[1]\nli = list(map(str, input().split()))\nfor i in range(n):\n\tif len(li[i]) <= len(d[li[i]]):\n\t\tprint(li[i], end=' ')\n\telse:\n\t\tprint(d[li[i]], end=' ')\n", "import itertools as ittls\nfrom collections import Counter\nimport string\n\ndef sqr(x):\n\treturn x * x\n\ndef inputarray(func=int):\n\treturn map(func, input().split())\n(N, M) = inputarray()\nA2B = {}\nfor i in range(M):\n\t(s, v) = input().split()\n\tA2B[s] = v\nprint(' '.join(map(lambda x: x if len(x) <= len(A2B[x]) else A2B[x], input().split())))\n", "(n, m) = map(int, input().split())\na = {}\nfor i in range(m):\n\t(p, q) = input().split()\n\ta[p] = q\ns = list(input().split())\nfor i in range(n):\n\tif len(s[i]) > len(a[s[i]]):\n\t\ts[i] = a[s[i]]\nprint(' '.join(s))\n", "(n, m) = (int(x) for x in input().split())\nd = {}\nfor _ in range(m):\n\t(s1, s2) = (s for s in input().split())\n\td[s1] = s2\nans = ''\nfor s in input().split():\n\tif len(s) <= len(d[s]):\n\t\tans += s\n\telse:\n\t\tans += d[s]\n\tans += ' '\nprint(ans)\n", "(n, m) = [int(x) for x in input().split()]\nmap1 = {}\nmap2 = {}\nfor i in range(m):\n\t(s1, s2) = [x for x in input().split()]\n\tmap1[s1] = s2\n\tmap1[s2] = ''\n\tmap2[s2] = s1\n\tmap2[s1] = ''\nl = [x for x in input().split()]\nans = []\nfor i in l:\n\ts1 = map1[i]\n\ts2 = map2[i]\n\tif s1 == '':\n\t\ta = len(s2)\n\t\tb = len(i)\n\t\tif a <= b:\n\t\t\tans.append(s2)\n\t\telse:\n\t\t\tans.append(i)\n\telif s2 == '':\n\t\ta = len(i)\n\t\tb = len(s1)\n\t\tif a <= b:\n\t\t\tans.append(i)\n\t\telse:\n\t\t\tans.append(s1)\nfor i in ans:\n\tprint(i, end=' ')\n", "from math import ceil, sqrt, floor\nimport sys\n(n, m) = map(int, input().split())\nmots = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tmots[a] = a\n\telse:\n\t\tmots[a] = b\nfor mot in input().split():\n\tprint(mots[mot], end=' ')\n", "(n, m) = map(int, input().split())\na = list()\nb = list()\nans = list()\nfor i in range(m):\n\t(t1, t2) = input().split()\n\ta.append(t1)\n\tb.append(t2)\nfor word in input().split():\n\tindex = [i for (i, string) in enumerate(a) if string == word]\n\tans.append(a[index[-1]] if len(a[index[-1]]) <= len(b[index[-1]]) else b[index[-1]])\nprint(*ans)\n", "(x, y) = map(int, input().split())\nd = dict()\nfor __ in range(y):\n\t(a, b) = input().split()\n\td[a] = b\na = list(input().split())\nfor i in a:\n\tif len(i) > len(d[i]):\n\t\tprint(d[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "l1 = {}\nl2 = {}\n(n, m) = [int(x) for x in input().split()]\nfor _ in range(m):\n\t(w1, w2) = input().split()\n\tl1[w1] = w2\n\tl2[w2] = w1\nmsg = input().split()\nfor i in range(len(msg)):\n\tlan1 = ''\n\tlan2 = ''\n\tif msg[i] in l1:\n\t\tlan1 = msg[i]\n\t\tlan2 = l1[lan1]\n\telse:\n\t\tlan2 = msg[i]\n\t\tlan1 = l2[lan2]\n\tif len(lan1) <= len(lan2):\n\t\tprint(lan1, end='')\n\telse:\n\t\tprint(lan2, end='')\n\tif i < len(msg) - 1:\n\t\tprint(' ', end='')\n", "(n, m) = [int(n1) for n1 in input().split()]\na = []\nb = []\nsolu = []\nfor i in range(m):\n\t(a1, b1) = [str(n1) for n1 in input().split()]\n\ta.append(a1)\n\tb.append(b1)\n\tif len(a1) > len(b1):\n\t\tsolu.append(b1)\n\telse:\n\t\tsolu.append(a1)\nc1 = [str(n1) for n1 in input().split()]\nfor i in range(n):\n\tif i != n - 1:\n\t\tprint(solu[a.index(c1[i])], end=' ')\n\telse:\n\t\tprint(solu[a.index(c1[i])])\n", "(n, m) = map(int, input().split())\nx = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif min(len(a), len(b)) == len(a):\n\t\tx.update({b: a})\n\telif len(a) == len(b):\n\t\tx.update({b: a})\n\telse:\n\t\tx.update({a: b})\ng = input().split()\nfor i in range(len(g)):\n\tif g[i] not in x.values():\n\t\tg[i] = x[g[i]]\nprint(' '.join(g))\n", "(n, m) = map(int, input().split())\nval = {}\nfor i in range(m):\n\ttmp = list(input().split())\n\ta = tmp[0]\n\tb = tmp[1]\n\tif len(a) <= len(b):\n\t\tval[a] = a\n\telse:\n\t\tval[a] = b\nlecture = list(input().split())\nans = ''\nfor x in lecture:\n\tans += val[x] + ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\n(a, b) = ([], [])\nfor _ in range(m):\n\ttmp = input().split()\n\ta.append(tmp[0])\n\tb.append(tmp[1])\nlecture = list(input().split())\nfor word in lecture:\n\tif word in a:\n\t\ttmp = a.index(word)\n\telse:\n\t\ttmp = b.index(word)\n\tif len(a[tmp]) > len(b[tmp]):\n\t\tprint(b[tmp], end=' ')\n\telse:\n\t\tprint(a[tmp], end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = {}\nfor i in range(m):\n\tf = input().split()\n\ta.append(f)\n\tb[f[0]] = f[1]\ns = input().split()\nfor i in s:\n\tif len(i) > len(b[i]):\n\t\tprint(b[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(N, M) = map(int, input().split())\nma = {}\nfor i in range(M):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tma[a] = a\n\telse:\n\t\tma[a] = b\nans = [ma[x] for x in input().split()]\nprint(' '.join(ans))\n", "(n, m) = [int(i) for i in input().split()]\na = []\nb = []\nr = []\nfor i in range(m):\n\t(x, y) = [j for j in input().split()]\n\ta.append(x)\n\tb.append(y)\np = [i for i in input().split()]\nfor j in range(n):\n\tif p[j] in a:\n\t\tc = a.index(p[j])\n\telse:\n\t\tc = b.index(p[j])\n\tif len(b[c]) < len(a[c]):\n\t\tr.append(b[c])\n\telse:\n\t\tr.append(a[c])\nfor k in range(len(r)):\n\tprint(r[k], end=' ')\n", "(n, m) = list(map(int, input().split(' ')))\na = dict()\nb = dict()\nfor i in range(m):\n\ttmp_words = input()\n\t(tmp_a, tmp_b) = tmp_words.split(' ')\n\ta[tmp_a] = tmp_b\n\tb[tmp_b] = tmp_a\nresult = ''\nfor word in input().split(' '):\n\tif word in a:\n\t\tresult += len(word) <= len(a[word]) and word or a[word]\n\telse:\n\t\tresult += len(word) < len(b[word]) and word or b[word]\n\tresult += ' '\nprint(result)\n", "dict = {}\n(x, y) = [int(a) for a in input().split()]\nfor i in range(0, y):\n\t(n, m) = input().split()\n\tdict[n] = m\ns = input().split()\nar = []\ng = ''\nfor j in s:\n\tif len(j) > len(dict[j]):\n\t\tar.append(dict[j])\n\telse:\n\t\tar.append(j)\nprint(*ar)\n", "(n, m) = [int(x) for x in input().split()]\nk = {}\nfor i in range(m):\n\t(s1, s2) = input().split(' ')\n\tk.update({s1: s2})\ns = input().split()\nans = ''\nfor wrd in s:\n\tif len(wrd) <= len(k[wrd]):\n\t\tans = ans + wrd + ' '\n\telse:\n\t\tans = ans + k[wrd] + ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\nmapping = dict()\nfor x in range(m):\n\t(a, b) = input().split()\n\tmapping[a] = b\nword = list(input().split())\nfor x in word:\n\tif len(x) <= len(mapping[x]):\n\t\tprint(x, end=' ')\n\telse:\n\t\tprint(mapping[x], end=' ')\n", "(n, m) = list(map(int, input().split()))\nword = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tword[a] = a\n\telse:\n\t\tword[a] = b\nres = ''\nlecture = input().split()\nfor i in lecture:\n\tres += word[i] + ' '\nprint(res)\n", "def findString(word):\n\tfor i in range(m):\n\t\tif word == a[i]:\n\t\t\tif len(a[i]) <= len(b[i]):\n\t\t\t\treturn a[i]\n\t\t\telse:\n\t\t\t\treturn b[i]\n(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(s1, s2) = input().split()\n\ta.append(s1)\n\tb.append(s2)\ns = list(input().split())\nfor i in range(n):\n\ts[i] = findString(s[i])\nprint(*s)\n", "dic = {}\n(n, m) = [int(x) for x in input().split()]\nfor i in range(0, m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tdic[a] = b\n\telse:\n\t\tdic[a] = a\nlecture = input().split()\nfor word in lecture:\n\tprint(dic[word], end=' ')\n", "(n, m) = map(int, input().split())\ndic = dict([])\nfor i in range(m):\n\ta = input().split()\n\t(x, y) = (a[0], a[1])\n\tif len(y) < len(x):\n\t\tdic[x] = y\n\telse:\n\t\tdic[y] = x\nt = input().split()\nfor i in t:\n\tif i in dic.keys():\n\t\tprint(dic[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = list(map(int, input().split()))\na = {}\nfor i in range(m):\n\t(b, c) = list(input().split())\n\ta[b] = c\nd = input()\nd = d.split()\nfor i in d:\n\t(e, f) = (len(i), len(a[i]))\n\tif e < f:\n\t\tprint(i, end=' ')\n\tif e > f:\n\t\tprint(a[i], end=' ')\n\tif e == f:\n\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nmy_dict = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tmy_dict[a] = b\ninp = input().split()\nfor i in range(n):\n\tif len(inp[i]) <= len(my_dict[inp[i]]):\n\t\tprint(inp[i], end=' ')\n\telse:\n\t\tprint(my_dict[inp[i]], end=' ')\n", "(n, m) = map(int, input().split())\nl = []\nk = []\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(b) < len(a):\n\t\tl.append(b)\n\t\tk.append(a)\n\telse:\n\t\tl.append(a)\n\t\tk.append(b)\ns = list(map(str, input().split()))\nfor i in s:\n\tif i in l:\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(l[k.index(i)], end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\tb.append(y)\nl = list(input().split())\nl1 = []\nfor i in l:\n\tif i in a:\n\t\ttemp = a.index(i)\n\t\tif len(b[temp]) < len(i):\n\t\t\tl1.append(b[temp])\n\t\telse:\n\t\t\tl1.append(i)\n\telif i in b:\n\t\ttemp = b.index(i)\n\t\tif len(a[temp]) < len(i):\n\t\t\tl1.append(a[temp])\n\t\telse:\n\t\t\tl1.append(i)\nfor i in l1:\n\tprint(i, end=' ')\n", "(n, m) = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n\t(k, v) = list(input().split())\n\td[k] = v\nfor i in input().split():\n\tif len(i) == len(d[i]):\n\t\tprint(i, end=' ')\n\telif len(i) < len(d[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(d[i], end=' ')\n", "D = {}\nlt = list(input().split())\n(n, m) = (int(lt[0]), int(lt[1]))\nwhile m != 0:\n\tm -= 1\n\tlt = list(input().split())\n\tif len(lt[1]) < len(lt[0]):\n\t\tD[lt[0]] = lt[1]\n\telse:\n\t\tD[lt[0]] = lt[0]\ns = list(input().split())\nfor i in s:\n\tprint(D[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(k, v) = input().split()\n\td[k] = v\n\ndef translate(w):\n\tw2 = d[w]\n\tif len(w2) < len(w):\n\t\treturn w2\n\telse:\n\t\treturn w\nprint(' '.join(map(translate, input().split())))\n", "dictx = {}\n(a, b) = map(int, input().split(' '))\nfor i in range(b):\n\t(x, y) = map(str, input().split(' '))\n\tif len(y) < len(x):\n\t\tdictx[x] = y\n\t\tdictx[y] = y\n\telse:\n\t\tdictx[y] = x\n\t\tdictx[x] = x\ngod = list(map(str, input().split(' ')))\nstrx = [dictx[i] for i in god]\nprint(' '.join(strx))\n", "string = input()\nnumbers = string.split(' ')\nn = int(numbers[1])\ndictionary = {}\nfor x in range(n):\n\tstring = input()\n\twords = string.split(' ')\n\tdictionary[words[0]] = words[1]\nstring = input()\nwords = string.split(' ')\nnewwords = []\nfor x in words:\n\ta = x\n\tb = dictionary[x]\n\tif len(b) < len(a):\n\t\tnewwords.append(b)\n\telse:\n\t\tnewwords.append(a)\nprint(' '.join(newwords))\n", "(n, m) = [int(x) for x in input().split()]\nd = dict()\nfor i in range(0, m):\n\t(str1, str2) = input().split()\n\td[str1] = str2\nlecture = input().split()\nfor word in lecture:\n\tword2 = d[word]\n\tif len(word2) < len(word):\n\t\tprint(word2, end=' ')\n\telse:\n\t\tprint(word, end=' ')\n", "(a, b) = map(int, input().split())\nwordDict = {}\nfor i in range(b):\n\t(x, y) = input().split()\n\twordDict[x] = y\n\twordDict[y] = x\nwords = input().split()\nfor word in words:\n\tif len(wordDict[word]) < len(word):\n\t\tprint(wordDict[word], end=' ')\n\telse:\n\t\tprint(word, end=' ')\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ndict = {}\nl = []\nans = [0] * 3001\nfor i in range(m):\n\tl.append([0] * 2)\ny = 0\nfor i in range(m):\n\t(k, p) = input().split()\n\tl[i][0] = k\n\tl[i][1] = p\n\tif len(k) > len(p):\n\t\tdict[l[i][0]] = y\n\t\tans[y] = l[i][1]\n\telse:\n\t\tdict[l[i][0]] = y\n\t\tans[y] = l[i][0]\n\ty += 1\na = input().split()\nfor i in a:\n\tind = dict.get(i)\n\tprint(ans[ind], end=' ')\n", "(n, m) = map(int, input().split(' '))\ndi = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split(' '))\n\tdi[a] = b\nli = list(map(str, input().split(' ', n)[:n]))\nst = ''\nfor i in range(len(li)):\n\tif len(li[i]) <= len(di[li[i]]):\n\t\tst += li[i]\n\telse:\n\t\tst += di[li[i]]\n\tst += ' '\nprint(st)\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nd = {}\nc = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tc.append(a)\n\td[a] = b\ns = list(map(str, input().rstrip().split()))\nfor x in s:\n\tif len(x) <= len(d[x]):\n\t\tprint(x, end=' ')\n\telse:\n\t\tprint(d[x], end=' ')\n", "class languagedic(dict):\n\n\tdef __missing__(self, key):\n\t\treturn key\n(m, n) = map(int, input().split())\ndic = languagedic()\nfor i in range(n):\n\t(fir, sec) = input().split()\n\tif len(fir) <= len(sec):\n\t\tdic[sec] = fir\n\telse:\n\t\tdic[fir] = sec\nlectures = list(input().split())\nfor i in lectures:\n\tprint(dic[i], end=' ')\n", "(n, m) = list(map(int, input().split(' ')))\na_b = {}\nfor i in range(m):\n\t(a, b) = input().split(' ')\n\ta_b[a] = b\nlecture = input().split(' ')\noutput = ''\nfor word in lecture:\n\tif len(word) > len(a_b[word]):\n\t\toutput += a_b[word] + ' '\n\telse:\n\t\toutput += word + ' '\nprint(output.rstrip())\n", "inp = list(map(int, input().split()))\n(n, m) = (inp[0], inp[1])\nd = {}\nword = []\nfor i in range(m):\n\tstr = list(input().split())\n\td[str[0]] = str[1]\nword = list(input().split())\nfor i in word:\n\tif i in d:\n\t\tif len(i) > len(d[i]):\n\t\t\tprint(d[i], end=' ')\n\t\telse:\n\t\t\tprint(i, end=' ')\n", "def get_notes(dict, lecture):\n\tresult = list()\n\tfor s in lecture:\n\t\tif len(dict[s]) >= len(s):\n\t\t\tresult.append(s)\n\t\telse:\n\t\t\tresult.append(dict[s])\n\treturn ' '.join(result)\nn_m = [int(i) for i in input().split()]\ndict = dict()\nfor i in range(n_m[1]):\n\tws = [i for i in input().split()]\n\tdict[ws[0]] = ws[1]\nlecture = [i for i in input().split()]\nprint(get_notes(dict, lecture))\n", "(n, m) = [int(x) for x in input().split()]\nl1 = {}\nl2 = {}\ndi = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tl1[a] = len(a)\n\tl2[b] = len(b)\n\tdi[a] = b\nlst = input().split()\nls = []\nfor i in range(len(lst)):\n\tnum1 = l1[lst[i]]\n\tnum2 = l2[di[lst[i]]]\n\tif num1 > num2:\n\t\tls.append(di[lst[i]])\n\telse:\n\t\tls.append(lst[i])\nprint(' '.join(ls))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\td[a] = b\n\telif len(b) > len(a):\n\t\td[b] = a\n\telse:\n\t\td[a] = a\ns = input().split()\nfor i in s:\n\tif i in d.keys():\n\t\tprint(d[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "def lecture(lang, sentence, n, m):\n\toutput = []\n\tword_to_dict = {}\n\tfor word in sentence:\n\t\tif word in word_to_dict.keys():\n\t\t\trow = word_to_dict[word]\n\t\telse:\n\t\t\tr = 0\n\t\t\twhile r < m:\n\t\t\t\tif lang[r][0] == word:\n\t\t\t\t\trow = r\n\t\t\t\t\tword_to_dict[word] = r\n\t\t\t\tr += 1\n\t\tword1 = lang[row][0]\n\t\tword2 = lang[row][1]\n\t\tif len(word1) > len(word2):\n\t\t\toutput.append(word2)\n\t\telse:\n\t\t\toutput.append(word1)\n\tprint(' '.join(output))\n(n, m) = list(map(int, input().strip().split(' ')))\nlang = [[None for y in range(2)] for x in range(m)]\nfor row in range(m):\n\tlang[row] = input().strip().split(' ')\nsentence = input().strip().split(' ')\nlecture(lang, sentence, n, m)\n", "lang1 = []\nlang2 = []\n(n, m) = map(int, input().split())\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tlang1.append(a)\n\tlang2.append(b)\nans = []\ninp = [x for x in input().split()]\nfor i in inp:\n\tif len(i) <= len(lang2[lang1.index(i)]):\n\t\tans.append(i)\n\telse:\n\t\tans.append(lang2[lang1.index(i)])\nprint(*ans)\n", "(n, m) = tuple(map(int, input().split()))\nd = {}\nfor _ in range(m):\n\t(s1, s2) = tuple(input().split())\n\td[s1] = s2\nmessage = list(input().split())\nanswer = []\nfor word in message:\n\tif len(d[word]) < len(word):\n\t\tanswer.append(d[word])\n\telse:\n\t\tanswer.append(word)\nprint(' '.join(answer))\n", "(n, m) = map(int, input().split())\na = {}\nb = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\ta[x] = y\n\tb[y] = x\nS = input().split()\nan = []\nfor s in S:\n\tif s in a and len(s) <= len(a[s]) or (s in b and len(s) < len(b[s])):\n\t\tan += [s]\n\telif s in a:\n\t\tan += [a[s]]\n\telse:\n\t\tan += [b[s]]\nprint(' '.join(an))\n", "(n, m) = input().split()\nm = int(m)\nlang = dict()\nfor i in range(m):\n\t(l1, l2) = input().split()\n\tlang[l1] = l1 if len(l1) <= len(l2) else l2\nlecture = input().split()\nnotes = ''\nfor word in lecture:\n\tnotes += lang[word]\n\tnotes += ' '\nprint(notes)\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = [i for i in input().split()]\n\td[a] = [a, b]\nfor w in input().split():\n\ttmp = d[w]\n\tif len(tmp[0]) <= len(tmp[1]):\n\t\tprint(tmp[0], end=' ')\n\telse:\n\t\tprint(tmp[1], end=' ')\n", "(n, m) = map(int, input().strip().split())\nl = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tif len(s2) < len(s1):\n\t\tl[s1] = s2\n\t\tl[s2] = s2\n\telse:\n\t\tl[s1] = s1\n\t\tl[s2] = s1\nfor s in input().split():\n\tprint(l[s], ' ', sep='', end='')\nprint()\n", "(m, n) = map(int, str.split(input()))\nkword = {}\nfor k in range(n):\n\t(i1, i2) = str.split(input())\n\tif len(i1) == len(i2):\n\t\tkword[i1] = i1\n\telif len(i1) < len(i2):\n\t\tkword[i1] = i1\n\telse:\n\t\tkword[i1] = i2\nlst = str.split(input())\nfor x in lst:\n\tprint(kword[x], end=' ')\n", "(n, m) = map(int, input().split())\nls = {}\nwhile m:\n\t(a, b) = input().split()\n\tls[a] = b if len(a) > len(b) else a\n\tm -= 1\nc = list(input().split())\nfor word in c:\n\tprint(ls[word], end=' ')\n", "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data():\n\treturn sys.stdin.readline().strip()\n\ndef out(*var, end='\\n'):\n\tsys.stdout.write(' '.join(map(str, var)) + end)\n\ndef L():\n\treturn list(sp())\n\ndef sl():\n\treturn list(ssp())\n\ndef sp():\n\treturn map(int, data().split())\n\ndef ssp():\n\treturn map(str, data().split())\n\ndef l1d(n, val=0):\n\treturn [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n\treturn [l1d(n, val) for j in range(m)]\ntry:\n\tsys.stdin = open('input.txt', 'r')\nexcept:\n\tpass\n(n, m) = L()\nA = [input().split() for i in range(m)]\nd = {}\nfor i in range(m):\n\td[A[i][0]] = [A[i][1], 1]\n\td[A[i][1]] = [A[i][0], 2]\nans = []\ns = input().split()\nfor i in range(n):\n\tx = d[s[i]][0]\n\tif len(x) < len(s[i]):\n\t\tans.append(x)\n\telif len(s[i]) < len(x):\n\t\tans.append(s[i])\n\telif d[s[i]][1] == 1:\n\t\tans.append(s[i])\n\telse:\n\t\tans.append(x)\nprint(' '.join(ans))\nendtime = time.time()\n", "(N, M) = map(int, input().split())\nhashTable = {}\nfor _ in range(M):\n\t(string1, string2) = map(str, input().split())\n\tif len(string1) > len(string2):\n\t\thashTable[string1] = string2\n\telse:\n\t\thashTable[string1] = string1\nlecture = list(map(str, input().split()))\nres = ''\nfor i in range(N):\n\tres += hashTable[lecture[i]] + ' '\nprint(res)\n", "(n, m) = [int(x) for x in input().split()]\nzidian = {}\nfor i in range(m):\n\t(yi, er) = [x for x in input().split()]\n\tif len(yi) > len(er):\n\t\tzidian[yi] = er\n\telse:\n\t\tzidian[yi] = yi\ns = ''\nfor x in input().split():\n\ts += zidian[x] + ' '\nprint(s)\n", "(n, m) = input().split()\nd = {}\nfor i in range(int(m)):\n\t(r, k) = input().split()\n\tv = min((r, k), key=len)\n\td[r] = v\nprint(*[d[l] for l in input().split()])\n", "(n, k) = map(int, input().split())\nd = {}\nfor i in range(k):\n\tlis = list(input().split())\n\td.update({lis[0]: lis[1]})\nlis = list(input().split())\nlis2 = []\nfor i in range(n):\n\tif len(lis[i]) <= len(d[lis[i]]):\n\t\tlis2.append(lis[i])\n\telse:\n\t\tlis2.append(d[lis[i]])\nres = ' '.join(lis2)\nprint(res)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tla = len(a)\n\tlb = len(b)\n\tif la <= lb:\n\t\td.update({a: a})\n\telse:\n\t\td.update({a: b})\ns = input()\nls = s.split()\nna = []\nfor i in ls:\n\tprint(d[i], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\tL = input().split()\n\td[L[0]] = L[1]\ns = input().split()\nfor i in range(n):\n\tif len(s[i]) > len(d[s[i]]):\n\t\ts[i] = d[s[i]]\nprint(*s, sep=' ')\n", "(wordcount, linecount) = input().split()\nwords = {}\nwordCnt = int(wordcount)\nlineCnt = int(linecount)\nfor i in range(0, lineCnt):\n\t(word1, word2) = input().split()\n\twords[word1] = word2\nlecture = input().split()\nresult = ''\nfor word in lecture:\n\tif len(words[word]) < len(word):\n\t\tresult += words[word] + ' '\n\telse:\n\t\tresult += word + ' '\nprint(result)\n", "(n, k) = input().split(' ')\nd = {}\nfor i in range(int(k)):\n\t(l1, l2) = input().split(' ')\n\td[l1] = l2\nlect = input().split()\nfor c in lect:\n\tcur_res = c\n\tif len(c) > len(d[c]):\n\t\tcur_res = d[c]\n\tprint(cur_res, end=' ')\n", "(n, m) = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n\ta = input().split()\n\tif len(a[0]) > len(a[1]):\n\t\td[a[0]] = a[1]\n\telse:\n\t\td[a[0]] = a[0]\nn1 = input().split()\nfor i in n1:\n\tprint(d[i], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nvocab = dict()\nmask = dict()\nfor _ in range(m):\n\t(l1, l2) = input().split()\n\tvocab[l1] = l2\n\tif len(l1) > len(l2):\n\t\tmask[l1] = 0\n\telse:\n\t\tmask[l1] = 1\nlecture = list(input().split())\nout = ''\nfor v in lecture:\n\tif mask[v] == 0:\n\t\tout += vocab[v]\n\telse:\n\t\tout += v\n\tout += ' '\nprint(out)\n", "(a, b) = map(int, input().split())\nl = []\n[l.append(input().split()) for j in range(b)]\nfor i in l:\n\tif len(i[0]) > len(i[1]):\n\t\t(i[0], i[1]) = (i[1], i[0])\nfor i in input().split():\n\t[print(j[0], end=' ') for j in l if i in j]\n", "l = [int(x) for x in input().split()]\nn = l[0]\nm = l[1]\ndic = {}\nfor i in range(0, m):\n\tlis = [x for x in input().split()]\n\tif len(lis[1]) < len(lis[0]):\n\t\tdic[lis[0]] = lis[1]\n\t\tdic[lis[1]] = lis[1]\n\telse:\n\t\tdic[lis[0]] = lis[0]\n\t\tdic[lis[1]] = lis[0]\nlis1 = [x for x in input().split()]\nfor i in lis1:\n\tprint(dic[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\t(a1, b1) = (len(a), len(b))\n\tif a1 <= b1:\n\t\td[a] = a\n\telse:\n\t\td[a] = b\nl = list(map(str, input().split(' ')))\nfor i in l:\n\tprint(d[i], end=' ')\n", "words = dict()\n(n, m) = [int(x) for x in input().split()]\nfor i in range(0, m):\n\t(s, s1) = input().split()\n\twords[s] = s1\ns = input().split()\ns1 = ''\nfor x in s:\n\tif len(words[x]) < len(x):\n\t\ts1 += words[x] + ' '\n\telse:\n\t\ts1 += x + ' '\nprint(s1[:len(s1) - 1])\n", "def main():\n\t(n, m) = map(int, input().split())\n\td = {}\n\tfor _ in range(m):\n\t\t(a, b) = input().split()\n\t\td[a] = d[b] = b if len(a) > len(b) else a\n\tprint(' '.join([d[_] for _ in input().split()]))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "(n, k) = map(int, input().split())\ns = {}\nfor i in range(k):\n\tz = list(input().split())\n\ts.setdefault(z[0], z[1])\nlec = list(input().split())\nfor i in lec:\n\tk = s.get(i)\n\tif len(i) <= len(k):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(k, end=' ')\n", "(n, k) = [int(x) for x in input().split()]\nd = {}\nfor i in range(k):\n\t(first, second) = input().split()\n\td[first] = first if len(first) <= len(second) else second\nfirst = True\nfor word in input().split():\n\tif not first:\n\t\tprint(' ', end='')\n\tprint(d[word], end='')\n\tfirst = False\n", "(n, m) = map(int, input().split())\nd = {}\nans = ''\nfor i in range(0, m):\n\t(s1, s2) = input().split()\n\td[s1] = s2\ns = input().split()\nfor k in s:\n\tif len(k) <= len(d[k]):\n\t\tans = ans + k + ' '\n\telse:\n\t\tans = ans + d[k] + ' '\nprint(ans)\n", "(a, b) = map(int, input().split())\n(v, c, z) = ([], [], [])\nfor i in range(b):\n\t(n, m) = input().split()\n\tv.append(n)\n\tc.append(m)\nn = list(input().split())\nfor i in n:\n\tw = v.index(i)\n\tif len(v[w]) <= len(c[w]):\n\t\tz.append(v[w])\n\telse:\n\t\tz.append(c[w])\nprint(' '.join(z))\n", "(n, m) = list(map(int, input().split()))\ndict = {}\nfor i in range(m):\n\t(w1, w2) = list(input().split())\n\tdict[w1] = [w2, len(w1), len(w2)]\nsen = list(input().split())\nfor i in sen:\n\ttemp = dict[i]\n\tif temp[1] <= temp[2]:\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(temp[0], end=' ')\n", "(a, b) = map(int, input().split())\nd = {}\nfor _ in range(b):\n\t(w1, w2) = [x for x in input().split()]\n\td[w1] = w2\nl = [x for x in input().split()]\nfor i in l:\n\tif len(i) <= len(d[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(d[i], end=' ')\n", "m: int = int(input().split()[1])\nd: str = dict([])\nfor _ in range(m):\n\ts = input()\n\tw = s.split()\n\tif len(w[0]) <= len(w[1]):\n\t\td[w[0]] = w[0]\n\t\td[w[1]] = w[0]\n\telse:\n\t\td[w[0]] = w[1]\n\t\td[w[1]] = w[1]\ns = input().split()\nprint(' '.join([d[w] for w in s]))\n", "(n, m) = map(int, input().split())\nmydict = {}\nfor i in range(0, m):\n\t(a, b) = input().split()\n\tmydict[a] = [b, len(a), len(b)]\narr = list(input().split())\nans = []\nfor i in arr:\n\tif mydict[i][1] <= mydict[i][2]:\n\t\tans.append(i)\n\telse:\n\t\tans.append(mydict[i][0])\nfor i in ans:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nt = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tt[a] = b\np = input().split()\nfor (i, a) in enumerate(p):\n\tif a in t:\n\t\tp[i] = t[a]\nprint(' '.join(p))\n", "def inlt():\n\treturn list(map(str, input().split()))\n\ndef invr():\n\treturn list(map(int, input().split()))\nnm = invr()\nn = nm[0]\nm = nm[1]\na = []\nb = []\nfor i in range(m):\n\tpair = inlt()\n\ta.append(pair[0])\n\tb.append(pair[1])\nlect = inlt()\ni = 0\nwhile i < len(lect):\n\tw = lect[i]\n\tif w in a:\n\t\tind = a.index(w)\n\t\tib = b[ind]\n\t\tlect[i] = ib if len(ib) < len(w) else w\n\ti += 1\nprint(' '.join(lect))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nt = input().split()\na = []\nfor i in t:\n\t(lk, lv) = (0, 0)\n\tlk = len(i)\n\tlv = len(d[i])\n\tif lk < lv or lk == lv:\n\t\ta.append(i)\n\telse:\n\t\ta.append(d[i])\nfor x in a:\n\tprint(x, end=' ')\nprint()\n", "import sys\n\ndef main():\n\t(n, m) = tuple([int(x) for x in input().split()])\n\ttrans = {}\n\tfor i in range(m):\n\t\tline = input().split()\n\t\tif len(line[1]) < len(line[0]):\n\t\t\ttrans[line[0]] = line[1]\n\t\telse:\n\t\t\ttrans[line[0]] = line[0]\n\tlec = input().split()\n\tfor i in range(len(lec)):\n\t\tprint(trans[lec[i]], end='')\n\t\tif i + 1 != len(lec):\n\t\t\tprint('', end=' ')\n\tprint()\nmain()\n", "(n, m) = [int(x) for x in input().split()]\ndict = {}\nfor i in range(m):\n\tarr = [x for x in input().split()]\n\tdict[arr[0]] = arr[1]\ns = list(input().split())\nans = ''\nfor i in range(n):\n\tif len(s[i]) <= len(dict[s[i]]):\n\t\tans += s[i] + ' '\n\telse:\n\t\tans += dict[s[i]] + ' '\nprint(ans)\n", "i = input()\ni = i.split()\ni1 = int(i[1])\nb = list()\np = dict()\nfor j in range(i1):\n\tk = input()\n\ti2 = k.split()\n\tif len(i2[0]) <= len(i2[1]):\n\t\tp[i2[0]] = i2[0]\n\telse:\n\t\tp[i2[0]] = i2[1]\nw = input()\nw = w.split()\nfor l in w:\n\tm1 = p[l]\n\tb.append(m1)\n\tb.append(' ')\nprint(''.join(b).strip())\n", "(n, m) = [int(n) for n in input().split()]\nletter = {}\nfor i in range(m):\n\t(a, b) = [str(a) for a in input().split()]\n\tif len(a) <= len(b):\n\t\tletter[a] = a\n\telse:\n\t\tletter[a] = b\nsentence = [str(sentence) for sentence in input().split()]\nfor i in sentence:\n\tprint(letter[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(w1, w2) = map(str, input().split())\n\td[w1] = w2\nl = list(map(str, input().split()))\nfor i in range(len(l)):\n\tif len(l[i]) > len(d[l[i]]):\n\t\tl[i] = d[l[i]]\nprint(*l)\n", "(n, m) = input().split()\nnotes = []\nwords = list((input().split() for _ in range(int(m))))\nlecture_words = input().split()\nfor i in range(len(lecture_words)):\n\tfor j in range(len(words)):\n\t\tif str(words[j][0]) == str(lecture_words[i]):\n\t\t\tif len(words[j][0]) > len(words[j][1]):\n\t\t\t\tnotes.append(words[j][1])\n\t\t\telse:\n\t\t\t\tnotes.append(words[j][0])\nprint(*notes, sep=' ')\n", "(n, m) = [int(x) for x in input().split()]\nlexicon = {}\nfor i in range(m):\n\t(first, second) = [str(x) for x in input().split()]\n\tif len(first) <= len(second):\n\t\tlexicon[first] = first\n\telse:\n\t\tlexicon[first] = second\nsentence = [lexicon[x] for x in input().split()]\nprint(' '.join(sentence))\n", "(n, m) = map(int, input().split())\nd = dict()\nfinal = []\nfor i in range(m):\n\t(key, value) = input().split()\n\td[key] = value\nprof = input().split()\nfor i in range(n):\n\ts = d[prof[i]]\n\tif len(s) < len(prof[i]):\n\t\tfinal.append(s)\n\telse:\n\t\tfinal.append(prof[i])\nprint(' '.join(final))\n", "from collections import *\nfrom bisect import *\nfrom math import *\nfrom heapq import *\nfrom fractions import *\nimport sys\ninput = sys.stdin.readline\nt = 1\n\ndef r(a):\n\treturn a * (a - 1) // 2\nwhile t:\n\tt -= 1\n\t(n, m) = map(int, input().split())\n\tf = {}\n\tfor i in range(m):\n\t\ta = input().split()\n\t\tif len(a[0]) == len(a[1]):\n\t\t\tcontinue\n\t\tif len(a[0]) > len(a[1]):\n\t\t\tf[a[0]] = a[1]\n\t\telse:\n\t\t\tf[a[1]] = a[0]\n\tb = input().split()\n\tfor i in b:\n\t\tif i not in f:\n\t\t\tprint(i, end=' ')\n\t\telse:\n\t\t\tprint(f[i], end=' ')\n\tprint()\n", "x = list(map(int, input().split()))\nn = x[0]\nm = x[1]\np = []\nq = []\nt = []\nfor i in range(m):\n\tab = list(map(str, input().split()))\n\tp.append(ab[0])\n\tq.append(ab[1])\nc = list(map(str, input().split()))\nfor i in range(len(c)):\n\tr = p.index(c[i])\n\ts = min(p[r], q[r], key=len)\n\tt.append(s)\nprint(' '.join(t))\n", "(n, m) = [int(x) for x in input().split()]\ntr = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(b) < len(a):\n\t\ttr[a] = b\ns = input().split()\nfor i in range(len(s)):\n\tif s[i] in tr:\n\t\ts[i] = tr[s[i]]\nprint(' '.join(s))\n", "(n, m) = map(int, input().split(' '))\n(f, s) = ([], [])\nfor i in range(m):\n\tv = list(input().split(' '))\n\tf.append(v[0])\n\ts.append(v[1])\nlect = list(input().split(' '))\nfor i in lect:\n\tif i in f:\n\t\t(l1, l2) = (len(f[f.index(i)]), len(s[f.index(i)]))\n\t\tif l2 < l1:\n\t\t\tprint(s[f.index(i)], end=' ')\n\t\telse:\n\t\t\tprint(i, end=' ')\n\telse:\n\t\t(l1, l2) = (len(i), len(f[s.index(i)]))\n\t\tif l2 < l1:\n\t\t\tprint(f[s.index(i)], end=' ')\n\t\telse:\n\t\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nlanguage = []\nnote = []\nfor i in range(m):\n\t(temp1, temp2) = map(str, input().split(' '))\n\tlanguage.append(temp1)\n\tif len(temp1) <= len(temp2):\n\t\tnote.append(temp1)\n\telse:\n\t\tnote.append(temp2)\nlecture = input().split(' ')\noutput = []\nfor x in lecture:\n\tpos = language.index(x)\n\toutput.append(note[pos])\nprint(' '.join(output))\n", "(n, m) = map(int, input().split())\narr = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) > len(b):\n\t\tarr[a] = b\nlect = input().split()\nres = []\nfor i in lect:\n\tif i in arr:\n\t\tres.append(arr[i])\n\telse:\n\t\tres.append(i)\nprint(' '.join(res))\n", "nums = input().split()\nn = int(nums[0])\nm = int(nums[1])\nd = {}\nfor i in range(0, m):\n\tstrs = input().split()\n\tif len(strs[0]) <= len(strs[1]):\n\t\td[strs[0]] = strs[0]\n\telse:\n\t\td[strs[0]] = strs[1]\ntext = input().split()\nfor word in text:\n\tprint(d[word], end=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\tdic[x] = y\n\tdic[y] = x\nans = []\nfor i in input().split():\n\tx = i\n\tif len(dic[x]) < len(x):\n\t\tans.append(dic[x])\n\telse:\n\t\tans.append(x)\nprint(*ans)\n", "(n, m) = map(int, input().split())\nD = {}\nE = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\tD[x] = y\n\tE[y] = x\ns = input()\nans = ''\nfor w in s.split():\n\tif w in D:\n\t\tif len(w) <= len(D[w]):\n\t\t\tans += w\n\t\telse:\n\t\t\tans += D[w]\n\tif w in E:\n\t\tif len(w) <= len(E[w]):\n\t\t\tans += w\n\t\telse:\n\t\t\tans += E[w]\n\tans += ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\nL = [str(input()).split(' ') for _ in range(m)]\nM = str(input()).split(' ')\nR = ['' for _ in range(m)]\nB = ['' for _ in range(m)]\nfor i in range(m):\n\ta = len(L[i][0])\n\tb = len(L[i][1])\n\tif a <= b:\n\t\tR[i] = L[i][0]\n\t\tB[i] = L[i][1]\n\telse:\n\t\tR[i] = L[i][1]\n\t\tB[i] = L[i][0]\nR = R + B\nr = ''\nfor i in range(n):\n\te = R.index(M[i])\n\tr += R[e % m] + ' '\nprint(r)\n", "(n, m) = [int(x) for x in input().split()]\nd = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\td[x] = y\nfor string in input().split():\n\tif len(d[string]) < len(string):\n\t\tprint(d[string], end=' ')\n\telse:\n\t\tprint(string, end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nfirst_lang = {}\nsecond_lang = {}\nfor _ in range(m):\n\twords = input().split()\n\tfirst_lang[words[0]] = words[1]\n\tsecond_lang[words[1]] = words[0]\ntext = input().split()\nfor word in text:\n\tsecond = first_lang.get(word)\n\tif second and len(second) < len(word):\n\t\tprint(second, end=' ')\n\t\tcontinue\n\tfirst = second_lang.get(word)\n\tif first and len(first) <= len(word):\n\t\tprint(first, end=' ')\n\t\tcontinue\n\tprint(word, end=' ')\n", "(_, wordCount) = map(int, input().split())\nwords = {}\nfor line in range(wordCount):\n\t(first, second) = input().split()\n\twords[first] = second\nresult = []\nsentence = input()\nfor word in sentence.split():\n\tdifferentLanguage = words[word]\n\tif len(differentLanguage) < len(word):\n\t\tresult.append(differentLanguage)\n\telse:\n\t\tresult.append(word)\nprint(' '.join(result))\n", "(n, m) = map(int, input().split())\na = [0] * m\nb = [0] * m\nc = [0] * m\nfor i in range(m):\n\t(l, r) = input().split()\n\ta[i] = l\n\tb[i] = r\n\tif len(l) <= len(r):\n\t\tc[i] = l\n\telse:\n\t\tc[i] = r\ns = list(input().split())\nanswer = ''\nfor i in range(n):\n\tif s[i] in a:\n\t\tx = a.index(s[i])\n\telse:\n\t\tx = b.index(s[i])\n\tanswer += c[x]\n\tanswer += ' '\ntr = len(answer)\nprint(answer[0:tr - 1])\n", "(n, m) = map(int, input().split())\nx = [None] * m\nfor i in range(m):\n\tx[i] = [x for x in input().split()]\ny = [x for x in input().split()]\nfor i in range(n):\n\tfor j in range(m):\n\t\tif y[i] in x[j]:\n\t\t\tif len(x[j][0]) <= len(x[j][1]):\n\t\t\t\ty[i] = x[j][0]\n\t\t\telse:\n\t\t\t\ty[i] = x[j][1]\nfor i in range(n):\n\tprint(y[i], end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nans = []\nfor i in range(m):\n\t(u, v) = input().split(' ')\n\ta.append(u)\n\tb.append(v)\nc = list(input().split())\nfor i in range(n):\n\tx = c[i]\n\tif x in a:\n\t\tia = a.index(x)\n\t\ty = b[ia]\n\t\txl = len(x)\n\t\tyl = len(y)\n\t\tif xl > yl:\n\t\t\tans.append(y)\n\t\telif xl == yl:\n\t\t\tans.append(x)\n\t\telse:\n\t\t\tans.append(x)\n\telse:\n\t\tib = b.index(x)\n\t\ty = a[ib]\n\t\txl = len(x)\n\t\tyl = len(y)\n\t\tif xl > yl:\n\t\t\tans.append(y)\n\t\telif xl == yl:\n\t\t\tans.append(x)\n\t\telse:\n\t\t\tans.append(x)\nprint(*ans)\n", "(n, m) = map(int, input().split())\nk = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tk[a] = b\nr = input().split()\nl = [r[j] if len(r[j]) <= len(k[r[j]]) else k[r[j]] for j in range(n)]\nprint(' '.join(l))\n", "(n, m) = map(int, input().split())\n(f, s) = ([], [])\nfor i in range(m):\n\ta = input().split()\n\tf.append(a[0])\n\ts.append(a[1])\nQ = input().split()\nans = ''\nfor i in range(n):\n\tInd = -1\n\tfor j in range(m):\n\t\tif f[j] == Q[i]:\n\t\t\tInd = j\n\t\t\tbreak\n\tW = f[Ind]\n\tif len(s[Ind]) < len(W):\n\t\tW = s[Ind]\n\tans += W + ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\nDC = {}\nfor i in range(m):\n\t(s, s1) = map(str, input().split())\n\tDC[s] = s1\n\tDC[s1] = s\nA = list(map(str, input().split(' ')[:n]))\nfor i in A:\n\tif len(i) > len(DC[i]):\n\t\tprint(DC[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nfrom collections import defaultdict\nd = defaultdict(str)\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\td[a] = min(a, b, key=len)\n\td[b] = min(a, b, key=len)\na = list(map(str, input().split()))\nres = str()\nfor i in a:\n\tres += d[i]\n\tres += ' '\nprint(res)\n", "(_, m) = map(int, input().split())\nd = {i[0]: i[1] for i in (input().split() for _ in range(m))}\nc = input().split()\nfor i in range(len(c)):\n\tif len(c[i]) > len(d[c[i]]):\n\t\tc[i] = d[c[i]]\nprint(*c)\n", "(n, m) = map(int, input().split())\nword_dict = dict()\nfor _ in range(m):\n\t(first, second) = input().split()\n\tif len(second) >= len(first):\n\t\tword_dict[first] = first\n\telse:\n\t\tword_dict[first] = second\nlecture = input().split()\nfor word in lecture:\n\tprint(word_dict[word], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nwords = dict()\nfor i in range(m):\n\t(w1, w2) = map(str, input().split())\n\tw = w1\n\tif len(w2) < len(w1):\n\t\tw = w2\n\twords[w1] = w\n\twords[w2] = w\ndata = input().split()\nfor i in range(n):\n\tprint(words[data[i]], end=' ')\n", "(x, y) = input().split()\nx = int(x)\ny = int(y)\nst1 = []\nst2 = []\nfor i in range(y):\n\t(s1, s2) = input().split()\n\tst1.append(s1)\n\tst2.append(s2)\nsr = input()\nwords = [str(w) for w in sr.split()]\nfor word in words:\n\ti = st1.index(word)\n\tif len(st1[i]) <= len(st2[i]):\n\t\tprint(st1[i], end=' ')\n\telse:\n\t\tprint(st2[i], end=' ')\n", "(n, m) = map(int, input().split())\nhash_map = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\thash_map[x] = y\nnotes = list(map(str, input().strip().split()))\nfor i in range(n):\n\tif len(str(notes[i])) <= len(hash_map[notes[i]]):\n\t\tcontinue\n\telse:\n\t\tnotes[i] = hash_map[notes[i]]\nfor i in notes:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\ntranslation = {}\nans = ''\nfor _ in range(m):\n\t(first, second) = input().split()\n\tif len(first) <= len(second):\n\t\ttranslation[first] = first\n\t\ttranslation[second] = first\n\telse:\n\t\ttranslation[second] = second\n\t\ttranslation[first] = second\nlecture = input().split(' ')\nfor j in lecture:\n\tans += translation[j] + ' '\nprint(ans)\n", "l = input().split()\na = int(l[0])\nb = int(l[1])\ndic = {}\nfor i in range(b):\n\tp = input().split()\n\tif len(p[0]) > len(p[1]):\n\t\tdic[p[0]] = p[1]\n\t\tdic[p[1]] = p[1]\n\telif len(p[0]) <= len(p[1]):\n\t\tdic[p[1]] = p[0]\n\t\tdic[p[0]] = p[0]\nr = input().split()\ns = dic[r[0]]\nfor i in range(1, a):\n\ts = s + ' ' + dic[r[i]]\nprint(s)\n", "(n, m) = map(int, input().split())\n(a, b) = ([], [])\nfor i in range(m):\n\t(x, y) = map(str, input().split(' '))\n\ta.append(x)\n\tb.append(y)\nl = list(map(str, input().split(' ')))\nfor i in range(n):\n\tif l[i] in a:\n\t\tind = a.index(l[i])\n\t\tif len(a[ind]) <= len(b[ind]):\n\t\t\tprint(a[ind], end=' ')\n\t\telse:\n\t\t\tprint(b[ind], end=' ')\n\telse:\n\t\tind = b.index(l[i])\n\t\tif len(a[ind]) <= len(b[ind]):\n\t\t\tprint(a[ind], end=' ')\n\t\telse:\n\t\t\tprint(b[ind], end=' ')\n", "class Solution:\n\n\tdef __init__(self):\n\t\t(self.n, self.m) = [int(x) for x in input().split()]\n\t\t(self.a, self.b) = ([], [])\n\t\tfor _ in range(self.m):\n\t\t\t(a, b) = [x for x in input().split()]\n\t\t\tself.a.append(a)\n\t\t\tself.b.append(b)\n\t\tself.c = [x for x in input().split()]\n\n\tdef solve_and_print(self):\n\t\tfor c in self.c:\n\t\t\tfor (a, b) in zip(self.a, self.b):\n\t\t\t\tif a == c:\n\t\t\t\t\tprint(a if len(a) <= len(b) else b, end=' ')\nSolution().solve_and_print()\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\t(dic[s1], dic[s2]) = (s2, s1)\ns = input().split()\nfor i in range(len(s)):\n\ts[i] = min(s[i], dic[s[i]], key=len)\nres = ' '.join(s)\nprint(res)\n", "from itertools import *\nfrom bisect import *\n\ndef main(n, m, a, b, s, ab):\n\tans = []\n\tab.sort()\n\ta = [x for (x, y) in ab]\n\tb = [y for (x, y) in ab]\n\tfor i in range(n):\n\t\tj = bisect_left(a, s[i])\n\t\tif len(a[j]) <= len(b[j]):\n\t\t\tans.append(a[j])\n\t\telse:\n\t\t\tans.append(b[j])\n\tprint(' '.join(ans))\n\ndef main_input(info=0):\n\t(n, m) = map(int, input().split())\n\t(a, b, l) = (list(range(m)), list(range(m)), list(range(n)))\n\tfor i in range(m):\n\t\t(a[i], b[i]) = input().split()\n\ts = input().split()\n\tab = []\n\tfor i in range(m):\n\t\tab.append((a[i], b[i]))\n\tmain(n, m, a, b, s, ab)\nmain_input()\n", "(n, m) = list(map(int, input().split()))\nch = {}\nfor x in range(m):\n\t(a, b) = input().split()\n\tif len(b) < len(a):\n\t\tch[a] = b\nc = input().split()\nfor y in range(len(c)):\n\tif c[y] in ch.keys():\n\t\tc[y] = ch[c[y]]\nprint(' '.join(c))\n", "(n, m) = list(map(int, input().split()))\ndict_ = dict()\nfor i in range(m):\n\t(st, st1) = list(input().split())\n\tdict_[st] = st if len(st) <= len(st1) else st1\nlist_ = list(input().split())\nfor i in list_:\n\tprint(dict_[i], end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(l1, l2) = input().split()\n\ta.append(l1)\n\tb.append(l2)\nc = list(input().split())\nfor j in c:\n\tk = a.index(j)\n\tlen1 = len(a[k])\n\tlen2 = len(b[k])\n\tif len2 < len1:\n\t\tprint(b[k], end=' ')\n\telse:\n\t\tprint(j, end=' ')\n", "(n, m) = map(int, input().split())\nl1 = set()\nw2w = {}\nfor _ in range(m):\n\t(w1, w2) = input().split()\n\tw2w[w1] = w2\n\tw2w[w2] = w1\n\tl1.add(w1)\nres = []\nlecture = input().split()\nfor w in lecture:\n\tif w in l1:\n\t\tw2 = w2w[w]\n\t\tw1 = w\n\telse:\n\t\tw1 = w2w[w]\n\t\tw2 = w\n\tif len(w1) == len(w2):\n\t\tres.append(w1)\n\telse:\n\t\tres.append(w1 if len(w1) < len(w2) else w2)\noutput = ' '.join(res)\nprint(output)\n", "(n, m) = map(int, input().split())\nlangMap = {}\nfor i in range(m):\n\ttemp = input().split()\n\tif temp[0] not in langMap:\n\t\tlangMap[temp[0]] = temp[1]\n\tif temp[1] not in langMap:\n\t\tlangMap[temp[1]] = temp[0]\nwri = input().split()\nans = []\nfor i in wri:\n\tif len(i) <= len(langMap[i]):\n\t\tans.append(i)\n\telse:\n\t\tans.append(langMap[i])\nfor i in ans:\n\tprint(i, end=' ')\n", "(N, M) = map(int, input().split())\nL1 = []\nL2 = []\nfor _ in range(M):\n\t(a, b) = map(str, input().split())\n\tL1.append(a)\n\tL2.append(b)\nL = list(map(str, input().split()))\ns = []\nfor i in L:\n\tn1 = L1.index(i)\n\tif len(L2[n1]) < len(L1[n1]):\n\t\ts.append(L2[n1])\n\telse:\n\t\ts.append(L1[n1])\nprint(*s)\n", "dic = {}\nfor i in range(int(input().split()[1])):\n\tm = input().split()\n\tdic[m[0]] = m[len(m[0]) > len(m[1])]\nfor i in input().split():\n\tprint(dic[i], end=' ')\n", "(n, m) = map(int, input().split())\nlag1 = []\nlag2 = []\nwhile m > 0:\n\tx = input().split(' ')\n\tlag1.append(x[0])\n\tlag2.append(x[1])\n\tm -= 1\ntext = input().split(' ')\nans = []\nfor i in range(len(text)):\n\ta = lag1.index(text[i])\n\tx = lag1[a]\n\ty = lag2[a]\n\tshort = min(x, y, key=len)\n\tans.append(short)\nstr1 = ' '\nprint(str1.join(ans))\n", "g = input()\n(n, m) = [int(x) for x in g.split()]\ndic = {}\nlis = []\nfor i in range(m):\n\tr = input()\n\t(r1, r2) = r.split()\n\tif len(r1) <= len(r2):\n\t\tdic[r1] = r1\n\t\tdic[r2] = r1\n\telse:\n\t\tdic[r1] = r2\n\t\tdic[r2] = r2\nt = input()\nfor x in t.split():\n\tlis.append(x)\nresult = ''\nfor x in lis:\n\tresult = result + dic[x] + ' '\nprint(result)\n", "(n, m) = map(int, input().split())\nw = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tw[a] = b\ns = list(input().split())\nans = []\nfor j in s:\n\tif len(w[j]) < len(j):\n\t\tans.append(w[j])\n\telse:\n\t\tans.append(j)\nprint(*ans)\n", "(n, m) = map(int, input().split())\ncorr = dict()\nfor i in range(m):\n\t(a, b) = input().split()\n\tcorr[a] = b\nlecture = input().split()\nnotes = []\nfor i in lecture:\n\tif len(i) <= len(corr[i]):\n\t\tnotes.append(i)\n\telse:\n\t\tnotes.append(corr[i])\nprint(' '.join(notes))\n", "(n, m) = map(int, input().split())\nb = []\nfor i in range(m):\n\ta = list(map(str, input().split()))\n\ta.sort(key=len)\n\tb.append(a[0])\n\tb.append(a[1])\nc = list(map(str, input().split()))\nfor i in c:\n\tt = b.index(i)\n\tif t % 2 == 0:\n\t\tprint(b[t], end=' ')\n\telse:\n\t\tprint(b[t - 1], end=' ')\n", "(n, m) = map(int, input().split())\nq1 = []\nq2 = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tq1.append(a)\n\tq2.append(b)\nk = input()\nl = list(k.split())\nfor i in range(n):\n\ta = q1.index(l[i])\n\tif len(q1[a]) > len(q2[a]):\n\t\tprint(q2[a], end=' ')\n\telse:\n\t\tprint(q1[a], end=' ')\n", "(n, m) = map(int, input().split())\ndict1 = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tif len(s1) <= len(s2):\n\t\tdict1[s1] = 1\n\telse:\n\t\tdict1[s1] = s2\nlist1 = list(input().split())\nfor i in range(n):\n\tif dict1[list1[i]] != 1:\n\t\tprint(dict1[list1[i]], end=' ')\n\telse:\n\t\tprint(list1[i], end=' ')\n", "n_m = list(map(int, input().split()))\nm = n_m[1]\nlec = ''\nD = {}\nDi = {}\nfor i in range(m):\n\tl = list(input().split())\n\tl_a = l[0]\n\tl_b = l[1]\n\tD[l_a] = l_b\n\tDi[l_b] = l_a\nlec_in = list(input().split())\nfor j in range(len(lec_in)):\n\tword = lec_in[j]\n\tif word in D.keys():\n\t\tif len(word) <= len(D[word]):\n\t\t\tlec = lec + word + ' '\n\t\telse:\n\t\t\tlec = lec + D[word] + ' '\n\telif len(word) < len(Di[word]):\n\t\tlec = lec + word + ' '\n\telse:\n\t\tlec = lec + Di[word] + ' '\nprint(lec.rstrip())\n", "import sys\nimport math\n\ndef main():\n\tpass\n\ndef binary(n):\n\treturn bin(n).replace('0b', '')\n\ndef decimal(s):\n\treturn int(s, 2)\n\ndef pow2(n):\n\tp = 0\n\twhile n > 1:\n\t\tn //= 2\n\t\tp += 1\n\treturn p\n\ndef isPrime(n):\n\tif n == 1:\n\t\treturn False\n\telse:\n\t\troot = int(n ** 0.5)\n\t\troot += 1\n\t\tfor i in range(2, root):\n\t\t\tif n % i == 0:\n\t\t\t\treturn False\n\t\treturn True\n\ndef sinp():\n\treturn sys.stdin.readline().strip()\n\ndef iinp():\n\treturn int(input())\n\ndef ninp():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef linp():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(a):\n\tprint(a)\n(n, m) = ninp()\nd = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tlen1 = len(s1)\n\tlen2 = len(s2)\n\tif len1 <= len2:\n\t\td[s1] = s1\n\telse:\n\t\td[s1] = s2\ns = input().split()\nfor i in s:\n\tprint(d.get(i), end=' ')\n", "try:\n\t(n, m) = list(map(int, input().split()))\n\ti = 0\n\tl = []\n\ts = []\n\twhile i < m:\n\t\t(a, b) = list(map(str, input().split()))\n\t\tl.append(a)\n\t\ts.append(b)\n\t\ti += 1\n\tt = list(map(str, input().split()))\n\tc = ''\n\tfor j in range(0, n):\n\t\tif t[j] in l:\n\t\t\td = l.index(t[j])\n\t\t\tg = len(l[d])\n\t\t\tf = len(s[d])\n\t\t\tif g > f:\n\t\t\t\tc = c + s[d] + ' '\n\t\t\telse:\n\t\t\t\tc = c + l[d] + ' '\n\t\tif t[j] in s:\n\t\t\td = l.index(t[j])\n\t\t\tg = len(l[d])\n\t\t\tf = len(s[d])\n\t\t\tif g > f:\n\t\t\t\tc = c + s[d] + ' '\n\t\t\telse:\n\t\t\t\tc = c + l[d] + ' '\n\tprint(c[0:-1])\nexcept:\n\tpass\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nl1 = [''] * m\nl2 = [''] * m\nfs = [0] * m\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tl1[i] = s1\n\tl2[i] = s2\nins = [i for i in input().split()]\nfor i in range(m):\n\tif len(l1[i]) <= len(l2[i]):\n\t\tfs[i] = 1\n\telse:\n\t\tfs[i] = 2\nfor j in range(n):\n\tfor i in range(m):\n\t\tif ins[j] == l1[i]:\n\t\t\tbreak\n\tif fs[i] == 1:\n\t\tprint(l1[i], end=' ')\n\telse:\n\t\tprint(l2[i], end=' ')\n", "inputz = input().split()\nn = int(inputz[0])\nm = int(inputz[1])\nword = {}\nfor i in range(m):\n\ttemp = input().split()\n\tif len(temp[0]) <= len(temp[1]):\n\t\tshorter = temp[0]\n\telse:\n\t\tshorter = temp[1]\n\tword[temp[0]] = shorter\ninputz = input().split()\nfor i in inputz:\n\tprint(word[i], end=' ')\n", "def min(l):\n\tif l[0] <= l[1]:\n\t\treturn 0\n\treturn 1\n(n, m) = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n\tp = []\n\tp = [x for x in input().split()]\n\tl1 = len(p[0])\n\tl2 = len(p[1])\n\tif l1 <= l2:\n\t\ta.append(p[0])\n\t\tb.append(p[1])\n\telse:\n\t\tb.append(p[0])\n\t\ta.append(p[1])\nstr = []\nstr = [x for x in input().split()]\nfor x in str:\n\ttry:\n\t\tp = a.index(x)\n\texcept:\n\t\tp = -1\n\tif p == -1:\n\t\tp = b.index(x)\n\t\tprint(a[p], end=' ')\n\telse:\n\t\tprint(x, end=' ')\n", "(n, m) = map(int, input().split())\nlecture = {}\nd = []\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\tlecture[s1] = s2\nl = list(input().split())\nfor i in l:\n\tif len(lecture[i]) == len(i) or len(lecture[i]) > len(i):\n\t\td.append(i)\n\telse:\n\t\td.append(lecture[i])\nfor i in d:\n\tprint(i, end=' ')\n", "(n, m) = [int(i) for i in input('').split()]\ndictionary = {}\nfor i in range(m):\n\t(a, b) = [i for i in input('').split()]\n\tdictionary[a] = b\nlecture = input('')\nwords = lecture.split()\noutput = []\nfor word in words:\n\tif len(dictionary[word]) < len(word):\n\t\toutput.append(dictionary[word])\n\telse:\n\t\toutput.append(word)\nprint(' '.join(output))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\ns = input().split()\nfor i in s:\n\tif len(i) < len(d[i]):\n\t\tprint(i, end=' ')\n\telif len(i) > len(d[i]):\n\t\tprint(d[i], end=' ')\n\telse:\n\t\tfor j in d:\n\t\t\tif d[j] == i or j == i:\n\t\t\t\tprint(j, end=' ')\n\t\t\t\tbreak\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\td[s1] = s2\ns = list(input().split())\nfor i in s:\n\tif len(d[i]) < len(i):\n\t\tprint(d[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nd = dict()\nwhile m:\n\t(a, b) = input().split()\n\tla = len(a)\n\tlb = len(b)\n\tif la <= lb:\n\t\td[a] = a\n\telse:\n\t\td[a] = b\n\tm -= 1\ntext = input().split()\nans = []\nfor i in text:\n\tans.append(d[i])\nprint(' '.join(ans))\n", "(a, b) = map(int, input().split())\nslov = {}\nfor i in range(0, b):\n\t(c, d) = map(str, input().split())\n\tif len(c) < len(d) or len(c) == len(d):\n\t\tslov[c] = c\n\telse:\n\t\tslov[c] = d\nmas = [str(i) for i in input().split()]\nk = str()\nfor i in mas:\n\tk = k + slov[i] + ' '\nprint(k)\n", "(n, m) = list(map(int, input().split()))\na = []\nfor i in range(m):\n\ta.append(list(input().split()))\nb = list(input().split())\nc = []\nd = {}\nfor j in range(len(a)):\n\tif len(a[j][1]) < len(a[j][0]):\n\t\td[a[j][0]] = a[j][1]\n\telse:\n\t\td[a[j][0]] = a[j][0]\nfor i in b:\n\tc.append(d[i])\nprint(*c)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(0, m):\n\t(s1, s2) = input().split()\n\tif len(s1) > len(s2):\n\t\td[s1] = s2\nprof_lec = list(input().split())\nresult = []\nfor item in prof_lec:\n\tif item in d:\n\t\tresult.append(d[item])\n\telse:\n\t\tresult.append(item)\nprint(' '.join(result))\n", "f = dict()\n(a, b) = map(int, input().split())\nfor i in range(b):\n\t(c, d) = input().split()\n\tf[c] = d\nfor i in input().split():\n\tprint(min(i, f[i], key=len), end=' ')\n", "(n, k) = map(int, input().split())\nres = {}\ntemp = []\nfor i in range(k):\n\t(r, s) = input().split()\n\tres[r] = s\nlecture = input()\ntemp = lecture.split(' ')\nfor i in range(len(temp)):\n\tif len(temp[i]) <= len(res[temp[i]]):\n\t\tprint(temp[i], end=' ')\n\telse:\n\t\tprint(res[temp[i]], end=' ')\n", "input1 = list(map(int, input().split()))\nn = input1[0]\nm = input1[1]\nlangMix = []\nlangAll = []\noutput = []\nfor i in range(m):\n\tlangMix = input().split()\n\tlangAll.append(langMix[0])\n\tlangAll.append(langMix[1])\nlecture1 = input().split()\ndict1 = {}\nfor i in range(len(langAll)):\n\tif i % 2 == 0:\n\t\tdict1[langAll[i]] = langAll[i + 1]\noutput = []\nfor i in range(n):\n\tif len(lecture1[i]) > len(dict1[lecture1[i]]):\n\t\toutput.append(dict1[lecture1[i]])\n\telse:\n\t\toutput.append(lecture1[i])\nprint(' '.join(output))\n", "(n, m) = (int(_) for _ in input().split(' '))\ndictionary = {}\nfor _ in range(m):\n\t(a, b) = input().split(' ')\n\tdictionary[a] = b\noutput = []\nfor word in input().split():\n\tif len(word) <= len(dictionary[word]):\n\t\toutput.append(word)\n\telse:\n\t\toutput.append(dictionary[word])\nprint(' '.join(output))\n", "from sys import stdin, stderr\n\ndef readInts():\n\treturn map(int, stdin.readline().strip().split())\n\ndef print_err(*args, **kwargs):\n\tprint(*args, file=stderr, **kwargs)\n\ndef solve(vs):\n\treturn None\n\ndef run():\n\t(text_size, dict_size) = readInts()\n\td = {}\n\tfor _ in range(dict_size):\n\t\t(l1, l2) = input().strip().split()\n\t\td[l1] = l2\n\tout = []\n\tfor w1 in input().strip().split():\n\t\tw2 = d[w1]\n\t\tif len(w2) < len(w1):\n\t\t\tout.append(w2)\n\t\telse:\n\t\t\tout.append(w1)\n\tprint(' '.join(out))\nrun()\n", "(n, m) = map(int, input().split())\nd = dict((input().split() for _ in range(m)))\nt = list(input().split(' '))\ns = ''\nfor i in range(len(t)):\n\tif len(t[i]) > len(d[t[i]]):\n\t\ts = s + d[t[i]] + ' '\n\telse:\n\t\ts = s + t[i] + ' '\nprint(s)\n", "(n, m) = input().split(' ')\nm = int(m)\nn = int(n)\nlanguage_1 = []\nlanguage_2 = []\nfor _i in range(m):\n\titem = input().split(' ')\n\tlanguage_1.append(item[0])\n\tlanguage_2.append(item[1])\nstring = input().split(' ')\nfor i in range(n):\n\tindex = -1\n\tif string[i] in language_1:\n\t\tindex = language_1.index(string[i])\n\telif string[i] in language_2:\n\t\tindex = language_2.index(string[i])\n\tif index > -1:\n\t\tstring[i] = language_1[index] if len(language_1[index]) <= len(language_2[index]) else language_2[index]\nprint(' '.join(string))\n", "def run():\n\timport sys\n\tsys.stdin = open('/home/punit/Documents/Cpp Programs/input.txt', 'r')\n\tsys.stdout = open('/home/punit/Documents/Cpp Programs/output.txt', 'w')\n\tfrom math import ceil, sqrt, floor\n(n, m) = map(int, input().split())\nd = dict()\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) > len(b):\n\t\td[a] = b\n\t\td[b] = b\n\telif len(a) < len(b):\n\t\td[a] = a\n\t\td[b] = a\n\telse:\n\t\td[a] = a\n\t\td[b] = b\ns = map(str, input().split())\nfor i in s:\n\tprint(d[i], end=' ')\n", "t = input().split()\nn = int(t[0])\nm = int(t[1])\na = []\nb = {}\nfor i in range(m):\n\tt = input().split()\n\tt1 = t[0]\n\tt2 = t[1]\n\tif len(t1) > len(t2):\n\t\ta.append(t1)\n\t\tb[t1] = t2\n\telse:\n\t\ta.append(t2)\n\t\tb[t2] = t1\nt = input().split()\nfor i in range(len(t)):\n\tif t[i] in a:\n\t\tt[i] = b[t[i]]\nprint(' '.join(t))\n", "(n, m) = map(int, input().split())\nx = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(b) < len(a):\n\t\tx[a] = b\n\telse:\n\t\tx[a] = a\ntext = list(input().split())\nfor i in text:\n\tprint(x[i], end=' ')\n", "(n, m) = map(int, input().split())\nfirst = dict()\nsecond = dict()\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tfirst[s1] = s2\n\tsecond[s2] = s1\nlection = input().split()\nfor i in lection:\n\tif len(i) > len(first[i]):\n\t\tprint(first[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "from sys import stdin\n(n, m) = list(map(int, stdin.readline().split()))\nd = {}\nfor _ in range(m):\n\t(a, b) = stdin.readline().split()\n\td[a] = b if len(b) < len(a) else a\ns = stdin.readline().split()\nres = []\nfor t in s:\n\tres.append(d[t])\nprint(' '.join(res))\n", "(n, m) = map(int, input().split())\nb = {}\nfor i in range(m):\n\t(k, l) = input().split()\n\ta = {len(k): k, len(l): l}\n\tif len(k) == len(l):\n\t\tb[k] = k\n\telse:\n\t\tb[k] = a[min(len(k), len(l))]\nq = input().split()\nm = ''\nfor r in q:\n\tm += '{} '.format(b[r])\nprint(m)\n", "[n, m] = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n\t[a, b] = input().split()\n\tla = len(a)\n\tlb = len(b)\n\tif la <= lb:\n\t\td[a] = a\n\t\td[b] = a\n\telse:\n\t\td[a] = b\n\t\td[b] = b\nc = input().split()\nos = ''\nfor word in c:\n\tos += d[word] + ' '\nprint(os.strip())\n", "(x, y) = map(int, input().split())\nt = []\nd = {}\nfor i in range(y):\n\ta = input().split()\n\td[a[0]] = a[1]\nl = input().split()\nfor i in range(x):\n\tif len(l[i]) > len(d[l[i]]):\n\t\tprint(d[l[i]], end=' ')\n\telif len(l[i]) <= len(d[l[i]]):\n\t\tprint(l[i], end=' ')\n", "(a, b) = map(int, input().split())\nl1 = []\nl2 = []\nl3 = []\nl4 = []\nind = 0\nfor i in range(0, b):\n\t(s1, s2) = map(str, input().split(' '))\n\tl1.append(s1)\n\tl2.append(s2)\n\tif len(s1) <= len(s2):\n\t\tl3.append(s1)\n\telse:\n\t\tl3.append(s2)\nl4 = list(map(str, input().split(' ')))\nfor i in range(0, a):\n\tind = l1.index(l4[i])\n\tprint(l3[ind], end=' ')\n", "(a, b) = map(int, input().split())\nlecture = []\nl1 = []\nl2 = []\nwhile b > 0:\n\t(a, b1) = map(str, input().split())\n\tif len(a) > len(b1):\n\t\tlan = b1\n\telse:\n\t\tlan = a\n\tl1.append(a)\n\tl2.append(lan)\n\tb -= 1\nd = dict(zip(l1, l2))\nword = input().split()\nstr1 = ''\nfor i in word:\n\tlan = str(d[i])\n\tstr1 += lan\n\tif word.index(i) < len(word) - 1:\n\t\tstr1 += ' '\n\telse:\n\t\tpass\nprint(str1)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b if len(b) < len(a) else a\ns = input().split()\nans = [d[i] for i in s]\nprint(*ans)\n", "(n, m) = map(int, input().split())\nlst = list()\nmydict = dict()\nfor i in range(m):\n\ttemp = input()\n\twords = temp.split()\n\tmydict[words[0]] = words[1]\ns = input()\nw = s.split(' ')\nm = list()\nfor word in w:\n\tif len(mydict[word]) < len(word):\n\t\tm.append(mydict[word])\n\telse:\n\t\tm.append(word)\nst = ''\nfor word in m:\n\tst = st + word + ' '\nprint(st)\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\tm = input().split()\n\ta.append(m[0])\n\tb.append(m[1])\nfor i in input().split():\n\tc = a.index(i)\n\tif len(a[c]) <= len(b[c]):\n\t\tprint(a[c], end=' ')\n\telse:\n\t\tprint(b[c], end=' ')\n", "(n, m) = map(int, input().split())\nl = []\nl1 = []\nfor i in range(m):\n\tt = list(map(str, input().split()))\n\tif len(t[0]) > len(t[1]):\n\t\t(t[0], t[1]) = (t[1], t[0])\n\tl.append(t)\n\tl1.append(t[0])\n\tl1.append(t[1])\nl2 = list(map(str, input().split()))\nfor i in range(len(l2)):\n\tx = l2[i]\n\tind = l1.index(x)\n\tind = ind // 2\n\tl2[i] = l[ind][0]\nfor i in l2:\n\tprint(i, end=' ')\n", "import sys\nimport math\ninput = sys.stdin.readline\n\ndef int_array():\n\treturn list(map(int, input().split()))\n\ndef str_array():\n\treturn list(map(str, input().split()))\n(n, k) = int_array()\nwords = []\nfor i in range(k):\n\twords += str_array()\nsentence = str_array()\nans = ''\nfor i in sentence:\n\tno = words.index(i)\n\tif len(words[no]) > len(words[no + 1]):\n\t\tans += words[no + 1] + ' '\n\telse:\n\t\tans += words[no] + ' '\nprint(ans)\n", "res = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(a, b) = input().split()\n\tif a not in res:\n\t\tres[a] = b\nli = list(input().split())\nfor i in range(n):\n\tif len(res[li[i]]) < len(li[i]):\n\t\tli[i] = res[li[i]]\nprint(*li)\n", "(n, m) = map(int, input().split())\na = dict()\nfor i in range(m):\n\ta.update({map(str, input().split())})\ns = [str(i) for i in input().split()]\nfor i in range(n):\n\tif len(s[i]) > len(a[s[i]]):\n\t\ts[i] = a[s[i]]\nb = ' '.join(s)\nprint(b)\n", "(n, m) = [int(i) for i in input().split()]\nD = {}\nfor i in range(m):\n\t(a, b) = [j.strip() for j in input().split()]\n\tD[a] = b\nNote = [i.strip() for i in input().split()]\nfor i in Note:\n\tif len(i) > len(D[i]):\n\t\tprint(D[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nl = []\nr = []\nout = []\nshort = []\nfor i in range(m):\n\ts = input().split(' ')\n\tl.append(s[0])\n\tr.append(s[1])\n\tif len(s[0]) <= len(s[1]):\n\t\tshort.append(s[0])\n\telse:\n\t\tshort.append(s[1])\ns = input().split(' ')\nfor i in range(n):\n\tif s[i] in l:\n\t\tx = l.index(s[i])\n\t\tout.append(short[x])\nprint(' '.join(out))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(w1, w2) = input().split()\n\tl1 = len(w1)\n\tl2 = len(w2)\n\tif l1 <= l2:\n\t\td[w1] = w1\n\t\td[w2] = w1\n\telse:\n\t\td[w1] = w2\n\t\td[w2] = w2\na = []\nfor s in input().strip().split():\n\ta.append(d[s])\nprint(' '.join(a))\n", "def language(arr, string):\n\ttemp = {}\n\tfor i in arr:\n\t\tif len(i[1]) < len(i[0]):\n\t\t\ttemp[i[0]] = i[1]\n\tfor i in range(len(string)):\n\t\tif string[i] in temp.keys():\n\t\t\tstring[i] = temp[string[i]]\n\tprint(*string)\n\treturn ''\n(a, b) = map(int, input().strip().split())\nblanck = []\nfor i in range(b):\n\t(a, b) = input().strip().split()\n\tblanck.append([a, b])\nlst = list(input().strip().split())\nprint(language(blanck, lst))\n", "(n, m) = map(int, input().split())\nfinal = {}\nfor _ in range(0, m):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\tfinal[a] = a\n\t\tfinal[b] = a\n\telse:\n\t\tfinal[a] = b\n\t\tfinal[b] = b\nlast = [i for i in input().split()]\nfor i in last:\n\tprint(final[i], end=' ')\n", "(n, m) = map(int, input().split())\nfrom collections import defaultdict\nd = defaultdict(lambda : '')\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\td[a] = a\n\t\td[b] = a\n\telse:\n\t\td[a] = b\n\t\td[b] = b\nl = [str(x) for x in input().split()]\nfor i in l:\n\tprint(d[i], end=' ')\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\ta.append(y)\nb = list(input().split())\nfor i in b:\n\tif i in a:\n\t\tind = a.index(i)\n\t\tif ind % 2 == 0:\n\t\t\tif len(a[ind]) <= len(a[ind + 1]):\n\t\t\t\tprint(a[ind], end=' ')\n\t\t\telse:\n\t\t\t\tprint(a[ind + 1], end=' ')\n\t\telif len(a[ind]) <= len(a[ind - 1]):\n\t\t\tprint(a[ind], end=' ')\n\t\telse:\n\t\t\tprint(a[ind - 1], end=' ')\n", "(n, m) = map(int, input().split())\nnotes = {}\nfor i in range(m):\n\t(lan1, lan2) = map(str, input().split())\n\tif len(lan1) <= len(lan2):\n\t\tnotes[lan1] = lan1\n\telse:\n\t\tnotes[lan1] = lan2\nlecture = input()\nlecturenotes = list(lecture.split(' '))\nfor word in lecturenotes:\n\tprint(notes[word], end=' ')\n", "(n, m) = map(int, input().split())\ndct = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tdct[a] = b\ns = input().split()\nfor i in s:\n\tprint(min(i, dct[i], key=len), end=' ')\n", "n = input().split()\ndictionary = {}\nfor i in range(int(n[1])):\n\tl = input().split()\n\tif len(l[0]) > len(l[1]):\n\t\tdictionary[l[0]] = l[1]\n\telse:\n\t\tdictionary[l[0]] = l[0]\nl = input().split()\nfor i in l:\n\tprint(dictionary[i], end=' ')\n", "a = input().strip().split()\nnotes = {}\nfor i in range(0, int(a[1])):\n\tb = input().strip().split()\n\tif len(b[0]) < len(b[1]):\n\t\tnotes[b[0]] = b[0]\n\telif len(b[0]) == len(b[1]):\n\t\tnotes[b[0]] = b[0]\n\telse:\n\t\tnotes[b[0]] = b[1]\nlecture_notes = input().strip().split()\nfor i in lecture_notes:\n\tprint(notes[i], end=' ')\n", "(n, m) = map(int, input().split())\na = [0] * m\nb = [0] * m\nc = [0] * n\nfor i in range(m):\n\t(a[i], b[i]) = map(str, input().split())\nc = list(map(str, input().split()))\nfor i in range(n):\n\tfor j in range(m):\n\t\tif c[i] == a[j] or c[i] == b[j]:\n\t\t\tif len(a[j]) > len(b[j]):\n\t\t\t\tprint(b[j], end=' ')\n\t\t\telse:\n\t\t\t\tprint(a[j], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tla = len(a)\n\tlb = len(b)\n\tif la < lb:\n\t\td[a] = a\n\telif la > lb:\n\t\td[a] = b\n\telse:\n\t\td[a] = a\nls = list(map(str, input().split()))\ns = ''\nfor j in range(n):\n\tif j == n - 1:\n\t\ts = s + d[ls[j]]\n\telse:\n\t\ts = s + d[ls[j]] + ' '\nprint(s)\n", "str = input()\nlist = [int(n) for n in str.split()]\nword1 = []\nword2 = []\nfor i in range(list[1]):\n\ttemp = [j for j in input().split()]\n\tword1.append(temp[0])\n\tword2.append(temp[1])\nstring = [j for j in input().split()]\noutput = ''\nfor i in range(len(string)):\n\tj = word1.index(string[i])\n\tif len(string[i]) > len(word2[j]):\n\t\toutput = output + word2[j] + ' '\n\telse:\n\t\toutput = output + string[i] + ' '\nprint(output)\n", "(n, p) = map(int, input().split())\ndi = {}\nfor i in range(p):\n\ttmp = input().split()\n\tif len(tmp[0]) > len(tmp[1]):\n\t\tdi[tmp[0]] = tmp[1]\n\telse:\n\t\tdi[tmp[0]] = tmp[0]\ntmp = input().split()\nans = ''\nfor i in tmp:\n\tans = ans + ' ' + di[i]\nprint(ans[1:])\n", "(n, m) = [int(x) for x in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = [str(x) for x in input().split()]\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\ns = [str(x) for x in input().split()]\nfor i in s:\n\tprint(d[i], end=' ')\nprint()\n", "(n, m) = [int(i) for i in input().split()]\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdic[a] = b\nc = [s for s in input().split()]\nfor i in range(n):\n\ts = c[i]\n\tt = dic[s]\n\tif len(s) <= len(t):\n\t\tprint(s, end=' ')\n\telse:\n\t\tprint(t, end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nhashmap = dict()\nfor i in range(m):\n\t(str1, str2) = input().split()\n\tif len(str1) <= len(str2):\n\t\thashmap[str1] = str1\n\telse:\n\t\thashmap[str1] = str2\ntemp = list(input().split())\nres = ''\nfor i in range(n):\n\tres += hashmap[temp[i]] + ' '\nprint(res)\n", "from sys import stdin\n[n, m] = map(int, stdin.readline().strip().split(' '))\nlang_map = {}\nsentence = []\nnew_sentence = []\nfor i in range(m):\n\t[l1, l2] = stdin.readline().strip().split(' ')\n\tlang_map[l1] = l2\nsentence = stdin.readline().strip().split(' ')\nfor i in range(n):\n\tif len(sentence[i]) > len(lang_map[sentence[i]]):\n\t\tnew_sentence.append(lang_map[sentence[i]])\n\telse:\n\t\tnew_sentence.append(sentence[i])\nnew_sentence = ' '.join(new_sentence)\nprint(new_sentence)\n", "(n, m) = map(int, input().split())\nl = []\ng = []\nf = len\nx = ''\nfor i in range(m):\n\t(a, b) = input().split()\n\tl.append(a)\n\tg.append(b)\nt = list(input().split())\nfor i in t:\n\tif i in l:\n\t\tinde = l.index(i)\n\telse:\n\t\tinde = g.index(i)\n\tif f(l[inde]) > f(g[inde]):\n\t\tx += g[inde] + ' '\n\telse:\n\t\tx += l[inde] + ' '\nprint(x)\n", "(n, m) = map(int, input().split())\nx = []\ny = []\ns = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tx.append(b)\n\t\ty.append(a)\n\telse:\n\t\tx.append(a)\n\t\ty.append(b)\nc = list(input().split())\nfor i in c:\n\tif i in x:\n\t\ts.append(i)\n\telif i in y:\n\t\ttemp = y.index(i)\n\t\ts.append(x[temp])\nprint(*s)\n", "(n, m) = map(int, input().split())\nl = []\nwhile m:\n\t(a, b) = map(str, input().split())\n\tl.append((a, b))\n\tm = m - 1\ns = list(map(str, input().split()))\nl2 = []\nfor i in range(len(s)):\n\tfor j in range(len(l)):\n\t\tif l[j][0] == s[i]:\n\t\t\tif len(l[j][0]) > len(l[j][1]):\n\t\t\t\tl2.append(l[j][1])\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tl2.append(l[j][0])\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\nprint(*l2)\n", "(n, m) = map(int, input().split())\nwords = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) < len(b) or len(a) == len(b):\n\t\twords[b] = a\n\telse:\n\t\twords[a] = b\na = list(map(str, input().split()))\nfor i in range(n):\n\tif a[i] in words:\n\t\ta[i] = words[a[i]]\nprint(*a)\n", "p = dict()\n(n, m) = list(map(int, input().split()))\na = []\nfor i in range(m):\n\th = input().split()\n\tif len(h[1]) > len(h[0]):\n\t\tp[h[1]] = h[0]\n\tif len(h[1]) < len(h[0]):\n\t\tp[h[0]] = h[1]\ng = input().split()\nfor i in range(len(g)):\n\tif g[i] in p:\n\t\tg[i] = p[g[i]]\nprint(*g)\n", "(n, m) = map(int, input().split(' '))\nc = []\nfor i in range(m):\n\t(a, b) = map(str, input().split(' '))\n\tc.append(a)\n\tc.append(b)\nl = input().split(' ')\nle = [len(i) for i in c]\nfor w in l:\n\tindex = c.index(w)\n\tif index % 2 == 0:\n\t\tif le[index + 1] < le[index]:\n\t\t\tindex += 1\n\telif le[index - 1] <= le[index]:\n\t\tindex -= 1\n\tprint(c[index], end=' ')\n", "(n, m) = map(int, input().split())\nf = []\ns = []\nans = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tf.append(a)\n\ts.append(b)\nip = list(input().split())\nfor i in ip:\n\ttemp = s[f.index(i)]\n\tif len(temp) < len(i):\n\t\tans.append(temp)\n\telse:\n\t\tans.append(i)\nfor j in ans:\n\tprint(j, end=' ')\n", "def prog():\n\tfrom sys import stdin\n\t(n, m) = map(int, stdin.readline().split())\n\tdi = {}\n\tfor i in range(m):\n\t\t(a, b) = stdin.readline().split()\n\t\tdi[a] = b\n\ts = map(str, stdin.readline().split())\n\trez = ''\n\tfor (i, x) in enumerate(s):\n\t\tif len(x) > len(di[x]):\n\t\t\trez = '%s%s ' % (rez, di[x])\n\t\telse:\n\t\t\trez = '%s%s ' % (rez, x)\n\tprint(rez[:len(rez) - 1])\nprog()\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\tdic[a] = a\n\t\tdic[b] = a\n\telse:\n\t\tdic[a] = b\n\t\tdic[b] = b\nx = list(map(str, input().split()))\ns = ''\nfor i in x:\n\ts += dic[i] + ' '\nprint(s[:-1])\n", "(n, m) = map(int, input().split())\ndict = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) == len(b) or len(a) < len(b):\n\t\tdict[a] = a\n\telse:\n\t\tdict[a] = b\nname = input().split()\nfor i in name:\n\tprint(dict[i], end=' ')\n", "(n, m) = list(map(int, input().split()))\nmaps = dict()\nfor count in range(m):\n\twords = input().split()\n\tmaps[words[0]] = words[1]\nlecture = input().split()\nfor word in lecture:\n\tif len(word) > len(maps[word]):\n\t\tprint(maps[word], end=' ')\n\telif len(word) < len(maps[word]):\n\t\tprint(word, end=' ')\n\telse:\n\t\tprint(word, end=' ')\n", "(n, m) = map(int, input().split())\n(one, two) = ([], [])\nfinal = []\nfor i in range(m):\n\t(c, a) = input().split()\n\tone.append(c)\n\ttwo.append(a)\ns = map(str, input().split())\nfor i in s:\n\tif i in one:\n\t\tif len(i) > len(two[one.index(i)]):\n\t\t\tfinal.append(two[one.index(i)])\n\t\telse:\n\t\t\tfinal.append(i)\n\telif len(i) > len(one[two.index(i)]):\n\t\tfinal.append(one[two.index(i)])\n\telse:\n\t\tfinal.append(i)\nprint(*final)\n", "firstLine = [int(x) for x in input().split()]\nd = {}\nfor i in range(0, firstLine[1]):\n\ttemp = [str(x) for x in input().split()]\n\tif len(temp[0]) <= len(temp[1]):\n\t\td[temp[1]] = temp[0]\n\telse:\n\t\td[temp[0]] = temp[1]\nlastLine = [str(x) for x in input().split()]\nfor s in lastLine:\n\tif s in d:\n\t\tprint(d[s], '', end='')\n\telse:\n\t\tprint(s, '', end='')\n", "inp = input().split(' ')\nchange = {}\nfor x in range(int(inp[1])):\n\ta = input().split()\n\tif len(a[1]) < len(a[0]):\n\t\tchange[a[0]] = a[1]\n\telse:\n\t\tchange[a[0]] = a[0]\nb = input().split(' ')\nout = ''\nc = b.pop(0)\nout = out + change[c]\nfor y in b:\n\tout = out + ' ' + change[y]\nprint(out)\n", "import sys\nsys.setrecursionlimit(100000)\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tfirst = list()\n\tsecond = list()\n\tM = {}\n\tfor i in range(m):\n\t\t(x, y) = input().split()\n\t\tM[x] = y\n\tlecture = list(input().split())\n\tfor word in lecture:\n\t\t(x, y) = (word, M[word])\n\t\tif len(x) <= len(y):\n\t\t\tprint(x, end=' ')\n\t\telse:\n\t\t\tprint(y, end=' ')\nmain()\n", "(n, m) = map(int, input().split())\nl = []\nfirst = [None] * m\nsecond = [None] * m\nfor i in range(m):\n\t(first[i], second[i]) = input().split()\ns = input().split()\nres = []\nfor str in s:\n\tfor i in range(m):\n\t\tif str == first[i]:\n\t\t\tif len(first[i]) > len(second[i]):\n\t\t\t\tres.append(second[i])\n\t\t\telse:\n\t\t\t\tres.append(first[i])\n\t\t\tbreak\nprint(' '.join(res))\n", "(n, m) = list(map(int, input().split()))\nA = dict()\nfor i in range(m):\n\t(s, d) = input().split()\n\tA[s] = d\nS = input().split()\nd = ''\nfor i in range(n):\n\tif len(S[i]) <= len(A[S[i]]):\n\t\td += S[i] + ' '\n\telse:\n\t\td += A[S[i]] + ' '\nprint(d)\n", "def Lecture():\n\t(n, m) = map(int, input().split())\n\twords = {}\n\tfor i in range(m):\n\t\t(w1, w2) = input().split()\n\t\tif len(w2) < len(w1):\n\t\t\twords[w1] = w2\n\t\telse:\n\t\t\twords[w1] = w1\n\tinputarray = list(input().split())\n\tans = []\n\tfor i in inputarray:\n\t\tans.append(words[i])\n\tprint(*ans)\n\ndef main():\n\tLecture()\nmain()\n", "I = lambda : input().split()\n(_, m) = map(int, I())\nd = {}\nfor _ in range(m):\n\t(a, b) = I()\n\tif len(a) > len(b):\n\t\td[a] = b\nfor c in I():\n\tprint(d[c] if c in d else c, end=' ')\n", "def inpNum():\n\treturn int(input())\n\ndef inpNums():\n\treturn map(int, input().split())\n\ndef inpList():\n\treturn list(map(int, input().split()))\n\ndef inpStrMatrix(rows):\n\treturn [list(input()) for _ in range(rows)]\n(n, m) = inpNums()\nwords = dict()\nfor i in range(m):\n\ts = input().split()\n\t(l1, l2) = (len(s[0]), len(s[1]))\n\tif l1 > l2:\n\t\twords[s[0]] = s[1]\nfor t in input().split():\n\tif t in words:\n\t\tprint(words[t], end=' ')\n\telse:\n\t\tprint(t, end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nl2 = []\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tif len(s1) <= len(s2):\n\t\tl2.append(s1)\n\telse:\n\t\tl2.append(s2)\n\tif len(s1) <= len(s2):\n\t\td[s1] = s2\n\telse:\n\t\td[s2] = s1\nl = list(input().split())\nfor i in l:\n\tif i in l2:\n\t\tprint(i, end=' ')\n\telse:\n\t\tfor (x, y) in d.items():\n\t\t\tif y == i:\n\t\t\t\tprint(x, end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor x in range(m):\n\tc = input().split()\n\t(a, b) = c\n\td[a] = b\nl = [x for x in input().split()]\nfor x in range(len(l)):\n\tif len(l[x]) > len(d[l[x]]):\n\t\tl[x] = d[l[x]]\nfor x in l:\n\tprint(x, end=' ')\nprint()\n", "(n, m) = map(int, input().split())\ndictionary = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdictionary[a] = b\nn = input().split()\nfor i in range(len(n)):\n\tif len(dictionary[n[i]]) < len(n[i]):\n\t\tn[i] = dictionary[n[i]]\nprint(*n)\n", "(n, m) = list(map(int, input().split()))\nd = dict()\nfor i in range(m):\n\ttmp = input().split()\n\td[tmp[0]] = tmp[1]\ns = input().split()\nres = []\nfor word in s:\n\tif len(word) <= len(d[word]):\n\t\tres.append(word)\n\telse:\n\t\tres.append(d[word])\nprint(' '.join(res))\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\tb.append(y)\ns = list(input().split())\nans = []\nfor i in range(len(s)):\n\tbs = a.index(s[i])\n\tif len(a[bs]) > len(b[bs]):\n\t\tans.append(b[bs])\n\telse:\n\t\tans.append(a[bs])\nfor i in ans:\n\tprint(i, end=' ')\n", "lijst = list(map(int, input().split(' ')))\nwoorden = []\nwoordenboek = {}\nfor i in range(0, lijst[1]):\n\twoorden.append(input().split(' '))\n\tif len(woorden[0][0]) <= len(woorden[0][1]):\n\t\twoordenboek[woorden[0][0]] = woorden[0][0]\n\telse:\n\t\twoordenboek[woorden[0][0]] = woorden[0][1]\n\twoorden = []\nvertalen = list(map(str, input().split(' ')))\nvertaling = ''\nfor i in range(0, lijst[0]):\n\tvertaling += ' ' + woordenboek[vertalen[i]]\nprint(vertaling[1:len(vertaling)])\n", "import sys\ncachedInput = sys.stdin\ncount = 0\ntotalNumberInLecture = 0\nnumberOfWordsInEachLanguage = 0\ndictionary = {}\nresult = []\n\ndef returnShortest(list):\n\tif len(list[0]) <= len(list[1]):\n\t\treturn list[0]\n\telse:\n\t\treturn list[1]\nline = input()\na = line.strip('\\n').split()\ntotalNumberInLecture = int(a[0])\nnumberOfWordsInEachLanguage = int(a[1])\nfor line in cachedInput:\n\tcount += 1\n\tif count <= numberOfWordsInEachLanguage:\n\t\tcurrentLine = line.strip('\\n').split()\n\t\tdictionary[currentLine[0]] = returnShortest(currentLine)\n\telse:\n\t\tlecture = line.strip('\\n').split()\nfor word in lecture:\n\tresult.append(dictionary[word])\nprint(' '.join(result))\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ndic = {}\nfor i in range(m):\n\t(t1, t2) = input().split()\n\tdic[t1] = t2\nans = []\nlecture = input().split()\nfor word in lecture:\n\tif len(word) > len(dic[word]):\n\t\tans.append(dic[word])\n\telse:\n\t\tans.append(word)\nprint(*ans)\n", "(n, m) = map(int, input().split())\n(d, op) = ({}, '')\nfor _ in range(m):\n\t(a, b) = input().split()\n\td[a] = b\narr = [i for i in input().split()]\nfor s in arr:\n\tif len(s) <= len(d[s]):\n\t\top += s + ' '\n\telse:\n\t\top += d[s] + ' '\nprint(op)\n", "(N, T) = input('').split()\nn = int(N)\nt = int(T)\nl = []\nfor i in range(0, t):\n\ts = input('').split()\n\tif len(s[0]) <= len(s[1]):\n\t\ta = [s[0], s[0]]\n\telse:\n\t\ta = [s[0], s[1]]\n\tl.append(a)\ng = []\nfor i in l:\n\tg.append(i[0])\nw = input('').split()\nr = ''\nfor i in w:\n\tv = g.index(i)\n\tr = r + l[v][1] + ' '\nprint(r)\n", "(n, m) = map(int, input().split())\na = {}\nfor i in range(m):\n\tt = input()\n\tt = t.split()\n\ta[t[0]] = t[1]\nans = ''\ns = input().split()\nfor i in range(len(s)):\n\tif len(s[i]) > len(a[s[i]]):\n\t\ts[i] = a[s[i]]\n\tans = ans + s[i] + ' '\nprint(ans)\n", "import sys\n\ndef FILE_IO():\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n(n, m) = map(int, input().split())\ndic = dict()\nfor _ in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tb = a\n\tdic[a] = b\nprofes = list(input().split())\nfor word in profes:\n\tif word in dic:\n\t\tprint(dic[word], end=' ')\n\telse:\n\t\tprint(word, end=' ')\n", "(n, m) = map(int, input().split())\ndictionary = dict()\nfor _ in range(m):\n\t(first, second) = input().split()\n\tdictionary[first] = second\nprint(' '.join(list(map(lambda x: x if len(x) <= len(dictionary[x]) else dictionary[x], input().split()))))\n", "(x, y) = list(map(int, input().split()))\nt = {}\npr = []\nfor i in range(y):\n\tu = list(input().split())\n\tt[u[0]] = u[1]\nf = input().split()\nfor j in range(len(f)):\n\tif len(t[f[j]]) < len(f[j]):\n\t\tpr.append(t[f[j]])\n\telse:\n\t\tpr.append(f[j])\nprint(*pr)\n", "(n, k) = list(map(int, input().split()))\nmapping = dict()\nfor i in range(k):\n\t(x, y) = input().split()\n\tmapping[x] = y\nlecture = input().split()\nans = []\nfor word in lecture:\n\tif len(word) <= len(mapping[word]):\n\t\tans.append(word)\n\telse:\n\t\tans.append(mapping[word])\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\nWords = []\nfor i in range(m):\n\tWords.append(input().split())\nletter = input().split()\nnote = ''\nfor wanted in letter:\n\tfor search in Words:\n\t\tif search[0] == wanted or search[1] == wanted:\n\t\t\tif len(search[0]) < len(search[1]):\n\t\t\t\tnote += search[0] + ' '\n\t\t\telif len(search[0]) > len(search[1]):\n\t\t\t\tnote += search[1] + ' '\n\t\t\telse:\n\t\t\t\tnote += search[0] + ' '\nprint(note)\n", "(n, m) = [int(i) for i in input().split()]\ndic = dict((input().split() for _ in range(m)))\nc = [s for s in input().split()]\nfor i in range(n):\n\ts = c[i]\n\tt = dic[s]\n\tprint(s if len(s) <= len(t) else t, end=' ')\n", "[n, m] = [int(x) for x in input().split()]\nref = {}\nfor i in range(m):\n\t[a, b] = [x for x in input().split()]\n\tref[a] = a if len(a) <= len(b) else b\ns = ''\ngiven = [x for x in input().split()]\nfor i in given:\n\ts += ref[i] + ' '\nprint(s[:-1])\n", "(n, m) = map(int, input().split())\ndict = {}\nfor i in range(m):\n\t(st1, st2) = input().split()\n\tl1 = len(st1)\n\tl2 = len(st2)\n\tif l1 <= l2:\n\t\tdict.update({st2: st1})\n\telse:\n\t\tdict.update({st1: st2})\nli = input().split()\nfor i in range(n):\n\tif li[i] in dict:\n\t\tli[i] = dict[li[i]]\nprint(' '.join(li))\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nf = []\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tf.append((s1, s2))\nf = sorted(f, key=lambda tup: tup[0])\nst = ''\nfound = False\na = input().split()\nfor i in range(n):\n\tl = 0\n\tr = m - 1\n\twhile l + 1 < r:\n\t\tb = (l + r) // 2\n\t\tif a[i] == f[b][0]:\n\t\t\tif len(f[b][0]) <= len(f[b][1]):\n\t\t\t\tst += f[b][0] + ' '\n\t\t\telse:\n\t\t\t\tst += f[b][1] + ' '\n\t\t\tfound = True\n\t\t\tbreak\n\t\telif a[i] < f[b][0]:\n\t\t\tr = b\n\t\telse:\n\t\t\tl = b\n\tif a[i] == f[r][0] and (not found):\n\t\tif len(f[r][0]) <= len(f[r][1]):\n\t\t\tst += f[r][0] + ' '\n\t\telse:\n\t\t\tst += f[r][1] + ' '\n\t\tfound = True\n\tif a[i] == f[l][0] and (not found):\n\t\tif len(f[l][0]) <= len(f[l][1]):\n\t\t\tst += f[l][0] + ' '\n\t\telse:\n\t\t\tst += f[l][1] + ' '\n\tfound = False\nprint(st)\n", "(n, m) = map(int, input().split())\n(a, b, res) = ([], [], [])\nfor i in range(m):\n\t(l, k) = map(str, input().split())\n\ta.append(l)\n\tb.append(k)\ns = input().split()\nfor j in range(len(s)):\n\tind = a.index(s[j])\n\tif len(s[j]) > len(b[ind]):\n\t\tres.append(b[ind])\n\telse:\n\t\tres.append(s[j])\nprint(*res)\n", "from collections import deque\nfrom collections import OrderedDict\nimport math\nimport sys\nimport os\nimport threading\nimport bisect\nimport operator\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport io\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n(n, m) = map(int, input().split())\nhash1 = dict()\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\thash1[a] = b + '2'\n\thash1[b] = a + '1'\nar = list(map(str, input().split()))\nfor i in range(len(ar)):\n\ts = hash1[ar[i]]\n\tif len(s) - 1 > len(ar[i]):\n\t\tprint(ar[i], end=' ')\n\telif len(s) - 1 < len(ar[i]):\n\t\tprint(s[0:len(s) - 1:1], end=' ')\n\telif s[len(s) - 1] == '1':\n\t\tprint(s[0:len(s) - 1:1], end=' ')\n\telse:\n\t\tprint(ar[i], end=' ')\n", "def main():\n\t(n, m) = map(int, input().split())\n\tli = []\n\twhile m > 0:\n\t\t(a, b) = input().split()\n\t\tli.append((a, b))\n\t\tm -= 1\n\tdi = dict(li)\n\tli1 = list(input().split())\n\tfor i in li1:\n\t\tif len(i) <= len(di[i]):\n\t\t\tprint(i, end=' ')\n\t\telse:\n\t\t\tprint(di[i], end=' ')\nmain()\n", "from collections import Counter, defaultdict\nBS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef to_base(s, b):\n\tres = ''\n\twhile s:\n\t\tres += BS[s % b]\n\t\ts //= b\n\treturn res[::-1] or '0'\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfrom math import floor, ceil, pi\n(n, m) = list(map(int, input().split()))\nd = {}\nfor l in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nfor word in input().split():\n\tprint(min(word, d[word], key=lambda x: len(x)), end=' ')\n", "(n, m) = map(int, input().split())\nx = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tx[a] = b\nlis = input().split()\nres = []\nfor i in lis:\n\tif len(i) <= len(x[i]):\n\t\tres.append(i)\n\telse:\n\t\tres.append(x[i])\nprint(' '.join(res))\n", "(n, m) = map(int, input().split())\nhaha1 = []\nhaha2 = []\nfinal = []\nfor i in range(m):\n\t(hah, haha) = map(str, input().split())\n\thaha1.append(hah)\n\thaha2.append(haha)\nstring = input()\nstring = string.split(' ')\nfor i in string:\n\tif i in haha1:\n\t\tresult = haha1.index(i)\n\t\tif len(haha1[result]) > len(haha2[result]):\n\t\t\tfinal.append(haha2[result])\n\t\telse:\n\t\t\tfinal.append(haha1[result])\n\telse:\n\t\tresult = haha2.index(i)\n\t\tif len(haha1[result]) > len(haha2[result]):\n\t\t\tfinal.append(haha2[result])\n\t\telse:\n\t\t\tfinal.append(haha1[result])\nfinal_result = ' '.join(final)\nprint(final_result)\n", "(n, m) = map(int, input().split())\nd = dict()\nfor _ in range(m):\n\t(a, b) = input().split()\n\tx = [a, b][len(a) > len(b)]\n\td[a] = d[b] = x\ns = input().split()\nfor i in s:\n\tprint(d[i], end=' ')\n", "(n, k) = map(int, input().split())\n(l, c) = ([], [])\nfor i in range(k):\n\t(x, y) = input().split()\n\tl.append(x)\n\tc.append(y)\np = ''\ns = input().split()\nfor i in s:\n\tfor j in range(k):\n\t\tif l[j] == i:\n\t\t\tif len(l[j]) <= len(c[j]):\n\t\t\t\tp += l[j]\n\t\t\telse:\n\t\t\t\tp += c[j]\n\tp += ' '\nprint(p)\n", "t = input()\nt = t.split()\nn = int(t[0])\nm = int(t[1])\na = dict()\nfor i in range(m):\n\td = input()\n\td = d.split()\n\tp = d[0]\n\tq = d[1]\n\tif len(p) > len(q):\n\t\ta[p] = q\nb = input()\nb = b.split()\nfor i in range(n):\n\tif b[i] in a:\n\t\tprint(a[b[i]], end=' ')\n\telse:\n\t\tprint(b[i], end=' ')\n", "(n, m) = map(int, input().split())\n(v, p) = ([], [])\nfor i in range(m):\n\tv.append(list(map(str, input().split())))\nl = list(map(str, input().split()))\nfor i in range(len(v)):\n\tfor j in range(len(l)):\n\t\tif v[i][0] == l[j] and len(v[i][0]) > len(v[i][1]):\n\t\t\tl[j] = v[i][1]\nprint(*l)\n", "(n, m) = map(int, input().split())\nd = {}\nfor z in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nlecture = list(input().split())\nfor i in lecture:\n\tif len(i) <= len(d[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(d[i], end=' ')\n", "(n, m) = input().split(' ')\n(n, m) = (int(n), int(m))\nd = {}\nfor i in range(m):\n\t(a, b) = input().split(' ')\n\td[a] = b\n\td[b] = a\nl = []\nc = input().split(' ')\nfor h in c:\n\tr1 = h\n\tr2 = d[h]\n\tif len(r1) <= len(r2):\n\t\tl.append(r1)\n\telse:\n\t\tl.append(r2)\nprint(' '.join(l))\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nfrst = []\nscnd = []\nfor i in range(0, m):\n\t(x, y) = input().split()\n\tfrst.append(x)\n\tscnd.append(y)\nlecture = input()\nword = lecture.split()\nfor i in range(0, m):\n\tif len(scnd[i]) < len(frst[i]):\n\t\tfor j in range(0, n):\n\t\t\tif frst[i] == word[j]:\n\t\t\t\tword[j] = scnd[i]\nprint(' '.join(word))\n", "from sys import stdin\ninput = stdin.readline\n(n, m) = map(int, input().split())\ndct = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tdct[a] = b if len(b) < len(a) else a\nprint(*map(lambda w: dct[w], input().split()))\n", "l1 = [int(x) for x in input().split()]\n(n, m) = (l1[0], l1[1])\nshorts = []\nlongs = []\nfor x in range(m):\n\tl4 = input().split()\n\tif len(l4[0]) > len(l4[1]):\n\t\tshorts.append(l4[1])\n\t\tlongs.append(l4[0])\n\telse:\n\t\tshorts.append(l4[0])\n\t\tlongs.append(l4[1])\nwords = input().split()\nans = []\nfor x in words:\n\tif x in shorts:\n\t\tans.append(x)\n\telse:\n\t\tans.append(shorts[longs.index(x)])\nprint(*ans)\n", "w = input().split()\nn = int(w[0])\nm = int(w[1])\nlist1 = []\nlist2 = []\nmy_dict = {}\nfor i in range(m):\n\tflag = 0\n\tlang = input()\n\tarr = lang.split()\n\tmy_dict[arr[0]] = arr[1]\nmssg = input()\nmsg = mssg.split()\nanswer = ''\nfor i in range(len(msg)):\n\tif len(msg[i]) > len(my_dict[msg[i]]):\n\t\tmsg[i] = my_dict[msg[i]]\nfor i in range(len(msg)):\n\tprint(msg[i], end=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(f, s) = input().split()\n\tdic[f] = s\nstr1 = input().split()\nstr2 = ''\nfor s in str1:\n\tif len(s) > len(dic[s]):\n\t\tstr2 += str(dic[s]) + ' '\n\telse:\n\t\tstr2 += str(s) + ' '\nprint(str2)\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\td.update({a: b})\nans = []\ns = input().split()\nfor x in s:\n\tif len(x) > len(d[x]):\n\t\tans.append(d[x])\n\telif len(x) < len(d[x]):\n\t\tans.append(x)\n\telse:\n\t\tans.append(x)\nprint(*ans)\n", "dict = {}\n(a, b) = map(int, input().split())\nfor i in range(b):\n\t(x, y) = input().split()\n\tdict[x] = y\nn = input().split()\na = []\nfor i in n:\n\tif len(i) == len(dict[i]):\n\t\ta.append(i)\n\telif len(i) > len(dict[i]):\n\t\ta.append(dict[i])\n\telse:\n\t\ta.append(i)\nprint(*a)\n", "(n, m) = map(int, input().split())\nwords = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\twords[a] = b\nc = input().split()\nout = []\nfor w in c:\n\tif len(words[w]) < len(w):\n\t\tout.append(words[w])\n\telse:\n\t\tout.append(w)\nprint(' '.join(out))\n", "(n, m) = map(int, input().split())\ndick = {}\nfor _ in ' ' * m:\n\t(a, b) = input().split()\n\tdick[a] = b if len(b) < len(a) else a\nout = []\nfor i in input().split():\n\tout += [dick[i]]\nprint(*out)\n", "def main():\n\t(n, m) = map(int, input().split())\n\tconv = {}\n\tfor _ in range(m):\n\t\t(f, s) = input().split()\n\t\tconv[f] = s\n\tnote = input().split()\n\tfor i in note:\n\t\talt = conv[i]\n\t\tif len(i) <= len(alt):\n\t\t\tprint(i, end=' ')\n\t\telse:\n\t\t\tprint(alt, end=' ')\nmain()\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\td[x] = y\na = list(map(str, input().split()))\nfor i in range(n):\n\tif len(a[i]) <= len(d[a[i]]):\n\t\tprint(a[i], end=' ')\n\telse:\n\t\tprint(d[a[i]], end=' ')\n", "(n, m) = map(int, input().split())\nop = {}\ndp = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\top[a] = b\nl = list(map(str, input().split()))\nans = []\nfor i in l:\n\tif len(i) <= len(op[i]):\n\t\tans.append(i)\n\telse:\n\t\tans.append(op[i])\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\nx = {}\nfor _ in range(m):\n\t(f, s) = map(str, input().split())\n\tif len(s) < len(f):\n\t\t(f, s) = (s, f)\n\tx[s] = f\ntest = list(map(str, input().split()))\nfor s in test:\n\tif s in x.keys():\n\t\tprint(x[s], end=' ')\n\telse:\n\t\tprint(s, end=' ')\n", "(prof, lang) = map(int, input().strip().split())\narr = dict()\nans = []\nfor i in range(lang):\n\ts = input().split()\n\tarr[s[0]] = s[1]\nspeech = input().split()\nfor i in speech:\n\tif len(i) > len(arr[i]):\n\t\tans.append(arr[i])\n\telse:\n\t\tans.append(i)\nprint(' '.join(ans))\n", "from collections import defaultdict\n(n, m) = map(int, input().split())\nd = defaultdict(list)\nfor i in range(m):\n\tX = input().split()\n\tA = X[0]\n\tB = X[1]\n\tif len(A) > len(B):\n\t\td[A] = B\n\t\td[B] = B\n\telse:\n\t\td[A] = A\n\t\td[B] = A\nstring = list(input().split())\nfor word in string:\n\tprint(d[word], end=' ')\n", "class Fraction:\n\n\tdef __init__(self, x='', y=''):\n\t\tself.first = x\n\t\tself.true = y\n\ndef replace(n):\n\ta = n.split()\n\tif len(a[0]) <= len(a[1]):\n\t\treturn a[0]\n\telse:\n\t\treturn a[1]\n(n, m) = map(int, input().split())\nchange = []\nfor i in range(m):\n\tx = input()\n\tif replace(x) != x.split()[0]:\n\t\tchange.append(Fraction(x.split()[0], replace(x)))\nletter = input().split()\nfor i in range(n):\n\tfor k in range(len(change)):\n\t\tif change[k].first == letter[i]:\n\t\t\tletter[i] = change[k].true\n\t\t\tbreak\nans = letter[0]\nfor i in range(1, len(letter)):\n\tans = ans + ' ' + letter[i]\nprint(ans)\n", "def main():\n\t[n, m] = [int(_) for _ in input().split()]\n\tdictionary = {}\n\tfor _ in range(m):\n\t\twords = input().split()\n\t\tdictionary[words[0]] = words[1]\n\tmessage = input().split()\n\tfor i in range(n):\n\t\tif len(dictionary[message[i]]) < len(message[i]):\n\t\t\tmessage[i] = dictionary[message[i]]\n\tprint(' '.join(message))\nmain()\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\tz = input().split()\n\tif len(z[0]) == len(z[1]):\n\t\td[z[1]] = z[0]\n\telif len(z[0]) > len(z[1]):\n\t\td[z[0]] = z[1]\n\telse:\n\t\td[z[1]] = z[0]\nz = input().split()\ns = ''\nfor i in z:\n\tif d.get(i, -1) == -1:\n\t\td[i] = i\n\t\ts += d[i] + ' '\n\telse:\n\t\ts += d[i] + ' '\nprint(s)\n", "(x, y) = map(int, input().split())\nd = {}\nfor i in range(y):\n\t(xx, yy) = input().split()\n\td[xx] = yy\nl = input().split()\nfor i in l:\n\tif len(i) <= len(d[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(d[i], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nst1 = {}\nst2 = {}\nfor i in range(m):\n\ts = input().split()\n\t(w1, w2) = (s[0], s[1])\n\tst1[w1] = w2\n\tst2[w2] = w1\ntest = input().split()\nfor x in test:\n\tw1 = x\n\tf = False\n\tif w1 in st1:\n\t\tf = True\n\t\tw2 = st1[w1]\n\telse:\n\t\tw2 = st2[w1]\n\tif len(w1) < len(w2):\n\t\tprint(w1, end=' ')\n\telif len(w2) < len(w1):\n\t\tprint(w2, end=' ')\n\telse:\n\t\tprint(w1 if f else w2, end=' ')\n", "def trial():\n\t(n, m) = list(map(int, input().split()))\n\tshort = {}\n\tfor i in range(m):\n\t\t(a, b) = list(map(str, input().split()))\n\t\tif len(a) > len(b):\n\t\t\tshort[a] = b\n\t\telse:\n\t\t\tshort[a] = a\n\tcase = list(map(str, input().split()))\n\tres = ''\n\tfor i in case:\n\t\tres += short[i] + ' '\n\treturn print(res)\ntrial()\n", "(n, m) = map(int, input().split())\ndict = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdict[a] = b\nk = input().split()\nfor i in k:\n\tif len(i) > len(dict[i]):\n\t\tk[k.index(i)] = dict[i]\nprint(*k)\n", "(a, b) = map(int, input().strip().split()[:2])\na1 = []\nb1 = []\nfor x in range(b):\n\t(p, q) = input().strip().split()[:2]\n\ta1.append(p)\n\tb1.append(q)\ns = input().split()[:a]\nfor x in s:\n\tk = a1.index(x)\n\tl = b1[k]\n\tif len(l) < len(a1[k]):\n\t\tprint(l, end=' ')\n\telse:\n\t\tprint(a1[k], end=' ')\n", "(a, b) = map(int, input().split())\nd = {}\nfor i in range(b):\n\t(s, s1) = input().split()\n\td[s] = s1\ns2 = list(input().split())\nr = ''\nfor k in s2:\n\tif k in d.keys():\n\t\tif len(k) <= len(d[k]):\n\t\t\tr += k + ' '\n\t\telse:\n\t\t\tr += d[k] + ' '\n\telif k in d.values():\n\t\tif len(k) < d.key(k):\n\t\t\tr += k + ' '\n\t\telse:\n\t\t\tr += d.key(k) + ' '\nprint(r)\n", "(n, m) = map(int, input().split())\nset_ele = []\nans = ''\nfor i in range(m):\n\t(l1, l2) = input().split()\n\tif len(l2) < len(l1):\n\t\tset_ele.append(l2)\n\t\tset_ele.append(l1)\n\telse:\n\t\tset_ele.append(l1)\n\t\tset_ele.append(l2)\nphrase = list(input().split())\nfor i in phrase:\n\tindex = set_ele.index(i)\n\tif index % 2 == 0:\n\t\tans += i + ' '\n\telse:\n\t\tans += set_ele[index - 1] + ' '\nprint(ans)\n", "(n, m) = map(int, input().split(' '))\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split(' ')\n\tif len(b) < len(a):\n\t\ts = b\n\telse:\n\t\ts = a\n\tdic[a] = s\n\tdic[b] = s\nprint(' '.join(map(lambda word: dic[word], input().split(' '))))\n", "(n, m) = [int(x) for x in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = d[b] = min(a, b, key=len)\ns = input().split()\nk = 0\nfor j in s:\n\tk += 1\n\tprint(d[j] + ' \\n'[k == n], end='')\n", "import os\nimport sys\nfrom math import *\nfrom io import BytesIO, IOBase\n\ndef vsInput():\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n\ndef array():\n\treturn [int(i) for i in input().split()]\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nd = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\na = [i for i in input().split()]\nfor i in a:\n\tprint(d[i], end=' ')\n", "(n, m) = map(int, input().split())\nA = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tA[a] = b\ns = input().split()\nfor i in s:\n\tl1 = len(i)\n\tl2 = len(A[i])\n\tif l1 <= l2:\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(A[i], end=' ')\n", "(n, m) = map(int, input().split())\n(l, k, f) = ([], [], [])\nfor i in range(m):\n\tb = list(input().split())\n\tl.append(b[0])\n\tk.append(b[1])\ng = list(input().split())\nfor j in range(n):\n\tt = l.index(g[j])\n\tif len(l[t]) <= len(k[t]):\n\t\tf.append(l[t])\n\telse:\n\t\tf.append(k[t])\nprint(*f)\n", "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\n\ndef main():\n\tpass\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write()\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(n, m) = map(int, input().rstrip().split())\nd = {}\nfor i in range(m):\n\t(s1, s2) = map(str, input().rstrip().split())\n\tif len(s1) <= len(s2):\n\t\td[s1] = s1\n\telse:\n\t\td[s1] = s2\nl = list(map(str, input().rstrip().split()))\nfor i in l:\n\tprint(d[i], end=' ')\n", "def main():\n\t(res, wds) = [int(x) for x in input().split()]\n\tdic = {}\n\tfor n in range(wds):\n\t\t(w1, w2) = input().split()\n\t\tdic[w1] = w2\n\tdata = input().split()\n\tfor val in data:\n\t\tprint(val if len(val) <= len(dic[val]) else dic[val], end=' ')\nmain()\n", "(n, m) = map(int, input().split())\nlist1 = []\nlist2 = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tlist1.append(a)\n\tlist2.append(b)\nlist3 = input().split()\nfor i in range(n):\n\tk = list1.index(list3[i])\n\tif len(list1[k]) > len(list2[k]):\n\t\tlist3[i] = list2[k]\nprint(' '.join(list3))\n", "from collections import defaultdict\nnm = list(map(int, input().split()))\nn = nm[0]\nm = nm[1]\nmymap = defaultdict(list)\nfor i in range(m):\n\tab = list(map(str, input().split()))\n\tmymap[ab[0]].append(ab[1])\n\tmymap[ab[0]].append(1)\n\tmymap[ab[1]].append(ab[0])\n\tmymap[ab[1]].append(2)\ninp = list(map(str, input().split()))\nres = []\nfor c in inp:\n\tif len(c) < len(mymap[c][0]):\n\t\tres.append(c)\n\telif len(c) > len(mymap[c][0]):\n\t\tres.append(mymap[c][0])\n\telif len(c) == len(mymap[c][0]):\n\t\tif mymap[c][1] == 1:\n\t\t\tres.append(c)\n\t\telse:\n\t\t\tres.append(mymap[c][0])\nfor val in res:\n\tprint(val, end=' ')\n", "(n, m) = map(int, input().split())\nd = dict()\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\td[s1] = [s1, s2][len(s2) < len(s1)]\nfor word in input().split():\n\tprint(d[word], end=' ')\n", "(n, m) = map(int, input().strip().split())\nd = {}\nfor i in range(m):\n\t(s1, s2) = input().strip().split()\n\td[s1] = s1 if len(s1) <= len(s2) else s2\narr = input().strip().split()\nprint(' '.join([d[x] for x in arr]))\n", "(n, m) = map(int, input().split())\ndc = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdc[a] = b\nwords = input().split()\nfor i in words:\n\tif len(i) <= len(dc[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(dc[i], end=' ')\n", "(n, m) = map(int, input().split())\nl = []\nz = []\nfor i in range(m):\n\t(s, d) = map(str, input().split())\n\tl.append(s)\n\tl.append(d)\ns = list(map(str, input().split()))\nfor i in range(len(s)):\n\tr = l.index(s[i])\n\tt = l[r + 1]\n\tif len(t) < len(s[i]):\n\t\ts[i] = t\nprint(*s)\n", "(n, m) = [int(x) for x in input().split(' ')]\nfirst = []\nbest = []\nfor i in range(m):\n\t(a, b) = [x for x in input().split(' ')]\n\tfirst.append(a)\n\tif len(a) <= len(b):\n\t\tbest.append(a)\n\telse:\n\t\tbest.append(b)\narray = [x for x in input().split(' ')]\nfor x in array:\n\tprint(best[first.index(x)], end=' ')\n", "(n, m) = map(int, input().split())\n(d1, d2) = (dict(), dict())\nfor i in range(m):\n\t(w1, w2) = map(str, input().split())\n\t(d1[w1], d2[w2]) = (w2, w1)\narr = list(map(str, input().split()))\nfor i in arr:\n\tif i in d1:\n\t\t(n1, n2) = (len(i), len(d1[i]))\n\t\tif n1 == n2:\n\t\t\tprint(i, end=' ')\n\t\telif n1 > n2:\n\t\t\tprint(d1[i], end=' ')\n\t\telse:\n\t\t\tprint(i, end=' ')\n\telif i in d2:\n\t\t(n1, n2) = (len(i), len(d2[i]))\n\t\tif n1 == n2:\n\t\t\tprint(d2[i], end=' ')\n\t\telif n1 < n2:\n\t\t\tprint(i, end=' ')\n\t\telif n1 > n2:\n\t\t\tprint(d2[i], end=' ')\n", "(n, m) = [int(x) for x in input().split()]\nd = dict()\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nl = input().split()\nfor i in range(n):\n\tif len(l[i]) > len(d[l[i]]):\n\t\tl[i] = d[l[i]]\nprint(' '.join(l))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\ta = input().split()\n\td[a[0]] = a[1]\nx = input().split()\nfor i in range(n):\n\tif len(x[i]) > len(d[x[i]]):\n\t\tprint(d[x[i]], end=' ')\n\telif len(x[i]) <= len(d[x[i]]):\n\t\tprint(x[i], end=' ')\n", "(n, m) = map(int, input().strip().split())\nwords = []\nfor _ in range(m):\n\tword = tuple(input().strip().split())\n\twords.append(word)\nsentence = input().strip().split()\nans = ''\nfor curr in sentence:\n\tfor word in words:\n\t\tif word[0] == curr or word[1] == curr:\n\t\t\tif len(word[0]) <= len(word[1]):\n\t\t\t\tans += word[0] + ' '\n\t\t\telse:\n\t\t\t\tans += word[1] + ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\nl1 = []\nl2 = []\nkl = ''\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tl1.append(a)\n\tl2.append(b)\nanst = input().split()\nfor i in anst:\n\tk = l1.index(i)\n\tl = min(len(l1[k]), len(l2[k]))\n\tif l == len(l1[k]):\n\t\tkl += str(l1[k])\n\t\tkl += ' '\n\telse:\n\t\tkl += str(l2[k])\n\t\tkl += ' '\nprint(kl)\n", "(_, words) = [int(x) for x in input().split(' ')]\nwords_dict = dict()\nnumbers_dict = dict()\nfor index in range(words):\n\t(w1, w2) = [x for x in input().split(' ')]\n\twords_dict[w1] = words_dict[w2] = index\n\tnumbers_dict[index] = w1 if len(w1) <= len(w2) else w2\nlecture = [word for word in input().split(' ')]\nfor word in lecture:\n\tprint(numbers_dict[words_dict[word]], end=' ')\nprint()\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\tb.append(y)\ns = list(map(str, input().split()))\nf = []\nfor i in range(n):\n\tfor j in range(m):\n\t\tif a[j] == s[i] or b[j] == s[i]:\n\t\t\tf.append(a[j]) if len(a[j]) <= len(b[j]) else f.append(b[j])\nprint(*f)\n", "s = input().split()\nn = int(s[0])\nm = int(s[1])\nmass1 = {}\nmass2 = {}\nfor i in range(m):\n\ts = input().split()\n\tmass1[s[0]] = s[1]\n\tmass2[s[1]] = s[0]\ns = input()\nres = []\nfor st in s.split():\n\tif st in mass1:\n\t\tif len(st) <= len(mass1[st]):\n\t\t\tres.append(st)\n\t\telse:\n\t\t\tres.append(mass1[st])\n\telif len(st) < len(mass2[st]):\n\t\tres.append(st)\n\telse:\n\t\tres.append(mass2[st])\nprint(' '.join(res))\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(s, t) = input().split()\n\tif len(t) < len(s):\n\t\td[s] = t\nfor (i, s) in enumerate(input().split()):\n\tif i != 0:\n\t\tprint(' ', end='')\n\tif s in d:\n\t\tprint(d[s], end='')\n\telse:\n\t\tprint(s, end='')\nprint('')\n", "n1 = input().split()\ni = 0\na = {}\nwhile i < int(n1[1]):\n\tinn = input().split()\n\ta[inn[0]] = inn[1]\n\ti += 1\nletters = input().split()\nanswers = ''\nfor i in letters:\n\tif len(i) <= len(a[i]):\n\t\tanswers += i + ' '\n\telse:\n\t\tanswers += a[i] + ' '\nprint(answers)\n", "(n, m) = map(int, input().split(' '))\ndict1 = {}\nfor _ in range(m):\n\t(str1, str2) = input().split(' ')\n\tdict1[str1] = str1 if len(str1) <= len(str2) else str2\ninp = list(input().split(' '))\nresult = ''\nfor i in inp:\n\tresult += dict1[i] + ' '\nprint(result)\n", "(n, m) = map(int, input().split())\nfirst = []\nsec = []\nfor i in range(m):\n\t(l, r) = map(str, input().split())\n\tfirst.append(l)\n\tsec.append(r)\nall_ = input()\nlst = all_.split(' ')\nrem = []\nfor j in range(0, len(lst)):\n\tif lst[j] in first:\n\t\tx = first.index(lst[j])\n\t\tif len(sec[x]) < len(first[x]):\n\t\t\trem.append(sec[x])\n\t\telse:\n\t\t\trem.append(first[x])\n\telif lst[j] in sec:\n\t\tx = sec.index(lst[j])\n\t\tif len(first[x]) < len(sec[x]):\n\t\t\trem.append(first[x])\n\t\telif len(first[x]) > len(sec[x]):\n\t\t\trem.append(sec[x])\n\t\telse:\n\t\t\trem.append(first[x])\nprint(' '.join(rem))\n", "from sys import stdin, stdout\n\ndef solve(text, dic):\n\tresult = ''\n\twords = text.split()\n\tfor word in words:\n\t\tresult += '{} '.format(dic[word])\n\treturn result.rstrip()\ndic = {}\n(n, m) = list(map(int, stdin.readline().rstrip().split()))\nwhile m:\n\tm -= 1\n\t(l1, l2) = list(map(str, stdin.readline().rstrip().split()))\n\tif len(l2) < len(l1):\n\t\tdic[l1] = l2\n\telse:\n\t\tdic[l1] = l1\ntext = stdin.readline().rstrip()\nstdout.write(str(solve(text, dic)))\n", "(n, m) = [int(i) for i in input().split()]\ns = []\ns1 = []\ns2 = []\nfor j in range(m):\n\ts = s + [str(i) for i in input().split()[:2]]\nfor i in range(len(s)):\n\tif i % 2 == 0:\n\t\ts1.append(s[i])\n\telse:\n\t\ts2.append(s[i])\nf = [str(i) for i in input().split()[:n]]\nv = []\nfor i in range(m):\n\tif len(s1[i]) < len(s2[i]):\n\t\tv.append(s1[i])\n\telif len(s1[i]) == len(s2[i]):\n\t\tv.append(s1[i])\n\telse:\n\t\tv.append(s2[i])\nfor i in range(n):\n\tif f[i] in s1:\n\t\tc = s1.index(f[i])\n\telif f[i] in s2:\n\t\tc = s2.index(f[i])\n\tif len(f[i]) > len(v[c]):\n\t\tf[i] = v[c]\ng = ' '\nprint(g.join(f))\n", "nums = input().split(' ')\nn = int(nums[0])\nm = int(nums[1])\ndict = {}\nres = list()\nlst = list()\nfor i in range(m):\n\tlst = input().split(' ')\n\tt = {lst[0]: [lst[0], lst[1]]}\n\tdict.update(t)\nlec = input().split(' ')\nfor i in range(n):\n\tif len(dict[lec[i]][0]) <= len(dict[lec[i]][1]):\n\t\tres.append(dict[lec[i]][0])\n\telse:\n\t\tres.append(dict[lec[i]][1])\nprint(*res)\n", "(n, m) = map(int, input().split())\nlegend = []\nfor t in range(m):\n\t(a, b) = input().split()\n\tlegend.append((a, b))\nans = list(input().split())\ndictionary = {}\nfor j in legend:\n\tif len(j[0]) <= len(j[1]):\n\t\tdictionary[j[0]] = j[0]\n\telse:\n\t\tdictionary[j[0]] = j[1]\nfor i in range(n):\n\tans[i] = dictionary[ans[i]]\nans = ' '.join(ans)\nprint(ans)\n", "(n, m) = map(int, input().split())\nfirst = []\nsecond = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tfirst.append(a)\n\tsecond.append(b)\nc = input().split()\ny = ''\nfor i in range(n):\n\tif c[i] in first:\n\t\tx = first.index(c[i])\n\telse:\n\t\tx = second.index(c[i])\n\tif len(first[x]) <= len(second[x]):\n\t\ty += first[x] + ' '\n\telse:\n\t\ty += second[x] + ' '\nprint(y)\n", "n = list(map(int, input().rstrip().split()))\ndctt = dict()\nfor i in range(n[1]):\n\tstrr = list(map(str, input().rstrip().split()))\n\tif len(strr[0]) > len(strr[1]):\n\t\tdctt[strr[0]] = strr[1]\n\telse:\n\t\tdctt[strr[0]] = strr[0]\nnn = list(map(str, input().rstrip().split()))\nfor i in nn:\n\tprint(dctt[i], end=' ')\n", "[n, m] = [int(x) for x in input().split()]\ng = {}\nfor i in range(0, m):\n\th = input().split()\n\tg[h[0]] = h[1]\nf = input().split()\nfor i in f:\n\tif len(i) <= len(g[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(g[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = dict()\nfor i in range(m):\n\tl = input().split()\n\tif len(l[0]) <= len(l[1]):\n\t\td[l[0]] = l[0]\n\telse:\n\t\td[l[0]] = l[1]\nans_list = input().split()\nfor i in range(n):\n\tprint(d.get(ans_list[i]), end=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tdic[a] = b\nlst = list(input().split())\nfor i in lst:\n\tprint([i, dic[i]][len(i) > len(dic[i])], end=' ')\n", "def lecture(dct, sentence):\n\tlst = []\n\tfor word in sentence:\n\t\tmapp = dct[word]\n\t\tif len(mapp) < len(word):\n\t\t\tlst.append(mapp)\n\t\telse:\n\t\t\tlst.append(word)\n\treturn ' '.join(lst)\n(n, m) = map(int, input().split())\ndct = {}\nfor _ in range(m):\n\twords = input().split(' ')\n\tdct[words[0]] = words[1]\nsentence = input().split(' ')\nprint(lecture(dct, sentence))\n", "num_input = input()\nnum_input = num_input.split(' ')\nn = int(num_input[0])\nm = int(num_input[1])\nmap = {}\nfor i in range(0, m):\n\tinput_string = input()\n\tinput_string = input_string.split(' ')\n\tfirst = input_string[0]\n\tsecond = input_string[1]\n\tmap[first] = second\nn_string = input()\nn_string = n_string.split(' ')\nfor i in range(0, len(n_string)):\n\tif len(n_string[i]) > len(map[n_string[i]]):\n\t\tn_string[i] = map[n_string[i]]\nn_string = ' '.join(n_string)\nprint(n_string)\n", "(n, m) = map(int, input().split())\nk = dict()\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tk[a] = a\n\telse:\n\t\tk[a] = b\nc = list(input().split())\nfor i in c:\n\tprint(k[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nf = []\nfor i in range(m):\n\tc = {}\n\te = {}\n\t(a, b) = input().split(' ')\n\tif len(a) <= len(b):\n\t\tc = {b: a}\n\t\te = {a: a}\n\t\td.update(c)\n\t\td.update(e)\n\telse:\n\t\tc = {a: b}\n\t\te = {b: b}\n\t\td.update(c)\n\t\td.update(e)\nwq = list(input().split(' '))\nfor i in wq:\n\tf.append(d[i])\nprint(*f)\n", "diction = {}\n(n, m) = [int(i) for i in input().split()]\nfor i in range(m):\n\t(a, b) = [i for i in input().split()]\n\tdiction[a] = b\nlecture = [i for i in input().split()]\nfor (i, word) in enumerate(lecture):\n\tif len(word) > len(diction[word]):\n\t\tlecture[i] = diction[word]\nsp = ' '\nprint(sp.join(lecture))\n", "([n, m], word_map) = ([int(i) for i in input().split()], {})\nfor i in range(m):\n\t[word_1, word_2] = input().split()\n\tword = word_1 if len(word_1) <= len(word_2) else word_2\n\tword_map[word_1] = word\n\tword_map[word_2] = word\nsentence = map(lambda x: word_map[x], input().split())\nprint(' '.join([x for x in sentence]))\n", "import sys\n(number, words) = map(int, sys.stdin.readline().split())\nlistofwords = dict()\nfor index in range(words):\n\t(w1, w2) = sys.stdin.readline().rstrip('\\n').split()\n\tif len(w2) < len(w1):\n\t\tlistofwords[w2] = w2\n\t\tlistofwords[w1] = w2\n\telse:\n\t\tlistofwords[w2] = w1\n\t\tlistofwords[w1] = w1\nlecture = sys.stdin.readline().rstrip('\\n').split()\nsoln = [listofwords[word] for word in lecture]\nprint(' '.join(soln))\n", "import sys\n(n, m) = sys.stdin.readline().strip().split(' ')\n(n, m) = (int(n), int(m))\nd = {}\nfor i in range(0, m):\n\t(a, b) = sys.stdin.readline().strip().split(' ')\n\tif len(a) <= len(b):\n\t\td[a] = a\n\t\td[b] = a\n\telse:\n\t\td[a] = b\n\t\td[b] = b\nl = sys.stdin.readline().strip().split(' ')\nres = []\nfor s in l:\n\tres.append(d[s])\np = ' '\nprint(p.join(res))\n", "p = input()\n(n, m) = map(int, p.split())\nq = []\nw = []\nfor i in range(m):\n\tr = input()\n\tr = r.split()\n\tif len(r[0]) <= len(r[1]):\n\t\tw.append(r[0])\n\telse:\n\t\tw.append(r[1])\n\tq.append(r[0])\nt = input()\nt = t.split()\nc = ''\nfor j in t:\n\tc += w[q.index(j)] + ' '\nprint(c)\n", "(n, m) = map(int, input('').split())\nl = [()]\nfor i in range(m):\n\tsp = input('').split()\n\tif len(sp[1]) >= len(sp[0]):\n\t\tsp[1] = ''\n\tl += [(sp[0], sp[1])]\np = list(map(str, input('').split(' ')))\nl = l[1:]\n\ndef pppp(x):\n\tfor i in l:\n\t\tif i[0] == x:\n\t\t\tif not i[1] == '':\n\t\t\t\treturn i[1]\n\t\t\telse:\n\t\t\t\treturn i[0]\nk = ''\nfor i in range(len(p)):\n\tk += pppp(p[i]) + ' '\nprint(k[:-1])\n", "(n, m) = map(int, input().split())\na = []\nb = []\narr = []\nfor i in range(m):\n\t(q, w) = map(str, input().split())\n\ta.append(q)\n\tb.append(w)\nc = list(map(str, input().split()))\nfor i in range(n):\n\tp = a.index(c[i])\n\tif len(a[p]) <= len(b[p]):\n\t\tarr.append(a[p])\n\telse:\n\t\tarr.append(b[p])\nprint(' '.join(arr))\n", "def ii():\n\treturn int(input())\n\ndef ss():\n\treturn [x for x in input()]\n\ndef si():\n\treturn [int(x) for x in input().split()]\n\ndef mi():\n\treturn map(int, input().split())\n(a, b) = mi()\ns1 = {}\nfor i in range(b):\n\tit = input().split()\n\ts1[it[0]] = it[1]\nc = input().split()\nfor i in c:\n\tif len(i) > len(s1[i]):\n\t\tprint(s1[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = [int(i) for i in input().split()]\na = [0] * m\nb = [0] * m\nfor i in range(m):\n\t(a[i], b[i]) = input().split()\nres = ''\nfor i in input().split():\n\tind = a.index(str(i))\n\tif len(a[ind]) > len(b[ind]):\n\t\tres += b[ind] + ' '\n\telse:\n\t\tres += a[ind] + ' '\nprint(res[:len(res) - 1])\n", "first_line = list(map(int, input().split(' ')))\nlength_speech = first_line[0]\ndictionary_len = first_line[1]\ndict = {}\nfor i in range(dictionary_len):\n\tline = list(input().split(' '))\n\tdict[line[0]] = line[1]\nspeech = list(input().split(' '))\nfor i in range(len(speech)):\n\tw = speech[i]\n\tif len(dict[w]) < len(w):\n\t\tspeech[i] = dict[w]\nprint(' '.join(speech))\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(st1, st2) = input().split()\n\ta.append(st1)\n\tb.append(st2)\nl = list(input().split())\nresult = []\nfor item in l:\n\tif a.count(item) > 0:\n\t\tindex = a.index(item)\n\t\tif len(a[index]) <= len(b[index]):\n\t\t\tresult.append(a[index])\n\t\telse:\n\t\t\tresult.append(b[index])\n\telse:\n\t\tindex = b.index(item)\n\t\tif len(a[index]) <= len(b[index]):\n\t\t\tresult.append(a[index])\n\t\telse:\n\t\t\tresult.append(b[index])\nprint(*result)\n", "(n, m) = map(int, input().split())\ndictionary = []\nfor i in range(m):\n\ta = [i for i in input().split()]\n\tif len(a[1]) < len(a[0]):\n\t\t(a[0], a[1]) = (a[1], a[0])\n\tdictionary.append(a)\ns = input().split()\nfor i in s:\n\tfor j in dictionary:\n\t\tif i in j:\n\t\t\tprint(j[0], end=' ')\n", "(n, m) = map(int, input().split())\ndc = {}\nfor i in range(m):\n\ta = input().split()\n\tdc[a[0]] = a[1]\nmat = input().split()\nfor word in mat:\n\tif len(word) > len(dc[word]):\n\t\tprint(dc[word], end=' ')\n\telse:\n\t\tprint(word, end=' ')\n", "(n, m) = map(int, input().split())\nwords = dict()\nfor _ in range(m):\n\t(s1, s2) = map(str, input().split())\n\twords[s1] = s2\nres = ''\nsent = input().split()\nfor word in sent:\n\tif len(word) > len(words[word]):\n\t\tres += words[word]\n\telse:\n\t\tres += word\n\tres += ' '\nprint(res)\n", "n = int(input().split()[1])\nd = {}\nfor i in range(0, n):\n\ta = input().split()\n\td[a[0]] = a[1]\nwords = input().split()\nans = ''\nfor i in words:\n\tif len(d[i]) < len(i):\n\t\tans += d[i]\n\telse:\n\t\tans += i\n\tans += ' '\nams = ans[:-1]\nprint(ans)\n", "scann = input()\nnumbers = scann.split()\nn = numbers[0]\nm = numbers[1]\nn_aux = int(n)\nm_aux = int(m)\nultimo = [1]\nb = []\ns = [None for x in range(n_aux)]\nfor i in range(m_aux):\n\thola = input()\n\tb.append(hola.split())\nhola = input()\nultimo[0] = hola.split()\nfor i in range(n_aux):\n\tfor j in range(m_aux):\n\t\tif ultimo[0][i] == b[j][0] or ultimo[0][i] == b[j][1]:\n\t\t\tif int(len(b[j][0])) <= int(len(b[j][1])):\n\t\t\t\ts[i] = b[j][0]\n\t\t\telse:\n\t\t\t\ts[i] = b[j][1]\nprint(' '.join(s))\n", "D_1 = []\nD_2 = []\nInpt = list(map(int, input().split()))\nfor I in range(Inpt[1]):\n\tIn = list(map(str, input().split()))\n\tD_1.append(In[0])\n\tD_2.append(In[1])\nM = list(map(str, input().split()))\nResult = []\nfor I in range(len(M)):\n\ttry:\n\t\tInd = D_1.index(str(M[I]))\n\texcept ValueError:\n\t\tInd = D_2.index(str(M[I]))\n\tif len(D_2[Ind]) < len(D_1[Ind]):\n\t\tResult.append(D_2[Ind])\n\telse:\n\t\tResult.append(D_1[Ind])\nfor A in Result:\n\tprint(A, end=' ')\n", "(n, f) = map(int, input().split())\nd = {}\nfor i in range(f):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\td[a] = b\n\telse:\n\t\td[b] = a\ns = list(input().split())\nans = []\nfor i in s:\n\tans.append(d.get(i, i))\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\nl1 = []\nl2 = []\nfor _ in range(m):\n\t(a, b) = input().split()\n\tl1.append(a)\n\tl2.append(b)\nlect = list(input().split())\nlp = []\nfor i in lect:\n\tind = l1.index(i)\n\tif len(l2[ind]) < len(i):\n\t\tlp.append(l2[ind])\n\telse:\n\t\tlp.append(i)\nprint(*lp, sep=' ')\n", "list_input = list(map(int, input().split()))\nn = list_input[0]\nm = list_input[1]\nd = dict()\nfor i in range(m):\n\twords = input().split()\n\tshorter = ''\n\tif len(words[0]) <= len(words[1]):\n\t\tshorter = words[0]\n\telse:\n\t\tshorter = words[1]\n\td[words[0]] = shorter\nlectures = input().split()\nfor word in lectures:\n\tprint(d[word], end=' ')\n", "import functools\n(n, m) = (int(x) for x in input().split(' '))\nlang = {}\nfor i in range(0, m):\n\t(a, b) = (x for x in input().split(' '))\n\tif len(a) > len(b):\n\t\tlang[a] = b\n\telse:\n\t\tlang[b] = a\n\ndef shorter(x):\n\tif x in lang:\n\t\treturn lang[x]\n\telse:\n\t\treturn x\nprint(functools.reduce(lambda x, y: x + ' ' + y, [shorter(x) for x in input().split()]))\n", "f = lambda : map(int, input().split())\n(n, m) = f()\nd = dict()\nfor i in range(m):\n\t(x, y) = input().split()\n\td[x] = y\ns = list(input().split())\nfor i in s:\n\tprint([i, d[i]][len(i) > len(d[i])], end=' ')\n", "d = dict()\n(n, m) = map(int, input().split())\nfor i in range(m):\n\tpair = input().split()\n\td[pair[0]] = pair[1]\ns = input().split()\nfor word in s:\n\tif len(word) <= len(d[word]):\n\t\tprint(word, end=' ')\n\telse:\n\t\tprint(d[word], end=' ')\n", "(n, m) = map(int, input().split())\nwords = {}\nfor i in range(m):\n\t(w1, w2) = input().split()\n\tif len(w2) < len(w1):\n\t\twords[w1] = w2\n\telse:\n\t\twords[w1] = w1\nfor word in input().split():\n\tprint(words[word], end=' ')\n", "(n, m) = map(int, input().split())\na = dict((input().split() for i in range(m)))\ns = ''\nfor i in input().split():\n\ts = s + ' ' + min((i, a[i]), key=len)\nprint(s)\n", "(n, m) = map(int, input().split())\na = {}\nfor _ in range(m):\n\ti = input().split()\n\tif len(i[0]) > len(i[1]):\n\t\ta[i[0]] = i[1]\nc = input().split()\nfor x in c:\n\tif x in a:\n\t\tprint(a[x], end=' ')\n\telse:\n\t\tprint(x, end=' ')\n", "(q, n) = list(map(int, input().split()))\nd = {}\nfor _ in range(n):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\td[a] = b\n\telse:\n\t\td[a] = a\ns = input().split()\nfor i in s:\n\tprint(d[i], end=' ')\n", "(n, m) = map(int, input().split())\nd = dict()\nfor _ in range(m):\n\t(a, b) = input().split()\n\td[a] = b if len(b) < len(a) else a\ns = input().split()\na = []\nfor w in s:\n\ta.append(d[w])\nprint(' '.join(a))\n", "(n, m) = map(int, input().split())\np = {}\np1 = {}\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\tif len(s2) < len(s1):\n\t\tp[s1] = s2\n\t\tp1[s1] = 1\n\telse:\n\t\tp[s2] = s1\n\t\tp1[s2] = int(1)\nl = list(map(str, input().split()))\nfor i in range(n):\n\ttry:\n\t\tprint(p[l[i]], end=' ')\n\texcept:\n\t\tprint(l[i], end=' ')\n", "(n, m) = map(int, input().split())\nwords = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\twords[a] = a if len(a) <= len(b) else b\nlecture = input().split()\nprint(' '.join((words[w] for w in lecture)))\n", "(n, m) = map(int, input().split())\ns = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\ts[a] = b\nline = list(input().split())\nfor i in line:\n\tif len(i) > len(s[i]):\n\t\tprint(s[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nl = list()\nAcopy = list()\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tl.append(b)\n\telse:\n\t\tl.append(a)\n\tAcopy.append(a)\narr = list(input().split())\nfor i in range(n):\n\tprint(l[Acopy.index(arr[i])], end=' ')\n", "(n, m) = map(int, input().split())\ndicts = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\tb = a\n\tdicts[a] = b\n\ndef lookup(x):\n\treturn dicts[x]\nresult = list(map(lookup, input().split()))\nprint(' '.join(result))\n", "(n, m) = [int(i) for i in input().split()]\nmydic = {}\nfor i in range(m):\n\t(first, second) = input().split()\n\tmydic[first] = second\na = input().split()\nfor elem in a:\n\tif len(mydic[elem]) < len(elem):\n\t\tprint(mydic[elem], end=' ')\n\telse:\n\t\tprint(elem, end=' ')\n", "def main():\n\t(n, m) = map(int, input().split(' '))\n\tlan = {}\n\tfor _ in range(m):\n\t\t(a, b) = map(str, input().split(' '))\n\t\tlan[a] = b\n\t\tlan[b] = a\n\tnote = list(input().split(' '))\n\tans = ''\n\tfor w in note:\n\t\ttemp = lan[w]\n\t\tans += lan[temp] if len(lan[temp]) <= len(temp) else temp\n\t\tans += ' '\n\tprint(ans)\nmain()\n", "(a, b) = map(int, input().split())\nd = {}\nfor i in range(b):\n\t(c, e) = map(str, input().split())\n\tif len(c) <= len(e):\n\t\te = c\n\telse:\n\t\te = e\n\td[c] = e\ne = list(map(str, input().split()))\nfor i in e:\n\tprint(d[i], end=' ')\n", "(x, y) = map(int, input().split())\n(li1, li2) = ([], [])\nfor i in range(y):\n\t(j, k) = input().split()\n\tli1.append(j)\n\tli2.append(k)\nli = list(input().split())\nans = ''\nfor i in li:\n\ta = li1.index(i)\n\tif len(li1[a]) <= len(li2[a]):\n\t\tans += f'{i} '\n\telse:\n\t\tans += f'{li2[a]} '\nprint(ans)\n", "(n, m) = map(int, input().split())\ni = [input().split() for _ in range(m)]\nlanguage = {x: (x, y)[len(y) < len(x)] for (x, y) in i}\nout = [language[x] for x in input().split()]\nprint(' '.join(out))\n", "(n, m) = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = [1, b]\n\td[b] = [2, a]\ns = input().split()\nfor i in range(len(s)):\n\tif len(s[i]) > len(d[s[i]][1]):\n\t\ts[i] = d[s[i]][1]\n\telif len(s[i]) == len(d[s[i]][1]):\n\t\tif d[s[i]][0] == 2:\n\t\t\ts[i] = d[s[i]][1]\nprint(' '.join(s))\n", "a = []\nb = []\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(s1, s2) = input().split()\n\ta.append(s1)\n\tb.append(s2)\ns = input().split()\nfor i in s:\n\tif len(a[a.index(i)]) <= len(b[a.index(i)]):\n\t\tprint(a[a.index(i)], end=' ')\n\telse:\n\t\tprint(b[a.index(i)], end=' ')\n", "def main():\n\trdl = list(map(int, input().split()))\n\t(n, m) = rdl\n\twords = []\n\tfor i in range(m):\n\t\trdl = input().split()\n\t\twords.append(rdl[0])\n\t\twords.append(rdl[1])\n\trdl = input().split()\n\tourNotePad = []\n\tfor i in rdl:\n\t\tj = words.index(i)\n\t\tif j % 2 == 0:\n\t\t\tif len(words[j]) <= len(words[j + 1]):\n\t\t\t\tourNotePad.append(words[j])\n\t\t\telse:\n\t\t\t\tourNotePad.append(words[j + 1])\n\t\telif len(words[j - 1]) <= len(words[j]):\n\t\t\tourNotePad.append(words[j - 1])\n\t\telse:\n\t\t\tourNotePad.append(words[j])\n\tfor i in range(len(ourNotePad)):\n\t\tif i != len(ourNotePad) - 1:\n\t\t\tprint(ourNotePad[i], end=' ')\n\t\telse:\n\t\t\tprint(ourNotePad[i])\nmain()\n", "(n, m) = map(int, input().split())\ndic = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tdic[a] = b\ns = list(map(str, input().split()))\nans = []\nfor i in s:\n\tif len(i) <= len(dic[i]):\n\t\tans.append(i)\n\telse:\n\t\tans.append(dic[i])\nprint(' '.join(ans))\n", "i = lambda : input().split()\nm = int(i()[1])\nd = {}\nfor _ in [0] * m:\n\t(x, y) = i()\n\ta = min(x, y, key=len)\n\td.update([(x, a), (y, a)])\nprint(*[d[x] for x in i()])\n", "(lecture_length, dictionary_length) = map(int, input().split())\ndictionary = {}\nfor i in range(dictionary_length):\n\t(source, translation) = input().split()\n\tdictionary[source] = translation\nlecture = input().split()\nres = []\nfor word in lecture:\n\ttranslation = dictionary[word]\n\t(source_lang_legth, knows_lang_length) = (len(word), len(translation))\n\tif source_lang_legth == knows_lang_length or source_lang_legth < knows_lang_length:\n\t\tres.append(word)\n\telse:\n\t\tres.append(translation)\nprint(' '.join(res))\n", "(n, m) = map(int, input().split())\nboth_idioms = dict((input().split() for _ in range(m)))\na_list = [x for x in input().split()]\nfinal_list = []\nfor key in a_list:\n\tvalue = both_idioms.get(key)\n\tif len(key) <= len(value):\n\t\tfinal_list.append(key)\n\telse:\n\t\tfinal_list.append(value)\nprint(' '.join(final_list))\n", "dic = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(a, b) = input().split()\n\tdic[b] = a\n\tdic[a] = b\nls = []\nm = input().split()\nfor i in range(len(m)):\n\tif len(m[i]) > len(dic[m[i]]):\n\t\tls.append(dic[m[i]])\n\telse:\n\t\tls.append(m[i])\nprint(*ls)\n", "(a, b) = map(int, input().split(' '))\nd = dict((input().split(' ') for i in range(b)))\nprint(' '.join((min((n, d[n]), key=len) for n in input().split(' '))))\n", "(n, m) = map(int, input().split())\nv = dict()\np = set()\nfor i in range(m):\n\ta = input().split()\n\tif len(a[0]) > len(a[1]):\n\t\tp.add(a[0])\n\t\tv[a[0]] = a[1]\nc = input().split()\nfor i in range(n):\n\tif c[i] in p:\n\t\tprint(v[c[i]], end=' ')\n\telse:\n\t\tprint(c[i], end=' ')\n", "(a, b) = map(int, input().split())\ndic = {}\nfor i in range(b):\n\ta = input().split(' ')\n\tif len(a[0]) > len(a[1]):\n\t\tdic[a[0]] = a[1]\n\t\tdic[a[1]] = a[1]\n\telse:\n\t\tdic[a[0]] = a[0]\n\t\tdic[a[1]] = a[0]\nt = input().split()\nfor i in range(len(t)):\n\tprint(dic[t[i]], end=' ')\n", "(n, m) = map(int, input().split())\n(a, b) = ([''] * m, [''] * m)\nfor i in range(0, m):\n\t(a[i], b[i]) = map(str, input().split())\np = [str(x) for x in input().split()]\nfor i in p:\n\tif i in a:\n\t\tx = a.index(i)\n\t\tif len(a[x]) <= len(b[x]):\n\t\t\tprint(a[x], end=' ')\n\t\telse:\n\t\t\tprint(b[x], end=' ')\n\telse:\n\t\tx = b.index(i)\n\t\tif len(a[x]) <= len(b[x]):\n\t\t\tprint(a[x], end=' ')\n\t\telse:\n\t\t\tprint(b[x], end=' ')\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nd = {}\nfor _ in range(m):\n\t(w1, w2) = input().split()\n\tif len(w1) > len(w2):\n\t\td[w1] = w2\n\telse:\n\t\td[w2] = w1\nlecture = input().split()\nans = []\nfor word in lecture:\n\tif word in d:\n\t\tans.append(d[word])\n\telse:\n\t\tans.append(word)\nprint(' '.join(ans))\n", "def main():\n\t(n, m) = map(int, input().split())\n\ttrans = {}\n\tfor i in range(m):\n\t\t(a, b) = input().split()\n\t\tif len(a) > len(b):\n\t\t\ttrans[a] = b\n\t\telse:\n\t\t\ttrans[a] = a\n\ts = input().split()\n\tnotes = []\n\tfor word in s:\n\t\tnotes.append(trans[word])\n\tprint(' '.join(notes))\nmain()\n", "(n, m) = [int(x) for x in input().strip().split()]\nword_dict = {}\nfor i in range(m):\n\t(a_i, b_i) = [str(x) for x in input().strip().split()]\n\tif len(a_i) <= len(b_i):\n\t\tword_dict[a_i] = a_i\n\t\tword_dict[b_i] = a_i\n\telse:\n\t\tword_dict[a_i] = b_i\n\t\tword_dict[b_i] = b_i\nlecture_words = [str(x) for x in input().strip().split()]\ntranslated_words = []\nfor word in lecture_words:\n\ttranslated_words.append(word_dict[word])\nprint(' '.join(translated_words))\n", "(n, m) = map(int, input().split())\ndict = {}\nnote = ''\nfor i in range(m):\n\t(word1, word2) = input().split()\n\tdict[word1] = word2\nprof_words = list(input().split())\nfor word in prof_words:\n\tif len(word) <= len(dict[word]):\n\t\tnote += word + ' '\n\telse:\n\t\tnote += dict[word] + ' '\nprint(note)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[b] = a\n\t\td[a] = a\n\telse:\n\t\td[a] = b\n\t\td[b] = b\nlecture = input().split()\noutput = []\nfor w in lecture:\n\toutput.append(d[w])\nprint(*output)\n", "(n, m) = map(int, input().split())\nwords = dict()\nfor i in range(m):\n\t(a, b) = input().split()\n\twords[a] = b\nlection = list(input().split())\nfor i in range(n):\n\tif len(lection[i]) > len(words[lection[i]]):\n\t\tlection[i] = words[lection[i]]\nprint(' '.join(lection))\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(k, v) = input().split()\n\tdic[k] = v\nst = input().split()\nfor i in range(n):\n\tif len(dic[st[i]]) < len(st[i]):\n\t\tst[i] = dic[st[i]]\n\telse:\n\t\tpass\nprint(*st)\n", "import re\nreplacement = dict()\n(n, m) = map(int, input().split(' '))\nfor i in range(m):\n\t(lone, ltwo) = input().split(' ')\n\tif len(ltwo) < len(lone):\n\t\treplacement[lone] = ltwo\nlecture = input()\nfor (word, repl) in replacement.items():\n\tlecture = re.sub('\\\\b%s\\\\b' % word, repl, lecture)\nprint(lecture)\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\ta.append(x)\n\tb.append(y)\nlecture = list(map(str, input().split()))\nfor i in range(len(lecture)):\n\tindx = a.index(lecture[i])\n\taLen = len(lecture[i])\n\tbLen = len(b[indx])\n\tif bLen < aLen:\n\t\tprint(b[indx], end=' ')\n\telse:\n\t\tprint(a[indx], end=' ')\n", "(n, m) = map(int, input().split())\nans = []\ndic = {}\nfor i in range(m + 1):\n\tif i == m:\n\t\tcom = list(input().split())\n\telse:\n\t\t(a, b) = input().split()\n\t\tdic[a] = b\nfor item in com:\n\tif len(item) <= len(dic[item]):\n\t\tprint(item, end=' ')\n\telse:\n\t\tprint(dic[item], end=' ')\n", "(n, m) = map(int, input().split())\n(ans, s, d) = ([], [], [])\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\ts.append(a)\n\t\td.append(b)\n\telse:\n\t\ts.append(b)\n\t\td.append(a)\np = list(map(str, input().split()))\nfor i in range(n):\n\tif p[i] not in s:\n\t\ttemp = d.index(p[i])\n\t\tans.append(s[temp])\n\telse:\n\t\tans.append(p[i])\nprint(*ans)\n", "from collections import defaultdict\n\ndef sexy(a, b):\n\tif len(a) > len(b):\n\t\treturn b\n\telse:\n\t\treturn a\n(n, m) = map(int, input().split())\nx = defaultdict(lambda : 'z' * 26)\nfor i in range(m):\n\t(a, b) = input().split()\n\tx[a] = b\ny = input().split()\nfor i in y:\n\tprint(sexy(i, x[i]), end=' ')\nprint()\n", "(n, k) = map(int, input().split())\nd = {}\nv = []\nfor i in range(k):\n\t(x, y) = map(str, input().split())\n\tif x not in d:\n\t\td[x] = y\ns = list(map(str, input().split()))\nfor i in s:\n\tif i in d:\n\t\tif len(i) <= len(d[i]):\n\t\t\tv.append(i)\n\t\telse:\n\t\t\tv.append(d[i])\nprint(' '.join(v))\n", "(n, m) = map(int, input().split())\nlang = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\tlang[x] = (x, y)\nlect = input().split()\nnotes = []\nfor item in lect:\n\tone = len(lang[item][0])\n\ttwo = len(lang[item][1])\n\tif one > two:\n\t\tnotes.append(lang[item][1])\n\telse:\n\t\tnotes.append(lang[item][0])\nprint(*notes)\n", "palavras = input().split()\ndicionario = {}\nfor line in range(int(palavras[1])):\n\ttermo = input().split()\n\tdicionario[termo[0]] = termo[1]\ntexto = input().split()\nnova = []\nfor entrada in texto:\n\tif dicionario[entrada]:\n\t\tif len(dicionario[entrada]) >= len(entrada):\n\t\t\tnova.append(entrada)\n\t\telse:\n\t\t\tnova.append(dicionario[entrada])\n\telse:\n\t\tfor (l1, l2) in dicionario.items():\n\t\t\tif l2 == entrada:\n\t\t\t\tif len(entrada) < len(l1):\n\t\t\t\t\tnova.append(entrada)\n\t\t\t\telse:\n\t\t\t\t\tnova.append(l1)\nprint(*nova)\n", "(n, m) = [int(x) for x in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = [x for x in input().split()]\n\tif len(a) <= len(b):\n\t\tc = a\n\telse:\n\t\tc = b\n\td[a] = c\n\td[b] = c\ntext = input().split()\nfor word in text:\n\tprint(d[word], end=' ')\n", "(n, m) = [int(x) for x in input().split()]\nd = {}\nfor _ in range(m):\n\t(s1, s2) = [x for x in input().split()]\n\tl1 = len(s1)\n\tl2 = len(s2)\n\tif l1 > l2:\n\t\td[s1] = s2\n\telse:\n\t\td[s1] = s1\narr = [x for x in input().split()]\nfor i in arr:\n\tprint(d[i], end=' ')\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor j in range(m):\n\ts = input().split(' ')\n\t(n1, n2) = (len(s[0]), len(s[1]))\n\t(d[s[0]], d[s[1]]) = (s[1], s[0])\n\tif n1 > n2:\n\t\td[s[1]] = s[1]\n\telse:\n\t\td[s[0]] = s[0]\nt = input().split(' ')\nfor elem in t:\n\tprint(d[elem], end=' ')\n", "a = list(map(int, input().split()))\nm = a[0]\nn = a[1]\ni = 0\nb = []\nwhile i < n:\n\tb += list(map(str, input().split()))\n\ti += 1\nc = list(map(str, input().split()))\nz = 0\nd = []\nwhile z < m:\n\tt = b.index(c[z])\n\tk = list(b[t])\n\ti = len(k)\n\tif t % 2 == 0:\n\t\tf = list(b[t + 1])\n\t\tj = len(f)\n\t\tl = 1\n\tif t % 2 == 1:\n\t\tf = list(b[t - 1])\n\t\tj = len(f)\n\t\tl = -1\n\tif i <= j:\n\t\td.append(b[t])\n\telse:\n\t\td.append(b[t + l])\n\tz += 1\nprint(' '.join(d))\n", "(n, m) = map(int, input().split())\nmydict = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(b) < len(a):\n\t\tmydict[a] = b\n\telse:\n\t\tmydict[a] = a\nz = list(map(str, input().split()))\nfor i in z:\n\tprint(mydict[i], end=' ')\n", "(n, m) = list(map(int, input().split()))\ns = list((sorted(input().split(), key=lambda x: len(x), reverse=0) for i in range(m)))\nm = dict(((s[i // 2][i % 2], s[i // 2][0]) for i in range(m * 2)))\nprint(' '.join(list(map(lambda x: m[x], input().split()))))\n", "(x, y) = map(int, input().split())\np = list()\nfor i in range(y):\n\t(a, b) = map(str, input().split())\n\tp.append(a)\n\tp.append(b)\nk = list(map(str, input().split()))\nfor i in k:\n\tl = p.index(i) + 1\n\tif len(i) <= len(p[l]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(p[l], end=' ')\n", "(x, y) = map(int, input('').split())\nsubList = []\nfor i in range(y):\n\tn = str(input()).split()\n\tsubList.append(n[0])\n\tsubList.append(n[1])\nmainList = list(str(input()).split(' '))\nfinalList = []\nfor i in range(x):\n\tind = subList.index(mainList[i])\n\tif len(subList[ind]) <= len(subList[ind + 1]):\n\t\tfinalList.append(subList[ind])\n\telse:\n\t\tfinalList.append(subList[ind + 1])\nfor i in finalList:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().strip().split(' '))\nlanga = {}\nlangb = {}\nfor i in range(m):\n\ttmp = input().split(' ')\n\tlanga[tmp[0]] = [len(tmp[0]), tmp[1]]\n\tlangb[tmp[1]] = len(tmp[1])\nc = input().split(' ')\nans = ''\nfor j in c:\n\tif langa[j][0] <= langb[langa[j][1]]:\n\t\tans += j + ' '\n\telse:\n\t\tans += langa[j][1] + ' '\nprint(ans.strip())\n", "(n, m) = [int(i) for i in input().split()]\nd = dict()\nfor i in range(m):\n\t(s, s2) = input().split()\n\td[s] = s2\nfor s in input().split():\n\tif len(d[s]) < len(s):\n\t\tprint(d[s], end=' ')\n\telse:\n\t\tprint(s, end=' ')\n", "from sys import stdin\nf = []\ns = []\n(n, m) = [int(c) for c in stdin.readline().split()]\nfor _ in range(0, m):\n\t(x, y) = stdin.readline().split()\n\tf.append(x)\n\ts.append(y)\nind = 0\nnote = ''\nlecture = stdin.readline().split()\nfor w in lecture:\n\tind = f.index(w)\n\tif len(s[ind]) < len(f[ind]):\n\t\tnote = note + ' ' + s[ind]\n\telse:\n\t\tnote = note + ' ' + w\nprint(note[1:])\n", "(n, m) = map(int, input().split())\nL1 = []\nL2 = []\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tL1.append(a)\n\tL2.append(b)\nL = list(map(str, input().split()))\nL3 = []\nfor i in range(len(L)):\n\tf = L1.index(L[i])\n\tif len(L1[f]) <= len(L2[f]):\n\t\tL3.append(L1[f])\n\telse:\n\t\tL3.append(L2[f])\na = ' '.join(L3)\nprint(a)\n", "def min_by_len(a, b):\n\tif len(b) < len(a):\n\t\treturn b\n\telse:\n\t\treturn a\nnm = input().split(' ')\nn = int(nm[0])\nm = int(nm[1])\ntranslations = {}\nfor i in range(m):\n\tpair = input().split(' ')\n\ttranslations[pair[0]] = pair[1]\nlecture = input()\nresult = ''\nfor word in lecture.split(' '):\n\tresult += min_by_len(word, translations[word]) + ' '\nprint(result[:-1])\n", "import sys\n\ndef read_from_stdin():\n\t(n, m) = input().split()\n\tlanguage = {}\n\tfor i in range(int(m)):\n\t\t(word1, word2) = input().split()\n\t\tif len(word1) > len(word2):\n\t\t\tlanguage[word1] = word2\n\t\telse:\n\t\t\tlanguage[word2] = word1\n\tlecture = input().split()\n\treturn (lecture, language)\n\ndef write_to_stdout(res):\n\tsys.stdout.write('%s\\n' % res)\n\ndef get_answer(lecture, language):\n\tnew_lecture = []\n\tfor word in lecture:\n\t\tif word in language:\n\t\t\tnew_lecture.append(language[word])\n\t\telse:\n\t\t\tnew_lecture.append(word)\n\treturn ' '.join(new_lecture)\n\ndef main():\n\t(lecture, language) = read_from_stdin()\n\tres = get_answer(lecture, language)\n\twrite_to_stdout(res)\nmain()\n", "def chose_word(w, Languages):\n\tfor l in Languages:\n\t\tif w in l:\n\t\t\tif len(l[0]) <= len(l[1]):\n\t\t\t\treturn l[0]\n\t\t\telse:\n\t\t\t\treturn l[1]\n\treturn ''\n(n, m) = map(int, input().split())\nL = []\nfor i in range(m):\n\tlanguage = input().split()\n\tL.append(language)\nwords = input().split()\nfor w in words:\n\tprint(chose_word(w, L), end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\td.update({a: b})\nl = list(input().split())\nfor i in range(n):\n\tx = l[i]\n\tif len(x) > len(d[x]):\n\t\tl[i] = d[x]\nfor i in l:\n\tprint(i, end=' ')\nprint()\n", "(n, m) = map(int, input().split())\nf1 = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\tf1[x.strip()] = y.strip()\nline = input().split()\nres = ''\nfor i in range(len(line)):\n\tline[i] = line[i].strip()\n\tif len(f1[line[i]]) < len(line[i]):\n\t\tres = res + f1[line[i]] + ' '\n\telse:\n\t\tres = res + line[i] + ' '\nprint(res)\n", "(n, m) = map(int, input().split())\nd = dict((input().split() for i in range(m)))\nS = input().split()\nc = 1\nS1 = ''\nfor x in S:\n\tif len(x) <= len(d[x]):\n\t\tv = x\n\telse:\n\t\tv = d[x]\n\tif c == 1:\n\t\tS1 = v\n\t\tc = 0\n\telse:\n\t\tS1 = S1 + ' ' + v\nprint(S1)\n", "(n, m) = map(int, input().split())\nl1 = []\nl = []\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tl.extend([a, b])\ns = input().split()\nans = ''\nfor i in range(n):\n\tword = s[i]\n\tind = l.index(word)\n\tif ind & 1 == 0:\n\t\tother = l[ind + 1]\n\telse:\n\t\tother = l[ind - 1]\n\tif len(word) <= len(other):\n\t\tl1.append(word)\n\telse:\n\t\tl1.append(other)\nprint(*l1)\n", "(n, m) = map(int, input().split())\ns = {}\nfor _ in [0] * m:\n\t(a, b) = input().split()\n\ts[a] = s[b] = b if len(b) < len(a) else a\nt = input().split()\nfor i in range(n):\n\tt[i] = s[t[i]]\nprint(' '.join(t))\n", "(n, m) = [int(i) for i in input().split()]\ndictionary = {}\nfor j in range(m):\n\t(word_1, word_2) = [i for i in input().split()]\n\tif len(word_1) > len(word_2):\n\t\tdictionary[word_1] = word_2\n\telse:\n\t\tdictionary[word_1] = word_1\nlection = input().split()\nresult = ''\nfor word in lection:\n\tresult += dictionary[word] + ' '\nprint(result[:-1])\n", "(n, m) = [int(x) for x in input().split()]\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(b) < len(a):\n\t\td[a] = b\n\telse:\n\t\td[a] = a\ntext = input().split()\nans = []\nfor i in text:\n\tans.append(d[i])\nprint(*ans)\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(i, j) = input().split()\n\tle = len(i)\n\tlj = len(j)\n\tif le < lj:\n\t\td[i] = i\n\telif le > lj:\n\t\td[i] = j\n\telse:\n\t\td[i] = i\nstring = input().split()\nfor j in string:\n\tx = d[j]\n\tprint(x, end='')\n\tprint(' ', end='')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\nres = ''\nfor word in input().split():\n\tres += d[word] + ' '\nprint(res[:-1])\n", "(n, m) = map(int, input().strip().split(' '))\nd = {}\nfor _ in range(m):\n\t(a, b) = input().strip().split(' ')\n\td[a] = b\ntxt = input().strip().split(' ')\nfor i in range(len(txt)):\n\ttmp = d[txt[i]]\n\tif len(tmp) < len(txt[i]):\n\t\ttxt[i] = tmp\nprint(' '.join(txt))\n", "from collections import Counter, defaultdict\nI = lambda : int(input())\nM = lambda : map(int, input().split())\nLI = lambda : list(map(str, input().split()))\n(n, m) = M()\nd = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\td[a] = b\na = LI()\nb = []\nfor i in range(len(a)):\n\tif len(a[i]) > len(d[a[i]]):\n\t\tb += [d[a[i]]]\n\telse:\n\t\tb += [a[i]]\nprint(*b)\n", "def call():\n\t(n, m) = map(int, input().split())\n\tk = {}\n\tfor _ in range(m):\n\t\t(a, b) = map(str, input().split())\n\t\tx = (b, a)[len(a) <= len(b)]\n\t\tk[a] = x\n\t\tk[b] = x\n\ttc = [x for x in input().split()]\n\ts = ''\n\tfor i in tc:\n\t\ts += k[i]\n\t\ts += ' '\n\tprint(s)\ncall()\n", "def search(li, i):\n\tstart = 0\n\tend = len(li)\n\twhile start <= end:\n\t\tmid = (start + end) // 2\n\t\tif li[mid][0] == i:\n\t\t\tbreak\n\t\telif li[mid][0] > i:\n\t\t\tend = mid - 1\n\t\telse:\n\t\t\tstart = mid + 1\n\tif len(li[mid][0]) <= len(li[mid][1]):\n\t\treturn li[mid][0]\n\telse:\n\t\treturn li[mid][1]\n\ndef sort2(li, sent):\n\tli.sort(key=lambda x: x[0])\n\tfor i in sent:\n\t\tprint(search(li, i), end=' ')\n(n, m) = [int(x) for x in input().split()]\nli = []\nfor i in range(m):\n\tx = [x for x in input().split()]\n\tli.append(x)\nsent = [x for x in input().split()]\nsort2(li, sent)\n", "__author__ = 'runekri3'\n(n, m) = map(int, input().split())\nfirst_language = []\nsecond_language = []\nsecond_is_shorter = []\nfor _ in range(m):\n\t(first, second) = input().split()\n\tfirst_language.append(first)\n\tsecond_language.append(second)\n\tsecond_is_shorter.append(len(first) > len(second))\nfinal_words = []\nfor word in input().split():\n\tindex = first_language.index(word)\n\tif second_is_shorter[index]:\n\t\tfinal_words.append(second_language[index])\n\telse:\n\t\tfinal_words.append(word)\nprint(' '.join(final_words))\n", "(n, m) = map(int, input().strip().split())\na = {}\nfor i in range(m):\n\t(x, y) = map(str, input().strip().split())\n\ta[x] = y\narr = list(map(str, input().strip().split()))\nans = []\nfor i in range(len(arr)):\n\tif len(a[arr[i]]) < len(arr[i]):\n\t\tans.append(a[arr[i]])\n\telse:\n\t\tans.append(arr[i])\nprint(*ans)\n", "a = list(map(int, input().split()))\nb = list()\ntrash = list()\nfor i in range(a[1]):\n\tc = input().split()\n\tif len(c[1]) < len(c[0]):\n\t\tb.append(c[1])\n\t\ttrash.append(c[0])\n\telse:\n\t\tb.append(c[0])\n\t\ttrash.append(c[1])\nd = input().split()\nans = ''\nfor i in range(len(d)):\n\tfor x in range(len(b)):\n\t\tif d[i] == trash[x]:\n\t\t\td[i] = b[x]\n\t\t\tbreak\n\tans += d[i] + ' '\nprint(ans)\n", "from collections import defaultdict\n(n, m) = map(int, input().split())\nd = defaultdict(str)\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\ns = input().split()\nprint(' '.join((d[i] for i in s)))\n", "def func(n):\n\tdictionary = dict((input().split() for i in range(n[1])))\n\ttext = input().split()\n\tans = []\n\tfor i in text:\n\t\tans.append(min(i, dictionary[i], key=len))\n\tprint(' '.join(ans))\nn = list(map(int, input().split()))\nfunc(n)\n", "(n, m) = [int(x) for x in input().split()]\nl = dict()\nfor _ in range(m):\n\t(a, b) = [str(x) for x in input().split()]\n\tl[a] = b\nq = [str(x) for x in input().split()]\nans = []\nfor x in q:\n\tfl = x\n\tsl = l[x]\n\tif len(fl) == len(sl):\n\t\tans.append(fl)\n\telse:\n\t\tans.append(fl if len(fl) < len(sl) else sl)\nprint(' '.join(ans))\n", "(n, m) = map(int, str(input()).split(' '))\nword_map = {}\nfor i in range(m):\n\t(a, b) = str(input()).split(' ')\n\tword_map[a] = b\nl = str(input()).split(' ')\nf = ''\nfor w in l:\n\tf += w if len(w) <= len(word_map[w]) else word_map[w]\n\tf += ' '\nprint(f)\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nb = dict()\nfor i in range(m):\n\t(x, y) = input().split()\n\tif len(x) <= len(y):\n\t\tb[x] = x\n\telse:\n\t\tb[x] = y\nc = input().split()\nfor i in range(n):\n\tprint(b[c[i]], end=' ')\n", "(n, m) = map(int, input().split())\nshorter = []\nlonger = []\nfor i in range(m):\n\t(word1, word2) = map(str, input().split())\n\tif len(word1) <= len(word2):\n\t\tshorter.append(word1)\n\t\tlonger.append(word2)\n\telse:\n\t\tshorter.append(word2)\n\t\tlonger.append(word1)\nlecture = map(str, input().split())\nfor word in lecture:\n\tif word in longer:\n\t\tprint(shorter[longer.index(word)], end=' ')\n\telse:\n\t\tprint(shorter[shorter.index(word)], end=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\tdic[x] = y\na = list(input().split())\nprint(*[i if len(i) <= len(dic[i]) else dic[i] for i in a])\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\t(a, b) = (b, a)\n\tdic[a] = a\n\tdic[b] = a\nline = input().split()\nans = [dic[i] for i in line]\nprint(*ans)\n", "(n, m) = input().split()\n(n, m) = (int(n), int(m))\nlis = []\nfor i in range(m):\n\tlis.append(input().split())\n\ndef decide(lis):\n\tif len(lis[0]) <= len(lis[1]):\n\t\treturn lis[0]\n\telse:\n\t\treturn lis[1]\ndic = {}\nfor i in range(m):\n\tdic[lis[i][0]] = decide(lis[i])\nlec = input().split()\nfor i in range(n):\n\tprint(dic[lec[i]], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\t\td[b] = a\n\telse:\n\t\td[b] = b\n\t\td[a] = b\ns = list(input().split())\nfor e in s:\n\tprint(d[e], end=' ')\n", "(n, m) = map(int, input().split())\nd = dict()\nfor i in range(m):\n\ta = list(map(str, input().split()))\n\td[a[0]] = [a[1], a[0]]\ns = list(map(str, input().split()))\nfor i in range(len(s)):\n\tif len(d[s[i]][0]) < len(d[s[i]][1]):\n\t\tprint(d[s[i]][0], end=' ')\n\telse:\n\t\tprint(d[s[i]][1], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nmsg = [s for s in input().split()]\nfor s in msg:\n\ta = s\n\tb = d[s]\n\tif len(a) <= len(b):\n\t\tprint(a, end=' ')\n\telse:\n\t\tprint(b, end=' ')\n", "def swap_words():\n\t(n, m) = map(int, input().split())\n\twords = dict()\n\tfor i in range(0, m):\n\t\t(k, v) = input().split()\n\t\twords[k] = v\n\tfor w in input().split():\n\t\tw2 = words[w]\n\t\tif len(w2) < len(w):\n\t\t\tyield w2\n\t\telse:\n\t\t\tyield w\nprint(' '.join(swap_words()))\n", "(n, m) = map(int, input().split(' '))\ndic = {}\nfor i in range(m):\n\t(first, second) = map(str, input().split(' '))\n\tdic[first] = second\nlecture = list(map(str, input().split()))\nfor i in range(len(lecture)):\n\tif len(dic[lecture[i]]) < len(lecture[i]):\n\t\tlecture[i] = dic[lecture[i]]\nprint(' '.join(lecture))\n", "s = input().strip().split()\n(n, m) = (int(s[0]), int(s[1]))\ndic = dict()\nfor i in range(m):\n\ts = input().strip().split()\n\tdic[s[0]] = s[1]\ns = input().strip().split()\nfor i in s:\n\tif len(i) <= len(dic[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(dic[i], end=' ')\n", "def main(lecter, dictt):\n\tres = []\n\td = dict(dictt)\n\tfor i in lecter:\n\t\tif len(i) <= len(d.get(i)):\n\t\t\tres.append(i)\n\t\telse:\n\t\t\tres.append(d.get(i))\n\treturn ' '.join([str(i) for i in res])\n(n, m) = list(map(int, input().split()))\ndictt = []\nfor i in range(m):\n\tdictt.append(list(input().split()))\nlecter = list(input().split())\nprint(main(lecter, dictt))\n", "(n, m) = map(int, input().split())\nl = []\nfirst = []\nsecond = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tfirst.append(a)\n\tsecond.append(b)\ns = input().split()\nres = ''\nfor str in s:\n\tfor i in range(m):\n\t\tif str == first[i]:\n\t\t\tif len(first[i]) > len(second[i]):\n\t\t\t\tres += second[i] + ' '\n\t\t\telse:\n\t\t\t\tres += first[i] + ' '\n\t\t\tbreak\nprint(res)\n", "(n, m) = map(int, input().split())\nL = {}\nfor i in range(m):\n\ta = input().split()\n\tx = a[0]\n\ty = a[1]\n\tL[x] = y\nZ = input().split()\nx = ''\nfor i in Z:\n\tif len(i) <= len(L[i]):\n\t\tx += i + ' '\n\telse:\n\t\tx += L[i] + ' '\nprint(x)\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\tword = input().split()\n\tdic[word[0]] = word[1]\nc = input().split()\nfor i in range(n):\n\tif len(dic[c[i]]) < len(c[i]):\n\t\tc[i] = dic[c[i]]\nprint(*c)\n", "(n, m) = [int(a_temp) for a_temp in input().strip().split()]\nd = {}\nfor _ in range(m):\n\tt = [str(a_temp) for a_temp in input().strip().split()]\n\td[t[0]] = t[1] if len(t[1]) < len(t[0]) else t[0]\nw = [str(a_temp) for a_temp in input().strip().split()]\nfor i in range(n):\n\tw[i] = d[w[i]]\nprint(' '.join(w))\n", "x = input().strip().split(' ')\nn = int(x[0])\nm = int(x[1])\n(i, j) = (0, 0)\nnotes = []\nlanguage = []\nfor i in range(0, m):\n\t(language1, language2) = input().strip().split(' ')\n\tif len(language1) > len(language2):\n\t\tlanguage.append([language2, language1])\n\telse:\n\t\tlanguage.append([language1, language2])\nlecture = input().strip().split(' ')\nfor i in range(0, n):\n\tfor j in range(0, m):\n\t\tif language[j][0] == lecture[i] or language[j][1] == lecture[i]:\n\t\t\tnotes.append(language[j][0])\nfor x in notes:\n\tprint(x, end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = list(input().split())\n\td[a] = b\nc = list(input().split())\nr = []\nfor s in c:\n\ta = s\n\tb = d[s]\n\tif len(a) > len(b):\n\t\tr.append(b)\n\telse:\n\t\tr.append(a)\nprint(' '.join(r))\n", "(n, m) = (int(X) for X in input().split())\nrulebook = []\nfor i in range(m):\n\trulebook.append([X for X in input().split()])\ntext = [X for X in input().split()]\noutput = ''\nfor X in text:\n\tfor i in range(m):\n\t\tif rulebook[i][0] == X:\n\t\t\tif len(rulebook[i][0]) > len(rulebook[i][1]):\n\t\t\t\toutput += rulebook[i][1] + ' '\n\t\t\telse:\n\t\t\t\toutput += rulebook[i][0] + ' '\nprint(output)\n", "import re\n(n, m) = map(int, input().split())\nwords = []\nfor i in range(m):\n\twords.append([i for i in input().split()])\nwords = sum(words, [])\ntext = input()\nwordList = re.sub('[^\\\\w]', ' ', text).split()\nfor i in wordList:\n\tx = words.index(i)\n\tif x % 2 == 1:\n\t\tprint(words[x] if len(words[x]) < len(words[x - 1]) else words[x - 1], end=' ')\n\telse:\n\t\tprint(words[x] if len(words[x]) <= len(words[x + 1]) else words[x + 1], end=' ')\n", "a = input().split()\nn = int(a[0])\nm = int(a[1])\nb = []\nc = {}\nfor i in range(m):\n\tb = input().split()\n\tif len(b[0]) <= len(b[1]):\n\t\tc[b[0]] = b[0]\n\telse:\n\t\tc[b[0]] = b[1]\nb = input().split()\nd = []\nfor i in range(n):\n\td.append(c[b[i]])\nprint(' '.join(d))\n", "(n, m) = list(map(int, input().split()))\ndictory = {}\nwhile m > 0:\n\twords = list(map(str, input().split()))\n\tif len(words[0]) <= len(words[1]):\n\t\tdictory[words[0]] = words[0]\n\telse:\n\t\tdictory[words[0]] = words[1]\n\tm -= 1\ntext = list(map(str, input().split()))\nstr_output = ''\nfor element in text:\n\tstr_output += ' ' + dictory[element]\nprint(str_output.strip())\n", "(n, m) = map(int, input().split())\nd = dict()\nfor i in range(m):\n\tk = input().split()\n\ta = k[0]\n\tb = k[1]\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\na = input().split()\nfor i in range(n):\n\tprint(d[a[i]], end=' ')\n", "l = input().split()\n(q, n) = (int(l[0]), int(l[1]))\n(a, b, c) = ([], [], [])\nfor i in range(n):\n\ts = input().split()\n\t(s1, s2) = (str(s[0]), str(s[1]))\n\ta.append(s1)\n\tif len(s2) < len(s1):\n\t\tb.append(s2)\n\telse:\n\t\tb.append(s1)\ns = list(map(str, input().split()))\nfor i in range(q):\n\tc.append(b[a.index(s[i])])\nprint(' '.join(c))\n", "def mi():\n\treturn map(int, input().split(' '))\n(m, n) = mi()\nd = {}\nfor i in range(n):\n\t(x, y) = map(str, input().split(' '))\n\tif len(x) <= len(y):\n\t\td[x] = x\n\t\td[y] = x\n\telse:\n\t\td[x] = y\n\t\td[y] = y\nli = [x for x in input().split(' ')]\nfor i in li:\n\tprint(d[i], end=' ')\n", "t = [int(x) for x in input().split()]\n(n, m) = (t[0], t[1])\n(f, s) = ([], [])\nfor i in range(m):\n\tp = input().split()\n\tf.append(p[0])\n\ts.append(p[1])\nlecture = input().split()\nz = [s[f.index(i)] if len(s[f.index(i)]) < len(i) else i for i in lecture]\nprint(' '.join(z))\n", "(n, m) = list(map(int, input().split()))\na_to_b = dict()\nfor _ in range(m):\n\t(a, b) = input().split()\n\ta_to_b[a] = b if len(b) < len(a) else a\nlecture = input().split()\nanswer = [a_to_b[i] for i in lecture]\ntemp = ' '.join(answer)\nprint(temp)\n", "(n, m) = map(int, input().split())\nlang = {}\nfor _ in range(m):\n\t(a, b) = input().split()\n\tlang[a] = b\nlec = list(input().split())\nfor (i, word) in enumerate(lec):\n\tif len(lang[word]) < len(word):\n\t\tlec[i] = lang[word]\nprint(' '.join(lec))\n", "(n, m) = map(int, input().split())\nlst = []\nfor i in range(m):\n\tlst.append(input().split())\nai = list(map(str, input().split()))\nfor i in ai:\n\tfor j in lst:\n\t\tif i in j:\n\t\t\tif len(j[0]) > len(j[1]):\n\t\t\t\tprint(j[1], end=' ')\n\t\t\telif len(j[1]) > len(j[0]):\n\t\t\t\tprint(j[0], end=' ')\n\t\t\telse:\n\t\t\t\tprint(j[0], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\tif len(s1) <= len(s2):\n\t\td[s1] = s1\n\telse:\n\t\td[s1] = s2\nsentence = [i for i in map(str, input().split())]\nresult = []\nfor letter in sentence:\n\tresult.append(d[letter])\nprint(' '.join(result))\n", "(n, m) = map(int, input().split())\nlanguage = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tlanguage[a] = min([a, b], key=lambda x: len(x))\nnotes = input().split()\nres = ''\nfor i in notes:\n\tres += language[i] + ' '\nprint(res.strip())\n", "(n, m) = map(int, input().split())\nd1 = []\nd2 = []\nfor _ in range(m):\n\t(a, b) = input().split()\n\td1.append(a)\n\td2.append(b)\nlec = list(input().split())\nfor i in range(n):\n\tif lec[i] in d1:\n\t\tind = d1.index(lec[i])\n\telse:\n\t\tind = d2.index(lec[i])\n\tif len(d1[ind]) <= len(d2[ind]):\n\t\tlec[i] = d1[ind]\n\telse:\n\t\tlec[i] = d2[ind]\nprint(*lec)\n", "(a, b) = map(int, input().split())\nc = []\nd = []\nans = ''\nfor i in range(0, b):\n\t(o, p) = map(str, input().split())\n\tc.append(o)\n\td.append(p)\nq = list(map(str, input().split()))\nfor j in q:\n\te = c.index(j)\n\tf = d[e]\n\tif len(j) > len(f):\n\t\tans += str(f) + ' '\n\telse:\n\t\tans += str(j) + ' '\nprint(ans)\n", "from sys import stdin, stdout\nfrom collections import Counter\n\ndef ai():\n\treturn list(map(int, stdin.readline().split()))\n\ndef ei():\n\treturn map(int, stdin.readline().split())\n\ndef ip():\n\treturn int(stdin.readline().strip())\n\ndef op(ans):\n\treturn stdout.write(str(ans) + '\\n')\nfrom math import ceil\n(n, m) = ei()\nd = {}\nfor i in range(m):\n\t(f, s) = input().split()\n\td[f] = [len(s), s]\nmain = input().split()\nfor i in range(len(main)):\n\tif len(main[i]) > d[main[i]][0]:\n\t\tmain[i] = d[main[i]][1]\nprint(*main)\n", "r = {}\n(n, m) = input().split()\nfor i in range(int(m)):\n\t(a, b) = input().split()\n\tif len(b) < len(a):\n\t\tr[a] = b\n\telse:\n\t\tr[a] = a\nl = []\nf = [i for i in input().split()]\nfor i in range(int(n)):\n\tl.append(r[f[i]])\nprint(*l)\n", "def f(l, a):\n\tfor i in range(0, len(l), 2):\n\t\tif l[i] == a:\n\t\t\tif len(a) > len(l[i + 1]):\n\t\t\t\treturn l[i + 1]\n\t\t\telse:\n\t\t\t\treturn a\n(n, m) = map(int, input().split())\nl = []\nfor i in range(m):\n\tl1 = list(input().split())\n\tl.append(l1[0])\n\tl.append(l1[1])\ns = list(input().split())\nfor i in range(n):\n\tprint(f(l, s[i]), end=' ')\n", "(n, m) = input().split()\n(n, m) = (int(n), int(m))\nl = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tl.append(a)\n\tl.append(b)\ns = input().split()\ns1 = []\nfor i in range(len(s)):\n\tx = l.index(s[i])\n\tif len(l[x + 1]) < len(l[x]):\n\t\ts1.append(l[x + 1])\n\telif len(l[x + 1]) >= len(l[x]):\n\t\ts1.append(l[x])\nprint(*s1)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(x, y) = input().split()\n\td[x] = y\ns = list(input().split())\np = ''\nfor i in s:\n\tif len(i) <= len(d[i]):\n\t\tp += i + ' '\n\telse:\n\t\tp += d[i] + ' '\nprint(p)\n", "from sys import stdin\n(n, m) = [int(i) for i in stdin.readline().split()]\nd = {}\nfor i in range(m):\n\t(f, s) = [j for j in stdin.readline().split()]\n\tif len(f) > len(s):\n\t\td[s] = s\n\t\td[f] = s\n\telse:\n\t\td[s] = f\n\t\td[f] = f\nw = [i for i in stdin.readline().split()]\nfor i in w:\n\tprint(d[i], end=' ')\n", "(n, m) = map(int, input().split())\ndict = {}\nfor i in range(m):\n\t(str1, str2) = input().split()\n\tdict[str1] = str2\nprof = input().split()\nres = []\nfor i in prof:\n\tif len(dict[i]) < len(i):\n\t\tres.append(dict[i])\n\telse:\n\t\tres.append(i)\nres = ' '.join(res)\nprint(res)\n", "s = str(input()).split()\ns[0] = int(s[0])\ns[1] = int(s[1])\nl = [[], []]\nfor i in range(s[1]):\n\tp = str(input()).split()\n\tl[0].append(p[0])\n\tl[1].append(p[1])\ns = str(input()).split()\nfor i in range(len(s)):\n\tj = l[0].index(s[i])\n\tif len(l[0][j]) <= len(l[1][j]):\n\t\tprint(l[0][j], end=' ')\n\telse:\n\t\tprint(l[1][j], end=' ')\n", "(n, m) = (int(x) for x in input().split())\nab = {}\nfor i in range(m):\n\tx = input().split()\n\tab[x[0]] = x[1]\ns = ' '.join((w if len(w) <= len(ab[w]) else ab[w] for w in input().split()))\nprint(s)\n", "from sys import stdin\nfrom collections import defaultdict\ninput = lambda : stdin.readline().strip()\n(a, b) = list(map(int, input().split()))\ndict1 = defaultdict()\nfor _ in range(b):\n\t(c, d) = input().split()\n\tif len(d) < len(c):\n\t\tdict1[c] = d\n\telse:\n\t\tdict1[c] = c\ns = input().split()\nfor i in s:\n\tprint(dict1[i], end=' ')\nprint()\n", "(m, n) = list(map(int, input().split()))\n(l, r) = ([], [])\nfor _ in range(n):\n\t(p, q) = list(input().split())\n\tl.append(p)\n\tr.append(q)\n(t, u) = (input().split(), '')\nfor i in t:\n\tif i in l:\n\t\tif len(l[l.index(i)]) == len(r[l.index(i)]):\n\t\t\tu = u + l[l.index(i)] + ' '\n\t\telif len(l[l.index(i)]) < len(r[l.index(i)]):\n\t\t\tu = u + l[l.index(i)] + ' '\n\t\telse:\n\t\t\tu = u + r[l.index(i)] + ' '\n\telif len(l[r.index(i)]) == len(r[r.index(i)]):\n\t\tu = u + l[r.index(i)] + ' '\n\telif len(l[r.index(i)]) < len(r[r.index(i)]):\n\t\tu = u + l[r.index(i)] + ' '\n\telse:\n\t\tu = u + r[r.index(i)] + ' '\nprint(u)\n", "def short(s1, s2):\n\tif len(s1) < len(s2):\n\t\treturn s1\n\telif len(s1) > len(s2):\n\t\treturn s2\n\telse:\n\t\treturn s1\n(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(a, b) = map(str, input().split())\n\tif a not in d:\n\t\td[a] = b\nL = list(input().split())\ns = ''\nfor c in L:\n\tprint(short(c, d[c]), end=' ')\n", "(n, m) = map(int, input().split())\nfirst = []\nsecond = []\nt = 0\nwhile t < m:\n\t(a, b) = input().split()\n\tfirst.append(a)\n\tsecond.append(b)\n\tt = t + 1\nlecture = input().split()\nfor i in lecture:\n\tif len(i) > len(second[first.index(i)]):\n\t\tlecture[lecture.index(i)] = second[first.index(i)]\nprint(' '.join(lecture))\n", "sen = input().split(' ')\nnum = int(sen[1])\nsen = int(sen[0])\nlang1 = dict()\nlang2 = dict()\nfor i in range(0, num):\n\tword = input().split(' ')\n\tlang1[word[0]] = word[1]\n\tlang2[word[1]] = word[0]\nsentence = input().split(' ')\nfinal = list()\nfor i in sentence:\n\tif i in lang1:\n\t\tif len(i) <= len(lang1[i]):\n\t\t\tfinal.append(i)\n\t\telse:\n\t\t\tfinal.append(lang1[i])\n\telif i in lang1:\n\t\tif len(i) < len(lang2[i]):\n\t\t\tfinal.append(i)\n\t\telse:\n\t\t\tfinal.append(lang2[i])\ns = ' '\nfinal = s.join(final)\nprint(final)\n", "(n, m) = map(int, input().split())\nwords1 = {}\nwords2 = {}\nres = []\nfor i in range(m):\n\t(w1, w2) = map(str, input().split())\n\twords1[w1] = w2\n\twords2[w2] = w1\nsntns = input()\nsntns = list(sntns.split(' '))\nfor i in sntns:\n\tif i in words1.keys():\n\t\tif len(i) <= len(words1[i]):\n\t\t\tres.append(i)\n\t\telse:\n\t\t\tres.append(words1[i])\n\telif i in words2.keys():\n\t\tif len(words2[i]) <= len(i):\n\t\t\tres.append(words2[i])\n\t\telse:\n\t\t\tres.append(i)\nfor i in res:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nc = []\nfor i in range(m):\n\ta = list(map(str, input().split()))\n\tc.append(a)\nz = list(map(str, input().split()))\nl = []\nfor i in range(len(c)):\n\tl.append(c[i][0])\nfor i in range(len(z)):\n\tq = l.index(z[i])\n\tif len(z[i]) > len(c[q][1]):\n\t\tz[i] = c[q][1]\nprint(' '.join(z))\n", "import sys, math\n(n, m) = [int(i) for i in input().split(' ')]\na = dict()\nfor i in range(m):\n\t(x, y) = [i for i in input().split(' ')]\n\ta[x] = y\nb = [i for i in input().split(' ')]\nk = 0\nfor i in range(b.__len__()):\n\ts = b[i]\n\tif a.get(s):\n\t\tif len(a[s]) < len(s):\n\t\t\tif k == 0:\n\t\t\t\tk = 1\n\t\t\t\tprint('', end='')\n\t\t\telse:\n\t\t\t\tprint(' ', end='')\n\t\t\tprint(a[b[i]], end='')\n\t\telse:\n\t\t\tif k == 0:\n\t\t\t\tk = 1\n\t\t\t\tprint('', end='')\n\t\t\telse:\n\t\t\t\tprint(' ', end='')\n\t\t\tprint(b[i], end='')\n\telse:\n\t\tif k == 0:\n\t\t\tk = 1\n\t\t\tprint('', end='')\n\t\telse:\n\t\t\tprint(' ', end='')\n\t\tprint(a[b[i]], end='')\n", "(n, m) = map(int, input().split(' '))\nans = []\nref = []\nres = []\nfor _ in range(m):\n\t(p, q) = input().split(' ')\n\tref.append(p)\n\tif len(p) == len(q):\n\t\tans.append(p)\n\telif len(p) < len(q):\n\t\tans.append(p)\n\telif len(p) > len(q):\n\t\tans.append(q)\ns = list(input().split(' '))\nfor ii in range(n):\n\tres.append(ans[ref.index(s[ii])])\nprint(*res)\n", "(lec, dic) = list(map(int, input().split()))\nlang1 = dict()\nfor _ in range(dic):\n\t(f, s) = input().split()\n\tlang1[f] = s\n\ndef get_min(word):\n\tif len(word) <= len(lang1[word]):\n\t\treturn word\n\treturn lang1[word]\nlecture = input().split()\nans = []\nfor word in lecture:\n\tans.append(get_min(word))\nprint(*ans)\n", "import math\nfrom collections import defaultdict\nml = lambda : map(int, input().split())\nll = lambda : list(map(int, input().split()))\nii = lambda : int(input())\nip = lambda : input()\n(a, b) = ml()\nd = defaultdict(str)\nfor _ in range(b):\n\t(x, y) = input().split()\n\tif len(y) < len(x):\n\t\td[x] = y\n\telse:\n\t\td[x] = x\nquery = list(input().split())\nfor i in query:\n\tprint(d[i], end=' ')\n", "(n, m) = [int(i) for i in input().split()]\nwords = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\twords[a] = a\n\telse:\n\t\twords[a] = b\nnotes = []\nfor word in input().split():\n\tnotes.append(words[word])\nprint(' '.join(notes))\n", "from math import ceil\nnumwords = input().split()\nn = int(numwords[0])\nm = int(numwords[1])\nwords = [input().split() for i in range(m)]\nlan1 = [i[0] for i in words]\nlan2 = [i[1] for i in words]\ntranslate = input().split()\nnew = translate\nk = 0\nwhile k < m:\n\tif len(lan1[k]) > len(lan2[k]):\n\t\tnew = list(map(lambda x: lan2[k] if x == lan1[k] else x, new))\n\tk += 1\nexp = ' '.join((i for i in new))\nprint(exp)\n", "(n, m) = map(int, input().split())\nlanguage_dict = dict()\noutput = []\nfor i in range(m):\n\tls = list(input().split())\n\tlanguage_dict[ls[0]] = ls[1]\ntext = list(input().split())\nfor i in range(n):\n\tvalue = len(language_dict[text[i]])\n\tif value >= len(text[i]):\n\t\toutput.append(text[i])\n\telse:\n\t\toutput.append(language_dict[text[i]])\nfor item in output:\n\tprint(item, end=' ')\n", "(x, y) = [int(i) for i in input().split()]\nz = {}\nfor i in range(y):\n\t(a, b) = input().split()\n\tz.update({a: b})\nfor i in input().split():\n\tc = z[i]\n\tif len(c) < len(i):\n\t\tprint(c, end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\n(a, b) = ([], [])\nfor i in range(m):\n\tab = input().split()\n\ta.append(ab[0])\n\tb.append(ab[1])\nc = input().split()\no = ' '.join([i if len(a[a.index(i)]) <= len(b[a.index(i)]) else b[a.index(i)] for i in c])\nprint(o)\n", "(n, m) = [int(i) for i in input().split()]\nd = {}\nfor i in range(m):\n\t(w0, w1) = input().split()\n\td[w0] = w1\na = input().split()\nfor w in a:\n\tif len(w) > len(d[w]):\n\t\tprint(d[w], end=' ')\n\telse:\n\t\tprint(w, end=' ')\n", "import sys\nINT_MAX = sys.maxsize\nINT_MIN = -sys.maxsize - 1\nsys.setrecursionlimit(10 ** 7)\nmod = 1000000007\n\ndef IOE():\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n\ndef main():\n\t(n, k) = map(int, sys.stdin.readline().split())\n\td = dict()\n\tfor i in range(k):\n\t\ts = list(map(str, sys.stdin.readline().split()))\n\t\tif s[0] not in d:\n\t\t\td[s[0]] = min(s, key=lambda i: len(i))\n\tss = list(map(str, sys.stdin.readline().split()))\n\tfor i in range(n):\n\t\tss[i] = d[ss[i]]\n\tprint(*ss)\ntry:\n\tIOE()\nexcept:\n\tpass\nmain()\n", "(n, m) = list(map(int, input().split()))\na = []\nb = ''\nfor i in range(m):\n\t(x, y) = input().split()\n\ta.append(x)\n\ta.append(y)\ns = list(input().split())\nfor i in s:\n\tif len(i) > len(a[a.index(i) + 1]):\n\t\tb += a[a.index(i) + 1] + ' '\n\telse:\n\t\tb += i + ' '\nprint(b)\n", "(n, m) = map(int, input().split())\nwords = []\nfor _ in range(m):\n\twords.append(input())\nsentence = input().split()\n(lang1, lang2) = ([], [])\nfor word in words:\n\tfor i in range(len(word)):\n\t\tif word[i] == ' ':\n\t\t\tlang1.append(word[:i])\n\t\t\tlang2.append(word[i + 1:])\n\t\t\tbreak\nto_speak = ''\nfor w in sentence:\n\tidx = lang1.index(w)\n\tto_speak += f'{[w, lang2[idx]][len(lang2[idx]) < len(w)]} '\nprint(to_speak)\n", "def readline():\n\treturn input()\n\nclass OptimalWriter:\n\tn = None\n\tm = None\n\tfirst_voc = None\n\tbest_voc = None\n\tdata = None\n\n\tdef __init__(self, readline):\n\t\tself.read(readline)\n\n\tdef voc_init(self):\n\t\tself.first_voc = [None] * self.m\n\t\tself.best_voc = [None] * self.m\n\n\tdef read(self, readline):\n\t\tnn = readline().split(' ')\n\t\tself.n = int(nn[0])\n\t\tself.m = int(nn[1])\n\t\tself.voc_init()\n\t\tfor i in range(self.m):\n\t\t\ts = readline().split(' ')\n\t\t\tself.first_voc[i] = s[0]\n\t\t\tif len(s[1]) < len(s[0]):\n\t\t\t\tself.best_voc[i] = s[1]\n\t\t\telse:\n\t\t\t\tself.best_voc[i] = s[0]\n\t\tself.data = readline().split(' ')\n\n\tdef generate(self):\n\t\tresult = ''\n\t\tfor word in self.data:\n\t\t\ti = self.first_voc.index(word)\n\t\t\tresult += ' ' + self.best_voc[i]\n\t\treturn result[1:]\n\ndef main():\n\twriter = OptimalWriter(readline)\n\tprint(writer.generate())\nmain()\n", "numbers = list(input().split(' '))\ndict1 = {}\nfor i in range(int(numbers[1])):\n\tchars = list(input().split(' '))\n\tdict1[chars[0]] = chars[1]\nsent = list(input().split(' '))\nst = ''\nfor i in sent:\n\tif len(i) > len(dict1[i]):\n\t\tst = st + ' ' + dict1[i]\n\tif len(i) < len(dict1[i]):\n\t\tst = st + ' ' + i\n\tif len(i) == len(dict1[i]):\n\t\tst = st + ' ' + i\nprint(st[1:])\n", "line = input().split()\nn = int(line[0])\nm = int(line[1])\ndict = {}\nfor i in range(m):\n\tline = input().split()\n\tdict[line[0]] = line[1]\nlecture = input().split()\nnotes = []\nfor word in lecture:\n\tfirst = word\n\tsecond = dict[first]\n\tif len(first) <= len(second):\n\t\tnotes.append(first)\n\telse:\n\t\tnotes.append(second)\nprint(' '.join(notes))\n", "import heapq as hp\nimport collections\nimport bisect\nimport math\nimport re\n\ndef unpack(func=int):\n\treturn map(func, input().split())\n\ndef l_unpack(func=int):\n\treturn list(map(func, input().split()))\n\ndef s_unpack(func=int):\n\treturn sorted(map(func, input().split()))\n\ndef ml_unpack(n):\n\treturn [int(input()) for i in range(n)]\n\ndef range_n():\n\treturn range(int(input()))\n\ndef counter(a):\n\td = {}\n\tfor x in a:\n\t\tif x in d:\n\t\t\td[x] += 1\n\t\telse:\n\t\t\td[x] = 1\n\treturn d\n\ndef getint():\n\treturn int(input())\n\ndef setbits(x):\n\tcount = 0\n\twhile x:\n\t\tx = x & x - 1\n\t\tcount += 1\n\treturn count\n\ndef main():\n\t(n, m) = unpack()\n\td = {}\n\tfor i in range(m):\n\t\t(key, value) = input().split()\n\t\td[key] = value\n\tlecture = input().split()\n\tans = [word if len(word) <= len(d[word]) else d[word] for word in lecture]\n\tprint(*ans)\nmain()\n", "dict = {}\n(a, b) = map(int, input().split())\nfor i in range(b):\n\t(x, y) = input().split()\n\tdict[x] = y\nfor i in input().split():\n\tprint(min(i, dict[i], key=len), '', end='')\n", "alle = input()\nalle = list(map(int, alle.split()))\nn = alle[0]\nm = alle[1]\nalle = []\ndicc = []\na = []\nlecture = []\noutput = []\nfor i in range(0, m):\n\ta = input()\n\ta = a.split(' ')\n\ta.append(0)\n\tdicc.append(a)\nlecture = input()\nlecture = list(lecture.split(' '))\nj = 0\nflag = False\nfor i in range(0, len(lecture)):\n\twhile flag == False and j <= len(dicc):\n\t\tif lecture[i] == dicc[j][0]:\n\t\t\tflag = True\n\t\t\tif dicc[j][2] == 0:\n\t\t\t\tif len(dicc[j][0]) <= len(dicc[j][1]):\n\t\t\t\t\toutput.append(dicc[j][0])\n\t\t\t\t\tdicc[j][2] = 1\n\t\t\t\telse:\n\t\t\t\t\toutput.append(dicc[j][1])\n\t\t\t\t\tdicc[j][2] = 2\n\t\t\telif dicc[j][2] == 1:\n\t\t\t\toutput.append(dicc[j][0])\n\t\t\telse:\n\t\t\t\toutput.append(dicc[j][1])\n\t\tj += 1\n\tflag = False\n\tj = 0\nfor i in range(0, len(output)):\n\tprint(output[i], end=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\tw = input().split()\n\tw = sorted(w, key=lambda x: len(x))\n\tdic[w[1]] = w[0]\nwords = input().split()\nfor i in words:\n\tif i in dic:\n\t\tprint(dic[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "def main():\n\t(n, m) = map(int, input().split())\n\twords = {}\n\tfor i in range(m):\n\t\t(a, b) = input().split()\n\t\tif len(a) > len(b):\n\t\t\twords[a] = b\n\t\telif len(a) < len(b):\n\t\t\twords[b] = a\n\tc = input().split()\n\tfor (i, word) in enumerate(c):\n\t\tif word in words:\n\t\t\tc[i] = words[word]\n\tprint(' '.join(c))\nmain()\n", "(n, m) = [int(i) for i in input().split()]\nmp = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tmp[a] = b\ntext = input().split()\nanswer = ''\nfor i in text:\n\tif len(i) <= len(mp[i]):\n\t\tanswer += i + ' '\n\telse:\n\t\tanswer += mp[i] + ' '\nprint(answer.rstrip())\n", "(n, m) = map(int, input().split())\ndic = dict()\nfor i in range(m):\n\t(l1, l2) = input().split()\n\tdic[l1] = l2\nlecture = input()\nlec_list = list(lecture.split(' '))\nfor i in lec_list:\n\tif len(i) > len(dic[i]):\n\t\tprint(dic[i], end=' ')\n\telse:\n\t\tprint(i, end=' ')\n", "(a, b) = (list(map(int, input().split())), [])\nfor i in range(a[1]):\n\tc = input().split()\n\tif len(c[0]) <= len(c[1]):\n\t\tb.append([c[1], c[0]])\n\telse:\n\t\tb.append([c[0], c[1]])\nc = dict(b)\nfor i in input().split():\n\ttry:\n\t\tprint(c[i], end=' ')\n\texcept KeyError:\n\t\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nlst1 = []\nlst2 = []\nfor i in range(0, m):\n\t(x, y) = map(str, input().split())\n\tlst1.append(x)\n\tlst2.append(y)\nmsg = list((str(m) for m in input().split()))[:n]\nstr1 = ''\nfor char in msg:\n\ti = lst1.index(char)\n\tif len(lst1[i]) > len(lst2[i]):\n\t\tstr1 += lst2[i] + ' '\n\telse:\n\t\tstr1 += lst1[i] + ' '\nprint(str1)\n", "(n, m) = map(int, input().split())\npr = []\nst = []\nfor i in range(m):\n\t(p, q) = map(str, input().split())\n\tpr.append(p)\n\tst.append(q)\nout = list(map(str, input().split()))\nfor i in range(n):\n\tx = pr.index(out[i])\n\tif len(pr[x]) <= len(st[x]):\n\t\tprint(pr[x], end=' ')\n\telse:\n\t\tprint(st[x], end=' ')\n", "from __future__ import division, print_function\nimport os, sys\nfrom io import BytesIO, IOBase\nif sys.version_info[0] < 3:\n\tfrom __builtin__ import xrange as range\n\tfrom future_builtins import ascii, filter, hex, map, oct, zip\n\ndef ii():\n\treturn int(input())\n\ndef si():\n\treturn input()\n\ndef mi():\n\treturn map(int, input().strip().split(' '))\n\ndef msi():\n\treturn map(str, input().strip().split(' '))\n\ndef li():\n\treturn list(mi())\n\ndef dmain():\n\tsys.setrecursionlimit(1000000)\n\tthreading.stack_size(1024000)\n\tthread = threading.Thread(target=main)\n\tthread.start()\nimport sys\ninput = sys.stdin.readline\nscan_int = lambda : int(input())\nscan_string = lambda : input().rstrip()\nread_list = lambda : list(read())\nread = lambda : map(int, input().split())\nread_float = lambda : map(float, input().split())\n\ndef ceil(x):\n\tif x != int(x):\n\t\tx = int(x) + 1\n\treturn x\n\ndef factorial(x, m):\n\tval = 1\n\twhile x > 0:\n\t\tval = val * x % m\n\t\tx -= 1\n\treturn val\n\ndef fact(x):\n\tval = 1\n\twhile x > 0:\n\t\tval *= x\n\t\tx -= 1\n\treturn val\n\ndef swaparr(arr, a, b):\n\ttemp = arr[a]\n\tarr[a] = arr[b]\n\tarr[b] = temp\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef lcm(a, b):\n\treturn a * b // math.gcd(a, b)\n\ndef is_integer(n):\n\treturn math.ceil(n) == math.floor(n)\n\ndef nCr(n, k):\n\tif k > n:\n\t\treturn 0\n\tif k > n - k:\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n\ndef primefs(n):\n\tprimes = {}\n\twhile n % 2 == 0 and n > 0:\n\t\tprimes[2] = primes.get(2, 0) + 1\n\t\tn = n // 2\n\tfor i in range(3, int(n ** 0.5) + 2, 2):\n\t\twhile n % i == 0 and n > 0:\n\t\t\tprimes[i] = primes.get(i, 0) + 1\n\t\t\tn = n // i\n\tif n > 2:\n\t\tprimes[n] = primes.get(n, 0) + 1\n\treturn primes\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef swap(a, b):\n\ttemp = a\n\ta = b\n\tb = temp\n\treturn (a, b)\n\ndef find(x, link):\n\tp = x\n\twhile p != link[p]:\n\t\tp = link[p]\n\twhile x != p:\n\t\tnex = link[x]\n\t\tlink[x] = p\n\t\tx = nex\n\treturn p\n\ndef union(x, y, link, size):\n\tx = find(x, link)\n\ty = find(y, link)\n\tif size[x] < size[y]:\n\t\t(x, y) = swap(x, y)\n\tif x != y:\n\t\tsize[x] += size[y]\n\t\tlink[y] = x\n\ndef sieve(n):\n\tprime = [True for i in range(n + 1)]\n\t(prime[0], prime[1]) = (False, False)\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\n\ndef phi(n):\n\tresult = n\n\tp = 2\n\twhile p * p <= n:\n\t\tif n % p == 0:\n\t\t\twhile n % p == 0:\n\t\t\t\tn = n // p\n\t\t\tresult = result * (1.0 - 1.0 / float(p))\n\t\tp = p + 1\n\tif n > 1:\n\t\tresult = result * (1.0 - 1.0 / float(n))\n\treturn int(result)\n\ndef is_prime(n):\n\tif n == 0:\n\t\treturn False\n\tif n == 1:\n\t\treturn True\n\tfor i in range(2, int(n ** (1 / 2)) + 1):\n\t\tif not n % i:\n\t\t\treturn False\n\treturn True\n\ndef next_prime(n, primes):\n\twhile primes[n] != True:\n\t\tn += 1\n\treturn n\nMAXN = int(100000.0 + 5)\n\ndef spf_sieve():\n\tspf[1] = 1\n\tfor i in range(2, MAXN):\n\t\tspf[i] = i\n\tfor i in range(4, MAXN, 2):\n\t\tspf[i] = 2\n\tfor i in range(3, ceil(MAXN ** 0.5), 2):\n\t\tif spf[i] == i:\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif spf[j] == j:\n\t\t\t\t\tspf[j] = i\nspf = [0 for i in range(MAXN)]\n\ndef factoriazation(x):\n\tres = []\n\tfor i in range(2, int(x ** 0.5) + 1):\n\t\twhile x % i == 0:\n\t\t\tres.append(i)\n\t\t\tx //= i\n\tif x != 1:\n\t\tres.append(x)\n\treturn res\n\ndef factors(n):\n\tres = []\n\tfor i in range(1, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tres.append(i)\n\t\t\tres.append(n // i)\n\treturn list(set(res))\n\ndef int_array():\n\treturn list(map(int, input().strip().split()))\n\ndef float_array():\n\treturn list(map(float, input().strip().split()))\n\ndef str_array():\n\treturn input().strip().split()\n\ndef binary_search(low, high, w, h, n):\n\twhile low < high:\n\t\tmid = low + (high - low) // 2\n\t\tif check(mid, w, h, n):\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid\n\treturn low\n\ndef check(beauty, s, n, count):\n\tpass\nMOD = int(1000000000.0) + 7\nCMOD = 998244353\nINF = float('inf')\nNINF = -float('inf')\nalphs = 'abcdefghijklmnopqrstuvwxyz'.upper()\nfrom itertools import permutations\nimport math\nimport bisect as bis\nimport random\nimport sys\nimport collections as collect\n\ndef solve():\n\t(n, m) = read()\n\tmp = {}\n\tfor i in range(m):\n\t\t(a, b) = input().rstrip().split()\n\t\tif len(a) == len(b):\n\t\t\tmp[a] = a\n\t\t\tmp[b] = b\n\t\telif len(a) < len(b):\n\t\t\tmp[a] = a\n\t\t\tmp[b] = a\n\t\telif len(a) > len(b):\n\t\t\tmp[a] = b\n\t\t\tmp[b] = b\n\tc = input().rstrip().split()\n\tans = []\n\tfor x in c:\n\t\tans.append(mp[x])\n\tprint(*ans)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\ndef print(*args, **kwargs):\n\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop('end', '\\n'))\n\tif kwargs.pop('flush', False):\n\t\tfile.flush()\nif sys.version_info[0] < 3:\n\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\nelse:\n\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfor i in range(1):\n\tsolve()\n", "(n, m) = map(int, input().split())\nl1 = []\nl2 = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tl1.append(a)\n\tl2.append(b)\nnlist = input().split()\nans = ''\nfor i in range(n):\n\tif nlist[i] in l1:\n\t\ty = l1.index(nlist[i])\n\t\tt = l1[y] if len(l1[y]) <= len(l2[y]) else l2[y]\n\t\tans += t\n\t\tans += ' '\n\telse:\n\t\ty = l2.index(nlist[i])\n\t\tt = l1[y] if len(l1[y]) <= len(l2[y]) else l2[y]\n\t\tans += t\n\t\tans += ' '\nprint(ans)\n", "(n, m) = map(int, input().split())\nDic = {}\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\tDic[a] = [b, 1, a]\n\telse:\n\t\tDic[a] = [b, 2, a]\nLec = list(map(str, input().split()))\nfor i in range(n):\n\tif Dic[Lec[i]][1] == 1:\n\t\tprint(Dic[Lec[i]][2], end=' ')\n\telse:\n\t\tprint(Dic[Lec[i]][0], end=' ')\n", "def lecture(words, sentence):\n\tans = []\n\tfor i in sentence:\n\t\tval = min(len(words[i]), len(i))\n\t\tif len(i) == val:\n\t\t\tans.append(i)\n\t\telse:\n\t\t\tans.append(words[i])\n\tprint(' '.join(ans))\n(n, m) = list(map(int, input().rstrip().split()))\nwords = {}\nfor i in range(m):\n\tx = input().rstrip().split()\n\twords[x[0]] = x[1]\nsentence = input().rstrip().split()\nlecture(words, sentence)\n", "(n, m) = [int(i) for i in input().split()]\na = []\nb = []\nfor _ in range(m):\n\tl = input().split()\n\ta.append(l[0])\n\tb.append(l[1])\ns = input().split()\nz = []\nfor i in s:\n\tx = a.index(i)\n\tif len(a[x]) == len(b[x]):\n\t\tz.append(a[x])\n\telif len(a[x]) > len(b[x]):\n\t\tz.append(b[x])\n\telif len(a[x]) < len(b[x]):\n\t\tz.append(a[x])\nprint(' '.join(z))\n", "import sys\n\ndef compare(a, b):\n\tif len(a) <= len(b):\n\t\treturn a\n\treturn b\n\ndef f(b, a):\n\tc = []\n\tfor i in range(len(b)):\n\t\tc.append(compare(a[a.index(b[i])], a[a.index(b[i]) + 1]))\n\treturn c\ninput = sys.stdin.read()\ndata = list(map(str, input.split()))\nn = int(data[0])\nm = int(data[1])\na = list(map(str, data[2:2 * m + 2]))\nb = list(data[2 * m + 2:])\nans = f(b, a)\nprint(*ans)\n", "numbers = list(map(int, input().split()))\ndictionary = []\nfor i in range(0, numbers[1]):\n\twords = input().split()\n\tdictionary.append(1 if len(words[0]) <= len(words[1]) else 2)\n\tdictionary.append(words[0])\n\tdictionary.append(words[1])\nlecture = input().split()\nresult = ''\nfor i in range(0, numbers[0]):\n\tindexInDic = dictionary.index(lecture[i])\n\tnumberIndex = indexInDic - indexInDic % 3\n\tnumber = dictionary[numberIndex]\n\tresult += dictionary[numberIndex + number] + ' '\nprint(result.strip())\n", "def answer(n, m, d, c):\n\tfor i in range(n):\n\t\tif len(c[i]) > len(d[c[i]]):\n\t\t\tc[i] = d[c[i]]\n\treturn c\n(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nc = input().split()\nprint(*answer(n, m, d, c))\n", "import sys\n\ndef input():\n\treturn sys.stdin.readline().strip()\n\ndef iinput():\n\treturn int(input())\n\ndef tinput():\n\treturn input().split()\n\ndef rinput():\n\treturn map(int, tinput())\n\ndef rlinput():\n\treturn list(rinput())\ndict = {}\n(n, m) = rinput()\nfor _ in range(m):\n\t(l1, l2) = tinput()\n\tif len(l1) < len(l2):\n\t\tsmaller = l1\n\telif len(l1) == len(l2):\n\t\tsmaller = l1\n\telse:\n\t\tsmaller = l2\n\tdict[l1] = smaller\n\tdict[l2] = smaller\nspeech = list(tinput())\nfor word in speech:\n\tprint(dict[word], end=' ')\n", "import sys\nimport math\nget_string = lambda : sys.stdin.readline().strip()\nget_int_list = lambda : list(map(int, sys.stdin.readline().strip().split()))\nget_int = lambda : int(sys.stdin.readline().strip())\n(n, m) = get_int_list()\nd = {}\nfor i in range(m):\n\t(a, b) = get_string().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\nstring = get_string().split()\nres = []\nfor i in string:\n\tres.append(d[i])\nprint(' '.join(res))\n", "import math\nfrom collections import defaultdict, Counter, deque\nINF = float('inf')\n\ndef gcd(a, b):\n\twhile b:\n\t\t(a, b) = (b, a % b)\n\treturn a\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\ti = 2\n\twhile i ** 2 <= n:\n\t\tif n % i == 0:\n\t\t\treturn False\n\t\ti += 1\n\treturn True\n\ndef vars():\n\treturn map(int, input().split())\n\ndef array():\n\treturn list(map(int, input().split()))\n\ndef main():\n\t(n, k) = vars()\n\tm = {}\n\tfor i in range(k):\n\t\t(s1, s2) = input().split()\n\t\tm[s1] = s2\n\twords = list(input().split())\n\tans = ''\n\tfor w in words:\n\t\tif len(w) <= len(m[w]):\n\t\t\tans += w + ' '\n\t\telse:\n\t\t\tans += m[w] + ' '\n\tprint(ans.strip())\nt = 1\nfor _ in range(t):\n\tmain()\n", "lang = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\tarr = list(map(str, input().split()))\n\tlang.update({arr[0]: arr[1]})\nstr1 = list(map(str, input().split()))\nfor i in range(n):\n\tif str1[i] in lang:\n\t\tx = str1[i]\n\t\ty = lang[x]\n\t\tif len(x) <= len(y):\n\t\t\tprint(x, end=' ')\n\t\telse:\n\t\t\tprint(y, end=' ')\n\telse:\n\t\ty = str1[i]\n\t\tfor k in lang:\n\t\t\tif lang[k] == y:\n\t\t\t\tx = lang[k]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcontinue\n\t\tif len(x) < len(y):\n\t\t\tprint(x, end=' ')\n\t\telse:\n\t\t\tprint(y, end=' ')\n", "(a, b) = map(int, input().split(' '))\nd = {}\nfor k in range(b):\n\t(a, b) = input().split(' ')\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\nfor k in input().split(' '):\n\tprint(d[k], end=' ')\n", "(n, m) = map(int, input().split())\nq = []\nw = []\nans = []\nfor i in range(m):\n\t(a, b) = map(str, input().split())\n\tq.append(a)\n\tw.append(b)\nans = list(map(str, input().split()))\nfor i in range(n):\n\tif len(q[q.index(ans[i])]) > len(w[q.index(ans[i])]):\n\t\tans[i] = w[q.index(ans[i])]\nprint(*ans)\n", "(n, m) = map(int, input().split())\nl_first = []\nl_second = []\nfor i in range(m):\n\t(first, second) = input().split()\n\tl_first.append(first)\n\tl_second.append(second)\nl = list(input().split())\ns = ''\nfor i in range(n):\n\tif len(l[i]) > len(l_second[l_first.index(l[i])]):\n\t\ts = s + l_second[l_first.index(l[i])] + ' '\n\telse:\n\t\ts = s + l[i] + ' '\nprint(s)\n", "(lec, w) = map(int, input().split())\nl = {}\nfor t in range(w):\n\tp = list(map(str, input().split()))\n\tl[p[0]] = p[1]\nmain = list(map(str, input().split()))\nfor t in main:\n\tif len(l[t]) < len(t):\n\t\tprint(l[t], end=' ')\n\telse:\n\t\tprint(t, end=' ')\nprint('\\r')\n", "(n, m) = map(int, input().split(' '))\nmp = {}\nfor i in range(m):\n\ts = input().split(' ')\n\t(mp[s[0]], mp[s[1]]) = (min(s, key=len), min(s, key=len))\nprint(' '.join((mp[i] for i in input().split(' '))))\n", "(n, m) = eval(input().replace(' ', ','))\nli1 = []\nli2 = []\ndic = {}\nfor i in range(m):\n\tli1.append(input().split(' '))\n\tif len(li1[i][0]) > len(li1[i][1]):\n\t\tdic[li1[i][0]] = li1[i][1]\n\telse:\n\t\tdic[li1[i][0]] = li1[i][0]\nli2 = input().split(' ')\nfor i in range(n):\n\tli2[i] = dic[li2[i]]\nprint(' '.join(li2))\n", "(n, m) = [int(i) for i in input().split()]\na = {}\nfor i in range(m):\n\t(aa, bb) = input().split()\n\tif len(bb) < len(aa):\n\t\ta[aa] = bb\n\telse:\n\t\ta[aa] = aa\nprint(' '.join([a[i] for i in input().split()]))\n", "(n, m) = map(int, input().split())\ntranslate = {}\nfor i in range(m):\n\t(first, second) = input().split()\n\tif len(first) <= len(second):\n\t\ttranslate[first] = first\n\telse:\n\t\ttranslate[first] = second\nwords = list(input().split())\nanswer = ''\nfor word in words:\n\tanswer += translate[word] + ' '\nprint(answer)\n", "(n, m) = input().strip().split(' ')\n(n, m) = [int(n), int(m)]\nlanguage = {}\nfor i in range(m):\n\twords = list(map(str, input().strip().split(' ')))\n\tlanguage.setdefault(words[0], words[1])\nlecture = list(map(str, input().strip().split(' ')))\ni = 0\nwhile i < n:\n\tif len(lecture[i]) > len(language[lecture[i]]):\n\t\tlecture[i] = language[lecture[i]]\n\ti += 1\nprint(' '.join(lecture))\n", "(n, m) = list(map(int, input().split()))\nl = []\nfor i in range(m):\n\tl.append(list(input().split()))\np = list(input().split())\nd = {}\nfor i in range(m):\n\td[l[i][0]] = l[i][1]\ns = ''\nfor i in range(n):\n\tif len(d[p[i]]) >= len(p[i]):\n\t\ts = s + p[i] + ' '\n\telse:\n\t\ts = s + d[p[i]] + ' '\nprint(s[0:len(s) - 1])\n", "(n, m) = map(int, input().split())\na_list = []\nb_list = []\nfor i in range(m):\n\t(a, b) = input().split()\n\ta_list.append(a)\n\tb_list.append(b)\nlect = input().split()\nans = []\nfor i in lect:\n\tif i in a_list:\n\t\tpos = a_list.index(i)\n\t\tj = b_list[pos]\n\t\tif len(i) > len(j):\n\t\t\tans.append(j)\n\t\telse:\n\t\t\tans.append(i)\n\telse:\n\t\tpos = b_list.index(i)\n\t\tj = a_list[pos]\n\t\tif len(i) > len(j):\n\t\t\tans.append(j)\n\t\telse:\n\t\t\tans.append(i)\nprint(*ans)\n", "(n, m) = list(map(int, input().split()))\n(first, second) = ([], [])\nfor i in range(m):\n\t(a, b) = input().split()\n\tfirst.append(a)\n\tsecond.append(b)\nlecture = input().split()\n(firstlen, secondlen) = ([], [])\nfor i in range(m):\n\tfirstlen.append(len(first[i]))\n\tsecondlen.append(len(second[i]))\nfor word in lecture:\n\ttemp = first.index(word)\n\tif firstlen[temp] <= secondlen[temp]:\n\t\tprint(first[temp], end=' ')\n\telse:\n\t\tprint(second[temp], end=' ')\n", "(n, m) = map(int, input().split())\nwords = []\nfor i in range(m):\n\twords.append(sorted(input().split(), key=len))\nsol = f' {input()} '\nfor word in words:\n\twhile sol.count(f' {word[1]} '):\n\t\tsol = sol.replace(f' {word[1]} ', f' {word[0]} ', 1)\nprint(sol.strip())\n", "(n, m) = map(int, input().split())\nwords = []\nnotes = []\nfor i in range(m):\n\t(z, x) = map(str, input().split())\n\twords.append(z)\n\twords.append(x)\nletter = [x for x in input().split()]\nfor i in range(len(letter)):\n\ttemp = words.index(letter[i])\n\tif temp % 2 == 0:\n\t\tif len(words[temp]) > len(words[temp + 1]):\n\t\t\tnotes.append(words[temp + 1])\n\t\telse:\n\t\t\tnotes.append(words[temp])\n\telif len(words[temp]) < len(words[temp - 1]):\n\t\tnotes.append(words[temp])\n\telse:\n\t\tnotes.append(words[temp - 1])\nprint(*notes)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(r1, r2) = input().split()\n\tif len(r2) < len(r1):\n\t\td[r1] = r2\n\telse:\n\t\td[r1] = r1\nprint(*[d[i] for i in input().split()])\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\ts = input()\n\tl = s.split(' ')\n\tkey = l[0]\n\tvalue = l[1]\n\tdic.update({key: value})\nstr = input()\nl = str.split(' ')\nres = ''\nfor i in l:\n\tif i in dic:\n\t\tif len(i) <= len(dic[i]):\n\t\t\tres = res + i + ' '\n\t\telse:\n\t\t\tres = res + dic[i] + ' '\nprint(res)\n", "(n, m) = map(int, input().split())\nA = [0] * m\nB = [0] * m\nfor i in range(m):\n\t(A[i], B[i]) = input().split()\na = input()\nC = [0] * n\nfor i in range(n - 1):\n\tnum = a.find(' ')\n\tC[i] = a[:num]\n\ta = a[num + 1:]\nC[n - 1] = a\nfor i in range(n):\n\tif C[i] in A:\n\t\tb = A.index(C[i])\n\t\tif len(A[b]) <= len(B[b]):\n\t\t\tprint(A[b], end=' ')\n\t\telse:\n\t\t\tprint(B[b], end=' ')\n\telse:\n\t\tb = B.index(C[i])\n\t\tif len(A[b]) <= len(B[b]):\n\t\t\tprint(A[b], end=' ')\n\t\telse:\n\t\t\tprint(B[b], end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\tl = input().split()\n\td[l[0]] = l[1]\np = input().split()\nfor i in range(n):\n\tif len(p[i]) <= len(d[p[i]]):\n\t\tprint(p[i], end=' ')\n\telse:\n\t\tprint(d[p[i]], end=' ')\n", "l = input().split()\nn = int(l[0])\nm = int(l[1])\nx = []\ny = []\nfor i in range(m):\n\tinp = input().split()\n\tx.append(inp[0])\n\tif len(inp[1]) < len(inp[0]):\n\t\ty.append(inp[1])\n\telse:\n\t\ty.append(inp[0])\nprof = input().split()\nfor i in range(n):\n\tprof[i] = y[x.index(prof[i])]\ns = prof[0]\nfor i in range(1, n):\n\ts += ' ' + prof[i]\nprint(s)\n", "import sys\n(n, m) = [int(x) for x in sys.stdin.readline().split()]\nd = dict()\nfor i in range(m):\n\t(s1, s2) = sys.stdin.readline().split()\n\tif len(s1) > len(s2):\n\t\td[s1] = s2\n\telse:\n\t\td[s2] = s1\nres = []\nfor i in sys.stdin.readline().split():\n\tif i in d:\n\t\tres.append(d[i])\n\telse:\n\t\tres.append(i)\nprint(' '.join(res))\n", "str = input()\n(teach, num) = str.split()\nteach = int(teach)\nnum = int(num)\nf = {}\nfor i in range(num):\n\tstr = input()\n\t(index, f[index]) = str.split()\nans = []\nstr = input()\nb = str.split()\nfor i in range(teach):\n\tif len(f[b[i]]) < len(b[i]):\n\t\tans.append(f[b[i]])\n\telse:\n\t\tans.append(b[i])\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\nresult2 = []\nresult1 = []\nfor i in range(m):\n\tinp = input().split()\n\tresult1.append(inp[0])\n\tif len(inp[1]) < len(inp[0]):\n\t\tresult2.append(inp[1])\n\telse:\n\t\tresult2.append(inp[0])\nql = list(input().split())\nfor i in range(len(ql)):\n\tindex = result1.index(ql[i])\n\tql[i] = result2[index]\nprint(' '.join(ql))\n", "(last, rows) = [int(a) for a in input().split()]\nRows = [0] * rows\nDict = {}\nfor x in range(rows):\n\tPair = input().split()\n\tif len(Pair[0]) > len(Pair[1]):\n\t\tMin = Pair[1]\n\telse:\n\t\tMin = Pair[0]\n\tDict[Pair[0]] = Min\n\tDict[Pair[1]] = Min\nWords = input().split()\nfor word in Words:\n\tprint(Dict[word], end=' ')\n", "(n, k) = map(int, input().split())\nlang1 = []\nlang2 = []\nfor i in range(k):\n\tstr1 = input()\n\t(a, b) = str1.split(' ')\n\tlang1.append(a)\n\tlang2.append(b)\nstr1 = input()\nprof = list(str1.split(' '))\nnotes = []\nfor i in range(n):\n\tword = prof[i]\n\tif lang1.count(word) == 1:\n\t\tindex = lang1.index(word)\n\t\tif len(lang1[index]) > len(lang2[index]):\n\t\t\tprint(lang2[index], end=' ')\n\t\telif len(lang1[index]) == len(lang2[index]):\n\t\t\tprint(lang1[index], end=' ')\n\t\telif len(lang1[index]) < len(lang2[index]):\n\t\t\tprint(lang1[index], end=' ')\n\telif lang2.count(word) == 1:\n\t\tindex = lang2.index(word)\n\t\tif len(lang1[index]) > len(lang2[index]):\n\t\t\tprint(lang2[index], end=' ')\n\t\telif len(lang1[index]) == len(lang2[index]):\n\t\t\tprint(lang1[index], end=' ')\n\t\telif len(lang1[index]) < len(lang2[index]):\n\t\t\tprint(lang1[index], end=' ')\nprint('\\n')\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\ttext = input().split()\n\tif len(text[0]) <= len(text[1]):\n\t\td[text[0]] = text[0]\n\telse:\n\t\td[text[0]] = text[1]\nnum = list(map(str, input().split()))\nfor i in range(0, n):\n\tprint(d[num[i]], end=' ')\n", "n = input().split(' ')\nstr = ''\nnew = []\nb = {}\nfor i in range(int(n[1])):\n\tn1 = input().split(' ')\n\tb[n1[0]] = n1[1]\nstr = input().split(' ')\nfor k in str:\n\tif len(k) <= len(b[k]):\n\t\tnew.append(k)\n\telse:\n\t\tnew.append(b[k])\nnew1 = ' '.join(new)\nprint(new1)\n", "(len_speech, num_words) = map(int, input().split())\nwords = {}\nfor x in range(num_words):\n\t(in1, in2) = map(str, input().split())\n\twords[in1] = in2\nspeech = list(input().split())\nfor x in range(len_speech - 1):\n\tif len(speech[x]) > len(words[speech[x]]):\n\t\tprint(words[speech[x]], end=' ')\n\telse:\n\t\tprint(speech[x], end=' ')\nif len(speech[len_speech - 1]) > len(words[speech[len_speech - 1]]):\n\tprint(words[speech[len_speech - 1]], end='')\nelse:\n\tprint(speech[len_speech - 1], end='')\n", "(a, b) = map(int, input().split())\ntotal = []\nans = ''\nfor i in range(b):\n\t(z, x) = input().split()\n\tif len(z) == len(x):\n\t\ttotal.append([z, x])\n\telif len(z) < len(x):\n\t\ttotal.append([z, x])\n\telse:\n\t\ttotal.append([x, z])\nword = input()\nfor i in word.split():\n\tfor x in total:\n\t\tif i in x:\n\t\t\tans += x[0] + ' '\nprint(ans)\n", "n = list(map(int, input().split()))\nlan1 = []\nlan2 = []\nfor i in range(n[1]):\n\tt = input().split()\n\tlan1.append(t[0])\n\tlan2.append(t[1])\nstr = input().split()\nfor i in str:\n\tt = lan1.index(i)\n\tif len(lan1[t]) <= len(lan2[t]):\n\t\tprint(lan1[t], end='')\n\telse:\n\t\tprint(lan2[t], end='')\n\tif not str.index(i) == len(str) - 1:\n\t\tprint(' ', end='')\n", "(n, k) = map(int, input().split())\nd = {}\nfor _ in range(k):\n\t(a, b) = map(str, input().split())\n\tif len(a) <= len(b):\n\t\td[a] = a\n\telse:\n\t\td[a] = b\ns = list(map(str, input().split()))\nw = ''\nfor i in range(n):\n\tw += d[s[i]] + ' '\nprint(w)\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\t(s1, s2) = input().split()\n\tdic[s1] = s2\nsample = input().split()\nfor i in sample:\n\ts3 = dic[i]\n\tif len(i) <= len(s3):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(s3, end=' ')\n", "(n, m) = [int(x) for x in input().split()]\nlanguage = {}\nfor i in range(m):\n\tword = [x for x in input().split()]\n\tif len(word[0]) <= len(word[1]):\n\t\tlanguage[word[0]] = word[0]\n\telse:\n\t\tlanguage[word[0]] = word[1]\nlecture = [x for x in input().split()]\nnote = []\nfor i in lecture:\n\tnote.append(language[i])\nprint(' '.join(note))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\td[a] = b\nout = ''\nfor i in input().split():\n\tif len(i) <= len(d[i]):\n\t\tout += i + ' '\n\telif len(i) > len(d[i]):\n\t\tout += d[i] + ' '\nprint(out.rstrip())\n", "__author__ = 'Rakshak.R.Hegde'\n(n, m) = map(int, input().split())\ntrans = dict()\nfor i in range(m):\n\t(x, y) = input().split()\n\ttrans[x] = y\nlect = input().split()\nans = ''\nfor w in lect:\n\tans += min(w, trans[w], key=lambda x: len(x)) + ' '\nprint(ans)\n", "a = [int(i) for i in input().split()]\ndic = {}\nfor i in range(a[1]):\n\tc = input().split()\n\tdic[c[0]] = c[1]\nc = input().split()\nletter = ''\nfor i in c:\n\tif len(i) > len(dic[i]):\n\t\tletter += dic[i] + ' '\n\telse:\n\t\tletter += i + ' '\nprint(letter)\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\td[a] = b\n\telif len(a) < len(b):\n\t\td[b] = a\nfor i in input().split():\n\tprint(d.get(i, i), end=' ')\n", "nm = list(map(int, input().split()))\nn = nm[0]\nm = nm[1]\n(l1, l2) = ([], [])\nshorter = []\nfor i in range(m):\n\t(a1, a2) = input().split()\n\tl1.append(a1)\n\tl2.append(a2)\n\tmini = a2 if len(a1) > len(a2) else a1\n\tshorter.append(mini)\ntext_words = list(input().split())\nfor word in text_words:\n\tif word in l1:\n\t\tprint(shorter[l1.index(word)], end=' ')\n\telse:\n\t\tprint(shorter[l2.index(word)], end=' ')\n", "(n, m) = tuple([int(x) for x in input().split()])\nd = {}\nfor x in range(0, m):\n\tt = tuple([x for x in input().split()])\n\td[t[0]] = t[1]\ns = input()\nl = s.split()\no = ''\nfor x in l:\n\tif len(x) > len(d[x]):\n\t\to += ' ' + d[x]\n\telse:\n\t\to += ' ' + x\nprint(o.strip())\n", "(n, m) = [int(i) for i in input().split()]\nlst = []\nwhile m:\n\tm -= 1\n\ts = input()\n\tfor i in s.split():\n\t\tlst.append(i)\ns = input()\nlst2 = []\nfor i in s.split():\n\tlst2.append(i)\ns = ''\nfor i in range(n):\n\tx = lst.index(lst2[i])\n\tif len(lst[x]) <= len(lst[x + 1]):\n\t\ts += lst[x] + ' '\n\telse:\n\t\ts += lst[x + 1] + ' '\nprint(s)\n", "(n, m) = map(int, input().split())\na = {}\nfor i in range(m):\n\t(n, m) = input().split()\n\ta[n] = m\nst = input()\nst1 = ''\nfor i in st.split():\n\tif len(a[i]) < len(i):\n\t\tst1 += a[i] + ' '\n\telse:\n\t\tst1 += i + ' '\nprint(st1)\n", "[a, b] = map(int, input().split())\nd = {}\nfor i in range(b):\n\t[s1, s2] = map(str, input().split())\n\td.update({s1: s2})\ns = list(map(str, input().split()))\nfor i in range(a):\n\tif len(s[i]) > len(d[s[i]]):\n\t\ts[i] = d[s[i]]\nprint(' '.join(s))\n", "(n, m) = map(int, input().split())\nd = {}\nfor i in range(m):\n\t(w, v) = input().split()\n\td[w] = v\nls = input().split()\nfor i in range(len(ls)):\n\tif len(d[ls[i]]) < len(ls[i]):\n\t\tls[i] = d[ls[i]]\nprint(' '.join(ls))\n", "one = two = i = str()\n(n, m) = [int(i) for i in input('').split(' ')]\nword = dict()\nj = int()\nfor j in range(m):\n\t(one, two) = input('').split(' ')\n\tif len(one) <= len(two):\n\t\tword[one] = one\n\telse:\n\t\tword[one] = two\nfor i in input('').split(' '):\n\tprint(word[i], end=' ')\n", "a = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(x, y) = map(str, input().split())\n\tif len(x) > len(y):\n\t\ta[x] = y\n\telse:\n\t\ta[x] = x\nb = [str(x) for x in input().split()]\nfor j in b:\n\tprint(a[j], end=' ')\nprint('\\n')\n", "(a, b) = map(int, input().split())\nm = {}\nfor i in range(b):\n\t(x, y) = map(str, input().split())\n\tif len(x) == len(y):\n\t\tcontinue\n\telif len(x) < len(y):\n\t\tm[y] = x\n\telse:\n\t\tm[x] = y\narr = list(map(str, input().split()))\nfor i in range(a):\n\tif arr[i] in m:\n\t\tarr[i] = m[arr[i]]\n\telse:\n\t\tcontinue\nprint(*arr)\n", "(n, m) = map(int, input().split())\na = []\nfor i in range(m):\n\tb = input().split()\n\tif len(b[1]) < len(b[0]):\n\t\tb.reverse()\n\ta += b\ns = input().split()\nd = ''\nfor i in s:\n\td += a[a.index(i) // 2 * 2] + ' '\nprint(d)\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ndictt = []\nfor i in range(m):\n\t(a, b) = input().split()\n\tdictt.append(a)\n\tdictt.append(b)\na = input().split()\nfor i in a:\n\tpos = dictt.index(i) // 2\n\tif len(dictt[2 * pos]) <= len(dictt[2 * pos + 1]):\n\t\tprint(dictt[2 * pos], end=' ')\n\telse:\n\t\tprint(dictt[2 * pos + 1], end=' ')\n", "is_debug = False\n(n, m) = [int(x) for x in input().split()]\nd = {}\nfor i in range(0, m):\n\t(k, v) = input().split()\n\tv = k if len(k) <= len(v) else v\n\td[k] = v\nprint(f'd={d}') if is_debug else ''\ns = input().split()\nl = []\nfor c in s:\n\tl.append(d[c])\nprint(f\"{' '.join(l)}\")\n", "size = list(map(int, input().split()))\nwords = {}\nfor i in range(size[1]):\n\ttemp = input().split()\n\tif len(temp[0]) > len(temp[1]):\n\t\twords[temp[0]] = temp[1]\n\telse:\n\t\twords[temp[0]] = temp[0]\nlec_words = input().split()\nfi = ''\nfor i in range(len(lec_words)):\n\tif i != len(lec_words) - 1:\n\t\tfi = fi + f'{words[lec_words[i]]} '\n\telse:\n\t\tfi = fi + f'{words[lec_words[i]]}'\nprint(fi)\n", "(n, m) = map(int, input().split())\n(firstLanguage, secondLanguage) = ([], [])\nfor i in range(m):\n\tline = input().split()\n\tfirstLanguage.append(line[0])\n\tsecondLanguage.append(line[1])\ns = input().split()\nfor i in s:\n\tidx = 0\n\tif firstLanguage.index(i) < 0:\n\t\tidx = secondLanguage.index(i)\n\telse:\n\t\tidx = firstLanguage.index(i)\n\tif len(firstLanguage[idx]) <= len(secondLanguage[idx]):\n\t\tprint(firstLanguage[idx], end=' ')\n\telse:\n\t\tprint(secondLanguage[idx], end=' ')\n", "(n, m) = tuple(map(int, input().split()))\ndic = {}\nfor k in range(m):\n\t(a, b) = tuple(input().split())\n\tif len(a) <= len(b):\n\t\tdic[a] = a\n\t\tdic[b] = a\n\telse:\n\t\tdic[a] = b\n\t\tdic[b] = b\nprint(' '.join(list(map(lambda x: dic[x], input().split()))))\n", "from collections import deque, Counter, OrderedDict\nfrom heapq import nsmallest, nlargest\nfrom math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi\n\ndef binNumber(n, size=4):\n\treturn bin(n)[2:].zfill(size)\n\ndef iar():\n\treturn list(map(int, input().split()))\n\ndef ini():\n\treturn int(input())\n\ndef isp():\n\treturn map(int, input().split())\n\ndef sti():\n\treturn str(input())\n\ndef par(a):\n\tprint(' '.join(list(map(str, a))))\n\ndef tdl(outerListSize, innerListSize, defaultValue=0):\n\treturn [[defaultValue] * innerListSize for i in range(outerListSize)]\n\ndef sts(s):\n\ts = list(s)\n\ts.sort()\n\treturn ''.join(s)\n\nclass pair:\n\n\tdef __init__(self, f, s):\n\t\tself.fi = f\n\t\tself.se = s\n\n\tdef __lt__(self, other):\n\t\treturn (self.fi, self.se) < (other.fi, other.se)\na = {}\n(n, m) = isp()\nwhile m > 0:\n\t(s1, s2) = map(str, input().split())\n\ta[s1] = s2\n\tm -= 1\ns = list(map(str, input().split()))\nfor i in s:\n\tif len(i) <= len(a[i]):\n\t\tprint(i, end=' ')\n\telse:\n\t\tprint(a[i], end=' ')\n", "(n, m) = map(int, input().split())\nf = []\ns = []\nfor i in range(m):\n\tz = input().split()\n\tf.append(z[0])\n\ts.append(z[1])\nz = input().split()\nt = ''\nfor x in z:\n\ti = f.index(x)\n\tif len(s[i]) < len(f[i]):\n\t\tt += s[i] + ' '\n\telse:\n\t\tt += f[i] + ' '\nprint(t)\n", "(n, k) = map(int, input().split())\nl = []\nr = []\nfor i in range(k):\n\tx = list(map(str, input().split()))\n\tl.append([x[0], len(x[0])])\n\tr.append([x[1], len(x[1])])\ny = list(map(str, input().split()))\nh = []\nfor i in y:\n\tk = l.index([i, len(i)])\n\tif l[k][1] > r[k][1]:\n\t\th.append(r[k][0])\n\telse:\n\t\th.append(l[k][0])\nprint(' '.join(h))\n", "def main():\n\tfrom sys import stdin, stdout\n\t(n, m) = map(int, stdin.readline().split())\n\tmydic = {}\n\tfor _ in range(m):\n\t\t(a, b) = map(str, stdin.readline().strip().split())\n\t\tmydic[a] = b\n\tfor k in stdin.readline().strip().split():\n\t\tif len(mydic[k]) < len(k):\n\t\t\tstdout.write(mydic[k] + ' ')\n\t\telse:\n\t\t\tstdout.write(k + ' ')\nmain()\n", "(m, n) = map(int, input().split())\nx = []\ny = []\nfor i in range(n):\n\t(p, q) = input().split()\n\tx.append(p)\n\ty.append(q)\nz = list(input().split())\nfor i in z:\n\tif i in x:\n\t\ta = i\n\t\tb = y[x.index(i)]\n\telse:\n\t\tb = i\n\t\ta = x[y.index(i)]\n\tif len(a) <= len(b):\n\t\tprint(a, end=' ')\n\telse:\n\t\tprint(b, end=' ')\n", "inp = input().split()\nn = int(inp[0])\nm = int(inp[1])\nl = {}\nfor _ in range(m):\n\tst = input().split()\n\tl[st[0]] = st[1]\nlec = input().split()\nfor x in lec:\n\tl2 = l[x]\n\tif len(l2) < len(x):\n\t\tprint(l2, end=' ')\n\telse:\n\t\tprint(x, end=' ')\n", "(a, b) = map(int, input().split())\nd = {}\nfor i in range(b):\n\t(j, k) = map(str, input().split())\n\td[j] = k\nk = input().split()\nl = []\nfor i in k:\n\tif len(d[i]) < len(i):\n\t\tl.append(d[i])\n\telse:\n\t\tl.append(i)\nprint(*l)\n", "def read_input():\n\t(n, m) = [int(i) for i in input().split(' ')]\n\trows = [input() for _ in range(m)]\n\tlecture = [c for c in input().split(' ')]\n\treturn (n, m, rows, lecture)\n\ndef do_lecture(n, m, rows, lecture):\n\tdic = {}\n\tfor row in rows:\n\t\t(first, second) = row.split(' ')\n\t\tdic[first] = first if min(len(first), len(second)) == len(first) else second\n\toutput = []\n\tfor word in lecture:\n\t\toutput.append(dic[word])\n\treturn output\n\ndef main():\n\t(n, m, rows, lecture) = read_input()\n\tprint(' '.join(do_lecture(n, m, rows, lecture)))\nmain()\n", "(words_in_lecture, words_in_language) = [int(a) for a in input().strip().split()]\nlang1_to_2 = dict()\nlang2_to_1 = dict()\nfor _ in range(words_in_language):\n\t(lang1, lang2) = [a for a in input().strip().split()]\n\tlang1_to_2[lang1] = lang2\n\tlang2_to_1[lang2] = lang1\nlecture_content = [a for a in input().strip().split()]\ntranslated = []\nfor word in lecture_content:\n\tif word in lang1_to_2.keys():\n\t\tif len(word) <= len(lang1_to_2[word]):\n\t\t\ttranslated.append(word)\n\t\telse:\n\t\t\ttranslated.append(lang1_to_2[word])\n\telif len(word) < len(lang2_to_1[word]):\n\t\ttranslated.append(word)\n\telse:\n\t\ttranslated.append(lang2_to_1[word])\nprint(' '.join(translated))\n", "(n, m) = list(map(int, input().split()))\nwords = []\nfor i in range(m):\n\t(a, b) = input().split()\n\twords.append(a)\n\twords.append(b)\ns = input()\nfor i in s.split():\n\tind = words.index(i)\n\tif ind % 2 == 0:\n\t\tlan1 = words[ind]\n\t\tlan2 = words[ind + 1]\n\telse:\n\t\tlan1 = words[ind]\n\t\tlan2 = words[ind - 1]\n\tif len(lan1) <= len(lan2):\n\t\tprint(lan1, end=' ')\n\telse:\n\t\tprint(lan2, end=' ')\n", "(n, m) = map(int, input().split())\nd = {}\nfor m0 in range(m):\n\t(a, b) = input().split()\n\tif len(a) <= len(b):\n\t\td[a] = a\n\t\td[b] = a\n\telse:\n\t\td[a] = b\n\t\td[b] = b\nc = input().split()\nl = [d[i] for i in c]\nprint(' '.join(l))\n", "(a, b) = map(int, input().split())\n(fl, sl) = ([], [])\nfor _ in range(b):\n\t(c, d) = map(str, input().split())\n\tfl.append(c)\n\tsl.append(d)\nf = list(map(str, input().split()))\nans = []\nfor _ in range(len(f)):\n\tind = fl.index(f[_])\n\tif len(f[_]) <= len(sl[ind]):\n\t\tans.append(f[_])\n\telse:\n\t\tans.append(sl[ind])\nprint(' '.join(ans))\n", "(n, m) = map(int, input().split())\nD = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\tD.update({a: b})\ns = input().split()\nS = str()\nfor i in s:\n\tif i in D.keys():\n\t\tS += D[i] + ' '\n\telse:\n\t\tS += i + ' '\nprint(S.rstrip())\n", "T = input().split()\nn = int(T[0])\nm = int(T[1])\nRelation = dict()\nfor i in range(m):\n\twords = input().split(sep=' ')\n\tlang1 = words[0]\n\tlang2 = words[1]\n\tif len(lang1) > len(lang2):\n\t\tRelation.update({lang1: lang2})\n\telse:\n\t\tRelation.update({lang2: lang1})\nlecture = input().split(sep=' ')\nans = []\nfor word in lecture:\n\tif Relation.get(word):\n\t\tans.append(Relation.get(word))\n\telse:\n\t\tans.append(word)\nprint(*ans)\n", "(n, m) = map(int, input().split(' '))\nf = [0] * n\nd = {}\nfor i in range(m):\n\t(a, b) = input().split(' ')\n\td[a] = b\ns = input().split(' ')\nfor (i, w) in enumerate(s):\n\tf[i] = w if len(w) <= len(d[w]) else d[w]\nprint(' '.join(f))\n", "(n, m) = map(int, input().split())\nhash = {}\nfor i in range(m):\n\t(k1, k2) = map(str, input().split())\n\thash[k1] = [k2, 1]\n\thash[k2] = [k1, 2]\nz = input()\nans = z.split()\nst = []\nfor i in ans:\n\tif len(hash[i][0]) < len(i):\n\t\tst.append(hash[i][0])\n\telif len(hash[i][0]) > len(i):\n\t\tst.append(i)\n\telif len(hash[i][0]) == len(i):\n\t\tif hash[i][1] == 1:\n\t\t\tst.append(i)\n\t\telse:\n\t\t\tst.append(hash[i][0])\nfor i in st:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\tx = input().split()\n\ta.append(x[0])\n\tb.append(x[1])\ns = input().split()\nl = []\nfor j in range(len(s)):\n\tl.append(s[j])\nans = ''\nfor i in l:\n\tif i in a:\n\t\tind = a.index(i)\n\telse:\n\t\tind = b.index(i)\n\tq = len(a[ind])\n\tw = len(b[ind])\n\tif w < q:\n\t\tans += b[ind]\n\t\tans += ' '\n\telse:\n\t\tans += a[ind]\n\t\tans += ' '\nprint(ans)\n", "def solve_the_problem():\n\t(n, m) = [int(x) for x in input().split(' ')]\n\tdictionary = {}\n\tfor i in range(0, m):\n\t\t(word, translation) = input().split(' ')\n\t\tdictionary[word] = translation\n\tteachers_speech = input().split(' ')\n\tresult = ''\n\tfor word in teachers_speech:\n\t\tif len(word) <= len(dictionary[word]):\n\t\t\tresult += word\n\t\t\tresult += ' '\n\t\telse:\n\t\t\tresult += dictionary[word]\n\t\t\tresult += ' '\n\tprint(result[:-1])\nsolve_the_problem()\n", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nlist1 = []\nlist2 = []\nsent = []\nanswer = []\nfor i in range(0, m):\n\t(x, y) = input().split()\n\tlist1.append(x)\n\tlist2.append(y)\nsent = input().split()\nfor i in range(0, len(sent)):\n\ttemp = sent[i]\n\tind = list1.index(temp)\n\tif len(list1[ind]) <= len(list2[ind]):\n\t\tanswer.append(list1[ind])\n\telse:\n\t\tanswer.append(list2[ind])\nprint(*answer)\n", "(n, m) = map(int, input().split())\ndicti = {}\nfor i in range(m):\n\t(first, second) = map(str, input().split())\n\tif len(first) <= len(second):\n\t\tdicti[first] = first\n\t\tdicti[second] = first\n\telse:\n\t\tdicti[first] = second\n\t\tdicti[second] = second\nsentence = list(map(str, input().split()))\nfor i in range(len(sentence)):\n\tsentence[i] = dicti[sentence[i]]\nprint(' '.join(sentence))\n", "([n, m], word_pairs) = ([int(i) for i in input().split()], [])\nfor i in range(m):\n\tword_pairs.append(input().split())\nsentence = input().split()\nword_map = {}\nfor pair in word_pairs:\n\tword = pair[0] if len(pair[0]) <= len(pair[1]) else pair[1]\n\tword_map[pair[0]] = word\n\tword_map[pair[1]] = word\nfor (i, word) in enumerate(sentence):\n\tsentence[i] = word_map[word]\nprint(' '.join([x for x in sentence]))\n", "def get_shorter(ci, _a, _b):\n\t_i = 0\n\twhile ci != _a[_i]:\n\t\t_i += 1\n\treturn _a[_i] if len(_a[_i]) <= len(_b[_i]) else _b[_i]\n(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(ai, bi) = input().split()\n\ta.append(ai)\n\tb.append(bi)\nc = input().split()\nresult = []\nfor i in range(n):\n\tresult.append(get_shorter(c[i], a, b))\nprint(*result, sep=' ')\n", "(n, m) = map(int, input().split())\ndic = {}\nfor i in range(m):\n\ta = input().split()\n\tif len(a[1]) < len(a[0]):\n\t\tdic.update({a[0]: a[1]})\nlec = input().split()\noutput = []\nfor i in lec:\n\tif i in dic:\n\t\toutput.append(dic[i])\n\telse:\n\t\toutput.append(i)\nprint(' '.join(output))\n", "(a, b) = map(int, input().split())\nz = {}\nfor x in range(b):\n\t(c, d) = input().split()\n\tif len(d) < len(c):\n\t\tz[c] = d\n\telse:\n\t\tz[c] = c\nl = list(input().split())\nfor x in range(a):\n\tl[x] = z[l[x]]\nprint(*l)\n", "(n, m) = map(int, input().split())\nl1 = []\nl2 = []\nfor i in range(m):\n\t(s1, s2) = map(str, input().split())\n\tl1.append(s1)\n\tl2.append(s2)\nl3 = list(map(str, input().split()))\nfs = ''\n(c, d, e) = (0, 0, 0)\nf = 0\nfor i in l3:\n\tif i in l1:\n\t\te = l1.index(i)\n\t\td = len(l2[e])\n\t\tc = len(i)\n\t\tif c <= d:\n\t\t\tfs += i\n\t\t\tfs += ' '\n\t\telse:\n\t\t\tfs += l2[e]\n\t\t\tfs += ' '\n\telse:\n\t\te = l2.index(i)\n\t\tc = len(l1[e])\n\t\td = len(i)\n\t\tif c <= d:\n\t\t\tfs += l1[e]\n\t\t\tfs += ' '\n\t\telse:\n\t\t\tfs += i\n\t\t\tfs += ' '\nprint(fs)\n", "dictionarie = {}\n(n, m) = map(int, input().split())\nfor i in range(m):\n\t(lang_1, lang_2) = input().split()\n\tif len(lang_1) <= len(lang_2):\n\t\tdictionarie[lang_2] = lang_1\n\telse:\n\t\tdictionarie[lang_1] = lang_2\nlecture = input().split()\nfor i in range(n):\n\tif lecture[i] in dictionarie.keys():\n\t\tlecture[i] = dictionarie[lecture[i]]\nprint(' '.join(lecture))\n", "from sys import stdin, stdout\nimport bisect\nimport math\n\ndef st():\n\treturn list(stdin.readline())\n\ndef inp():\n\treturn int(stdin.readline())\n\ndef li():\n\treturn list(map(int, stdin.readline().split()))\n\ndef mp():\n\treturn map(int, stdin.readline().split())\n\ndef pr(n):\n\tstdout.write(str(n) + '\\n')\n\ndef soe(limit):\n\tl = [1] * (limit + 1)\n\tprime = []\n\tfor i in range(2, limit + 1):\n\t\tif l[i]:\n\t\t\tfor j in range(i * i, limit + 1, i):\n\t\t\t\tl[j] = 0\n\tfor i in range(2, limit + 1):\n\t\tif l[i]:\n\t\t\tprime.append(i)\n\treturn prime\n\ndef segsoe(low, high):\n\tlimit = int(high ** 0.5) + 1\n\tprime = soe(limit)\n\tn = high - low + 1\n\tl = [0] * (n + 1)\n\tfor i in range(len(prime)):\n\t\tlowlimit = low // prime[i] * prime[i]\n\t\tif lowlimit < low:\n\t\t\tlowlimit += prime[i]\n\t\tif lowlimit == prime[i]:\n\t\t\tlowlimit += prime[i]\n\t\tfor j in range(lowlimit, high + 1, prime[i]):\n\t\t\tl[j - low] = 1\n\tfor i in range(low, high + 1):\n\t\tif not l[i - low]:\n\t\t\tif i != 1:\n\t\t\t\tprint(i)\n\ndef power(a, n):\n\tr = 1\n\twhile n:\n\t\tif n & 1:\n\t\t\tr = r * a\n\t\t\tn = n - 1\n\t\telse:\n\t\t\ta = a * a\n\t\t\tn = n >> 1\n\treturn r\n\ndef solve():\n\t(n, m) = mp()\n\tx = []\n\tp = []\n\tfor i in range(m):\n\t\ts = input().split()\n\t\tx.append(s)\n\t\tif len(s[0]) <= len(s[1]):\n\t\t\tp.append(s[0])\n\t\telse:\n\t\t\tp.append(s[1])\n\tl = input().split()\n\ty = []\n\tfor i in l:\n\t\tif i in p:\n\t\t\ty.append(i)\n\t\telse:\n\t\t\tfor j in range(m):\n\t\t\t\tif i in x[j]:\n\t\t\t\t\tif len(x[j][0]) <= len(x[j][1]):\n\t\t\t\t\t\ty.append(x[j][0])\n\t\t\t\t\telse:\n\t\t\t\t\t\ty.append(x[j][1])\n\tprint(*y)\nsolve()\n", "(n, m) = input().split()\na = []\nb = []\nfor i in range(int(m)):\n\t(s, k) = input().split()\n\ta.append(s)\n\tb.append(k)\nw = list(input().split(' '))\nfor i in w:\n\tif i in a:\n\t\tind = a.index(i)\n\telse:\n\t\tind = b.index(i)\n\tif len(b[ind]) > len(a[ind]) or len(b[ind]) == len(a[ind]):\n\t\tprint(a[ind], end=' ')\n\telse:\n\t\tprint(b[ind], end=' ')\n", "(n, m) = map(int, input().split())\na = []\nb = []\nfor i in range(m):\n\t(a1, b1) = input().split()\n\ta.append(a1)\n\tb.append(b1)\nc = list(input().split())\nans = ''\nfor i in range(n):\n\tc1 = a.index(c[i])\n\tans += min(a[c1], b[c1], key=len)\n\tans += ' '\nprint(ans)\n", "n = input().split()\nk = []\nk.append('0')\nfor i in range(0, int(n[1])):\n\ttemp = input().split()\n\tk.append(temp[0])\n\tk.append(temp[1])\nlek = input().split()\nst = ''\nfor i in lek:\n\tnum = k.index(i)\n\ttemp1 = 0\n\ttemp2 = 0\n\tif num % 2 == 1:\n\t\ttemp1 = k[num]\n\t\ttemp2 = k[num + 1]\n\telse:\n\t\ttemp1 = k[num - 1]\n\t\ttemp2 = k[num]\n\tif len(temp1) > len(temp2):\n\t\tst += temp2 + ' '\n\telif len(temp2) > len(temp1):\n\t\tst += temp1 + ' '\n\telse:\n\t\tst += temp1 + ' '\nprint(st.strip())\n", "first_line = list(map(int, input().split()))\nmy_dict = dict()\nfor i in range(first_line[1]):\n\ttwo_words = list(input().split())\n\tif len(two_words[0]) <= len(two_words[1]):\n\t\tmy_dict[two_words[0]] = two_words[0]\n\t\tmy_dict[two_words[1]] = two_words[0]\n\telse:\n\t\tmy_dict[two_words[0]] = two_words[1]\n\t\tmy_dict[two_words[1]] = two_words[1]\noutput = list()\nfor w in list(input().split()):\n\toutput.append(my_dict[w])\nprint(*output)\n", "d = {}\n(n, m) = list(map(int, input().split()))\nfor _ in range(m):\n\t(a, b) = input().split()\n\tif len(b) == max(len(a), len(b)):\n\t\td[b] = a\n\telse:\n\t\td[a] = b\nc = input().split()\nfor s in c:\n\tprint(d[s] if s in d else s, end=' ')\n", "(n, m) = [int(i) for i in input().split()]\ndic = {}\nfor i in range(m):\n\t(a, b) = [j for j in input().split()]\n\tdic[a] = b\nprofessorL = [i for i in input().split()]\nlecture = [''] * n\nfor i in range(n):\n\ts = professorL[i]\n\tla = len(s)\n\tlb = len(dic[s])\n\tif la <= lb:\n\t\tlecture[i] = s\n\telse:\n\t\tlecture[i] = dic[s]\nprint(*lecture)\n", "(n, m) = map(int, input().split())\narr_1 = []\narr_2 = []\nfor _ in range(m):\n\t(a, b) = input().split()\n\tarr_1.append(a)\n\tarr_2.append(b)\nsentence = list(input().split())\nans = []\nnotes = []\nfor i in sentence:\n\tans.append(arr_1.index(i))\nfor i in ans:\n\tif len(arr_1[i]) < len(arr_2[i]):\n\t\tnotes.append(arr_1[i])\n\telif len(arr_1[i]) > len(arr_2[i]):\n\t\tnotes.append(arr_2[i])\n\telse:\n\t\tnotes.append(arr_1[i])\nfor i in notes:\n\tprint(i, end=' ')\n", "(n, m) = map(int, input().split())\nlanguage_one = []\nlanguage_two = []\nfor x in range(m):\n\t(a, b) = map(str, input().split())\n\tlanguage_one += [a]\n\tlanguage_two += [b]\nlecture = list(input().split())\nfor x in lecture:\n\tb = language_one.index(x)\n\tif len(x) <= len(language_two[b]):\n\t\tprint(x, end=' ')\n\telse:\n\t\tprint(language_two[b], end=' ')\n", "words = {k: v for (k, v) in (input().split() for i in range(0, int(input().split()[1])))}\nprint(' '.join((min(w, words[w], key=len) for w in input().split())))\n", "def rii():\n\treturn [int(x) for x in input().split()]\n(n, m) = rii()\nmapping = {}\nfor _ in range(m):\n\t(k, v) = input().split()\n\tmapping[k] = k if len(k) <= len(v) else v\n\tmapping[v] = k if len(k) <= len(v) else v\nprint(' '.join((mapping[w] for w in input().split())))\n", "(n, k) = map(int, input().split())\nll = []\nfor i in range(k):\n\tStr = input().split()\n\tll.append(Str)\nString = input().split()\nfor i in range(n):\n\tf = String[i]\n\tfor j in range(len(ll)):\n\t\tg = ll[j][0]\n\t\tif g == String[i]:\n\t\t\tif len(ll[j][1]) < len(f):\n\t\t\t\tString[i] = ll[j][1]\n\t\t\t\tbreak\nprint(*String)\n", "temp = str(input()).split(' ')\n(x, y) = (int(temp[0]), int(temp[1]))\nd = {}\nfor i in range(y):\n\ttemp = [x for x in input().split(' ')]\n\td[temp[0]] = temp[0] if len(temp[0]) <= len(temp[1]) else temp[1]\nans = ''\nfor i in input().split(' '):\n\tans += d[i] + ' '\nprint(ans[:-1])\n", "(n, m) = map(int, input().split())\nabb = {}\nfor i in range(m):\n\t(a, b) = input().split()\n\tc = a if len(a) <= len(b) else b\n\tabb[a] = c\nnotes = []\nS = input().split()\nfor s in S:\n\tnotes.append(abb[s])\nprint(' '.join(map(str, notes)))\n", "(n, m) = input().split(' ')\nn = int(n)\nm = int(m)\nmylib = {}\nfor i in range(m):\n\tstring = input().split(' ')\n\tmylib.update({string[0]: string[1]})\nletter = input().split(' ')\nfor i in range(len(letter)):\n\tif len(letter[i]) <= len(mylib.get(letter[i])):\n\t\tprint(letter[i], end=' ')\n\telse:\n\t\tprint(mylib.get(letter[i]), end=' ')\n", "(n, m) = map(int, input().split())\nws = dict()\nfor i in range(m):\n\t(w1, w2) = input().split()\n\tws[w1] = w2 if len(w2) < len(w1) else w1\nls = input().split()\nrs = [ws[w] for w in ls]\nprint(' '.join(rs))\n", "(N, M) = map(int, input().split())\nmap = {}\nfor i in range(M):\n\t(w1, w2) = input().split()\n\tmap[w1] = w2\nres = []\nfor w in input().split():\n\tif len(w) <= len(map[w]):\n\t\tres.append(w)\n\telse:\n\t\tres.append(map[w])\nprint(' '.join(res))\n", "(n, m) = [int(x) for x in input().split()]\nlst = {}\nfor x in range(m):\n\tx = input().split()\n\tif len(x[0]) > len(x[1]):\n\t\tlst[x[0]] = x[1]\n\telse:\n\t\tlst[x[1]] = x[0]\nprofs = [x for x in input().split()]\n\ndef notes(lst, profs):\n\tfinalWords = []\n\tfor word in profs:\n\t\tif word in lst.keys():\n\t\t\tfinalWords.append(lst[word])\n\t\telse:\n\t\t\tfinalWords.append(word)\n\treturn ' '.join(finalWords)\nprint(notes(lst, profs))\n", "(n, m) = [int(i) for i in input().split()]\nwords = {}\nfor i in range(0, m):\n\t(a, b) = input().split()\n\tif len(a) > len(b):\n\t\twords[a] = b\n\telse:\n\t\twords[a] = a\nstring = input()\nres = string.split()\nfor word in res:\n\tprint(words[word], end=' ')\n", "(n, m) = map(int, input().split())\nslownik = dict()\nfor i in range(m):\n\t(a, b) = input().split()\n\tslownik[a] = b\n\tslownik[b] = a\na = input().split()\nfor i in a:\n\tif len(slownik[i]) < len(slownik[slownik[i]]):\n\t\tprint(slownik[i], end=' ')\n\telse:\n\t\tprint(slownik[slownik[i]], end=' ')\n", "(n, m) = tuple(map(int, input().split()))\ndic = dict()\nfor _ in range(m):\n\t(a, b) = input().rsplit()\n\tdic[a] = b\nwords = input().rsplit()\nout = list()\nfor word in words:\n\tif len(dic[word]) < len(word):\n\t\tout.append(dic[word])\n\telse:\n\t\tout.append(word)\nprint(' '.join(out))\n", "(m, n) = [int(x) for x in input().split(' ')]\ndict = {}\nfor i in range(0, n):\n\twords = input().split(' ')\n\twlen1 = len(words[0])\n\twlen2 = len(words[1])\n\tif (wlen1 < wlen2) | (wlen1 == wlen2):\n\t\tdict[words[0]] = words[0]\n\telse:\n\t\tdict[words[0]] = words[1]\nscript = input().split(' ')\nstr = ''\nfor i in script:\n\tstr = str + dict[i] + ' '\nprint(str.strip())\n", "(n, m) = map(int, input().split())\nd = {}\nfor _ in range(m):\n\t(x, y) = input().split()\n\td[x] = y\ns = list(input().split())\nfor i in range(n):\n\tif len(s[i]) > len(d[s[i]]):\n\t\ts[i] = d[s[i]]\nprint(' '.join(s))\n", "(n, m) = [int(_) for _ in input().split()]\ntrans = {}\n\ndef better(a, b):\n\tif len(a) <= len(b):\n\t\treturn a\n\telse:\n\t\treturn b\nfor i in range(m):\n\t(a, b) = input().split()\n\ttrans[a] = better(a, b)\n\ttrans[b] = better(a, b)\nl = input().split()\ns = ''\nfor i in l:\n\ts += trans[i] + ' '\nprint(s)\n", "from functools import reduce\nimport os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import *\nfrom io import BytesIO, IOBase\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef value():\n\treturn tuple(map(int, input().split()))\n\ndef arr():\n\treturn [int(i) for i in input().split()]\n\ndef sarr():\n\treturn [int(i) for i in input()]\n\ndef starr():\n\treturn [str(x) for x in input().split()]\n\ndef inn():\n\treturn int(input())\n\ndef svalue():\n\treturn tuple(map(str, input().split()))\nmo = 1000000007\n(n, m) = value()\nd = defaultdict(int)\nfor i in range(m):\n\t(x, y) = svalue()\n\tif len(x) <= len(y):\n\t\td[x] = x\n\telse:\n\t\td[x] = y\na = starr()\nfor i in a:\n\tprint(d[i], end=' ')\n", "(n, m) = map(int, input().split())\n(a, b) = ([], [])\nfor i in range(m):\n\t(k, l) = map(str, input().split())\n\ta.append(k)\n\tb.append(l)\nc = list(map(str, input().split()))\nk = []\nfor i in range(n):\n\tfor j in range(m):\n\t\tif c[i] == a[j]:\n\t\t\tif len(a[j]) <= len(b[j]):\n\t\t\t\tk.append(a[j])\n\t\t\telse:\n\t\t\t\tk.append(b[j])\nprint(*k)\n", "n = list(map(int, input().split()))\nl = []\nfor i in range(n[-1]):\n\tj = input().split()\n\tl += j\nc = input().split()\ns = ''\nfor i in c:\n\th = l.index(i)\n\tif h % 2 == 0:\n\t\to = l[h + 1]\n\t\tif len(o) == len(i):\n\t\t\ts += i + ' '\n\t\telif len(o) < len(i):\n\t\t\ts += o + ' '\n\t\telif len(i) < len(o):\n\t\t\ts += i + ' '\n\telse:\n\t\to = l[h - 1]\n\t\tif len(o) == len(i):\n\t\t\ts += o + ' '\n\t\telif len(o) < len(i):\n\t\t\ts += o + ' '\n\t\telif len(i) < len(o):\n\t\t\ts += i + ' '\nprint(s)\n", "(n, m) = map(int, input().split(' '))\narr = []\nfor i in range(m):\n\tw = input().split(' ')\n\tarr.append(w)\nk = input().split(' ')\nout = []\nfor i in range(len(k)):\n\tfor j in range(len(arr)):\n\t\tif k[i] == arr[j][0] or k[i] == arr[j][1]:\n\t\t\tif len(arr[j][0]) <= len(arr[j][1]):\n\t\t\t\tout.append(arr[j][0])\n\t\t\telif len(arr[j][0]) > len(arr[j][1]):\n\t\t\t\tout.append(arr[j][1])\np = ''\nfor i in range(len(out)):\n\tp = p + str(out[i]) + ' '\nprint(p)\n"], "public_test_cases": [{"input": "4 3\ncodeforces codesecrof\ncontest round\nletter message\ncodeforces contest letter contest\n", "output": "codeforces round letter round\n", "type": "stdin"}, {"input": "5 3\njoll wuqrd\neuzf un\nhbnyiyc rsoqqveh\nhbnyiyc joll joll euzf joll\n", "output": "hbnyiyc joll joll un joll\n", "type": "stdin"}], "test_cases": [{"input": "4 3\ncodeforces codesecrof\ncontest round\nletter message\ncodeforces contest letter contest\n", "output": "codeforces round letter round\n", "type": "stdin"}, {"input": "5 3\njoll wuqrd\neuzf un\nhbnyiyc rsoqqveh\nhbnyiyc joll joll euzf joll\n", "output": "hbnyiyc joll joll un joll\n", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk qpfzoqx\nytnyonoc hnxsd\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hnxsd b\n", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel tj\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs\n", "type": "stdin"}, {"input": "1 1\namit am\namit\n", "output": "am\n", "type": "stdin"}, {"input": "1 1\na c\na\n", "output": "a\n", "type": "stdin"}, {"input": "1 1\na c\na\n", "output": "a ", "type": "stdin"}, {"input": "1 1\namit am\namit\n", "output": "am ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel tj\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk qpfzoqx\nytnyonoc hnxsd\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hnxsd b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "1 1\namit ma\namit\n", "output": "ma ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk qpfzoqx\nytnyonoc hdxsn\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hdxsn b ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk qpqzofx\nytnyonoc hnxsd\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hnxsd b ", "type": "stdin"}, {"input": "4 3\ncodeforces codesecrof\ncontest round\nletter egassem\ncodeforces contest letter contest\n", "output": "codeforces round letter round ", "type": "stdin"}, {"input": "1 1\namit la\namit\n", "output": "la ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglw\nbixyfm jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpyni\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpyni ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb sjz\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth sjz ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq qwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef qwt cbfhfxi qwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qynpi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qynpi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qqnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qqnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnxi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnxi ecdayth zjs ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb nv\ntabzvk qpqzofx\nytnyonoc hnwsd\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hnwsd b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx wfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb rjz\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth rjz ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib owuchvnpej\njqzakipr uam\nl rw\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zis\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zis ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntbbzvk qpfzoqx\nytnyonoc hdxsn\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hdxsn b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel tj\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk qpfzoqx\nytnyonoc hdxsn\njpggvr lcginjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hdxsn b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi zyrdvbnrq\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smlbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nm rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vlgfv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr aum\nm rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uan\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglw\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vlgfv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nlfqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr aum\nm rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\naty smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglw\nbixyfm jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl xr\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglw\nbixyfm jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpyni\nj tixqrno\ndo tcfmzoti\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpyni ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixprno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel tj\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk xqozfpq\nytnyonoc hnxsd\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hnxsd b ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb nv\ntbbzvk qpfzoqx\nytnyonoc hdxsn\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hdxsn b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib owuchvnpej\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natw smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qnrbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazarll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel tj\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb nv\ntabzvk qpqzofx\nytnyonoc hnxsd\njpggvr lchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hnxsd b ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb vn\ntabzvk xqozfpq\nytnyonoc hdxsn\njpggvr lcginjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hdxsn b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zgaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqarxjxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smlbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\ncjotfxeq p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rluwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr aum\nm rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\naux smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uan\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nldqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglw\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkdxmirx dv\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwpel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\nfh vdyayei\njphveblohx vlgfv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nlfqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib pejnvhcuwo\njqzakipr aum\nm rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\naty smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nk xr\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglw\nbixyfm jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpyni\nj tixqrno\ndo tcfmzoti\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwk\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpyni ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx wfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb sjz\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth sjz ", "type": "stdin"}, {"input": "5 5\nqueyqj f\nb nv\ntbbzvk qpfzoqx\nytnyonoc hdxsn\njpggvr kchinjmt\nqueyqj jpggvr b ytnyonoc b\n", "output": "f jpggvr b hdxsn b ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib owuchvnpej\njqzakipr uam\nl rw\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef crlntwnnqi\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natw smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\njcvkkhu rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oeo\ngh wdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nk rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvkx\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qnrbvdryz\nleqw kt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazarll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uma\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel tj\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zgaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nas qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyaxei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqarxjxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smlbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfct\nikkmxdirx ev\ncjotfxeq p\nkdazb zjs\nmbk xkvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\ns` qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll neo\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnohcuwv\njqzakipr aum\nm rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\naux smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvvj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwpel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\nfh vdyayei\njphveblohx vlgfv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\ns` qcthz\ncbfhfxi qrnbvdryz\nlfqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nk xr\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zafegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nxrimxdkki ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zgaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nas qcthz\ncbfhfxi qrnbvdryz\nleqw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyaxei\njphveblohx vfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl xr\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqarxjxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtnlrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smlbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib jepnvhcuwn\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\ndo itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\ns` qcthz\ncbfhfxi qrnbvdryz\nwqel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ve\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvvj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwpel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\nfh vdyayei\njphveblohx vlgfv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\ns` qcthz\ncbfhfxi qrnbvdryz\nlfpw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vgglv\nmfyxib jepnvhcuwo\nrpikazqj uam\nk xr\nokjenof qpnyi\nj tixqrno\nod itozmfdt\nikkdxmirx ev\nqexftojc p\nkdazb zjs\nmbk uxaxrjqvky\nhbcwhouzq pwt\nmirpsz zafegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nqwel jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx wfglv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb rjz\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nwqel jt\n`tx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth rjz ", "type": "stdin"}, {"input": "10 22\nazbrll oen\ngh vdyayei\njphveblohx vfglv\nmfyxib owuchvnpej\njqzakipr uam\nl rw\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirx ev\nqexftojc p\nkdazb zis\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhklvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\nsa qcthz\ncbfhfxi qrnbvdryz\nleqw jt\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zis ", "type": "stdin"}, {"input": "10 22\nazbrll oen\nfh vdyayei\njphveblohx vlgfv\nmfyxib jepnvhcuwo\njqzakipr uam\nl rx\nokjenof qpnyi\nj tixqrno\nod itozmfct\nikkdxmirw ev\nqexftojc p\nkdazb zjs\nmbk ykvqjrxaxu\nhbcwhouzq pwt\nmirpsz zfaegpl\nuhkkvcj rlvwj\nef iqnnwtolrc\npjzfcpmeag ecdayth\ns` qcthz\ncbfhfxi qrnbvdryz\nlfpw js\natx smkbid\nef hbcwhouzq cbfhfxi hbcwhouzq mirpsz cbfhfxi cbfhfxi okjenof pjzfcpmeag kdazb\n", "output": "ef pwt cbfhfxi pwt mirpsz cbfhfxi cbfhfxi qpnyi ecdayth zjs ", "type": "stdin"}, {"input": "4 3\ncodeforces codesecrof\ncontest round\nletter message\ncodeforces contest letter contest\n", "output": "codeforces round letter round ", "type": "stdin"}, {"input": "5 3\njoll wuqrd\neuzf un\nhbnyiyc rsoqqveh\nhbnyiyc joll joll euzf joll\n", "output": "hbnyiyc joll joll un joll ", "type": "stdin"}], "problem_id": "taco_train_327", "metadata": {"config": "taco", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 105}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nIn order to pass the entrance examination tomorrow, Taro has to study for T more hours.\nFortunately, he can leap to World B where time passes X times as fast as it does in our world (World A).\nWhile (X \\times t) hours pass in World B, t hours pass in World A.\nHow many hours will pass in World A while Taro studies for T hours in World B?\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq T \\leq 100\n - 1 \\leq X \\leq 100\n\n-----Input-----\nInput is given from Standard Input in the following format:\nT X\n\n-----Output-----\nPrint the number of hours that will pass in World A.\nThe output will be regarded as correct when its absolute or relative error from the judge's output is at most 10^{-3}.\n\n-----Sample Input-----\n8 3\n\n-----Sample Output-----\n2.6666666667\n\nWhile Taro studies for eight hours in World B where time passes three times as fast, 2.6666... hours will pass in World A.\nNote that an absolute or relative error of at most 10^{-3} is allowed.\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\n(a, b) = map(int, input().split())\nprint(a / b)\n\n```"], "public_test_cases": [{"input": "8 3\n", "output": "2.6666666667\n", "type": "stdin"}, {"input": "1 1\n", "output": "1.0000000000\n", "type": "stdin"}, {"input": "99 1\n", "output": "99.0000000000\n", "type": "stdin"}], "test_cases": [{"input": "8 3\n", "output": "2.6666666667\n", "type": "stdin"}, {"input": "99 1\n", "output": "99.0000000000\n", "type": "stdin"}, {"input": "1 100\n", "output": "0.0100000000\n", "type": "stdin"}, {"input": "22 75\n", "output": "0.2933333333\n", "type": "stdin"}, {"input": "26 45\n", "output": "0.5777777778\n", "type": "stdin"}, {"input": "72 81\n", "output": "0.8888888889\n", "type": "stdin"}, {"input": "1 94\n", "output": "0.0106382979\n", "type": "stdin"}, {"input": "95 1\n", "output": "95.0000000000\n", "type": "stdin"}, {"input": "93 3\n", "output": "31.0000000000\n", "type": "stdin"}, {"input": "1 1\n", "output": "1.0000000000\n", "type": "stdin"}, {"input": "100 1\n", "output": "100.0000000000\n", "type": "stdin"}, {"input": "100 17\n", "output": "5.8823529412\n", "type": "stdin"}, {"input": "56 100\n", "output": "0.5600000000\n", "type": "stdin"}, {"input": "8 2", "output": "4.0\n", "type": "stdin"}, {"input": "8 4", "output": "2.0\n", "type": "stdin"}, {"input": "8 6", "output": "1.33333333333\n", "type": "stdin"}, {"input": "8 9", "output": "0.888888888889\n", "type": "stdin"}, {"input": "14 9", "output": "1.55555555556\n", "type": "stdin"}, {"input": "14 4", "output": "3.5\n", "type": "stdin"}, {"input": "14 5", "output": "2.8\n", "type": "stdin"}, {"input": "13 5", "output": "2.6\n", "type": "stdin"}, {"input": "13 9", "output": "1.44444444444\n", "type": "stdin"}, {"input": "13 18", "output": "0.722222222222\n", "type": "stdin"}, {"input": "4 18", "output": "0.222222222222\n", "type": "stdin"}, {"input": "4 5", "output": "0.8\n", "type": "stdin"}, {"input": "4 8", "output": "0.5\n", "type": "stdin"}, {"input": "4 13", "output": "0.307692307692\n", "type": "stdin"}, {"input": "4 26", "output": "0.153846153846\n", "type": "stdin"}, {"input": "8 5", "output": "1.6\n", "type": "stdin"}, {"input": "16 5", "output": "3.2\n", "type": "stdin"}, {"input": "16 6", "output": "2.66666666667\n", "type": "stdin"}, {"input": "11 5", "output": "2.2\n", "type": "stdin"}, {"input": "18 5", "output": "3.6\n", "type": "stdin"}, {"input": "9 5", "output": "1.8\n", "type": "stdin"}, {"input": "1 5", "output": "0.2\n", "type": "stdin"}, {"input": "1 8", "output": "0.125\n", "type": "stdin"}, {"input": "1 10", "output": "0.1\n", "type": "stdin"}, {"input": "1 3", "output": "0.333333333333\n", "type": "stdin"}, {"input": "1 9", "output": "0.111111111111\n", "type": "stdin"}, {"input": "2 8", "output": "0.25\n", "type": "stdin"}, {"input": "2 2", "output": "1.0\n", "type": "stdin"}, {"input": "3 2", "output": "1.5\n", "type": "stdin"}, {"input": "5 2", "output": "2.5\n", "type": "stdin"}, {"input": "3 1", "output": "3.0\n", "type": "stdin"}, {"input": "5 1", "output": "5.0\n", "type": "stdin"}, {"input": "9 1", "output": "9.0\n", "type": "stdin"}, {"input": "7 5", "output": "1.4\n", "type": "stdin"}, {"input": "12 2", "output": "6.0\n", "type": "stdin"}, {"input": "28 9", "output": "3.11111111111\n", "type": "stdin"}, {"input": "27 5", "output": "5.4\n", "type": "stdin"}, {"input": "26 9", "output": "2.88888888889\n", "type": "stdin"}, {"input": "13 6", "output": "2.16666666667\n", "type": "stdin"}, {"input": "4 31", "output": "0.129032258065\n", "type": "stdin"}, {"input": "4 22", "output": "0.181818181818\n", "type": "stdin"}, {"input": "5 13", "output": "0.384615384615\n", "type": "stdin"}, {"input": "5 26", "output": "0.192307692308\n", "type": "stdin"}, {"input": "3 26", "output": "0.115384615385\n", "type": "stdin"}, {"input": "8 1", "output": "8.0\n", "type": "stdin"}, {"input": "4 6", "output": "0.666666666667\n", "type": "stdin"}, {"input": "19 5", "output": "3.8\n", "type": "stdin"}, {"input": "23 5", "output": "4.6\n", "type": "stdin"}, {"input": "2 5", "output": "0.4\n", "type": "stdin"}, {"input": "1 16", "output": "0.0625\n", "type": "stdin"}, {"input": "1 7", "output": "0.142857142857\n", "type": "stdin"}, {"input": "0 3", "output": "0.0\n", "type": "stdin"}, {"input": "7 1", "output": "7.0\n", "type": "stdin"}, {"input": "-1 2", "output": "-0.5\n", "type": "stdin"}, {"input": "1 6", "output": "0.166666666667\n", "type": "stdin"}, {"input": "1 011", "output": "0.0909090909091\n", "type": "stdin"}, {"input": "-1 1", "output": "-1.0\n", "type": "stdin"}, {"input": "9 15", "output": "0.6\n", "type": "stdin"}, {"input": "26 7", "output": "3.71428571429\n", "type": "stdin"}, {"input": "27 2", "output": "13.5\n", "type": "stdin"}, {"input": "13 17", "output": "0.764705882353\n", "type": "stdin"}, {"input": "4 55", "output": "0.0727272727273\n", "type": "stdin"}, {"input": "5 23", "output": "0.217391304348\n", "type": "stdin"}, {"input": "8 14", "output": "0.571428571429\n", "type": "stdin"}, {"input": "3 34", "output": "0.0882352941176\n", "type": "stdin"}, {"input": "-1 3", "output": "-0.333333333333\n", "type": "stdin"}, {"input": "16 13", "output": "1.23076923077\n", "type": "stdin"}, {"input": "19 8", "output": "2.375\n", "type": "stdin"}, {"input": "23 7", "output": "3.28571428571\n", "type": "stdin"}, {"input": "17 2", "output": "8.5\n", "type": "stdin"}, {"input": "3 4", "output": "0.75\n", "type": "stdin"}, {"input": "0 -1", "output": "-0.0\n", "type": "stdin"}, {"input": "-2 3", "output": "-0.666666666667\n", "type": "stdin"}, {"input": "7 3", "output": "2.33333333333\n", "type": "stdin"}, {"input": "3 -1", "output": "-3.0\n", "type": "stdin"}, {"input": "-2 1", "output": "-2.0\n", "type": "stdin"}, {"input": "18 4", "output": "4.5\n", "type": "stdin"}, {"input": "15 8", "output": "1.875\n", "type": "stdin"}, {"input": "16 15", "output": "1.06666666667\n", "type": "stdin"}, {"input": "24 7", "output": "3.42857142857\n", "type": "stdin"}, {"input": "27 4", "output": "6.75\n", "type": "stdin"}, {"input": "1 55", "output": "0.0181818181818\n", "type": "stdin"}, {"input": "4 11", "output": "0.363636363636\n", "type": "stdin"}, {"input": "8 23", "output": "0.347826086957\n", "type": "stdin"}, {"input": "8 18", "output": "0.444444444444\n", "type": "stdin"}, {"input": "2 34", "output": "0.0588235294118\n", "type": "stdin"}, {"input": "-1 4", "output": "-0.25\n", "type": "stdin"}, {"input": "19 9", "output": "2.11111111111\n", "type": "stdin"}, {"input": "3 7", "output": "0.428571428571\n", "type": "stdin"}, {"input": "17 3", "output": "5.66666666667\n", "type": "stdin"}, {"input": "7 4", "output": "1.75\n", "type": "stdin"}, {"input": "-1 8", "output": "-0.125\n", "type": "stdin"}, {"input": "-1 011", "output": "-0.0909090909091\n", "type": "stdin"}, {"input": "30 4", "output": "7.5\n", "type": "stdin"}, {"input": "16 23", "output": "0.695652173913\n", "type": "stdin"}, {"input": "4 17", "output": "0.235294117647\n", "type": "stdin"}, {"input": "1 106", "output": "0.00943396226415\n", "type": "stdin"}, {"input": "5 4", "output": "1.25\n", "type": "stdin"}, {"input": "8 29", "output": "0.275862068966\n", "type": "stdin"}, {"input": "2 53", "output": "0.0377358490566\n", "type": "stdin"}, {"input": "1 100", "output": "0.0100000000", "type": "stdin"}, {"input": "99 1", "output": "99.0000000000", "type": "stdin"}, {"input": "8 3", "output": "2.6666666667", "type": "stdin"}], "problem_id": "primeintellect_train_8133", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 3, "num_original_tests": 116}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nIn the International System of Units (SI), various physical quantities are expressed in the form of \"numerical value + prefix + unit\" using prefixes such as kilo, mega, and giga. For example, \"3.5 kilometers\", \"5.1 milligrams\", and so on.\n\nOn the other hand, these physical quantities can be expressed as \"3.5 * 10 ^ 3 meters\" and \"5.1 * 10 ^ -3 grams\" using exponential notation.\n\nMeasurement of physical quantities always includes errors. Therefore, there is a concept of significant figures to express how accurate the measured physical quantity is. In the notation considering significant figures, the last digit may contain an error, but the other digits are considered reliable. For example, if you write \"1.23\", the true value is 1.225 or more and less than 1.235, and the digits with one decimal place or more are reliable, but the second decimal place contains an error. The number of significant digits when a physical quantity is expressed in the form of \"reliable digit + 1 digit including error\" is called the number of significant digits. For example, \"1.23\" has 3 significant digits.\n\nIf there is a 0 before the most significant non-zero digit, that 0 is not included in the number of significant digits. For example, \"0.45\" has two significant digits. If there is a 0 after the least significant non-zero digit, whether or not that 0 is included in the number of significant digits depends on the position of the decimal point. If there is a 0 to the right of the decimal point, that 0 is included in the number of significant digits. For example, \"12.300\" has 5 significant digits. On the other hand, when there is no 0 to the right of the decimal point like \"12300\", it is not clear whether to include the 0 on the right side in the number of significant digits, but it will be included in this problem. That is, the number of significant digits of \"12300\" is five.\n\nNatsume was given a physics problem as a school task. I have to do calculations related to significant figures and units, but the trouble is that I still don't understand how to use significant figures and units. Therefore, I would like you to create a program that automatically calculates them and help Natsume.\n\nWhat you write is a program that, given a prefixed notation, converts it to exponential notation with the same number of significant digits. The following 20 prefixes are used.\n\n* yotta = 10 ^ 24\n* zetta = 10 ^ 21\n* exa = 10 ^ 18\n* peta = 10 ^ 15\n* tera = 10 ^ 12\n* giga = 10 ^ 9\n* mega = 10 ^ 6\n* kilo = 10 ^ 3\n* hecto = 10 ^ 2\n* deca = 10 ^ 1\n* deci = 10 ^ -1\n* centi = 10 ^ -2\n* milli = 10 ^ -3\n* micro = 10 ^ -6\n* nano = 10 ^ -9\n* pico = 10 ^ -12\n* femto = 10 ^ -15\n* ato = 10 ^ -18\n* zepto = 10 ^ -21\n* yocto = 10 ^ -24\n\nNotes on Submission\n\nMultiple datasets are given in the above format. The first line of input data gives the number of datasets. Create a program that outputs the output for each data set in order in the above format.\n\n\n\nInput\n\nThe input consists of only one line, which contains numbers, unit prefixes (if any), and units. Each is separated by a blank. In some cases, there is no unit prefix, in which case only numbers and units are included in the line. Units with the same name as the unit prefix do not appear. The most significant digit is never 0, except for the ones digit when a decimal is given. The number given is positive. The number given is 1000 digits or less including the decimal point, and the unit name is 50 characters or less.\n\nOutput\n\nOutput the quantity expressed in exponential notation in the form of a * 10 ^ b [unit]. However, 1 <= a <10. The difference between the singular and plural forms of the unit name is not considered. Output the unit name given to the input as it is.\n\nExample\n\nInput\n\n7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.42 joules\n1234.56789012345678901234567890 hecto pascals\n\n\nOutput\n\n1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\nm = {\"yotta\":24, \"zetta\":21, \"exa\":18, \"peta\":15, \"tera\":12, \"giga\":9, \"mega\":6, \"kilo\":3, \"hecto\":2, \"deca\":1, \"deci\":-1, \"centi\":-2, \"milli\":-3, \"micro\":-6, \"nano\":-9, \"pico\":-12, \"femto\":-15, \"ato\":-18, \"zepto\":-21, \"yocto\":-24}\nfor _ in range(int(input())):\n    v, *b = input().split()\n    if len(b) == 2:\n        k, b = b[0], b[1]\n        a = m[k]\n    else:b = b[0];a = 0\n    s = 0\n    for i in range(len(v)):\n        if v[i] in \"123456789\":\n            if i != 0:\n                a -= i - 1\n                if i != len(v) - 1:v = v[i] + \".\" + v[i + 1:]\n                else:v = v[i]\n            else:\n                try:\n                    j = v[i:].index(\".\")\n                    a += j - 1\n                    v = v[0] + \".\" + v[1:j] + v[j + 1:]\n                except:\n                    a += len(v) - 1\n                    v = v[0] + \".\" + v[1:]\n            break\n    print(\"{} * 10^{} {}\".format(v, a, b))\n\n```"], "public_test_cases": [{"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.42 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals", "type": "stdin"}], "test_cases": [{"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.42 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.5868394692236264 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n5.868394692236264 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n42 amperes\n0.42 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascalr", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascalr\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.5868394692236264 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n5.868394692236264 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n42 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grams\n1000000100000000000000000 yocto seconds\n42 amperes\n0.951642419825234 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grams\n1.000000100000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n9 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n9 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grans\n1000000100000000000000000 yocto seconds\n42 amperes\n0.951642419825234 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grans\n1.000000100000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 jpules\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1234.792208213191 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.234792208213191 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n2 amperes\n0.42 seluoj\n1234.792208213191 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n2 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.234792208213191 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.551170275871279 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.3551170275871279 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.42 juoles\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 juoles\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1235.20014397066 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23520014397066 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n42 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 jovles\n1234.56789012345678901234567890 hecto pascalr", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 jovles\n1.23456789012345678901234567890 * 10^5 pascalr\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 seluoj\n1234.56789012345678901234567890 hecto pasdals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pasdals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.9039205721910736 yotta grams\n1000000000000000010000000 yocto seconds\n42 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n9.039205721910736 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n6 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n6 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.811915426426053 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.2811915426426053 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grals\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grals\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wavts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 jpules\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wavts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000100000000 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000100000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n2 amperfs\n0.42 seluoj\n1234.792208213191 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n2 * 10^0 amperfs\n4.2 * 10^-1 seluoj\n1.234792208213191 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.551170275871279 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000010 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.3551170275871279 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000010 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo metert\n0.45 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 metert\n4.5 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n42 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.9039205721910736 yotta grams\n1000000000000000010000000 yocto seconds\n42 amperes\n0.42 seluoj\n1234.751112806723 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n9.039205721910736 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 seluoj\n1.234751112806723 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watst\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n6 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watst\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n6 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.811915426426053 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 seqepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.2811915426426053 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 seqepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wavts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 sereqma\n0.951642419825234 jpules\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wavts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 sereqma\n9.51642419825234 * 10^-1 jpules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.710407820962175 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n2 amperfs\n0.42 seluoj\n1234.792208213191 hecto pascals", "output": "1.2710407820962175 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n2 * 10^0 amperfs\n4.2 * 10^-1 seluoj\n1.234792208213191 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.551170275871279 kilo meters\n0.45 mega wauts\n0.8734064229004153 yotta gmars\n1000000000000000000000010 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.3551170275871279 * 10^4 meters\n4.5 * 10^5 wauts\n8.734064229004153 * 10^23 gmars\n1.000000000000000000000010 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo metert\n0.45 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 metert\n4.5 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n3 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n3 * 10^0 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watst\n0.000000000000000000000001 yotta gramr\n1000000000000000010000000 yocto seconds\n6 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watst\n1 * 10^0 gramr\n1.000000000000000010000000 * 10^0 seconds\n6 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.34662106661138 kilo meters\n0.45 mega wavts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 sereqma\n0.951642419825234 jpules\n1235.0324885234443 hecto pascals", "output": "1.334662106661138 * 10^4 meters\n4.5 * 10^5 wavts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 sereqma\n9.51642419825234 * 10^-1 jpules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo metfrt\n0.45 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 metfrt\n4.5 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000100000010000000 yocto seconds\n3 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000100000010000000 * 10^0 seconds\n3 * 10^0 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.34662106661138 kilo neters\n0.45 mega wavts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 sereqma\n0.951642419825234 jpules\n1235.0324885234443 hecto pascals", "output": "1.334662106661138 * 10^4 neters\n4.5 * 10^5 wavts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 sereqma\n9.51642419825234 * 10^-1 jpules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo metfrt\n0.45 mega sttaw\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 metfrt\n4.5 * 10^5 sttaw\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000100000010000000 yocto seconds\n3 apmeres\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000100000010000000 * 10^0 seconds\n3 * 10^0 apmeres\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.729479136172973 kilo metfrt\n0.45 mega sttaw\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2729479136172973 * 10^4 metfrt\n4.5 * 10^5 sttaw\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000100000010010000 yocto seconds\n3 apmeres\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000100000010010000 * 10^0 seconds\n3 * 10^0 apmeres\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.729479136172973 kilo metfrt\n0.45 mega sttaw\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n36 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2729479136172973 * 10^4 metfrt\n4.5 * 10^5 sttaw\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n3.6 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wctts\n0.000000000000000000000001 yotta grams\n1000000000100000010010000 yocto seconds\n3 apmeres\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wctts\n1 * 10^0 grams\n1.000000000100000010010000 * 10^0 seconds\n3 * 10^0 apmeres\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.729479136172973 kilo metfru\n0.45 mega sttaw\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n36 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2729479136172973 * 10^4 metfru\n4.5 * 10^5 sttaw\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n3.6 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wctts\n0.000000000000000000000001 yotta grams\n1000000000100000010010000 yocto seconds\n3 apmeres\n0.42 soeluj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wctts\n1 * 10^0 grams\n1.000000000100000010010000 * 10^0 seconds\n3 * 10^0 apmeres\n4.2 * 10^-1 soeluj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.729479136172973 kilo metfru\n0.45 mega sttaw\n0.000000000000000000000001 yotta nrags\n1000000000000000000000000 yocto seconds\n36 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2729479136172973 * 10^4 metfru\n4.5 * 10^5 sttaw\n1 * 10^0 nrags\n1.000000000000000000000000 * 10^0 seconds\n3.6 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000100000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000100000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.5868394692236264 yotta grams\n1000000000000000000000000 yocto seconds\n27 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n5.868394692236264 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n2.7 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n43 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.3 * 10^1 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto sdnoces\n42 amperes\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 sdnoces\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grans\n1000000100000000000000000 yocto seconds\n42 amperes\n0.951642419825234 seluoj\n1235.1827627986022 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grans\n1.000000100000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 seluoj\n1.2351827627986022 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1235.3626662779077 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.2353626662779077 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 joulfs\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joulfs\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto secoods\n1 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 secoods\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega stuaw\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 stuaw\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 jpules\n1235.5090616372397 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpules\n1.2355090616372397 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n1 amperes\n0.44501921775806347 seluoj\n1234.792208213191 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.4501921775806347 * 10^-1 seluoj\n1.234792208213191 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.916899266862071 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.2916899266862071 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.201510002587156 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grams\n1000000000000000010000000 yocto seconds\n2 amperes\n0.42 seluoj\n1234.792208213191 hecto pascals", "output": "1.3201510002587156 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n2 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.234792208213191 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.5671267016478702 yotta grams\n1000000000000000000000000 yocto seconds\n42 amperes\n0.42 juoles\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n5.671267016478702 * 10^23 grams\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n4.2 * 10^-1 juoles\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto sdnoces\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 sdnoces\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n23 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n2.3 * 10^1 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grams\n1000000000000000000000000 yocto sdnoces\n42 amperes\n0.951642419825234 seluoj\n1234.56789012345678901234567890 hecto pasdals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grams\n1.000000000000000000000000 * 10^0 sdnoces\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pasdals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n6 amserep\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n6 * 10^0 amserep\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.811915426426053 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto secondr\n42 serepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.2811915426426053 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 secondr\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.5306518539261769 yotta grals\n1000000000000000010000000 yocto seconds\n1 amperes\n0.42 seluoj\n1234.924397029936 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n5.306518539261769 * 10^23 grals\n1.000000000000000010000000 * 10^0 seconds\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.234924397029936 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta gmars\n1000000000000000100000000 yocto seconds\n4 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 gmars\n1.000000000000000100000000 * 10^0 seconds\n4 * 10^0 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo metert\n0.5125616408370866 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 metert\n5.125616408370866 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n49 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.9 * 10^1 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watst\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n6 amperfs\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watst\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n6 * 10^0 amperfs\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n13.551170275871279 kilo meters\n0.45 mega wauts\n0.8734064229004153 yotta gmars\n1000000000000000100000010 yocto seconds\n42 serepma\n0.951642419825234 jpvles\n1235.0324885234443 hecto pascals", "output": "1.3551170275871279 * 10^4 meters\n4.5 * 10^5 wauts\n8.734064229004153 * 10^23 gmars\n1.000000000000000100000010 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 jpvles\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo metert\n0.45 mega watts\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto slacsap", "output": "1.23 * 10^4 metert\n4.5 * 10^5 watts\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 slacsap\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.606796701735519 yotta grams\n1000000000000000010000000 yocto seconds\n3 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n6.06796701735519 * 10^23 grams\n1.000000000000000010000000 * 10^0 seconds\n3 * 10^0 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watst\n0.000000000000000000000001 yotta gramr\n1000000000000000010000000 yocto seconds\n6 amperes\n0.5409021934885971 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watst\n1 * 10^0 gramr\n1.000000000000000010000000 * 10^0 seconds\n6 * 10^0 amperes\n5.409021934885971 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000100000010000000 yocto teconds\n3 amperes\n0.42 soulej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000100000010000000 * 10^0 teconds\n3 * 10^0 amperes\n4.2 * 10^-1 soulej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wbtts\n0.000000000000000000000001 yotta grams\n1000000000100000010000000 yocto seconds\n3 apmeres\n0.42 soumej\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wbtts\n1 * 10^0 grams\n1.000000000100000010000000 * 10^0 seconds\n3 * 10^0 apmeres\n4.2 * 10^-1 soumej\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.729479136172973 kilo metfrt\n0.45 mega sttaw\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n42 ampdres\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2729479136172973 * 10^4 metfrt\n4.5 * 10^5 sttaw\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 ampdres\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.729479136172973 kilo mfteru\n0.45 mega sttaw\n0.000000000000000000000001 yotta mrags\n1000000000000000000000000 yocto seconds\n36 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2729479136172973 * 10^4 mfteru\n4.5 * 10^5 sttaw\n1 * 10^0 mrags\n1.000000000000000000000000 * 10^0 seconds\n3.6 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.942815183124743 kilo metfru\n0.45 mega sttaw\n0.000000000000000000000001 yotta nrags\n1000000000000000000000000 yocto seconds\n36 amperes\n0.951642419825234 joulfs\n1234.56789012345678901234567890 hecto pascals", "output": "1.2942815183124743 * 10^4 metfru\n4.5 * 10^5 sttaw\n1 * 10^0 nrags\n1.000000000000000000000000 * 10^0 seconds\n3.6 * 10^1 amperes\n9.51642419825234 * 10^-1 joulfs\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000000100000 yocto seconds\n42 amperes\n0.951642419825234 joules\n1234.7494951906465 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000000100000 * 10^0 seconds\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.2347494951906465 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.000000000000000000000001 yotta grams\n1000000000000000010000000 yocto seconds\n43 amperet\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n1 * 10^0 grams\n1.000000000000000010000000 * 10^0 seconds\n4.3 * 10^1 amperet\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wauts\n0.5868394692236264 yotta glars\n1000000000000000000000000 yocto sdnoces\n42 amperes\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wauts\n5.868394692236264 * 10^23 glars\n1.000000000000000000000000 * 10^0 sdnoces\n4.2 * 10^1 amperes\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega watts\n0.6843066209821149 yotta grans\n1000000100000000000000000 yocto seconds\n42 amperet\n0.951642419825234 seluoj\n1235.1827627986022 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 watts\n6.843066209821149 * 10^23 grans\n1.000000100000000000000000 * 10^0 seconds\n4.2 * 10^1 amperet\n9.51642419825234 * 10^-1 seluoj\n1.2351827627986022 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.3 kilo meters\n0.45 mega wstta\n0.000000000000000000000001 yotta grams\n1001000000000000010000000 yocto secoods\n1 amperes\n0.42 seluoj\n1234.56789012345678901234567890 hecto pascals", "output": "1.23 * 10^4 meters\n4.5 * 10^5 wstta\n1 * 10^0 grams\n1.001000000000000010000000 * 10^0 secoods\n1 * 10^0 amperes\n4.2 * 10^-1 seluoj\n1.23456789012345678901234567890 * 10^5 pascals\n", "type": "stdin"}, {"input": "7\n12.578975550100722 kilo meters\n0.45 mega stubw\n0.5868394692236264 yotta gmars\n1000000000000000000000000 yocto seconds\n42 serepma\n0.951642419825234 joules\n1235.0324885234443 hecto pascals", "output": "1.2578975550100722 * 10^4 meters\n4.5 * 10^5 stubw\n5.868394692236264 * 10^23 gmars\n1.000000000000000000000000 * 10^0 seconds\n4.2 * 10^1 serepma\n9.51642419825234 * 10^-1 joules\n1.2350324885234443 * 10^5 pascals\n", "type": "stdin"}], "problem_id": "primeintellect_train_14250", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 1, "num_original_tests": 101}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nMr Keks is a typical white-collar in Byteland.\n\nHe has a bookshelf in his office with some books on it, each book has an integer positive price.\n\nMr Keks defines the value of a shelf as the sum of books prices on it. \n\nMiraculously, Mr Keks was promoted and now he is moving into a new office.\n\nHe learned that in the new office he will have not a single bookshelf, but exactly $k$ bookshelves. He decided that the beauty of the $k$ shelves is the bitwise AND of the values of all the shelves.\n\nHe also decided that he won't spend time on reordering the books, so he will place several first books on the first shelf, several next books on the next shelf and so on. Of course, he will place at least one book on each shelf. This way he will put all his books on $k$ shelves in such a way that the beauty of the shelves is as large as possible. Compute this maximum possible beauty.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 50$)\u00a0\u2014 the number of books and the number of shelves in the new office.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots a_n$, ($0 < a_i < 2^{50}$)\u00a0\u2014 the prices of the books in the order they stand on the old shelf.\n\n\n-----Output-----\n\nPrint the maximum possible beauty of $k$ shelves in the new office.\n\n\n-----Examples-----\nInput\n10 4\n9 14 28 1 7 13 15 29 2 31\n\nOutput\n24\n\nInput\n7 3\n3 14 15 92 65 35 89\n\nOutput\n64\n\n\n\n-----Note-----\n\nIn the first example you can split the books as follows:\n\n$$(9 + 14 + 28 + 1 + 7) \\& (13 + 15) \\& (29 + 2) \\& (31) = 24.$$\n\nIn the second example you can split the books as follows:\n\n$$(3 + 14 + 15 + 92) \\& (65) \\& (35 + 89) = 64.$$\n\nThe input will be stdin and you should print your solution to stdout\n\n\nNow solve the problem and return the code.", "solutions": ["```python\n#!/usr/bin/env python3\n\n[n, k] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\niais = [0 for _ in range(n + 1)]\nfor i in range(n):\n\tiais[i + 1] = iais[i] + ais[i]\n\ndef calc(k, split):\n\tres = 0\n\tfor i in range(k):\n\t\tres &= iais[split[i + 1]] - iais[split[i]]\n\treturn res\n\ndef check_mask(mask):\n\tdp = [[False for j in range(n + 1)] for i in range(k + 1)]\n\n\tfor j in range(1, n - k + 1 + 1):\n\t\tdp[1][j] = (iais[j] & mask == mask)\n\tif not any(dp[1]):\n\t\treturn False\n\n\tfor i in range(2, k + 1):\n\t\tfor j in range(i, n - (k - i) + 1):\n\t\t\tdp[i][j] = any(dp[i - 1][r] and ((iais[j] - iais[r]) & mask == mask) for r in range(i - 1, j - 1 + 1))\n\t\tif not any(dp[i]):\n\t\t\treturn False\n\n\treturn dp[k][n]\n\n\nmask = 0\nfor i in range(55, -1, -1):\n\tif check_mask(mask | (1 << i)):\n\t\tmask |= 1 << i\n\nprint (mask)\n\n\n```"], "public_test_cases": [{"input": "10 4\n9 14 28 1 7 13 15 29 2 31\n", "output": "24\n", "type": "stdin"}, {"input": "7 3\n3 14 15 92 65 35 89\n", "output": "64\n", "type": "stdin"}], "test_cases": [{"input": "10 4\n9 14 28 1 7 13 15 29 2 31\n", "output": "24\n", "type": "stdin"}, {"input": "7 3\n3 14 15 92 65 35 89\n", "output": "64\n", "type": "stdin"}, {"input": "40 5\n6 18 24 5 14 16 31 9 15 5 25 2 18 12 19 27 10 23 23 18 22 14 1 14 6 14 17 28 11 21 8 23 10 30 21 5 17 11 26 16\n", "output": "80\n", "type": "stdin"}, {"input": "20 15\n927353279298143 655102800384382 40376603048780 1008958973042960 1123049780860278 853122601026128 154596679092462 200013924385343 591199113039915 140875624438732 924096460433635 609326666846280 639191601375336 868486002971126 338452290857190 947205016908287 1091731324024232 315465850740682 804685495436596 1102057294815123\n", "output": "16777216\n", "type": "stdin"}, {"input": "10 4\n318346909478488 165408439052762 201407789817026 481299976321209 960738945073700 249445428976993 1096588610084096 605348669136305 817617728356976 256799633127974\n", "output": "563104572248080\n", "type": "stdin"}, {"input": "50 15\n10 30 15 11 9 5 7 16 4 3 29 28 14 20 9 10 21 16 1 7 30 19 16 25 12 29 12 5 3 23 27 16 11 25 21 18 22 12 23 16 24 27 19 7 11 12 30 1 24 11\n", "output": "32\n", "type": "stdin"}, {"input": "20 8\n29 25 19 16 26 18 25 9 5 2 17 16 19 16 3 16 4 17 7 20\n", "output": "16\n", "type": "stdin"}, {"input": "30 4\n893642632982367 772277951746295 510759449350295 826812150840579 1060893142351815 525992742241552 154832018679993 645715002371268 27232975419720 475004229372388 200177708355593 810661468479466 49618609534806 301608930846726 97042172725806 441637617418914 594900693592862 626510702147446 653604971179679 51832188158797 771139366286148 604472775724297 543106972286801 854107321252442 958411818162963 419377189839607 595529582510881 663396887427244 543023709380824 1078875721144944\n", "output": "3940649673949202\n", "type": "stdin"}, {"input": "40 5\n22 16 24 23 3 18 20 12 25 26 29 4 10 31 31 30 2 7 11 16 24 8 2 24 19 17 5 17 20 7 15 26 1 16 26 21 27 4 19 25\n", "output": "106\n", "type": "stdin"}, {"input": "20 9\n162679258761381 497029570950369 441562370676165 658883349839306 803660720071652 397337645985983 1098171846564844 578539182000384 612361670323974 773464823371908 133451479483291 1053028311550002 812258927376098 1012522114357354 692621870999109 73882870347249 783703450776904 897456103589081 217535031946368 318888756116976\n", "output": "571746046443520\n", "type": "stdin"}, {"input": "50 12\n22 12 31 3 3 12 19 19 21 15 24 25 31 18 9 3 8 5 3 24 6 26 30 25 14 25 9 25 3 29 9 6 11 3 12 12 15 6 1 28 28 28 26 9 15 12 17 2 18 18\n", "output": "36\n", "type": "stdin"}, {"input": "16 7\n1103813397013349 727264530801741 378049079598082 630901233315595 518569339136212 532452143552615 428093804691193 371529237344587 940308912730366 704551472087683 631663816743474 29306660032804 583388823624504 1109142272484691 257363549141980 1089402363164001\n", "output": "572020924350465\n", "type": "stdin"}, {"input": "30 2\n26 8 26 25 27 18 6 13 10 22 25 19 7 14 20 4 10 22 9 10 30 30 11 7 27 8 23 13 17 21\n", "output": "125\n", "type": "stdin"}, {"input": "10 3\n30 15 26 16 21 13 25 5 27 11\n", "output": "33\n", "type": "stdin"}, {"input": "10 6\n977831009728918 953593140925615 784863715891337 774777129376154 384491823368699 788094311512692 223966626677969 1066171741163060 119044778274639 876388748099519\n", "output": "562949953683460\n", "type": "stdin"}, {"input": "20 9\n2 3 15 8 17 7 23 12 30 23 4 23 16 21 11 6 7 16 3 3\n", "output": "16\n", "type": "stdin"}, {"input": "20 8\n483137921056907 768218083275243 207834138817392 354531452905166 963403044757413 833232873786483 582872528360258 514660235281883 1011861985723061 459485641216220 942598735621775 873490204734628 649359794076787 543622431653711 10411517577635 91729283882125 291509560140622 287260200844128 879410314598283 206118644453476\n", "output": "562951027164160\n", "type": "stdin"}, {"input": "30 9\n21 6 19 18 27 3 14 18 1 5 7 9 11 13 9 26 8 12 14 31 21 6 9 3 3 10 2 24 22 24\n", "output": "36\n", "type": "stdin"}, {"input": "30 22\n73306162994949 868677001959133 1106639997936963 879122920975808 161227935543926 760034092541884 1120594333824270 1054807665792407 476276883119188 271363692993319 440885048025850 7074457876332 636209225974410 221086579024023 1009685779703594 647498280909980 816934931718733 452863796888983 1061332951888385 942660914590384 365185997676754 112920162715865 178172288962138 810584030647354 923637556325003 1102808429103893 1118229467600088 1074261154123678 839042706865637 352292698714231\n", "output": "2097152\n", "type": "stdin"}, {"input": "23 10\n935459645688325 899894863244863 776172843769766 986122540485649 248016433194357 475375806620409 20513751182830 421086691387167 247543829168446 155673663632778 415875856906302 128486751653325 849753391760463 1083573552851049 244133940871958 934119204927643 1085966359617308 577156229051957 1081049229814148 935408354841926 1093470105244215 288440615891778 467185550898222\n", "output": "562950087639040\n", "type": "stdin"}, {"input": "40 5\n2 20 10 21 4 30 27 12 17 20 5 21 11 12 28 12 24 20 20 31 19 2 1 27 31 1 14 8 1 21 10 2 29 22 29 9 12 29 21 7\n", "output": "80\n", "type": "stdin"}, {"input": "10 4\n22 21 18 7 16 14 12 11 18 5\n", "output": "16\n", "type": "stdin"}, {"input": "50 24\n19 14 27 12 29 18 26 24 16 23 23 22 3 28 18 11 27 14 24 19 25 23 14 7 25 31 20 7 23 10 21 9 30 3 25 17 11 16 27 28 3 25 8 19 17 27 21 19 26 31\n", "output": "16\n", "type": "stdin"}, {"input": "10 4\n23 12 4 5 7 10 22 18 1 6\n", "output": "4\n", "type": "stdin"}, {"input": "4 2\n158042378809438 929800196167200 663932725437382 1056705514263205\n", "output": "594152991508074\n", "type": "stdin"}, {"input": "20 8\n8 29 23 29 3 24 21 4 2 8 12 17 22 8 14 15 21 18 2 22\n", "output": "16\n", "type": "stdin"}, {"input": "1 1\n1\n", "output": "1\n", "type": "stdin"}, {"input": "50 50\n1 3 7 15 31 63 127 255 511 1023 2047 4095 8191 16383 32767 65535 131071 262143 524287 1048575 2097151 4194303 8388607 16777215 33554431 67108863 134217727 268435455 536870911 1073741823 2147483647 4294967295 8589934591 17179869183 34359738367 68719476735 137438953471 274877906943 549755813887 1099511627775 2199023255551 4398046511103 8796093022207 17592186044415 35184372088831 70368744177663 140737488355327 281474976710655 562949953421311 1125899906842623\n", "output": "1\n", "type": "stdin"}, {"input": "1 1\n847523811295364\n", "output": "847523811295364\n", "type": "stdin"}, {"input": "16 4\n874317845770206 387621540079007 155991277344382 691438508026243 930771471405935 572771476513435 743983828305226 4504492981600 163201683368400 839227763533133 66330553316499 1019586586453035 361344913793137 983404846165187 1054785536664003 328380935299964\n", "output": "1214153029059594\n", "type": "stdin"}, {"input": "8 3\n1091780344011621 940196424994342 1122602056403610 446348279968546 844618893669060 630726534256806 583591612685392 410152590972252\n", "output": "633396032195072\n", "type": "stdin"}, {"input": "4 2\n162835105872970 116592879151848 139965176195127 395498533500931\n", "output": "392680337115137\n", "type": "stdin"}, {"input": "2 1\n209353646212060 198207100745412\n", "output": "407560746957472\n", "type": "stdin"}, {"input": "16 14\n104025519164115 388661629481441 867118235830760 833392737978583 446248951095413 1075527144295046 1065273356416483 60098918081731 29503418096534 995667681082455 1087347063175248 131807733936246 235096689659338 202086293947852 889771265698655 384926479287439\n", "output": "0\n", "type": "stdin"}, {"input": "8 5\n173728498114277 92445238671418 136142198208213 974561146026363 1099401507969061 180377338638143 458779251007513 55384960555288\n", "output": "140737555464192\n", "type": "stdin"}, {"input": "4 3\n266761283825161 255669386891250 772637301427796 659604966525743\n", "output": "19928690198528\n", "type": "stdin"}, {"input": "8 1\n562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312\n", "output": "4503599627370496\n", "type": "stdin"}, {"input": "16 1\n562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312 562949953421312\n", "output": "9007199254740992\n", "type": "stdin"}, {"input": "17 1\n1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 1125899906842623 16\n", "output": "18014398509481984\n", "type": "stdin"}], "problem_id": "primeintellect_train_7657", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 39}, "generated_solutions": []}
{"problem": "Solve the following coding problem using the programming language python:\n\nMaria participates in a bicycle race.\n\nThe speedway takes place on the shores of Lake Lucerne, just repeating its contour. As you know, the lake shore consists only of straight sections, directed to the north, south, east or west.\n\nLet's introduce a system of coordinates, directing the Ox axis from west to east, and the Oy axis from south to north. As a starting position of the race the southernmost point of the track is selected (and if there are several such points, the most western among them). The participants start the race, moving to the north. At all straight sections of the track, the participants travel in one of the four directions (north, south, east or west) and change the direction of movement only in bends between the straight sections. The participants, of course, never turn back, that is, they do not change the direction of movement from north to south or from east to west (or vice versa).\n\nMaria is still young, so she does not feel confident at some turns. Namely, Maria feels insecure if at a failed or untimely turn, she gets into the water. In other words, Maria considers the turn dangerous if she immediately gets into the water if it is ignored.\n\nHelp Maria get ready for the competition \u2014 determine the number of dangerous turns on the track.\n\nInput\n\nThe first line of the input contains an integer n (4 \u2264 n \u2264 1000) \u2014 the number of straight sections of the track.\n\nThe following (n + 1)-th line contains pairs of integers (xi, yi) ( - 10 000 \u2264 xi, yi \u2264 10 000). The first of these points is the starting position. The i-th straight section of the track begins at the point (xi, yi) and ends at the point (xi + 1, yi + 1).\n\nIt is guaranteed that:\n\n  * the first straight section is directed to the north; \n  * the southernmost (and if there are several, then the most western of among them) point of the track is the first point; \n  * the last point coincides with the first one (i.e., the start position); \n  * any pair of straight sections of the track has no shared points (except for the neighboring ones, they share exactly one point); \n  * no pair of points (except for the first and last one) is the same; \n  * no two adjacent straight sections are directed in the same direction or in opposite directions. \n\nOutput\n\nPrint a single integer \u2014 the number of dangerous turns on the track.\n\nExamples\n\nInput\n\n6\n0 0\n0 1\n1 1\n1 2\n2 2\n2 0\n0 0\n\n\nOutput\n\n1\n\n\nInput\n\n16\n1 1\n1 5\n3 5\n3 7\n2 7\n2 9\n6 9\n6 7\n5 7\n5 3\n4 3\n4 4\n3 4\n3 2\n5 2\n5 1\n1 1\n\n\nOutput\n\n6\n\nNote\n\nThe first sample corresponds to the picture:\n\n<image>\n\nThe picture shows that you can get in the water under unfortunate circumstances only at turn at the point (1, 1). Thus, the answer is 1.\n\nThe input will be given via stdin and the output should be printed to stdout by your code.\n\nNow solve the problem by providing the code.", "solutions": ["```python\nread = lambda: map(int, input().split())   \nvect = lambda a, b: a[0] * b[1] - a[1] * b[0]\nvector = lambda A, B: (B[0] - A[0], B[1] - A[1])\nn = int(input())\np = [tuple(read()) for i in range(n)]\ncnt = 0\nfor i in range(2, n):\n    v1 = vector(p[i], p[i - 1])\n    v2 = vector(p[i - 1], p[i - 2])\n    if vect(v1, v2) < 0:\n        cnt += 1\nprint(cnt)\n\n```"], "public_test_cases": [{"input": "6\n0 0\n0 1\n1 1\n1 2\n2 2\n2 0\n0 0\n", "output": "1\n", "type": "stdin"}, {"input": "16\n1 1\n1 5\n3 5\n3 7\n2 7\n2 9\n6 9\n6 7\n5 7\n5 3\n4 3\n4 4\n3 4\n3 2\n5 2\n5 1\n1 1\n", "output": "6\n", "type": "stdin"}], "test_cases": [{"input": "16\n1 1\n1 5\n3 5\n3 7\n2 7\n2 9\n6 9\n6 7\n5 7\n5 3\n4 3\n4 4\n3 4\n3 2\n5 2\n5 1\n1 1\n", "output": "6\n", "type": "stdin"}, {"input": "6\n0 0\n0 1\n1 1\n1 2\n2 2\n2 0\n0 0\n", "output": "1\n", "type": "stdin"}, {"input": "24\n-10000 -10000\n-10000 9998\n9998 9998\n9998 -10000\n-6364 -10000\n-6364 6362\n6362 6362\n6362 -6364\n-2728 -6364\n-2728 2726\n2726 2726\n2726 -910\n908 -910\n908 908\n-910 908\n-910 -4546\n4544 -4546\n4544 4544\n-4546 4544\n-4546 -8182\n8180 -8182\n8180 8180\n-8182 8180\n-8182 -10000\n-10000 -10000\n", "output": "10\n", "type": "stdin"}, {"input": "4\n0 0\n0 10000\n10000 10000\n10000 0\n0 0\n", "output": "0\n", "type": "stdin"}, {"input": "4\n-10000 -10000\n-10000 10000\n10000 10000\n10000 -10000\n-10000 -10000\n", "output": "0\n", "type": "stdin"}, {"input": "12\n-10000 -10000\n-10000 10000\n10000 10000\n10000 6000\n-6000 6000\n-6000 2000\n10000 2000\n10000 -2000\n-6000 -2000\n-6000 -6000\n10000 -6000\n10000 -10000\n-10000 -10000\n", "output": "4\n", "type": "stdin"}, {"input": "8\n-10000 -10000\n-10000 5000\n0 5000\n0 10000\n10000 10000\n10000 0\n0 0\n0 -10000\n-10000 -10000\n", "output": "2\n", "type": "stdin"}, {"input": "20\n-4286 -10000\n-4286 -7778\n-7143 -7778\n-7143 -3334\n-10000 -3334\n-10000 1110\n-4286 1110\n-4286 -3334\n4285 -3334\n4285 -1112\n7142 -1112\n7142 3332\n4285 3332\n4285 9998\n9999 9998\n9999 -3334\n7142 -3334\n7142 -5556\n-1429 -5556\n-1429 -10000\n-4286 -10000\n", "output": "8\n", "type": "stdin"}, {"input": "4\n6 8\n6 9\n7 9\n7 8\n6 8\n", "output": "0\n", "type": "stdin"}, {"input": "12\n-10000 -10000\n-10000 10000\n10000 10000\n10000 6000\n-9800 6000\n-9800 2000\n10000 2000\n10000 -2000\n-9800 -2000\n-9800 -6000\n10000 -6000\n10000 -10000\n-10000 -10000\n", "output": "4\n", "type": "stdin"}], "problem_id": "primeintellect_train_6405", "metadata": {"config": "primeintellect", "split": "train", "extraction_model": "claude-3-5-haiku-20241022", "num_extracted_tests": 2, "num_original_tests": 10}, "generated_solutions": []}
