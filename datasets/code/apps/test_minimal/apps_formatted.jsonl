{"problem_id": "train_1", "description": "Mikhail walks on a Cartesian plane. He starts at the point (0, 0), and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point (0, 0), he can go to any of the following points in one move: (1, 0); (1, 1); (0, 1); (-1, 1); (-1, 0); (-1, -1); (0, -1); (1, -1).\n\nIf Mikhail goes from the point (x1, y1) to the point (x2, y2) in one move, and x1 \u2260 x2 and y1 \u2260 y2, then such a move is called a diagonal move.\n\nMikhail has q queries. For the i-th query Mikhail's target is to go to the point (n_i, m_i) from the point (0, 0) in exactly k_i moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point (0, 0) to the point (n_i, m_i) in k_i moves.\n\nNote that Mikhail can visit any point any number of times (even the destination point!).", "test_cases": [{"input": "max_diagonal_moves([(2, 2, 3), (4, 3, 7), (10, 1, 9)])", "expected_output": "[1, 6, -1]"}], "dataset": "apps", "function_name": "max_diagonal_moves", "broken_test_cases": [], "correct_solution": "def max_diagonal_moves(queries):\n    results = []\n    for x, y, k in queries:\n        x, y = abs(x), abs(y)\n        x, y = max(x, y), min(x, y)\n        \n        if(x%2!=k%2):\n            k-=1\n            y-=1\n        \n        if(x>k):\n            results.append(-1)\n            continue\n        if((x-y)%2):\n            k-=1\n            x-=1\n        results.append(k)\n    \n    return results", "difficulty": "interview", "tags": [], "prompt": null, "full_completion": null, "parsed_completion": null, "mixed_tests": []}
{"problem_id": "train_3", "description": "You have $n$ barrels lined up in a row, numbered from left to right from one. Initially, the $i$-th barrel contains $a_i$ liters of water.\n\nYou can pour water from one barrel to another. In one act of pouring, you can choose two different barrels $x$ and $y$ (the $x$-th barrel shouldn't be empty) and pour any possible amount of water from barrel $x$ to barrel $y$ (possibly, all water). You may assume that barrels have infinite capacity, so you can pour any amount of water in each of them. \n\nCalculate the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $k$ times.\n\nSome examples:   if you have four barrels, each containing $5$ liters of water, and $k = 1$, you may pour $5$ liters from the second barrel into the fourth, so the amounts of water in the barrels are $[5, 0, 5, 10]$, and the difference between the maximum and the minimum is $10$;  if all barrels are empty, you can't make any operation, so the difference between the maximum and the minimum amount is still $0$.", "test_cases": [{"input": "max_water_difference(4, 1, [5, 5, 5, 5])", "expected_output": "10"}, {"input": "max_water_difference(3, 2, [0, 0, 0])", "expected_output": "0"}], "dataset": "apps", "function_name": "max_water_difference", "broken_test_cases": [], "correct_solution": "def max_water_difference(n, k, a):\n    lst = a[:]\n    lst.sort()\n    ans = 0\n    for i in range(n - k - 1, n):\n        ans += lst[i]\n    return ans", "difficulty": "interview", "tags": [], "prompt": null, "full_completion": null, "parsed_completion": null, "mixed_tests": []}
{"problem_id": "train_4", "description": "You are given a permutation p=[p_1, p_2, ..., p_n] of integers from 1 to n. Let's call the number m (1 \u2264 m \u2264 n) beautiful, if there exists two indices l, r (1 \u2264 l \u2264 r \u2264 n), such that the numbers [p_l, p_{l+1}, ..., p_r] is a permutation of numbers 1, 2, ..., m.\n\nFor example, let p = [4, 5, 1, 3, 2, 6]. In this case, the numbers 1, 3, 5, 6 are beautiful and 2, 4 are not. It is because: if l = 3 and r = 3 we will have a permutation [1] for m = 1; if l = 3 and r = 5 we will have a permutation [1, 3, 2] for m = 3; if l = 1 and r = 5 we will have a permutation [4, 5, 1, 3, 2] for m = 5; if l = 1 and r = 6 we will have a permutation [4, 5, 1, 3, 2, 6] for m = 6; it is impossible to take some l and r, such that [p_l, p_{l+1}, ..., p_r] is a permutation of numbers 1, 2, ..., m for m = 2 and for m = 4.\n\nYou are given a permutation p=[p_1, p_2, ..., p_n]. For all m (1 \u2264 m \u2264 n) determine if it is a beautiful number or not.", "test_cases": [{"input": "find_beautiful_numbers([4, 5, 1, 3, 2, 6])", "expected_output": "101011"}, {"input": "find_beautiful_numbers([5, 3, 1, 2, 4])", "expected_output": "11111"}, {"input": "find_beautiful_numbers([1, 4, 3, 2])", "expected_output": "1001"}], "dataset": "apps", "function_name": "find_beautiful_numbers", "broken_test_cases": [], "correct_solution": "def find_beautiful_numbers(nums):\n    new_ar = list(zip(nums,[i for i in range(len(nums))]))\n    new_ar.sort()\n    \n    maxx = new_ar[0][1]\n    minn = new_ar[0][1]\n    s=\"1\"\n    for j in range(1,len(new_ar)):\n        if(new_ar[j][1]>maxx):\n            maxx = new_ar[j][1]\n        if(new_ar[j][1]<minn):\n            minn = new_ar[j][1]\n        if(maxx-minn<j+1):\n            s+=\"1\"\n        else:\n            s+=\"0\"\n        \n    return s", "difficulty": "interview", "tags": [], "prompt": null, "full_completion": null, "parsed_completion": null, "mixed_tests": []}
{"problem_id": "train_2", "description": "You are given three sequences: a\u2081, a\u2082, ..., a\u2099; b\u2081, b\u2082, ..., b\u2099; c\u2081, c\u2082, ..., c\u2099.\n\nFor each i, a\u1d62 \u2260 b\u1d62, a\u1d62 \u2260 c\u1d62, b\u1d62 \u2260 c\u1d62.\n\nFind a sequence p\u2081, p\u2082, ..., p\u2099, that satisfy the following conditions:\n\n\u2022 p\u1d62 \u2208 {a\u1d62, b\u1d62, c\u1d62}\n\u2022 p\u1d62 \u2260 p\u208d\u1d62 mod n\u208e + 1\n\nIn other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.\n\nIt can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.", "test_cases": [{"input": "find_valid_sequence(3, [1, 1, 1], [2, 2, 2], [3, 3, 3])", "expected_output": "1 2 3"}, {"input": "find_valid_sequence(4, [1, 2, 1, 2], [2, 1, 2, 1], [3, 4, 3, 4])", "expected_output": "1 2 1 2"}, {"input": "find_valid_sequence(7, [1, 3, 3, 1, 1, 1, 1], [2, 4, 4, 3, 2, 2, 4], [4, 2, 2, 2, 4, 4, 2])", "expected_output": "1 3 4 1 2 1 4"}, {"input": "find_valid_sequence(3, [1, 2, 1], [2, 3, 3], [3, 1, 2])", "expected_output": "1 2 3"}, {"input": "find_valid_sequence(10, [1, 1, 1, 2, 2, 2, 3, 3, 3, 1], [2, 2, 2, 3, 3, 3, 1, 1, 1, 2], [3, 3, 3, 1, 1, 1, 2, 2, 2, 3])", "expected_output": "1 2 1 2 3 2 3 1 3 2"}], "dataset": "apps", "function_name": "find_valid_sequence", "broken_test_cases": [], "correct_solution": "def find_valid_sequence(n, a, b, c):\n    q = [a, b, c]\n    ans = q[0].copy()\n    for i in range(1, n):\n        if ans[i] == ans[i - 1]:\n            ans[i] = q[1][i]\n        if i == n - 1:\n            o = 0\n            while q[o][i] == ans[n - 2] or q[o][i] == ans[0]:\n                o += 1\n            ans[i] = q[o][i]\n    return ' '.join(map(str, ans))", "difficulty": "interview", "tags": [], "prompt": null, "full_completion": null, "parsed_completion": null, "mixed_tests": []}
